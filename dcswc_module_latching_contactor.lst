CCS PCH C Compiler, Version 5.090, 49113               04-Nov-23 23:09

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\dcswc_module_latching_contactor\dcswc_module_latching_contactor.lst

               ROM used:   14632 bytes (89%)
                           Largest free fragment is 1748
               RAM used:   283 (55%) at main() level
                           311 (61%) worst case
               Stack used: 4 locations (2 in main + 2 for interrupts)
               Stack size: 31

0000:  GOTO   3710
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   00D4
0060:  BTFSS  F9D.3
0062:  GOTO   006C
0066:  BTFSC  F9E.3
0068:  GOTO   0EA4
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include "dcswc_module_latching_contactor.h"
.................... #include <18F14K22.h>
.................... //////////// Standard Header file for the PIC18F14K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F14K22
00BA:  CLRF   FF7
00BC:  ADDLW  CA
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  RETURN 0
00CA:  DATA 34,2D
00CC:  DATA 4E,6F
00CE:  DATA 76,2D
00D0:  DATA 32,33
00D2:  DATA 00,00
*
0F70:  DATA 23,20
0F72:  DATA 20,20
0F74:  DATA 20,20
0F76:  DATA 20,20
0F78:  DATA 76,69
0F7A:  DATA 6E,20
0F7C:  DATA 61,64
0F7E:  DATA 63,3D
0F80:  DATA 25,6C
0F82:  DATA 75,0D
0F84:  DATA 0A,00
0F86:  DATA 23,20
0F88:  DATA 20,20
0F8A:  DATA 20,20
0F8C:  DATA 20,74
0F8E:  DATA 65,6D
0F90:  DATA 70,20
0F92:  DATA 61,64
0F94:  DATA 63,3D
0F96:  DATA 25,6C
0F98:  DATA 75,0D
0F9A:  DATA 0A,00
0F9C:  DATA 23,20
0F9E:  DATA 20,20
0FA0:  DATA 63,68
0FA2:  DATA 5B,30
0FA4:  DATA 5D,2E
0FA6:  DATA 73,74
0FA8:  DATA 61,74
0FAA:  DATA 65,3D
0FAC:  DATA 30,78
0FAE:  DATA 25,32
0FB0:  DATA 58,0D
0FB2:  DATA 0A,00
0FB4:  DATA 23,20
0FB6:  DATA 20,20
0FB8:  DATA 63,68
0FBA:  DATA 5B,31
0FBC:  DATA 5D,2E
0FBE:  DATA 73,74
0FC0:  DATA 61,74
0FC2:  DATA 65,3D
0FC4:  DATA 30,78
0FC6:  DATA 25,32
0FC8:  DATA 58,0D
0FCA:  DATA 0A,00
0FCC:  DATA 23,2D
0FCE:  DATA 2D,2D
0FD0:  DATA 2D,2D
0FD2:  DATA 2D,2D
0FD4:  DATA 0D,0A
0FD6:  DATA 00,00
0FD8:  DATA 23,20
0FDA:  DATA 63,6F
0FDC:  DATA 6E,66
0FDE:  DATA 69,67
0FE0:  DATA 2E,63
0FE2:  DATA 68,5B
0FE4:  DATA 25,75
0FE6:  DATA 5D,0D
0FE8:  DATA 0A,00
0FEA:  DATA 23,20
0FEC:  DATA 20,63
0FEE:  DATA 6F,6D
0FF0:  DATA 6D,61
0FF2:  DATA 6E,64
0FF4:  DATA 5F,6F
0FF6:  DATA 6E,5F
0FF8:  DATA 68,6F
0FFA:  DATA 6C,64
0FFC:  DATA 5F,74
0FFE:  DATA 69,6D
1000:  DATA 65,3D
1002:  DATA 25,6C
1004:  DATA 75,0D
1006:  DATA 0A,00
1008:  DATA 23,20
100A:  DATA 63,6F
100C:  DATA 6D,6D
100E:  DATA 61,6E
1010:  DATA 64,5F
1012:  DATA 6F,66
1014:  DATA 66,5F
1016:  DATA 68,6F
1018:  DATA 6C,64
101A:  DATA 5F,74
101C:  DATA 69,6D
101E:  DATA 65,3D
1020:  DATA 25,6C
1022:  DATA 75,0D
1024:  DATA 0A,00
1026:  DATA 23,0D
1028:  DATA 0A,00
102A:  DATA 23,20
102C:  DATA 63,68
102E:  DATA 61,6E
1030:  DATA 6E,65
1032:  DATA 6C,5B
1034:  DATA 25,75
1036:  DATA 5D,0D
1038:  DATA 0A,00
103A:  DATA 23,20
103C:  DATA 20,20
103E:  DATA 20,20
1040:  DATA 20,20
1042:  DATA 20,20
1044:  DATA 20,20
1046:  DATA 20,20
1048:  DATA 20,20
104A:  DATA 20,20
104C:  DATA 20,20
104E:  DATA 20,20
1050:  DATA 20,20
1052:  DATA 20,73
1054:  DATA 74,61
1056:  DATA 74,65
1058:  DATA 3D,30
105A:  DATA 78,25
105C:  DATA 30,32
105E:  DATA 78,0D
1060:  DATA 0A,00
1062:  DATA 23,20
1064:  DATA 20,20
1066:  DATA 20,20
1068:  DATA 20,20
106A:  DATA 20,20
106C:  DATA 20,20
106E:  DATA 63,6F
1070:  DATA 6D,6D
1072:  DATA 61,6E
1074:  DATA 64,5F
1076:  DATA 6F,6E
1078:  DATA 5F,73
107A:  DATA 65,63
107C:  DATA 6F,6E
107E:  DATA 64,73
1080:  DATA 3D,25
1082:  DATA 6C,75
1084:  DATA 0D,0A
1086:  DATA 00,00
1088:  DATA 23,20
108A:  DATA 20,20
108C:  DATA 20,20
108E:  DATA 20,63
1090:  DATA 6F,6D
1092:  DATA 6D,61
1094:  DATA 6E,64
1096:  DATA 5F,6F
1098:  DATA 6E,5F
109A:  DATA 68,6F
109C:  DATA 6C,64
109E:  DATA 5F,73
10A0:  DATA 65,63
10A2:  DATA 6F,6E
10A4:  DATA 64,73
10A6:  DATA 3D,25
10A8:  DATA 6C,75
10AA:  DATA 0D,0A
10AC:  DATA 00,00
10AE:  DATA 23,20
10B0:  DATA 20,20
10B2:  DATA 20,20
10B4:  DATA 20,20
10B6:  DATA 20,20
10B8:  DATA 20,63
10BA:  DATA 6F,6D
10BC:  DATA 6D,61
10BE:  DATA 6E,64
10C0:  DATA 5F,6F
10C2:  DATA 66,66
10C4:  DATA 5F,73
10C6:  DATA 65,63
10C8:  DATA 6F,6E
10CA:  DATA 64,73
10CC:  DATA 3D,25
10CE:  DATA 6C,75
10D0:  DATA 0D,0A
10D2:  DATA 00,00
10D4:  DATA 23,20
10D6:  DATA 20,20
10D8:  DATA 20,20
10DA:  DATA 63,6F
10DC:  DATA 6D,6D
10DE:  DATA 61,6E
10E0:  DATA 64,5F
10E2:  DATA 6F,66
10E4:  DATA 66,5F
10E6:  DATA 68,6F
10E8:  DATA 6C,64
10EA:  DATA 5F,73
10EC:  DATA 65,63
10EE:  DATA 6F,6E
10F0:  DATA 64,73
10F2:  DATA 3D,25
10F4:  DATA 6C,75
10F6:  DATA 0D,0A
10F8:  DATA 00,00
10FA:  DATA 23,20
10FC:  DATA 6C,76
10FE:  DATA 64,5F
1100:  DATA 64,69
1102:  DATA 73,63
1104:  DATA 6F,6E
1106:  DATA 6E,65
1108:  DATA 63,74
110A:  DATA 5F,64
110C:  DATA 65,6C
110E:  DATA 61,79
1110:  DATA 5F,73
1112:  DATA 65,63
1114:  DATA 6F,6E
1116:  DATA 64,73
1118:  DATA 3D,25
111A:  DATA 6C,75
111C:  DATA 0D,0A
111E:  DATA 00,00
1120:  DATA 23,20
1122:  DATA 20,6C
1124:  DATA 76,64
1126:  DATA 5F,72
1128:  DATA 65,63
112A:  DATA 6F,6E
112C:  DATA 6E,65
112E:  DATA 63,74
1130:  DATA 5F,64
1132:  DATA 65,6C
1134:  DATA 61,79
1136:  DATA 5F,73
1138:  DATA 65,63
113A:  DATA 6F,6E
113C:  DATA 64,73
113E:  DATA 3D,25
1140:  DATA 6C,75
1142:  DATA 0D,0A
1144:  DATA 00,00
1146:  DATA 23,20
1148:  DATA 68,76
114A:  DATA 64,5F
114C:  DATA 64,69
114E:  DATA 73,63
1150:  DATA 6F,6E
1152:  DATA 6E,65
1154:  DATA 63,74
1156:  DATA 5F,64
1158:  DATA 65,6C
115A:  DATA 61,79
115C:  DATA 5F,73
115E:  DATA 65,63
1160:  DATA 6F,6E
1162:  DATA 64,73
1164:  DATA 3D,25
1166:  DATA 6C,75
1168:  DATA 0D,0A
116A:  DATA 00,00
116C:  DATA 23,20
116E:  DATA 20,68
1170:  DATA 76,64
1172:  DATA 5F,72
1174:  DATA 65,63
1176:  DATA 6F,6E
1178:  DATA 6E,65
117A:  DATA 63,74
117C:  DATA 5F,64
117E:  DATA 65,6C
1180:  DATA 61,79
1182:  DATA 5F,73
1184:  DATA 65,63
1186:  DATA 6F,6E
1188:  DATA 64,73
118A:  DATA 3D,25
118C:  DATA 6C,75
118E:  DATA 0D,0A
1190:  DATA 00,00
1192:  DATA 23,20
1194:  DATA 6C,74
1196:  DATA 64,5F
1198:  DATA 64,69
119A:  DATA 73,63
119C:  DATA 6F,6E
119E:  DATA 6E,65
11A0:  DATA 63,74
11A2:  DATA 5F,64
11A4:  DATA 65,6C
11A6:  DATA 61,79
11A8:  DATA 5F,73
11AA:  DATA 65,63
11AC:  DATA 6F,6E
11AE:  DATA 64,73
11B0:  DATA 3D,25
11B2:  DATA 6C,75
11B4:  DATA 0D,0A
11B6:  DATA 00,00
11B8:  DATA 23,20
11BA:  DATA 20,6C
11BC:  DATA 74,64
11BE:  DATA 5F,72
11C0:  DATA 65,63
11C2:  DATA 6F,6E
11C4:  DATA 6E,65
11C6:  DATA 63,74
11C8:  DATA 5F,64
11CA:  DATA 65,6C
11CC:  DATA 61,79
11CE:  DATA 5F,73
11D0:  DATA 65,63
11D2:  DATA 6F,6E
11D4:  DATA 64,73
11D6:  DATA 3D,25
11D8:  DATA 6C,75
11DA:  DATA 0D,0A
11DC:  DATA 00,00
11DE:  DATA 23,20
11E0:  DATA 68,74
11E2:  DATA 64,5F
11E4:  DATA 64,69
11E6:  DATA 73,63
11E8:  DATA 6F,6E
11EA:  DATA 6E,65
11EC:  DATA 63,74
11EE:  DATA 5F,64
11F0:  DATA 65,6C
11F2:  DATA 61,79
11F4:  DATA 5F,73
11F6:  DATA 65,63
11F8:  DATA 6F,6E
11FA:  DATA 64,73
11FC:  DATA 3D,25
11FE:  DATA 6C,75
1200:  DATA 0D,0A
1202:  DATA 00,00
1204:  DATA 23,20
1206:  DATA 20,68
1208:  DATA 74,64
120A:  DATA 5F,72
120C:  DATA 65,63
120E:  DATA 6F,6E
1210:  DATA 6E,65
1212:  DATA 63,74
1214:  DATA 5F,64
1216:  DATA 65,6C
1218:  DATA 61,79
121A:  DATA 5F,73
121C:  DATA 65,63
121E:  DATA 6F,6E
1220:  DATA 64,73
1222:  DATA 3D,25
1224:  DATA 6C,75
1226:  DATA 0D,0A
1228:  DATA 00,00
122A:  DATA 23,20
122C:  DATA 64,63
122E:  DATA 73,77
1230:  DATA 63,5F
1232:  DATA 6D,6F
1234:  DATA 64,75
1236:  DATA 6C,65
1238:  DATA 5F,6C
123A:  DATA 61,74
123C:  DATA 63,68
123E:  DATA 69,6E
1240:  DATA 67,5F
1242:  DATA 63,6F
1244:  DATA 6E,74
1246:  DATA 61,63
1248:  DATA 74,6F
124A:  DATA 72,20
124C:  DATA 25,73
124E:  DATA 0D,0A
1250:  DATA 23,20
1252:  DATA 00,00
1254:  DATA 34,2D
1256:  DATA 4E,6F
1258:  DATA 76,2D
125A:  DATA 32,33
125C:  DATA 00,00
125E:  DATA 57,44
1260:  DATA 54,20
1262:  DATA 54,49
1264:  DATA 4D,45
1266:  DATA 4F,55
1268:  DATA 54,00
126A:  DATA 4D,43
126C:  DATA 4C,52
126E:  DATA 20,46
1270:  DATA 52,4F
1272:  DATA 4D,20
1274:  DATA 53,4C
1276:  DATA 45,45
1278:  DATA 50,00
127A:  DATA 4D,43
127C:  DATA 4C,52
127E:  DATA 20,46
1280:  DATA 52,4F
1282:  DATA 4D,20
1284:  DATA 52,55
1286:  DATA 4E,00
1288:  DATA 4E,4F
128A:  DATA 52,4D
128C:  DATA 41,4C
128E:  DATA 20,50
1290:  DATA 4F,57
1292:  DATA 45,52
1294:  DATA 20,55
1296:  DATA 50,00
1298:  DATA 42,52
129A:  DATA 4F,57
129C:  DATA 4E,4F
129E:  DATA 55,54
12A0:  DATA 20,52
12A2:  DATA 45,53
12A4:  DATA 54,41
12A6:  DATA 52,54
12A8:  DATA 00,00
12AA:  DATA 57,44
12AC:  DATA 54,20
12AE:  DATA 46,52
12B0:  DATA 4F,4D
12B2:  DATA 20,53
12B4:  DATA 4C,45
12B6:  DATA 45,50
12B8:  DATA 00,00
12BA:  DATA 52,45
12BC:  DATA 53,45
12BE:  DATA 54,20
12C0:  DATA 49,4E
12C2:  DATA 53,54
12C4:  DATA 52,55
12C6:  DATA 43,54
12C8:  DATA 49,4F
12CA:  DATA 4E,00
12CC:  DATA 55,4E
12CE:  DATA 4B,4E
12D0:  DATA 4F,57
12D2:  DATA 4E,21
12D4:  DATA 00,00
*
1B5E:  TBLRD*+
1B60:  MOVFF  FF6,121
1B64:  MOVFF  FF7,122
1B68:  MOVF   FF5,W
1B6A:  BTFSS  F9E.4
1B6C:  BRA    1B6A
1B6E:  MOVWF  FAD
1B70:  MOVFF  121,FF6
1B74:  MOVFF  122,FF7
1B78:  MOVLB  1
1B7A:  DECFSZ x20,F
1B7C:  BRA    1B80
1B7E:  BRA    1B84
1B80:  MOVLB  0
1B82:  BRA    1B5E
1B84:  MOVLB  0
1B86:  RETURN 0
1B88:  TBLRD*+
1B8A:  MOVF   FF5,F
1B8C:  BZ    1BA8
1B8E:  MOVFF  FF6,11C
1B92:  MOVFF  FF7,11D
1B96:  MOVF   FF5,W
1B98:  BTFSS  F9E.4
1B9A:  BRA    1B98
1B9C:  MOVWF  FAD
1B9E:  MOVFF  11C,FF6
1BA2:  MOVFF  11D,FF7
1BA6:  BRA    1B88
1BA8:  RETURN 0
*
2E5A:  MOVFF  FEA,128
2E5E:  MOVFF  FE9,127
2E62:  MOVLB  1
2E64:  SWAPF  x21,W
2E66:  IORLW  F0
2E68:  MOVWF  x23
2E6A:  ADDWF  x23,F
2E6C:  ADDLW  E2
2E6E:  MOVWF  x24
2E70:  ADDLW  32
2E72:  MOVWF  x26
2E74:  MOVF   x21,W
2E76:  ANDLW  0F
2E78:  ADDWF  x24,F
2E7A:  ADDWF  x24,F
2E7C:  ADDWF  x26,F
2E7E:  ADDLW  E9
2E80:  MOVWF  x25
2E82:  ADDWF  x25,F
2E84:  ADDWF  x25,F
2E86:  SWAPF  x20,W
2E88:  ANDLW  0F
2E8A:  ADDWF  x25,F
2E8C:  ADDWF  x26,F
2E8E:  RLCF   x25,F
2E90:  RLCF   x26,F
2E92:  COMF   x26,F
2E94:  RLCF   x26,F
2E96:  MOVF   x20,W
2E98:  ANDLW  0F
2E9A:  ADDWF  x26,F
2E9C:  RLCF   x23,F
2E9E:  MOVLW  07
2EA0:  MOVWF  x22
2EA2:  MOVLW  0A
2EA4:  DECF   x25,F
2EA6:  ADDWF  x26,F
2EA8:  BNC   2EA4
2EAA:  DECF   x24,F
2EAC:  ADDWF  x25,F
2EAE:  BNC   2EAA
2EB0:  DECF   x23,F
2EB2:  ADDWF  x24,F
2EB4:  BNC   2EB0
2EB6:  DECF   x22,F
2EB8:  ADDWF  x23,F
2EBA:  BNC   2EB6
2EBC:  MOVLW  01
2EBE:  MOVWF  FEA
2EC0:  MOVLW  22
2EC2:  MOVWF  FE9
2EC4:  MOVLW  07
2EC6:  ANDWF  x27,W
2EC8:  BCF    x27.6
2ECA:  ADDWF  FE9,F
2ECC:  MOVLW  00
2ECE:  ADDWFC FEA,F
2ED0:  MOVF   FE9,W
2ED2:  SUBLW  26
2ED4:  BNZ   2EDC
2ED6:  DECFSZ FEA,W
2ED8:  BRA    2EDC
2EDA:  BSF    x27.6
2EDC:  MOVF   FEF,W
2EDE:  MOVWF  00
2EE0:  BNZ   2EF2
2EE2:  BTFSC  x27.6
2EE4:  BRA    2EF2
2EE6:  BTFSC  x27.4
2EE8:  BRA    2F02
2EEA:  BTFSC  x27.3
2EEC:  BRA    2EF2
2EEE:  MOVLW  20
2EF0:  BRA    2EF8
2EF2:  BSF    x27.3
2EF4:  BCF    x27.4
2EF6:  MOVLW  30
2EF8:  ADDWF  00,F
2EFA:  MOVF   00,W
2EFC:  BTFSS  F9E.4
2EFE:  BRA    2EFC
2F00:  MOVWF  FAD
2F02:  MOVF   FEE,W
2F04:  BTFSS  x27.6
2F06:  BRA    2ED0
2F08:  MOVLB  0
2F0A:  RETURN 0
2F0C:  MOVLB  1
2F0E:  BTFSC  x20.7
2F10:  BRA    2F32
2F12:  MOVLW  0F
2F14:  MOVWF  00
2F16:  SWAPF  x1F,W
2F18:  ANDWF  00,F
2F1A:  MOVLW  0A
2F1C:  SUBWF  00,W
2F1E:  BC    2F26
2F20:  MOVLW  30
2F22:  ADDWF  00,F
2F24:  BRA    2F2A
2F26:  MOVF   x20,W
2F28:  ADDWF  00,F
2F2A:  MOVF   00,W
2F2C:  BTFSS  F9E.4
2F2E:  BRA    2F2C
2F30:  MOVWF  FAD
2F32:  MOVLW  0F
2F34:  ANDWF  x1F,F
2F36:  MOVLW  0A
2F38:  SUBWF  x1F,W
2F3A:  BC    2F40
2F3C:  MOVLW  30
2F3E:  BRA    2F44
2F40:  BCF    x20.7
2F42:  MOVF   x20,W
2F44:  ADDWF  x1F,F
2F46:  MOVF   x1F,W
2F48:  BTFSS  F9E.4
2F4A:  BRA    2F48
2F4C:  MOVWF  FAD
2F4E:  MOVLB  0
2F50:  RETURN 0
2F52:  MOVLB  1
2F54:  MOVF   x1F,W
2F56:  CLRF   01
2F58:  SUBWF  x1E,W
2F5A:  BC    2F62
2F5C:  MOVFF  11E,00
2F60:  BRA    2F7A
2F62:  CLRF   00
2F64:  MOVLW  08
2F66:  MOVWF  x20
2F68:  RLCF   x1E,F
2F6A:  RLCF   00,F
2F6C:  MOVF   x1F,W
2F6E:  SUBWF  00,W
2F70:  BTFSC  FD8.0
2F72:  MOVWF  00
2F74:  RLCF   01,F
2F76:  DECFSZ x20,F
2F78:  BRA    2F68
2F7A:  MOVLB  0
2F7C:  RETURN 0
2F7E:  MOVF   01,W
2F80:  MOVFF  11C,11E
2F84:  MOVLW  64
2F86:  MOVLB  1
2F88:  MOVWF  x1F
2F8A:  MOVLB  0
2F8C:  RCALL  2F52
2F8E:  MOVFF  00,11C
2F92:  MOVF   01,W
2F94:  MOVLW  30
2F96:  BNZ   2FA8
2F98:  MOVLB  1
2F9A:  BTFSS  x1D.1
2F9C:  BRA    2FBA
2F9E:  BTFSC  x1D.3
2FA0:  BRA    2FBA
2FA2:  BTFSC  x1D.4
2FA4:  MOVLW  20
2FA6:  BRA    2FB0
2FA8:  MOVLB  1
2FAA:  BCF    x1D.3
2FAC:  BCF    x1D.4
2FAE:  BSF    x1D.0
2FB0:  ADDWF  01,F
2FB2:  MOVF   01,W
2FB4:  BTFSS  F9E.4
2FB6:  BRA    2FB4
2FB8:  MOVWF  FAD
2FBA:  MOVFF  11C,11E
2FBE:  MOVLW  0A
2FC0:  MOVWF  x1F
2FC2:  MOVLB  0
2FC4:  RCALL  2F52
2FC6:  MOVFF  00,11C
2FCA:  MOVF   01,W
2FCC:  MOVLW  30
2FCE:  BNZ   2FE0
2FD0:  MOVLB  1
2FD2:  BTFSC  x1D.3
2FD4:  BRA    2FEC
2FD6:  BTFSS  x1D.0
2FD8:  BRA    2FEC
2FDA:  BTFSC  x1D.4
2FDC:  MOVLW  20
2FDE:  MOVLB  0
2FE0:  ADDWF  01,F
2FE2:  MOVF   01,W
2FE4:  BTFSS  F9E.4
2FE6:  BRA    2FE4
2FE8:  MOVWF  FAD
2FEA:  MOVLB  1
2FEC:  MOVLW  30
2FEE:  ADDWF  x1C,F
2FF0:  MOVF   x1C,W
2FF2:  BTFSS  F9E.4
2FF4:  BRA    2FF2
2FF6:  MOVWF  FAD
2FF8:  MOVLB  0
2FFA:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #device *=16
.................... #use delay(clock=16MHz)
*
12D6:  MOVLW  01
12D8:  MOVWF  FEA
12DA:  MOVLW  28
12DC:  MOVWF  FE9
12DE:  MOVF   FEF,W
12E0:  BZ    12FE
12E2:  MOVLW  05
12E4:  MOVWF  01
12E6:  CLRF   00
12E8:  DECFSZ 00,F
12EA:  BRA    12E8
12EC:  DECFSZ 01,F
12EE:  BRA    12E6
12F0:  MOVLW  2E
12F2:  MOVWF  00
12F4:  DECFSZ 00,F
12F6:  BRA    12F4
12F8:  BRA    12FA
12FA:  DECFSZ FEF,F
12FC:  BRA    12E2
12FE:  RETURN 0
.................... 
.................... /* hardware I2C port is slave and is connected to DCSWC bus */
.................... #use i2c(stream=STREAM_SLAVE,SLAVE, I2C1, FORCE_HW)
*
0E8E:  MOVF   FC9,W
0E90:  MOVFF  12D,FC9
0E94:  BSF    FC6.4
0E96:  BCF    F9E.3
0E98:  BTFSC  FC7.0
0E9A:  BRA    0E98
0E9C:  CLRF   01
0E9E:  BTFSS  FC5.6
0EA0:  INCF   01,F
0EA2:  RETURN 0
.................... /* slave address set based on dip switch in init() */
.................... 
.................... /* important FUSE notes! 
.................... MPLAB defaults to DEBUG mode and that will override fuses.
.................... make sure it is on "BUILD CONFIGURATION" of "RELEASE" under
.................... "PROJECT" menu.
.................... 
.................... CCS setup functions can override fuses. Check .LST file
.................... to see if anything has been overriden!
.................... */
.................... 
.................... #fuses NODEBUG 
.................... #fuses INTRC_IO
.................... #fuses NOPCLKEN
.................... #fuses NOPLLEN
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses BROWNOUT
.................... #fuses BORV30
.................... #fuses NOPUT
.................... #fuses WDT
.................... #fuses WDT128     /* this can be override by setup_wdt() */
.................... #fuses NOHFOFST
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses NOLVP
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... #fuses NOPROTECT
.................... #fuses NOWRT
.................... #fuses NOWRTC 
.................... #fuses NOWRTB
.................... #fuses NOWRTD
.................... #fuses NOEBTR
.................... #fuses NOEBTRB
.................... #fuses BBSIZ1K
.................... 
.................... 
.................... #use standard_io(ALL)
.................... 
.................... #use rs232(UART1,stream=STREAM_FTDI,baud=57600,errors)	
*
00DC:  BTFSS  F9E.4
00DE:  BRA    00DC
00E0:  MOVWF  FAD
00E2:  GOTO   011C (RETURN)
*
2E42:  BTFSS  F9E.5
2E44:  BRA    2E42
2E46:  MOVFF  FAB,1A
2E4A:  MOVFF  FAE,01
2E4E:  BTFSS  1A.1
2E50:  BRA    2E56
2E52:  BCF    FAB.4
2E54:  BSF    FAB.4
2E56:  GOTO   38FC (RETURN)
.................... 
.................... /* program config CRC of 0 and a serial_prefix of 'A' ... that will trigger a write default on first boot */
.................... #ROM 0xF00000 = { 0x00, 0x00, 0x40, 0x00 }
.................... 
.................... 
.................... 
.................... 
.................... #define SW_OVERRIDE_A        PIN_A5
.................... #define SW_OVERRIDE_B        PIN_A4
.................... #define BRIDGE_B_A           PIN_C5
.................... #define BRIDGE_A_B           PIN_C4
.................... #define BRIDGE_A_A           PIN_C3
.................... #define BRIDGE_B_B           PIN_C6
.................... #define AN_DIP               PIN_C7
.................... #define SER_TO_PC            PIN_B7
.................... #define AN_VTEMP             PIN_A2
.................... #define AN_IN_VOLTS          PIN_C0
.................... #define LED_A                PIN_C1
.................... #define LED_B                PIN_C2
.................... #define I2C_SDA              PIN_B4
.................... #define SER_FROM_PC          PIN_B5
.................... #define I2C_SCL              PIN_B6
.................... 
.................... 
.................... /* 
.................... Parameters are stored in EEPROM
.................... */
.................... #define PARAM_CRC_ADDRESS  0x00
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2
.................... 
.................... 
.................... 
.................... /* bit positions for a channel state byte */
.................... #define CH_STATE_BIT_FUTURE   7  /* reserved for future use */
.................... #define CH_STATE_BIT_HTD      6  /* high temperature disconnect */
.................... #define CH_STATE_BIT_LTD      5  /* low temperature disconnect */
.................... #define CH_STATE_BIT_HVD      4  /* high voltage disconnect */
.................... #define CH_STATE_BIT_LVD      3  /* low voltage disconnect */
.................... #define CH_STATE_BIT_CMD_OFF  2  /* commanded off */
.................... #define CH_STATE_BIT_CMD_ON   1  /* commanded on (takes presedence over commanded off) */
.................... #define CH_STATE_BIT_OVERRIDE 0  /* override switch */
.................... 
.................... /* _OVERRIDE or _CMD_ON set means output on */
.................... #define CH_STATE_MASK_ON     0b00000011 
.................... /* _CMD_OFF, _LVD, _HVD, _LTD, _HTD means output off, unless override by on mask */
.................... #define CH_STATE_MASK_OFF    0b01111100 
.................... 
.................... #define ADC_SAMPLE_TICKS              20
.................... #define CONTACTOR_POWER_SAVE_MS       200 /* milliseconds for contactor be on. Must be >0 and <= 255 */
.................... #define CONTACTOR_REFRESH_CYCLES      10  /* re-appply contactor coil voltage every N cycles. 65525 disables */
.................... 
.................... #define BLINK_ON_TIME                 254
.................... #define BLINK_OFF_TIME                200
.................... 
.................... 
.................... typedef struct {
.................... 	/* command on hold time */
.................... 	int16 command_on_hold_time;
.................... 
.................... 	/* command off hold time */
.................... 	int16 command_off_hold_time;
.................... 
.................... 	/* low voltage disconnect */
.................... 	int16 lvd_disconnect_adc;
.................... 	int16 lvd_disconnect_delay;
.................... 	int16 lvd_reconnect_adc;
.................... 	int16 lvd_reconnect_delay;
.................... 
.................... 	/* high voltage disconnect */
.................... 	int16 hvd_disconnect_adc;
.................... 	int16 hvd_disconnect_delay;
.................... 	int16 hvd_reconnect_adc;
.................... 	int16 hvd_reconnect_delay;
.................... 
.................... 	/* low temperature disconnect */
.................... 	int16 ltd_disconnect_adc;
.................... 	int16 ltd_disconnect_delay;
.................... 	int16 ltd_reconnect_adc;
.................... 	int16 ltd_reconnect_delay;
.................... 
.................... 	/* high temperature disconnect */
.................... 	int16 htd_disconnect_adc;
.................... 	int16 htd_disconnect_delay;
.................... 	int16 htd_reconnect_adc;
.................... 	int16 htd_reconnect_delay;
.................... } struct_config_channel;
.................... 
.................... typedef struct {
.................... 	/* not much going on here */
.................... 	struct_config_channel ch[2];
.................... } struct_config;
.................... 
.................... 
.................... typedef struct {
.................... 	int8 state;
.................... 
.................... 	int16 command_on_seconds;			/* counts down. Off at zero. */
.................... 	int16 command_on_hold_seconds;      /* counts down. Off at zero. */
.................... 
.................... 	int16 command_off_seconds;			/* counts down. Off at zero. */
.................... 	int16 command_off_hold_seconds;     /* counts down. Off at zero. */
.................... 
.................... 	int16 lvd_disconnect_delay_seconds;	/* counts down */
.................... 	int16  lvd_reconnect_delay_seconds;	/* counts down */
.................... 
.................... 	int16 hvd_disconnect_delay_seconds;	/* counts down */
.................... 	int16  hvd_reconnect_delay_seconds;	/* counts down */
.................... 
.................... 	int16 ltd_disconnect_delay_seconds; /* counts down */
.................... 	int16 ltd_reconnect_delay_seconds;  /* counts down */
.................... 
.................... 	int16 htd_disconnect_delay_seconds; /* counts down */
.................... 	int16 htd_reconnect_delay_seconds;  /* counts down */
.................... } struct_channel;
.................... 
.................... typedef struct {
.................... 	/* circular buffer for ADC readings */
.................... 	int16 adc_buffer[3][16];
.................... 	int8  adc_buffer_index;
.................... 
.................... 	int16 sequence_number;
.................... 	int16 uptime_minutes;
.................... 	int16 interval_milliseconds;
.................... 
.................... 	int8 factory_unlocked;
.................... 
.................... 
.................... 	int8 compile_year;
.................... 	int8 compile_month;
.................... 	int8 compile_day;
.................... 
.................... 
.................... 	int8 default_params_written;
.................... } struct_current;
.................... 
.................... typedef struct {
.................... 	/* action flags */
.................... 	int1 now_adc_sample;
.................... 	int1 now_adc_reset_count;
.................... 
.................... 	int1 now_millisecond;
.................... 
.................... 	int1 now_write_config;
.................... 	int1 now_reset_config;
.................... 
.................... 	int1 now_debug_dump;
.................... 
.................... 
.................... 	/* timers */
.................... 	int8 led_blink[2];
.................... 	int8 led_on[2];
.................... 	int8 led_off[2];
.................... 
.................... 	/* contactors */
.................... 	int8 contactor[2]; 	         /* current state */
.................... 	int8 contactor_powersave[2]; /* countdown to shut off power to coil at 0 */
.................... } struct_time_keep;
.................... 
.................... /* global structures */
.................... struct_config config={0};
.................... struct_current current={0};
.................... struct_time_keep timers={0};
.................... struct_channel channel[2]={0};
.................... 
.................... #include "adc_dcswc_module_latching_contactor.c"
.................... int16 adc_get(int8 ch) {
.................... 	int16 sum;
.................... 	int8 i;
.................... 
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */
.................... 	int16 *p;
.................... 	p = current.adc_buffer[ch];
*
05AA:  MOVLB  1
05AC:  MOVF   x2F,W
05AE:  MULLW  20
05B0:  MOVF   FF3,W
05B2:  CLRF   03
05B4:  ADDLW  63
05B6:  MOVWF  01
05B8:  MOVLW  00
05BA:  ADDWFC 03,F
05BC:  MOVFF  01,133
05C0:  MOVFF  03,134
.................... 
.................... 	// Calculate the mean.  This is done by summing up the
.................... 	// values and dividing by the number of elements.
.................... 	sum = 0;
05C4:  CLRF   x31
05C6:  CLRF   x30
.................... 	for( i = 0; i < 16 ; i++ ) {
05C8:  CLRF   x32
05CA:  MOVF   x32,W
05CC:  SUBLW  0F
05CE:  BNC   05FA
.................... //		sum += current.adc_buffer[ch][i];
.................... 		sum += p[i];
05D0:  CLRF   03
05D2:  MOVFF  132,02
05D6:  BCF    FD8.0
05D8:  RLCF   02,F
05DA:  RLCF   03,F
05DC:  MOVF   02,W
05DE:  ADDWF  x33,W
05E0:  MOVWF  FE9
05E2:  MOVF   x34,W
05E4:  ADDWFC 03,W
05E6:  MOVWF  FEA
05E8:  MOVFF  FEC,03
05EC:  MOVF   FED,F
05EE:  MOVF   FEF,W
05F0:  ADDWF  x30,F
05F2:  MOVF   03,W
05F4:  ADDWFC x31,F
05F6:  INCF   x32,F
05F8:  BRA    05CA
.................... 	}
.................... 
.................... 	/* divide sum by our 16 samples and round by adding 8 */
.................... 	return ( (sum+8) >> 4 );
05FA:  MOVLW  08
05FC:  ADDWF  x30,W
05FE:  MOVWF  x35
0600:  MOVLW  00
0602:  ADDWFC x31,W
0604:  MOVWF  x36
0606:  RRCF   x36,W
0608:  MOVWF  03
060A:  RRCF   x35,W
060C:  MOVWF  02
060E:  RRCF   03,F
0610:  RRCF   02,F
0612:  RRCF   03,F
0614:  RRCF   02,F
0616:  RRCF   03,F
0618:  RRCF   02,F
061A:  MOVLW  0F
061C:  ANDWF  03,F
061E:  MOVFF  02,01
0622:  MOVFF  03,02
0626:  MOVLB  0
0628:  RETURN 0
.................... }
.................... 
.................... 
.................... void adc_update(void) {
.................... 
.................... 	/* wrap buffer around */
.................... 	current.adc_buffer_index++;
*
1BAA:  INCF   xC3,F
.................... 	if ( current.adc_buffer_index >= 16 )
1BAC:  MOVF   xC3,W
1BAE:  SUBLW  0F
1BB0:  BC    1BB4
.................... 		current.adc_buffer_index=0;
1BB2:  CLRF   xC3
.................... 
.................... 	set_adc_channel(4);
1BB4:  MOVLW  10
1BB6:  MOVWF  01
1BB8:  MOVF   FC2,W
1BBA:  ANDLW  C3
1BBC:  IORWF  01,W
1BBE:  MOVWF  FC2
.................... 	current.adc_buffer[0][current.adc_buffer_index] = read_adc();
1BC0:  BCF    FD8.0
1BC2:  RLCF   xC3,W
1BC4:  CLRF   03
1BC6:  ADDLW  63
1BC8:  MOVWF  FE9
1BCA:  MOVLW  00
1BCC:  ADDWFC 03,W
1BCE:  MOVWF  FEA
1BD0:  BSF    FC2.1
1BD2:  BTFSC  FC2.1
1BD4:  BRA    1BD2
1BD6:  MOVFF  FC3,FEF
1BDA:  MOVFF  FC4,FEC
.................... 
.................... 
.................... 	set_adc_channel(2);
1BDE:  MOVLW  08
1BE0:  MOVWF  01
1BE2:  MOVF   FC2,W
1BE4:  ANDLW  C3
1BE6:  IORWF  01,W
1BE8:  MOVWF  FC2
.................... 	delay_ms(1);
1BEA:  MOVLW  01
1BEC:  MOVLB  1
1BEE:  MOVWF  x28
1BF0:  MOVLB  0
1BF2:  CALL   12D6
.................... 	current.adc_buffer[1][current.adc_buffer_index] = read_adc();
1BF6:  BCF    FD8.0
1BF8:  RLCF   xC3,W
1BFA:  CLRF   03
1BFC:  ADDLW  83
1BFE:  MOVWF  FE9
1C00:  MOVLW  00
1C02:  ADDWFC 03,W
1C04:  MOVWF  FEA
1C06:  BSF    FC2.1
1C08:  BTFSC  FC2.1
1C0A:  BRA    1C08
1C0C:  MOVFF  FC3,FEF
1C10:  MOVFF  FC4,FEC
.................... 
.................... 	set_adc_channel(9);
1C14:  MOVLW  24
1C16:  MOVWF  01
1C18:  MOVF   FC2,W
1C1A:  ANDLW  C3
1C1C:  IORWF  01,W
1C1E:  MOVWF  FC2
.................... 	delay_ms(1);
1C20:  MOVLW  01
1C22:  MOVLB  1
1C24:  MOVWF  x28
1C26:  MOVLB  0
1C28:  CALL   12D6
.................... 	current.adc_buffer[2][current.adc_buffer_index] = read_adc();
1C2C:  BCF    FD8.0
1C2E:  RLCF   xC3,W
1C30:  CLRF   03
1C32:  ADDLW  A3
1C34:  MOVWF  FE9
1C36:  MOVLW  00
1C38:  ADDWFC 03,W
1C3A:  MOVWF  FEA
1C3C:  BSF    FC2.1
1C3E:  BTFSC  FC2.1
1C40:  BRA    1C3E
1C42:  MOVFF  FC3,FEF
1C46:  MOVFF  FC4,FEC
1C4A:  RETURN 0
.................... }
.................... 
.................... int8 read_dip_switch(void) {
.................... 	int16 adc;
.................... 
.................... 	set_adc_channel(9);
*
1300:  MOVLW  24
1302:  MOVWF  01
1304:  MOVF   FC2,W
1306:  ANDLW  C3
1308:  IORWF  01,W
130A:  MOVWF  FC2
.................... 	delay_ms(1);
130C:  MOVLW  01
130E:  MOVLB  1
1310:  MOVWF  x28
1312:  MOVLB  0
1314:  RCALL  12D6
.................... 	adc=read_adc();
1316:  BSF    FC2.1
1318:  BTFSC  FC2.1
131A:  BRA    1318
131C:  MOVFF  FC4,127
1320:  MOVFF  FC3,126
.................... 
.................... 	/* (note that table is sorted by vout reading 
.................... 	SW3.1 (LSB) SW3.2 (MSB) VALUE ADC
....................     OFF         OFF         0     1023
.................... 	OFF         ON          2     682
....................     ON          OFF         1     511
.................... 	ON          ON          3     409
.................... 	*/
.................... 
.................... 	if ( adc > (1023-64) )
1324:  MOVLB  1
1326:  MOVF   x27,W
1328:  SUBLW  02
132A:  BC    133C
132C:  XORLW  FF
132E:  BNZ   1336
1330:  MOVF   x26,W
1332:  SUBLW  BF
1334:  BC    133C
.................... 		return 0;
1336:  MOVLW  00
1338:  MOVWF  01
133A:  BRA    136C
.................... 	if ( adc > (682-64) )
133C:  MOVF   x27,W
133E:  SUBLW  01
1340:  BC    1352
1342:  XORLW  FF
1344:  BNZ   134C
1346:  MOVF   x26,W
1348:  SUBLW  6A
134A:  BC    1352
.................... 		return 2;
134C:  MOVLW  02
134E:  MOVWF  01
1350:  BRA    136C
.................... 	if ( adc > (511-64) )
1352:  MOVF   x27,W
1354:  SUBLW  00
1356:  BC    1368
1358:  XORLW  FF
135A:  BNZ   1362
135C:  MOVF   x26,W
135E:  SUBLW  BF
1360:  BC    1368
.................... 		return 1;
1362:  MOVLW  01
1364:  MOVWF  01
1366:  BRA    136C
.................... 
.................... 	return 3;
1368:  MOVLW  03
136A:  MOVWF  01
136C:  MOVLB  0
136E:  GOTO   163C (RETURN)
.................... }
.................... 
.................... #include "param_dcswc_module_latching_contactor.c"
.................... #inline
.................... char xor_crc(char oldcrc, char data) {
.................... 	return oldcrc ^ data;
*
1706:  MOVF   x28,W
1708:  XORWF  x29,W
170A:  MOVWF  01
*
1754:  MOVF   x28,W
1756:  XORWF  x29,W
1758:  MOVWF  01
.................... }
.................... 
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) {
*
169E:  MOVLB  1
16A0:  CLRF   x24
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
16A2:  MOVFF  123,126
16A6:  MOVF   x22,W
16A8:  BTFSC  FD8.2
16AA:  DECF   x23,F
16AC:  DECF   x22,F
16AE:  MOVWF  x25
16B0:  MOVF   x25,F
16B2:  BNZ   16B8
16B4:  MOVF   x26,F
16B6:  BZ    1718
.................... 		*data = read_eeprom( address++ );
16B8:  MOVFF  121,03
16BC:  MOVF   x20,W
16BE:  MOVWF  FE9
16C0:  MOVFF  03,FEA
16C4:  MOVF   x1F,W
16C6:  MOVWF  03
16C8:  MOVF   x1E,W
16CA:  INCF   x1E,F
16CC:  BTFSC  FD8.2
16CE:  INCF   x1F,F
16D0:  MOVWF  x27
16D2:  MOVFF  03,128
16D6:  MOVFF  FF2,129
16DA:  BCF    FF2.7
16DC:  MOVFF  127,FA9
16E0:  BCF    FA6.6
16E2:  BCF    FA6.7
16E4:  BSF    FA6.0
16E6:  MOVF   FA8,W
16E8:  BTFSC  x29.7
16EA:  BSF    FF2.7
16EC:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data);
16EE:  MOVFF  121,03
16F2:  MOVF   x20,W
16F4:  MOVWF  FE9
16F6:  MOVFF  03,FEA
16FA:  MOVFF  FEF,125
16FE:  MOVFF  124,128
1702:  MOVFF  125,129
*
170C:  MOVFF  01,124
.................... 		data++;
1710:  INCF   x20,F
1712:  BTFSC  FD8.2
1714:  INCF   x21,F
1716:  BRA    16A2
.................... 	}
.................... 	return crc;
1718:  MOVFF  124,01
171C:  MOVLB  0
171E:  GOTO   1B34 (RETURN)
.................... }
.................... 
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) {
1722:  MOVLB  1
1724:  CLRF   x26
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
1726:  MOVFF  125,128
172A:  MOVF   x24,W
172C:  BTFSC  FD8.2
172E:  DECF   x25,F
1730:  DECF   x24,F
1732:  MOVWF  x27
1734:  MOVF   x27,F
1736:  BNZ   173C
1738:  MOVF   x28,F
173A:  BZ    17B4
.................... 		/* restart_wdt() */
.................... 		crc = xor_crc(crc,*data);
173C:  MOVFF  123,03
1740:  MOVF   x22,W
1742:  MOVWF  FE9
1744:  MOVFF  03,FEA
1748:  MOVFF  FEF,127
174C:  MOVFF  126,128
1750:  MOVFF  127,129
*
175A:  MOVFF  01,126
.................... 		write_eeprom( address++, *data++ );
175E:  MOVF   x21,W
1760:  MOVWF  03
1762:  MOVF   x20,W
1764:  INCF   x20,F
1766:  BTFSC  FD8.2
1768:  INCF   x21,F
176A:  MOVWF  x27
176C:  MOVFF  03,128
1770:  MOVF   x23,W
1772:  MOVWF  03
1774:  MOVF   x22,W
1776:  INCF   x22,F
1778:  BTFSC  FD8.2
177A:  INCF   x23,F
177C:  MOVWF  FE9
177E:  MOVFF  03,FEA
1782:  MOVFF  FEF,129
1786:  MOVF   FF2,W
1788:  MOVWF  00
178A:  BCF    FF2.7
178C:  MOVFF  127,FA9
1790:  MOVFF  129,FA8
1794:  BCF    FA6.6
1796:  BCF    FA6.7
1798:  BSF    FA6.2
179A:  MOVLB  F
179C:  MOVLW  55
179E:  MOVWF  FA7
17A0:  MOVLW  AA
17A2:  MOVWF  FA7
17A4:  BSF    FA6.1
17A6:  BTFSC  FA6.1
17A8:  BRA    17A6
17AA:  BCF    FA6.2
17AC:  MOVF   00,W
17AE:  IORWF  FF2,F
17B0:  MOVLB  1
17B2:  BRA    1726
.................... 	}
.................... 
.................... 	return crc;
17B4:  MOVFF  126,01
17B8:  MOVLB  0
17BA:  GOTO   17DA (RETURN)
.................... }
.................... 
.................... void write_param_file() {
.................... 	int8 crc;
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config));
17BE:  MOVLB  1
17C0:  MOVLW  1B
17C2:  MOVWF  x1E
17C4:  CLRF   x21
17C6:  MOVLW  02
17C8:  MOVWF  x20
17CA:  CLRF   x23
17CC:  MOVFF  11E,122
17D0:  CLRF   x25
17D2:  MOVLW  48
17D4:  MOVWF  x24
17D6:  MOVLB  0
17D8:  BRA    1722
17DA:  MOVFF  01,11D
.................... 	/* write the CRC was calculated on the structure */
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc);
17DE:  MOVF   FF2,W
17E0:  MOVWF  00
17E2:  BCF    FF2.7
17E4:  CLRF   FA9
17E6:  MOVFF  11D,FA8
17EA:  BCF    FA6.6
17EC:  BCF    FA6.7
17EE:  BSF    FA6.2
17F0:  MOVLB  F
17F2:  MOVLW  55
17F4:  MOVWF  FA7
17F6:  MOVLW  AA
17F8:  MOVWF  FA7
17FA:  BSF    FA6.1
17FC:  BTFSC  FA6.1
17FE:  BRA    17FC
1800:  BCF    FA6.2
1802:  MOVF   00,W
1804:  IORWF  FF2,F
1806:  MOVLB  0
1808:  RETURN 0
.................... }
.................... 
.................... void write_default_param_file() {
.................... 	int8 i;
.................... 
.................... 	current.default_params_written=1;
180A:  MOVLW  01
180C:  MOVWF  xCE
.................... 
.................... 	/* both LEDs on */
.................... 	timers.led_blink[0]=255;
180E:  SETF   xD0
.................... 	timers.led_blink[1]=255;
1810:  SETF   xD1
.................... 
.................... 
.................... 	for ( i=0 ; i<2 ; i++ ) {
1812:  MOVLB  1
1814:  CLRF   x1C
1816:  MOVF   x1C,W
1818:  SUBLW  01
181A:  BTFSS  FD8.0
181C:  BRA    1B12
.................... 		config.ch[i].command_on_hold_time=60;
181E:  MOVF   x1C,W
1820:  MULLW  24
1822:  MOVF   FF3,W
1824:  CLRF   x1E
1826:  MOVWF  x1D
1828:  MOVLW  1B
182A:  ADDWF  x1D,W
182C:  MOVWF  FE9
182E:  MOVLW  00
1830:  ADDWFC x1E,W
1832:  MOVWF  FEA
1834:  CLRF   FEC
1836:  MOVF   FED,F
1838:  MOVLW  3C
183A:  MOVWF  FEF
.................... 		config.ch[i].command_off_hold_time=15;
183C:  MOVF   x1C,W
183E:  MULLW  24
1840:  MOVF   FF3,W
1842:  CLRF   x1E
1844:  MOVWF  x1D
1846:  MOVLW  02
1848:  ADDWF  x1D,W
184A:  MOVWF  01
184C:  MOVLW  00
184E:  ADDWFC x1E,W
1850:  MOVWF  03
1852:  MOVF   01,W
1854:  ADDLW  1B
1856:  MOVWF  FE9
1858:  MOVLW  00
185A:  ADDWFC 03,W
185C:  MOVWF  FEA
185E:  CLRF   FEC
1860:  MOVF   FED,F
1862:  MOVLW  0F
1864:  MOVWF  FEF
.................... 
.................... 		/* low voltage disconnect */
.................... 		config.ch[i].lvd_disconnect_adc=593;  /* 23.16 volts */
1866:  MOVF   x1C,W
1868:  MULLW  24
186A:  MOVF   FF3,W
186C:  CLRF   x1E
186E:  MOVWF  x1D
1870:  MOVLW  04
1872:  ADDWF  x1D,W
1874:  MOVWF  01
1876:  MOVLW  00
1878:  ADDWFC x1E,W
187A:  MOVWF  03
187C:  MOVF   01,W
187E:  ADDLW  1B
1880:  MOVWF  FE9
1882:  MOVLW  00
1884:  ADDWFC 03,W
1886:  MOVWF  FEA
1888:  MOVLW  02
188A:  MOVWF  FEC
188C:  MOVF   FED,F
188E:  MOVLW  51
1890:  MOVWF  FEF
.................... 		config.ch[i].lvd_disconnect_delay=20; /* 65535 disables LVD */
1892:  MOVF   x1C,W
1894:  MULLW  24
1896:  MOVF   FF3,W
1898:  CLRF   x1E
189A:  MOVWF  x1D
189C:  MOVLW  06
189E:  ADDWF  x1D,W
18A0:  MOVWF  01
18A2:  MOVLW  00
18A4:  ADDWFC x1E,W
18A6:  MOVWF  03
18A8:  MOVF   01,W
18AA:  ADDLW  1B
18AC:  MOVWF  FE9
18AE:  MOVLW  00
18B0:  ADDWFC 03,W
18B2:  MOVWF  FEA
18B4:  CLRF   FEC
18B6:  MOVF   FED,F
18B8:  MOVLW  14
18BA:  MOVWF  FEF
.................... 		config.ch[i].lvd_reconnect_adc=602;   /* 23.51 volts */
18BC:  MOVF   x1C,W
18BE:  MULLW  24
18C0:  MOVF   FF3,W
18C2:  CLRF   x1E
18C4:  MOVWF  x1D
18C6:  MOVLW  08
18C8:  ADDWF  x1D,W
18CA:  MOVWF  01
18CC:  MOVLW  00
18CE:  ADDWFC x1E,W
18D0:  MOVWF  03
18D2:  MOVF   01,W
18D4:  ADDLW  1B
18D6:  MOVWF  FE9
18D8:  MOVLW  00
18DA:  ADDWFC 03,W
18DC:  MOVWF  FEA
18DE:  MOVLW  02
18E0:  MOVWF  FEC
18E2:  MOVF   FED,F
18E4:  MOVLW  5A
18E6:  MOVWF  FEF
.................... 		config.ch[i].lvd_reconnect_delay=10;
18E8:  MOVF   x1C,W
18EA:  MULLW  24
18EC:  MOVF   FF3,W
18EE:  CLRF   x1E
18F0:  MOVWF  x1D
18F2:  MOVLW  0A
18F4:  ADDWF  x1D,W
18F6:  MOVWF  01
18F8:  MOVLW  00
18FA:  ADDWFC x1E,W
18FC:  MOVWF  03
18FE:  MOVF   01,W
1900:  ADDLW  1B
1902:  MOVWF  FE9
1904:  MOVLW  00
1906:  ADDWFC 03,W
1908:  MOVWF  FEA
190A:  CLRF   FEC
190C:  MOVF   FED,F
190E:  MOVLW  0A
1910:  MOVWF  FEF
.................... 		
.................... 		/* high voltage disconnect */
.................... 		config.ch[i].hvd_disconnect_adc=700; 
1912:  MOVF   x1C,W
1914:  MULLW  24
1916:  MOVF   FF3,W
1918:  CLRF   x1E
191A:  MOVWF  x1D
191C:  MOVLW  0C
191E:  ADDWF  x1D,W
1920:  MOVWF  01
1922:  MOVLW  00
1924:  ADDWFC x1E,W
1926:  MOVWF  03
1928:  MOVF   01,W
192A:  ADDLW  1B
192C:  MOVWF  FE9
192E:  MOVLW  00
1930:  ADDWFC 03,W
1932:  MOVWF  FEA
1934:  MOVLW  02
1936:  MOVWF  FEC
1938:  MOVF   FED,F
193A:  MOVLW  BC
193C:  MOVWF  FEF
.................... 		config.ch[i].hvd_disconnect_delay=65535; /* 65535 disables HVD */
193E:  MOVF   x1C,W
1940:  MULLW  24
1942:  MOVF   FF3,W
1944:  CLRF   x1E
1946:  MOVWF  x1D
1948:  MOVLW  0E
194A:  ADDWF  x1D,W
194C:  MOVWF  01
194E:  MOVLW  00
1950:  ADDWFC x1E,W
1952:  MOVWF  03
1954:  MOVF   01,W
1956:  ADDLW  1B
1958:  MOVWF  FE9
195A:  MOVLW  00
195C:  ADDWFC 03,W
195E:  MOVWF  FEA
1960:  SETF   FEC
1962:  MOVF   FED,F
1964:  SETF   FEF
.................... 		config.ch[i].hvd_reconnect_adc=650;
1966:  MOVF   x1C,W
1968:  MULLW  24
196A:  MOVF   FF3,W
196C:  CLRF   x1E
196E:  MOVWF  x1D
1970:  MOVLW  10
1972:  ADDWF  x1D,W
1974:  MOVWF  01
1976:  MOVLW  00
1978:  ADDWFC x1E,W
197A:  MOVWF  03
197C:  MOVF   01,W
197E:  ADDLW  1B
1980:  MOVWF  FE9
1982:  MOVLW  00
1984:  ADDWFC 03,W
1986:  MOVWF  FEA
1988:  MOVLW  02
198A:  MOVWF  FEC
198C:  MOVF   FED,F
198E:  MOVLW  8A
1990:  MOVWF  FEF
.................... 		config.ch[i].hvd_reconnect_delay=60;
1992:  MOVF   x1C,W
1994:  MULLW  24
1996:  MOVF   FF3,W
1998:  CLRF   x1E
199A:  MOVWF  x1D
199C:  MOVLW  12
199E:  ADDWF  x1D,W
19A0:  MOVWF  01
19A2:  MOVLW  00
19A4:  ADDWFC x1E,W
19A6:  MOVWF  03
19A8:  MOVF   01,W
19AA:  ADDLW  1B
19AC:  MOVWF  FE9
19AE:  MOVLW  00
19B0:  ADDWFC 03,W
19B2:  MOVWF  FEA
19B4:  CLRF   FEC
19B6:  MOVF   FED,F
19B8:  MOVLW  3C
19BA:  MOVWF  FEF
.................... 
.................... 		/* low temperature disconnect */
.................... 		config.ch[i].ltd_disconnect_adc=786; // 0C / 32F
19BC:  MOVF   x1C,W
19BE:  MULLW  24
19C0:  MOVF   FF3,W
19C2:  CLRF   x1E
19C4:  MOVWF  x1D
19C6:  MOVLW  14
19C8:  ADDWF  x1D,W
19CA:  MOVWF  01
19CC:  MOVLW  00
19CE:  ADDWFC x1E,W
19D0:  MOVWF  03
19D2:  MOVF   01,W
19D4:  ADDLW  1B
19D6:  MOVWF  FE9
19D8:  MOVLW  00
19DA:  ADDWFC 03,W
19DC:  MOVWF  FEA
19DE:  MOVLW  03
19E0:  MOVWF  FEC
19E2:  MOVF   FED,F
19E4:  MOVLW  12
19E6:  MOVWF  FEF
.................... 		config.ch[i].ltd_disconnect_delay=65535; /* 65535 disables LTD */
19E8:  MOVF   x1C,W
19EA:  MULLW  24
19EC:  MOVF   FF3,W
19EE:  CLRF   x1E
19F0:  MOVWF  x1D
19F2:  MOVLW  16
19F4:  ADDWF  x1D,W
19F6:  MOVWF  01
19F8:  MOVLW  00
19FA:  ADDWFC x1E,W
19FC:  MOVWF  03
19FE:  MOVF   01,W
1A00:  ADDLW  1B
1A02:  MOVWF  FE9
1A04:  MOVLW  00
1A06:  ADDWFC 03,W
1A08:  MOVWF  FEA
1A0A:  SETF   FEC
1A0C:  MOVF   FED,F
1A0E:  SETF   FEF
.................... 		config.ch[i].ltd_reconnect_adc=683;  // 10C / 50F
1A10:  MOVF   x1C,W
1A12:  MULLW  24
1A14:  MOVF   FF3,W
1A16:  CLRF   x1E
1A18:  MOVWF  x1D
1A1A:  MOVLW  18
1A1C:  ADDWF  x1D,W
1A1E:  MOVWF  01
1A20:  MOVLW  00
1A22:  ADDWFC x1E,W
1A24:  MOVWF  03
1A26:  MOVF   01,W
1A28:  ADDLW  1B
1A2A:  MOVWF  FE9
1A2C:  MOVLW  00
1A2E:  ADDWFC 03,W
1A30:  MOVWF  FEA
1A32:  MOVLW  02
1A34:  MOVWF  FEC
1A36:  MOVF   FED,F
1A38:  MOVLW  AB
1A3A:  MOVWF  FEF
.................... 		config.ch[i].ltd_reconnect_delay=4;
1A3C:  MOVF   x1C,W
1A3E:  MULLW  24
1A40:  MOVF   FF3,W
1A42:  CLRF   x1E
1A44:  MOVWF  x1D
1A46:  MOVLW  1A
1A48:  ADDWF  x1D,W
1A4A:  MOVWF  01
1A4C:  MOVLW  00
1A4E:  ADDWFC x1E,W
1A50:  MOVWF  03
1A52:  MOVF   01,W
1A54:  ADDLW  1B
1A56:  MOVWF  FE9
1A58:  MOVLW  00
1A5A:  ADDWFC 03,W
1A5C:  MOVWF  FEA
1A5E:  CLRF   FEC
1A60:  MOVF   FED,F
1A62:  MOVLW  04
1A64:  MOVWF  FEF
.................... 
.................... 		/* high temperature disconnect */
.................... 		config.ch[i].htd_disconnect_adc=405; // 35C / 95F
1A66:  MOVF   x1C,W
1A68:  MULLW  24
1A6A:  MOVF   FF3,W
1A6C:  CLRF   x1E
1A6E:  MOVWF  x1D
1A70:  MOVLW  1C
1A72:  ADDWF  x1D,W
1A74:  MOVWF  01
1A76:  MOVLW  00
1A78:  ADDWFC x1E,W
1A7A:  MOVWF  03
1A7C:  MOVF   01,W
1A7E:  ADDLW  1B
1A80:  MOVWF  FE9
1A82:  MOVLW  00
1A84:  ADDWFC 03,W
1A86:  MOVWF  FEA
1A88:  MOVLW  01
1A8A:  MOVWF  FEC
1A8C:  MOVF   FED,F
1A8E:  MOVLW  95
1A90:  MOVWF  FEF
.................... 		config.ch[i].htd_disconnect_delay=65535; /* 65535 disables LTD */
1A92:  MOVF   x1C,W
1A94:  MULLW  24
1A96:  MOVF   FF3,W
1A98:  CLRF   x1E
1A9A:  MOVWF  x1D
1A9C:  MOVLW  1E
1A9E:  ADDWF  x1D,W
1AA0:  MOVWF  01
1AA2:  MOVLW  00
1AA4:  ADDWFC x1E,W
1AA6:  MOVWF  03
1AA8:  MOVF   01,W
1AAA:  ADDLW  1B
1AAC:  MOVWF  FE9
1AAE:  MOVLW  00
1AB0:  ADDWFC 03,W
1AB2:  MOVWF  FEA
1AB4:  SETF   FEC
1AB6:  MOVF   FED,F
1AB8:  SETF   FEF
.................... 		config.ch[i].htd_reconnect_adc=512;  // 25C / 77F
1ABA:  MOVF   x1C,W
1ABC:  MULLW  24
1ABE:  MOVF   FF3,W
1AC0:  CLRF   x1E
1AC2:  MOVWF  x1D
1AC4:  MOVLW  20
1AC6:  ADDWF  x1D,W
1AC8:  MOVWF  01
1ACA:  MOVLW  00
1ACC:  ADDWFC x1E,W
1ACE:  MOVWF  03
1AD0:  MOVF   01,W
1AD2:  ADDLW  1B
1AD4:  MOVWF  FE9
1AD6:  MOVLW  00
1AD8:  ADDWFC 03,W
1ADA:  MOVWF  FEA
1ADC:  MOVLW  02
1ADE:  MOVWF  FEC
1AE0:  MOVF   FED,F
1AE2:  CLRF   FEF
.................... 		config.ch[i].htd_reconnect_delay=4;
1AE4:  MOVF   x1C,W
1AE6:  MULLW  24
1AE8:  MOVF   FF3,W
1AEA:  CLRF   x1E
1AEC:  MOVWF  x1D
1AEE:  MOVLW  22
1AF0:  ADDWF  x1D,W
1AF2:  MOVWF  01
1AF4:  MOVLW  00
1AF6:  ADDWFC x1E,W
1AF8:  MOVWF  03
1AFA:  MOVF   01,W
1AFC:  ADDLW  1B
1AFE:  MOVWF  FE9
1B00:  MOVLW  00
1B02:  ADDWFC 03,W
1B04:  MOVWF  FEA
1B06:  CLRF   FEC
1B08:  MOVF   FED,F
1B0A:  MOVLW  04
1B0C:  MOVWF  FEF
.................... 	}
.................... 	
.................... 
.................... #if 0
1B0E:  INCF   x1C,F
1B10:  BRA    1816
.................... 	/* set the two channels differently */
.................... 	/* LVD 1 bus (modem, etc) @ Fairway */
.................... 	config.ch[0].lvd_disconnect_adc=602; /* 23.5 */
.................... 	config.ch[0].lvd_reconnect_adc=627;  /* 24.5 */
....................  	/* LVD 2 bus (CODAR) @ Fairway */
.................... 	config.ch[1].lvd_disconnect_adc=614; /* 24.0 */
.................... 	config.ch[1].lvd_reconnect_adc=640;  /* 25.0 */		
.................... #endif
.................... 
.................... 
.................... 	/* write them so next time we use from EEPROM */
.................... 	write_param_file();
1B12:  MOVLB  0
1B14:  RCALL  17BE
1B16:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void read_param_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config)); 
1B18:  MOVLB  1
1B1A:  MOVLW  1B
1B1C:  MOVWF  x1C
1B1E:  CLRF   x1F
1B20:  MOVLW  02
1B22:  MOVWF  x1E
1B24:  CLRF   x21
1B26:  MOVFF  11C,120
1B2A:  CLRF   x23
1B2C:  MOVLW  48
1B2E:  MOVWF  x22
1B30:  MOVLB  0
1B32:  BRA    169E
1B34:  MOVFF  01,11B
.................... 		
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) {
1B38:  MOVFF  FF2,11C
1B3C:  BCF    FF2.7
1B3E:  CLRF   FA9
1B40:  BCF    FA6.6
1B42:  BCF    FA6.7
1B44:  BSF    FA6.0
1B46:  MOVF   FA8,W
1B48:  MOVLB  1
1B4A:  BTFSC  x1C.7
1B4C:  BSF    FF2.7
1B4E:  SUBWF  x1B,W
1B50:  BZ    1B58
.................... 		write_default_param_file();
1B52:  MOVLB  0
1B54:  RCALL  180A
1B56:  MOVLB  1
.................... 	}
1B58:  MOVLB  0
1B5A:  GOTO   37C2 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... #include "i2c_handler_dcswc_module_latching_contactor.c"
.................... #include "registers_dcswc_module_latching_contactor.h"
.................... 
.................... /* first two or three registers will give enough information for telemetry */
.................... /* 10 bit input voltage ADC averaged value */
.................... #define I2C_REG_VOLTAGE_INPUT_AVG             0  
.................... /* two 8 bit channel states (A is MSB / B is LSB) */
.................... #define I2C_REG_STATE_CONTACTORS              1 
.................... /* 10 bit NTC thermistor ADC averaged value */
.................... #define I2C_REG_TEMPERATURE_BOARD_AVG         2
.................... 
....................   
.................... /* channel 0 / A */
.................... /* command can only come from I2C interface */
.................... #define I2C_REG_CH0_COMMAND_ON                3 /* R/W seconds */
.................... #define I2C_REG_CH0_COMMAND_ON_HOLD           4
.................... 
.................... #define I2C_REG_CH0_COMMAND_OFF               5 /* R/W seconds */
.................... #define I2C_REG_CH0_COMMAND_OFF_HOLD          6
.................... 
.................... /* low voltage disconnect */
.................... #define I2C_REG_CH0_LVD_DISCONNECT            7  /* R seconds */
.................... #define I2C_REG_CH0_LVD_RECONNECT             8 
.................... 
.................... /* high voltage disconnect */
.................... #define I2C_REG_CH0_HVD_DISCONNECT            9 /* R seconds */
.................... #define I2C_REG_CH0_HVD_RECONNECT             10
.................... 
.................... /* low temperature disconnect */
.................... #define I2C_REG_CH0_LTD_DISCONNECT            11  /* R seconds */
.................... #define I2C_REG_CH0_LTD_RECONNECT             12
.................... 
.................... /* high temperature disconnect */
.................... #define I2C_REG_CH0_HTD_DISCONNECT            13 /* R seconds */
.................... #define I2C_REG_CH0_HTD_RECONNECT             14
.................... 
.................... /* reserved for future, unimplemented */
.................... #define I2C_REG_CH0_FUT_DISCONNECT            15 /* R seconds */
.................... #define I2C_REG_CH0_FUT_RECONNECT             16
.................... 
.................... /* channel 1 / B */
.................... /* command can only come from I2C interface */
.................... #define I2C_REG_CH1_COMMAND_ON                17 /* R/W seconds */
.................... #define I2C_REG_CH1_COMMAND_ON_HOLD           18
.................... 
.................... #define I2C_REG_CH1_COMMAND_OFF               19 /* R/W seconds */
.................... #define I2C_REG_CH1_COMMAND_OFF_HOLD          20
.................... 
.................... /* low voltage disconnect */
.................... #define I2C_REG_CH1_LVD_DISCONNECT            21 /* R seconds */
.................... #define I2C_REG_CH1_LVD_RECONNECT             22 
.................... 
.................... /* high voltage disconnect */
.................... #define I2C_REG_CH1_HVD_DISCONNECT            23 /* R seconds */
.................... #define I2C_REG_CH1_HVD_RECONNECT             24
.................... 
.................... /* low temperature disconnect */
.................... #define I2C_REG_CH1_LTD_DISCONNECT            25  /* R seconds */
.................... #define I2C_REG_CH1_LTD_RECONNECT             26
.................... 
.................... /* high temperature disconnect */
.................... #define I2C_REG_CH1_HTD_DISCONNECT            27 /* R seconds */
.................... #define I2C_REG_CH1_HTD_RECONNECT             28
.................... 
.................... /* reserved for future, unimplemented */
.................... #define I2C_REG_CH1_FUT_DISCONNECT            29 /* R seconds */
.................... #define I2C_REG_CH1_FUT_RECONNECT             30
.................... 
.................... /* meta */
.................... #define I2C_REG_SEQUENCE_NUMBER               31 /* R */
.................... #define I2C_REG_TIME_INTERVAL_MILLISECONDS    32
.................... #define I2C_REG_TIME_UPTIME_MINUTES           33
.................... #define I2C_REG_DEFAULT_PARAMS_WRITTEN        34
.................... 
.................... /* channel configuration */
.................... /* channel 0 / A */
.................... #define I2C_REG_CH0_COMMAND_ON_HOLD_INITIAL   40
.................... 
.................... #define I2C_REG_CH0_COMMAND_OFF_HOLD_INITIAL  41
.................... 
.................... #define I2C_REG_CH0_LVD_DISCONNECT_ADC        42
.................... #define I2C_REG_CH0_LVD_DISCONNECT_DELAY      43
.................... #define I2C_REG_CH0_LVD_RECONNECT_ADC         44
.................... #define I2C_REG_CH0_LVD_RECONNECT_DELAY       45
.................... 
.................... #define I2C_REG_CH0_HVD_DISCONNECT_ADC        46
.................... #define I2C_REG_CH0_HVD_DISCONNECT_DELAY      47
.................... #define I2C_REG_CH0_HVD_RECONNECT_ADC         48
.................... #define I2C_REG_CH0_HVD_RECONNECT_DELAY       49
.................... 
.................... #define I2C_REG_CH0_LTD_DISCONNECT_ADC        50
.................... #define I2C_REG_CH0_LTD_DISCONNECT_DELAY      51
.................... #define I2C_REG_CH0_LTD_RECONNECT_ADC         52
.................... #define I2C_REG_CH0_LTD_RECONNECT_DELAY       53
.................... 
.................... #define I2C_REG_CH0_HTD_DISCONNECT_ADC        54
.................... #define I2C_REG_CH0_HTD_DISCONNECT_DELAY      55
.................... #define I2C_REG_CH0_HTD_RECONNECT_ADC         56
.................... #define I2C_REG_CH0_HTD_RECONNECT_DELAY       57
.................... 
.................... #define I2C_REG_CH0_FUT_DISCONNECT_VALUE      58
.................... #define I2C_REG_CH0_FUT_DISCONNECT_DELAY      59
.................... #define I2C_REG_CH0_FUT_RECONNECT_VALUE       60
.................... #define I2C_REG_CH0_FUT_RECONNECT_DELAY       61
.................... 
.................... /* channel 1 / B */
.................... #define I2C_REG_CH1_COMMAND_ON_HOLD_INITIAL   62
.................... 
.................... #define I2C_REG_CH1_COMMAND_OFF_HOLD_INITIAL  63
.................... 
.................... #define I2C_REG_CH1_LVD_DISCONNECT_ADC        64
.................... #define I2C_REG_CH1_LVD_DISCONNECT_DELAY      65
.................... #define I2C_REG_CH1_LVD_RECONNECT_ADC         66
.................... #define I2C_REG_CH1_LVD_RECONNECT_DELAY       67
.................... 
.................... #define I2C_REG_CH1_HVD_DISCONNECT_ADC        68
.................... #define I2C_REG_CH1_HVD_DISCONNECT_DELAY      69
.................... #define I2C_REG_CH1_HVD_RECONNECT_ADC         70
.................... #define I2C_REG_CH1_HVD_RECONNECT_DELAY       71
.................... 
.................... #define I2C_REG_CH1_LTD_DISCONNECT_ADC        72
.................... #define I2C_REG_CH1_LTD_DISCONNECT_DELAY      73
.................... #define I2C_REG_CH1_LTD_RECONNECT_ADC         74
.................... #define I2C_REG_CH1_LTD_RECONNECT_DELAY       75
.................... 
.................... #define I2C_REG_CH1_HTD_DISCONNECT_ADC        76
.................... #define I2C_REG_CH1_HTD_DISCONNECT_DELAY      77
.................... #define I2C_REG_CH1_HTD_RECONNECT_ADC         78
.................... #define I2C_REG_CH1_HTD_RECONNECT_DELAY       79
.................... 
.................... #define I2C_REG_CH1_FUT_DISCONNECT_VALUE      80
.................... #define I2C_REG_CH1_FUT_DISCONNECT_DELAY      81
.................... #define I2C_REG_CH1_FUT_RECONNECT_VALUE       82
.................... #define I2C_REG_CH1_FUT_RECONNECT_DELAY       83
.................... 
.................... 
.................... /* configuration */
.................... #define I2C_REG_CONFIG_HARDWARE_MODEL         84 /* R */
.................... #define I2C_REG_CONFIG_HARDWARE_VERSION       85
.................... #define I2C_REG_CONFIG_SOFTWARE_MODEL         86
.................... #define I2C_REG_CONFIG_SOFTWARE_VERSION       87
.................... #define I2C_REG_CONFIG_SOFTWARE_YEAR          88
.................... #define I2C_REG_CONFIG_SOFTWARE_MONTH         89
.................... #define I2C_REG_CONFIG_SOFTWARE_DAY           90
.................... 
.................... #define I2C_REG_CONFIG_PARAM_WRITE            100 /* R / W */
.................... 
.................... 
.................... 
.................... void write_i2c(int8 addr, int16 value) {
.................... 	int8 c;
.................... 
.................... 	/* c is the channel we are accessing based on register range */
.................... 	if ( addr >= I2C_REG_CH1_COMMAND_ON && addr <= I2C_REG_CH1_FUT_RECONNECT ) {
*
00E6:  MOVLB  1
00E8:  MOVF   x2E,W
00EA:  SUBLW  10
00EC:  BC    00FE
00EE:  MOVF   x2E,W
00F0:  SUBLW  1E
00F2:  BNC   00FE
.................... 		/* channel 1 status region */
.................... 		c=1;
00F4:  MOVLW  01
00F6:  MOVWF  x31
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON - I2C_REG_CH0_COMMAND_ON);
00F8:  MOVLW  0E
00FA:  SUBWF  x2E,F
.................... 	} else if ( addr >= I2C_REG_CH1_COMMAND_ON_HOLD && addr <= I2C_REG_CH1_FUT_RECONNECT_DELAY ) {
00FC:  BRA    0116
00FE:  MOVF   x2E,W
0100:  SUBLW  11
0102:  BC    0114
0104:  MOVF   x2E,W
0106:  SUBLW  53
0108:  BNC   0114
.................... 		/* channel 1 configuration region */
.................... 		c=1;
010A:  MOVLW  01
010C:  MOVWF  x31
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON_HOLD - I2C_REG_CH0_COMMAND_ON_HOLD );
010E:  MOVLW  0E
0110:  SUBWF  x2E,F
.................... 	} else {
0112:  BRA    0116
.................... 		c=0;
0114:  CLRF   x31
.................... 	}
.................... 
.................... 	fputc(addr,STREAM_FTDI);
0116:  MOVF   x2E,W
0118:  MOVLB  0
011A:  BRA    00DC
.................... 
.................... 	switch ( addr ) {
011C:  MOVLB  1
011E:  MOVF   x2E,W
0120:  XORLW  03
0122:  MOVLB  0
0124:  BZ    019C
0126:  XORLW  07
0128:  BZ    01CC
012A:  XORLW  01
012C:  BZ    01FC
012E:  XORLW  03
0130:  BTFSC  FD8.2
0132:  BRA    022C
0134:  XORLW  2C
0136:  BTFSC  FD8.2
0138:  BRA    025C
013A:  XORLW  01
013C:  BTFSC  FD8.2
013E:  BRA    028C
0140:  XORLW  07
0142:  BTFSC  FD8.2
0144:  BRA    02BC
0146:  XORLW  01
0148:  BTFSC  FD8.2
014A:  BRA    02EC
014C:  XORLW  03
014E:  BTFSC  FD8.2
0150:  BRA    031C
0152:  XORLW  01
0154:  BTFSC  FD8.2
0156:  BRA    034C
0158:  XORLW  1F
015A:  BTFSC  FD8.2
015C:  BRA    037C
015E:  XORLW  01
0160:  BTFSC  FD8.2
0162:  BRA    03AC
0164:  XORLW  03
0166:  BTFSC  FD8.2
0168:  BRA    03DC
016A:  XORLW  01
016C:  BTFSC  FD8.2
016E:  BRA    040C
0170:  XORLW  07
0172:  BTFSC  FD8.2
0174:  BRA    043C
0176:  XORLW  01
0178:  BTFSC  FD8.2
017A:  BRA    046C
017C:  XORLW  03
017E:  BTFSC  FD8.2
0180:  BRA    049C
0182:  XORLW  01
0184:  BTFSC  FD8.2
0186:  BRA    04CC
0188:  XORLW  0F
018A:  BTFSC  FD8.2
018C:  BRA    04FC
018E:  XORLW  01
0190:  BTFSC  FD8.2
0192:  BRA    052C
0194:  XORLW  5D
0196:  BTFSC  FD8.2
0198:  BRA    055C
019A:  BRA    05A4
.................... 		case I2C_REG_CH0_COMMAND_ON:
.................... 			channel[c].command_on_seconds=value;
019C:  MOVLB  1
019E:  MOVF   x31,W
01A0:  MULLW  19
01A2:  MOVF   FF3,W
01A4:  CLRF   x33
01A6:  MOVWF  x32
01A8:  MOVLW  01
01AA:  ADDWF  x32,W
01AC:  MOVWF  01
01AE:  MOVLW  00
01B0:  ADDWFC x33,W
01B2:  MOVWF  03
01B4:  MOVF   01,W
01B6:  ADDLW  DA
01B8:  MOVWF  FE9
01BA:  MOVLW  00
01BC:  ADDWFC 03,W
01BE:  MOVWF  FEA
01C0:  MOVFF  130,FEC
01C4:  MOVF   FED,F
01C6:  MOVFF  12F,FEF
.................... 			break;
01CA:  BRA    05A4
.................... 		case I2C_REG_CH0_COMMAND_ON_HOLD:
.................... 			channel[c].command_on_hold_seconds=value;
01CC:  MOVLB  1
01CE:  MOVF   x31,W
01D0:  MULLW  19
01D2:  MOVF   FF3,W
01D4:  CLRF   x33
01D6:  MOVWF  x32
01D8:  MOVLW  03
01DA:  ADDWF  x32,W
01DC:  MOVWF  01
01DE:  MOVLW  00
01E0:  ADDWFC x33,W
01E2:  MOVWF  03
01E4:  MOVF   01,W
01E6:  ADDLW  DA
01E8:  MOVWF  FE9
01EA:  MOVLW  00
01EC:  ADDWFC 03,W
01EE:  MOVWF  FEA
01F0:  MOVFF  130,FEC
01F4:  MOVF   FED,F
01F6:  MOVFF  12F,FEF
.................... 			break;	
01FA:  BRA    05A4
.................... 		case I2C_REG_CH0_COMMAND_OFF:
.................... 			channel[c].command_off_seconds=value;
01FC:  MOVLB  1
01FE:  MOVF   x31,W
0200:  MULLW  19
0202:  MOVF   FF3,W
0204:  CLRF   x33
0206:  MOVWF  x32
0208:  MOVLW  05
020A:  ADDWF  x32,W
020C:  MOVWF  01
020E:  MOVLW  00
0210:  ADDWFC x33,W
0212:  MOVWF  03
0214:  MOVF   01,W
0216:  ADDLW  DA
0218:  MOVWF  FE9
021A:  MOVLW  00
021C:  ADDWFC 03,W
021E:  MOVWF  FEA
0220:  MOVFF  130,FEC
0224:  MOVF   FED,F
0226:  MOVFF  12F,FEF
.................... 			break;
022A:  BRA    05A4
.................... 		case I2C_REG_CH0_COMMAND_OFF_HOLD:
.................... 			channel[c].command_off_hold_seconds=value;
022C:  MOVLB  1
022E:  MOVF   x31,W
0230:  MULLW  19
0232:  MOVF   FF3,W
0234:  CLRF   x33
0236:  MOVWF  x32
0238:  MOVLW  07
023A:  ADDWF  x32,W
023C:  MOVWF  01
023E:  MOVLW  00
0240:  ADDWFC x33,W
0242:  MOVWF  03
0244:  MOVF   01,W
0246:  ADDLW  DA
0248:  MOVWF  FE9
024A:  MOVLW  00
024C:  ADDWFC 03,W
024E:  MOVWF  FEA
0250:  MOVFF  130,FEC
0254:  MOVF   FED,F
0256:  MOVFF  12F,FEF
.................... 			break;
025A:  BRA    05A4
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_ADC:
.................... 			config.ch[c].lvd_disconnect_adc=value;
025C:  MOVLB  1
025E:  MOVF   x31,W
0260:  MULLW  24
0262:  MOVF   FF3,W
0264:  CLRF   x33
0266:  MOVWF  x32
0268:  MOVLW  04
026A:  ADDWF  x32,W
026C:  MOVWF  01
026E:  MOVLW  00
0270:  ADDWFC x33,W
0272:  MOVWF  03
0274:  MOVF   01,W
0276:  ADDLW  1B
0278:  MOVWF  FE9
027A:  MOVLW  00
027C:  ADDWFC 03,W
027E:  MOVWF  FEA
0280:  MOVFF  130,FEC
0284:  MOVF   FED,F
0286:  MOVFF  12F,FEF
.................... 			break;
028A:  BRA    05A4
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_DELAY:
.................... 			config.ch[c].lvd_disconnect_delay=value;
028C:  MOVLB  1
028E:  MOVF   x31,W
0290:  MULLW  24
0292:  MOVF   FF3,W
0294:  CLRF   x33
0296:  MOVWF  x32
0298:  MOVLW  06
029A:  ADDWF  x32,W
029C:  MOVWF  01
029E:  MOVLW  00
02A0:  ADDWFC x33,W
02A2:  MOVWF  03
02A4:  MOVF   01,W
02A6:  ADDLW  1B
02A8:  MOVWF  FE9
02AA:  MOVLW  00
02AC:  ADDWFC 03,W
02AE:  MOVWF  FEA
02B0:  MOVFF  130,FEC
02B4:  MOVF   FED,F
02B6:  MOVFF  12F,FEF
.................... 			break;
02BA:  BRA    05A4
.................... 		case I2C_REG_CH0_LVD_RECONNECT_ADC:
.................... 			config.ch[c].lvd_reconnect_adc=value;
02BC:  MOVLB  1
02BE:  MOVF   x31,W
02C0:  MULLW  24
02C2:  MOVF   FF3,W
02C4:  CLRF   x33
02C6:  MOVWF  x32
02C8:  MOVLW  08
02CA:  ADDWF  x32,W
02CC:  MOVWF  01
02CE:  MOVLW  00
02D0:  ADDWFC x33,W
02D2:  MOVWF  03
02D4:  MOVF   01,W
02D6:  ADDLW  1B
02D8:  MOVWF  FE9
02DA:  MOVLW  00
02DC:  ADDWFC 03,W
02DE:  MOVWF  FEA
02E0:  MOVFF  130,FEC
02E4:  MOVF   FED,F
02E6:  MOVFF  12F,FEF
.................... 			break;
02EA:  BRA    05A4
.................... 		case I2C_REG_CH0_LVD_RECONNECT_DELAY:
.................... 			config.ch[c].lvd_reconnect_delay=value;
02EC:  MOVLB  1
02EE:  MOVF   x31,W
02F0:  MULLW  24
02F2:  MOVF   FF3,W
02F4:  CLRF   x33
02F6:  MOVWF  x32
02F8:  MOVLW  0A
02FA:  ADDWF  x32,W
02FC:  MOVWF  01
02FE:  MOVLW  00
0300:  ADDWFC x33,W
0302:  MOVWF  03
0304:  MOVF   01,W
0306:  ADDLW  1B
0308:  MOVWF  FE9
030A:  MOVLW  00
030C:  ADDWFC 03,W
030E:  MOVWF  FEA
0310:  MOVFF  130,FEC
0314:  MOVF   FED,F
0316:  MOVFF  12F,FEF
.................... 			break;
031A:  BRA    05A4
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_ADC:
.................... 			config.ch[c].hvd_disconnect_adc=value;
031C:  MOVLB  1
031E:  MOVF   x31,W
0320:  MULLW  24
0322:  MOVF   FF3,W
0324:  CLRF   x33
0326:  MOVWF  x32
0328:  MOVLW  0C
032A:  ADDWF  x32,W
032C:  MOVWF  01
032E:  MOVLW  00
0330:  ADDWFC x33,W
0332:  MOVWF  03
0334:  MOVF   01,W
0336:  ADDLW  1B
0338:  MOVWF  FE9
033A:  MOVLW  00
033C:  ADDWFC 03,W
033E:  MOVWF  FEA
0340:  MOVFF  130,FEC
0344:  MOVF   FED,F
0346:  MOVFF  12F,FEF
.................... 			break;
034A:  BRA    05A4
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_DELAY:
.................... 			config.ch[c].hvd_disconnect_delay=value;
034C:  MOVLB  1
034E:  MOVF   x31,W
0350:  MULLW  24
0352:  MOVF   FF3,W
0354:  CLRF   x33
0356:  MOVWF  x32
0358:  MOVLW  0E
035A:  ADDWF  x32,W
035C:  MOVWF  01
035E:  MOVLW  00
0360:  ADDWFC x33,W
0362:  MOVWF  03
0364:  MOVF   01,W
0366:  ADDLW  1B
0368:  MOVWF  FE9
036A:  MOVLW  00
036C:  ADDWFC 03,W
036E:  MOVWF  FEA
0370:  MOVFF  130,FEC
0374:  MOVF   FED,F
0376:  MOVFF  12F,FEF
.................... 			break;
037A:  BRA    05A4
.................... 		case I2C_REG_CH0_HVD_RECONNECT_ADC:
.................... 			config.ch[c].hvd_reconnect_adc=value;
037C:  MOVLB  1
037E:  MOVF   x31,W
0380:  MULLW  24
0382:  MOVF   FF3,W
0384:  CLRF   x33
0386:  MOVWF  x32
0388:  MOVLW  10
038A:  ADDWF  x32,W
038C:  MOVWF  01
038E:  MOVLW  00
0390:  ADDWFC x33,W
0392:  MOVWF  03
0394:  MOVF   01,W
0396:  ADDLW  1B
0398:  MOVWF  FE9
039A:  MOVLW  00
039C:  ADDWFC 03,W
039E:  MOVWF  FEA
03A0:  MOVFF  130,FEC
03A4:  MOVF   FED,F
03A6:  MOVFF  12F,FEF
.................... 			break;
03AA:  BRA    05A4
.................... 		case I2C_REG_CH0_HVD_RECONNECT_DELAY:
.................... 			config.ch[c].hvd_reconnect_delay=value;
03AC:  MOVLB  1
03AE:  MOVF   x31,W
03B0:  MULLW  24
03B2:  MOVF   FF3,W
03B4:  CLRF   x33
03B6:  MOVWF  x32
03B8:  MOVLW  12
03BA:  ADDWF  x32,W
03BC:  MOVWF  01
03BE:  MOVLW  00
03C0:  ADDWFC x33,W
03C2:  MOVWF  03
03C4:  MOVF   01,W
03C6:  ADDLW  1B
03C8:  MOVWF  FE9
03CA:  MOVLW  00
03CC:  ADDWFC 03,W
03CE:  MOVWF  FEA
03D0:  MOVFF  130,FEC
03D4:  MOVF   FED,F
03D6:  MOVFF  12F,FEF
.................... 			break;
03DA:  BRA    05A4
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_ADC:
.................... 			config.ch[c].ltd_disconnect_adc=value;
03DC:  MOVLB  1
03DE:  MOVF   x31,W
03E0:  MULLW  24
03E2:  MOVF   FF3,W
03E4:  CLRF   x33
03E6:  MOVWF  x32
03E8:  MOVLW  14
03EA:  ADDWF  x32,W
03EC:  MOVWF  01
03EE:  MOVLW  00
03F0:  ADDWFC x33,W
03F2:  MOVWF  03
03F4:  MOVF   01,W
03F6:  ADDLW  1B
03F8:  MOVWF  FE9
03FA:  MOVLW  00
03FC:  ADDWFC 03,W
03FE:  MOVWF  FEA
0400:  MOVFF  130,FEC
0404:  MOVF   FED,F
0406:  MOVFF  12F,FEF
.................... 			break;
040A:  BRA    05A4
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_DELAY:
.................... 			config.ch[c].ltd_disconnect_delay=value;
040C:  MOVLB  1
040E:  MOVF   x31,W
0410:  MULLW  24
0412:  MOVF   FF3,W
0414:  CLRF   x33
0416:  MOVWF  x32
0418:  MOVLW  16
041A:  ADDWF  x32,W
041C:  MOVWF  01
041E:  MOVLW  00
0420:  ADDWFC x33,W
0422:  MOVWF  03
0424:  MOVF   01,W
0426:  ADDLW  1B
0428:  MOVWF  FE9
042A:  MOVLW  00
042C:  ADDWFC 03,W
042E:  MOVWF  FEA
0430:  MOVFF  130,FEC
0434:  MOVF   FED,F
0436:  MOVFF  12F,FEF
.................... 			break;
043A:  BRA    05A4
.................... 		case I2C_REG_CH0_LTD_RECONNECT_ADC:
.................... 			config.ch[c].ltd_reconnect_adc=value;
043C:  MOVLB  1
043E:  MOVF   x31,W
0440:  MULLW  24
0442:  MOVF   FF3,W
0444:  CLRF   x33
0446:  MOVWF  x32
0448:  MOVLW  18
044A:  ADDWF  x32,W
044C:  MOVWF  01
044E:  MOVLW  00
0450:  ADDWFC x33,W
0452:  MOVWF  03
0454:  MOVF   01,W
0456:  ADDLW  1B
0458:  MOVWF  FE9
045A:  MOVLW  00
045C:  ADDWFC 03,W
045E:  MOVWF  FEA
0460:  MOVFF  130,FEC
0464:  MOVF   FED,F
0466:  MOVFF  12F,FEF
.................... 			break;
046A:  BRA    05A4
.................... 		case I2C_REG_CH0_LTD_RECONNECT_DELAY:
.................... 			config.ch[c].ltd_reconnect_delay=value;
046C:  MOVLB  1
046E:  MOVF   x31,W
0470:  MULLW  24
0472:  MOVF   FF3,W
0474:  CLRF   x33
0476:  MOVWF  x32
0478:  MOVLW  1A
047A:  ADDWF  x32,W
047C:  MOVWF  01
047E:  MOVLW  00
0480:  ADDWFC x33,W
0482:  MOVWF  03
0484:  MOVF   01,W
0486:  ADDLW  1B
0488:  MOVWF  FE9
048A:  MOVLW  00
048C:  ADDWFC 03,W
048E:  MOVWF  FEA
0490:  MOVFF  130,FEC
0494:  MOVF   FED,F
0496:  MOVFF  12F,FEF
.................... 			break;
049A:  BRA    05A4
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_ADC:
.................... 			config.ch[c].htd_disconnect_adc=value;
049C:  MOVLB  1
049E:  MOVF   x31,W
04A0:  MULLW  24
04A2:  MOVF   FF3,W
04A4:  CLRF   x33
04A6:  MOVWF  x32
04A8:  MOVLW  1C
04AA:  ADDWF  x32,W
04AC:  MOVWF  01
04AE:  MOVLW  00
04B0:  ADDWFC x33,W
04B2:  MOVWF  03
04B4:  MOVF   01,W
04B6:  ADDLW  1B
04B8:  MOVWF  FE9
04BA:  MOVLW  00
04BC:  ADDWFC 03,W
04BE:  MOVWF  FEA
04C0:  MOVFF  130,FEC
04C4:  MOVF   FED,F
04C6:  MOVFF  12F,FEF
.................... 			break;
04CA:  BRA    05A4
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_DELAY:
.................... 			config.ch[c].htd_disconnect_delay=value;
04CC:  MOVLB  1
04CE:  MOVF   x31,W
04D0:  MULLW  24
04D2:  MOVF   FF3,W
04D4:  CLRF   x33
04D6:  MOVWF  x32
04D8:  MOVLW  1E
04DA:  ADDWF  x32,W
04DC:  MOVWF  01
04DE:  MOVLW  00
04E0:  ADDWFC x33,W
04E2:  MOVWF  03
04E4:  MOVF   01,W
04E6:  ADDLW  1B
04E8:  MOVWF  FE9
04EA:  MOVLW  00
04EC:  ADDWFC 03,W
04EE:  MOVWF  FEA
04F0:  MOVFF  130,FEC
04F4:  MOVF   FED,F
04F6:  MOVFF  12F,FEF
.................... 			break;
04FA:  BRA    05A4
.................... 		case I2C_REG_CH0_HTD_RECONNECT_ADC:
.................... 			config.ch[c].htd_reconnect_adc=value;
04FC:  MOVLB  1
04FE:  MOVF   x31,W
0500:  MULLW  24
0502:  MOVF   FF3,W
0504:  CLRF   x33
0506:  MOVWF  x32
0508:  MOVLW  20
050A:  ADDWF  x32,W
050C:  MOVWF  01
050E:  MOVLW  00
0510:  ADDWFC x33,W
0512:  MOVWF  03
0514:  MOVF   01,W
0516:  ADDLW  1B
0518:  MOVWF  FE9
051A:  MOVLW  00
051C:  ADDWFC 03,W
051E:  MOVWF  FEA
0520:  MOVFF  130,FEC
0524:  MOVF   FED,F
0526:  MOVFF  12F,FEF
.................... 			break;
052A:  BRA    05A4
.................... 		case I2C_REG_CH0_HTD_RECONNECT_DELAY:
.................... 			config.ch[c].htd_reconnect_delay=value;
052C:  MOVLB  1
052E:  MOVF   x31,W
0530:  MULLW  24
0532:  MOVF   FF3,W
0534:  CLRF   x33
0536:  MOVWF  x32
0538:  MOVLW  22
053A:  ADDWF  x32,W
053C:  MOVWF  01
053E:  MOVLW  00
0540:  ADDWFC x33,W
0542:  MOVWF  03
0544:  MOVF   01,W
0546:  ADDLW  1B
0548:  MOVWF  FE9
054A:  MOVLW  00
054C:  ADDWFC 03,W
054E:  MOVWF  FEA
0550:  MOVFF  130,FEC
0554:  MOVF   FED,F
0556:  MOVFF  12F,FEF
.................... 			break;
055A:  BRA    05A4
.................... 		/* don't need to implement FUT ... there is nowhere for it to go anyhow */
.................... 
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			if ( 1 == value ) {
055C:  MOVLB  1
055E:  DECFSZ x2F,W
0560:  BRA    056E
0562:  MOVF   x30,F
0564:  BNZ   056E
.................... 				timers.now_write_config=1;
0566:  MOVLB  0
0568:  BSF    xCF.3
.................... 			} else if ( 2 == value ) {
056A:  BRA    05A2
056C:  MOVLB  1
056E:  MOVF   x2F,W
0570:  SUBLW  02
0572:  BNZ   0580
0574:  MOVF   x30,F
0576:  BNZ   0580
.................... 				timers.now_reset_config=1;
0578:  MOVLB  0
057A:  BSF    xCF.4
.................... 			} else if ( 1802 == value ) {
057C:  BRA    05A2
057E:  MOVLB  1
0580:  MOVF   x2F,W
0582:  SUBLW  0A
0584:  BNZ   0596
0586:  MOVF   x30,W
0588:  SUBLW  07
058A:  BNZ   0596
.................... 				current.factory_unlocked =1;
058C:  MOVLW  01
058E:  MOVLB  0
0590:  MOVWF  xCA
.................... 			} else if ( 65535 == value ) {
0592:  BRA    05A2
0594:  MOVLB  1
0596:  INCFSZ x2F,W
0598:  BRA    05A0
059A:  INCFSZ x30,W
059C:  BRA    05A0
.................... 				reset_cpu();
059E:  RESET
05A0:  MOVLB  0
.................... 			}
.................... 			break;
05A2:  MOVLB  1
05A4:  MOVLB  0
.................... 		default:
.................... 			/* do nothing */
.................... 	}
05A6:  GOTO   0F28 (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... int16 map_i2c(int8 addr) {
.................... 	int8 c;
.................... 
.................... 	/* c is the channel we are accessing based on register range */
.................... 	if ( addr >= I2C_REG_CH1_COMMAND_ON && addr <= I2C_REG_CH1_FUT_RECONNECT ) {
*
062A:  MOVLB  1
062C:  MOVF   x2D,W
062E:  SUBLW  10
0630:  BC    0642
0632:  MOVF   x2D,W
0634:  SUBLW  1E
0636:  BNC   0642
.................... 		/* channel 1 status region */
.................... 		c=1;
0638:  MOVLW  01
063A:  MOVWF  x2E
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON - I2C_REG_CH0_COMMAND_ON);
063C:  MOVLW  0E
063E:  SUBWF  x2D,F
.................... 	} else if ( addr >= I2C_REG_CH1_COMMAND_ON_HOLD && addr <= I2C_REG_CH1_FUT_RECONNECT_DELAY ) {
0640:  BRA    065A
0642:  MOVF   x2D,W
0644:  SUBLW  11
0646:  BC    0658
0648:  MOVF   x2D,W
064A:  SUBLW  53
064C:  BNC   0658
.................... 		/* channel 1 configuration region */
.................... 		c=1;
064E:  MOVLW  01
0650:  MOVWF  x2E
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON_HOLD - I2C_REG_CH0_COMMAND_ON_HOLD );
0652:  MOVLW  0E
0654:  SUBWF  x2D,F
.................... 	} else {
0656:  BRA    065A
.................... 		c=0;
0658:  CLRF   x2E
.................... 	}
.................... 
.................... 	switch ( addr ) {
065A:  MOVF   x2D,W
065C:  XORLW  00
065E:  MOVLB  0
0660:  BTFSC  FD8.2
0662:  BRA    0792
0664:  XORLW  01
0666:  BTFSC  FD8.2
0668:  BRA    079E
066A:  XORLW  03
066C:  BTFSC  FD8.2
066E:  BRA    07AC
0670:  XORLW  01
0672:  BTFSC  FD8.2
0674:  BRA    07BA
0676:  XORLW  07
0678:  BTFSC  FD8.2
067A:  BRA    07F0
067C:  XORLW  01
067E:  BTFSC  FD8.2
0680:  BRA    0826
0682:  XORLW  03
0684:  BTFSC  FD8.2
0686:  BRA    085C
0688:  XORLW  01
068A:  BTFSC  FD8.2
068C:  BRA    0892
068E:  XORLW  0F
0690:  BTFSC  FD8.2
0692:  BRA    08C8
0694:  XORLW  01
0696:  BTFSC  FD8.2
0698:  BRA    08FE
069A:  XORLW  03
069C:  BTFSC  FD8.2
069E:  BRA    0934
06A0:  XORLW  01
06A2:  BTFSC  FD8.2
06A4:  BRA    096A
06A6:  XORLW  07
06A8:  BTFSC  FD8.2
06AA:  BRA    09A0
06AC:  XORLW  01
06AE:  BTFSC  FD8.2
06B0:  BRA    09D6
06B2:  XORLW  03
06B4:  BTFSC  FD8.2
06B6:  BRA    0A0C
06B8:  XORLW  01
06BA:  BTFSC  FD8.2
06BC:  BRA    0A42
06BE:  XORLW  1F
06C0:  BTFSC  FD8.2
06C2:  BRA    0A42
06C4:  XORLW  0F
06C6:  BTFSC  FD8.2
06C8:  BRA    0A4A
06CA:  XORLW  3F
06CC:  BTFSC  FD8.2
06CE:  BRA    0A54
06D0:  XORLW  01
06D2:  BTFSC  FD8.2
06D4:  BRA    0A5E
06D6:  XORLW  03
06D8:  BTFSC  FD8.2
06DA:  BRA    0A68
06DC:  XORLW  0A
06DE:  BTFSC  FD8.2
06E0:  BRA    0A70
06E2:  XORLW  01
06E4:  BTFSC  FD8.2
06E6:  BRA    0A9A
06E8:  XORLW  03
06EA:  BTFSC  FD8.2
06EC:  BRA    0AD0
06EE:  XORLW  01
06F0:  BTFSC  FD8.2
06F2:  BRA    0B06
06F4:  XORLW  07
06F6:  BTFSC  FD8.2
06F8:  BRA    0B3C
06FA:  XORLW  01
06FC:  BTFSC  FD8.2
06FE:  BRA    0B72
0700:  XORLW  03
0702:  BTFSC  FD8.2
0704:  BRA    0BA8
0706:  XORLW  01
0708:  BTFSC  FD8.2
070A:  BRA    0BDE
070C:  XORLW  1F
070E:  BTFSC  FD8.2
0710:  BRA    0C14
0712:  XORLW  01
0714:  BTFSC  FD8.2
0716:  BRA    0C4A
0718:  XORLW  03
071A:  BTFSC  FD8.2
071C:  BRA    0C80
071E:  XORLW  01
0720:  BTFSC  FD8.2
0722:  BRA    0CB6
0724:  XORLW  07
0726:  BTFSC  FD8.2
0728:  BRA    0CEC
072A:  XORLW  01
072C:  BTFSC  FD8.2
072E:  BRA    0D22
0730:  XORLW  03
0732:  BTFSC  FD8.2
0734:  BRA    0D58
0736:  XORLW  01
0738:  BTFSC  FD8.2
073A:  BRA    0D8E
073C:  XORLW  0F
073E:  BTFSC  FD8.2
0740:  BRA    0DC4
0742:  XORLW  01
0744:  BTFSC  FD8.2
0746:  BRA    0DFA
0748:  XORLW  03
074A:  BTFSC  FD8.2
074C:  BRA    0E30
074E:  XORLW  01
0750:  BTFSC  FD8.2
0752:  BRA    0E30
0754:  XORLW  07
0756:  BTFSC  FD8.2
0758:  BRA    0E30
075A:  XORLW  01
075C:  BTFSC  FD8.2
075E:  BRA    0E30
0760:  XORLW  69
0762:  BTFSC  FD8.2
0764:  BRA    0E38
0766:  XORLW  01
0768:  BTFSC  FD8.2
076A:  BRA    0E42
076C:  XORLW  03
076E:  BTFSC  FD8.2
0770:  BRA    0E4C
0772:  XORLW  01
0774:  BTFSC  FD8.2
0776:  BRA    0E56
0778:  XORLW  0F
077A:  BTFSC  FD8.2
077C:  BRA    0E60
077E:  XORLW  01
0780:  BTFSC  FD8.2
0782:  BRA    0E68
0784:  XORLW  03
0786:  BTFSC  FD8.2
0788:  BRA    0E70
078A:  XORLW  3E
078C:  BTFSC  FD8.2
078E:  BRA    0E78
0790:  BRA    0E80
.................... 		/* not channel based */
.................... 		case I2C_REG_VOLTAGE_INPUT_AVG: 
.................... 			return (int16) adc_get(0);
0792:  MOVLB  1
0794:  CLRF   x2F
0796:  MOVLB  0
0798:  RCALL  05AA
079A:  MOVF   02,W
079C:  BRA    0E8A
.................... 		case I2C_REG_STATE_CONTACTORS:
.................... 			return (int16) make16(channel[0].state,channel[1].state);
079E:  MOVFF  DA,03
07A2:  MOVFF  F3,01
07A6:  MOVFF  DA,02
07AA:  BRA    0E8A
.................... 		case I2C_REG_TEMPERATURE_BOARD_AVG: 
.................... 			return (int16) adc_get(1);
07AC:  MOVLW  01
07AE:  MOVLB  1
07B0:  MOVWF  x2F
07B2:  MOVLB  0
07B4:  RCALL  05AA
07B6:  MOVF   02,W
07B8:  BRA    0E8A
.................... 
.................... 		/* status based on channel value c */
.................... 		case I2C_REG_CH0_COMMAND_ON :
.................... 			return (int16) channel[c].command_on_seconds;
07BA:  MOVLB  1
07BC:  MOVF   x2E,W
07BE:  MULLW  19
07C0:  MOVF   FF3,W
07C2:  CLRF   x30
07C4:  MOVWF  x2F
07C6:  MOVLW  01
07C8:  ADDWF  x2F,W
07CA:  MOVWF  01
07CC:  MOVLW  00
07CE:  ADDWFC x30,W
07D0:  MOVWF  03
07D2:  MOVF   01,W
07D4:  ADDLW  DA
07D6:  MOVWF  FE9
07D8:  MOVLW  00
07DA:  ADDWFC 03,W
07DC:  MOVWF  FEA
07DE:  MOVFF  FEC,03
07E2:  MOVF   FED,F
07E4:  MOVFF  FEF,01
07E8:  MOVFF  03,02
07EC:  MOVLB  0
07EE:  BRA    0E8A
.................... 		case I2C_REG_CH0_COMMAND_ON_HOLD:
.................... 			return (int16) channel[c].command_on_hold_seconds;
07F0:  MOVLB  1
07F2:  MOVF   x2E,W
07F4:  MULLW  19
07F6:  MOVF   FF3,W
07F8:  CLRF   x30
07FA:  MOVWF  x2F
07FC:  MOVLW  03
07FE:  ADDWF  x2F,W
0800:  MOVWF  01
0802:  MOVLW  00
0804:  ADDWFC x30,W
0806:  MOVWF  03
0808:  MOVF   01,W
080A:  ADDLW  DA
080C:  MOVWF  FE9
080E:  MOVLW  00
0810:  ADDWFC 03,W
0812:  MOVWF  FEA
0814:  MOVFF  FEC,03
0818:  MOVF   FED,F
081A:  MOVFF  FEF,01
081E:  MOVFF  03,02
0822:  MOVLB  0
0824:  BRA    0E8A
.................... 
.................... 		case I2C_REG_CH0_COMMAND_OFF:
.................... 			return (int16) channel[c].command_off_seconds;
0826:  MOVLB  1
0828:  MOVF   x2E,W
082A:  MULLW  19
082C:  MOVF   FF3,W
082E:  CLRF   x30
0830:  MOVWF  x2F
0832:  MOVLW  05
0834:  ADDWF  x2F,W
0836:  MOVWF  01
0838:  MOVLW  00
083A:  ADDWFC x30,W
083C:  MOVWF  03
083E:  MOVF   01,W
0840:  ADDLW  DA
0842:  MOVWF  FE9
0844:  MOVLW  00
0846:  ADDWFC 03,W
0848:  MOVWF  FEA
084A:  MOVFF  FEC,03
084E:  MOVF   FED,F
0850:  MOVFF  FEF,01
0854:  MOVFF  03,02
0858:  MOVLB  0
085A:  BRA    0E8A
.................... 		case I2C_REG_CH0_COMMAND_OFF_HOLD:
.................... 			return (int16) channel[c].command_off_hold_seconds;
085C:  MOVLB  1
085E:  MOVF   x2E,W
0860:  MULLW  19
0862:  MOVF   FF3,W
0864:  CLRF   x30
0866:  MOVWF  x2F
0868:  MOVLW  07
086A:  ADDWF  x2F,W
086C:  MOVWF  01
086E:  MOVLW  00
0870:  ADDWFC x30,W
0872:  MOVWF  03
0874:  MOVF   01,W
0876:  ADDLW  DA
0878:  MOVWF  FE9
087A:  MOVLW  00
087C:  ADDWFC 03,W
087E:  MOVWF  FEA
0880:  MOVFF  FEC,03
0884:  MOVF   FED,F
0886:  MOVFF  FEF,01
088A:  MOVFF  03,02
088E:  MOVLB  0
0890:  BRA    0E8A
.................... 
.................... 		case I2C_REG_CH0_LVD_DISCONNECT:
.................... 			return (int16) channel[c].lvd_disconnect_delay_seconds;
0892:  MOVLB  1
0894:  MOVF   x2E,W
0896:  MULLW  19
0898:  MOVF   FF3,W
089A:  CLRF   x30
089C:  MOVWF  x2F
089E:  MOVLW  09
08A0:  ADDWF  x2F,W
08A2:  MOVWF  01
08A4:  MOVLW  00
08A6:  ADDWFC x30,W
08A8:  MOVWF  03
08AA:  MOVF   01,W
08AC:  ADDLW  DA
08AE:  MOVWF  FE9
08B0:  MOVLW  00
08B2:  ADDWFC 03,W
08B4:  MOVWF  FEA
08B6:  MOVFF  FEC,03
08BA:  MOVF   FED,F
08BC:  MOVFF  FEF,01
08C0:  MOVFF  03,02
08C4:  MOVLB  0
08C6:  BRA    0E8A
.................... 		case I2C_REG_CH0_LVD_RECONNECT:
.................... 			return (int16) channel[c].lvd_reconnect_delay_seconds;
08C8:  MOVLB  1
08CA:  MOVF   x2E,W
08CC:  MULLW  19
08CE:  MOVF   FF3,W
08D0:  CLRF   x30
08D2:  MOVWF  x2F
08D4:  MOVLW  0B
08D6:  ADDWF  x2F,W
08D8:  MOVWF  01
08DA:  MOVLW  00
08DC:  ADDWFC x30,W
08DE:  MOVWF  03
08E0:  MOVF   01,W
08E2:  ADDLW  DA
08E4:  MOVWF  FE9
08E6:  MOVLW  00
08E8:  ADDWFC 03,W
08EA:  MOVWF  FEA
08EC:  MOVFF  FEC,03
08F0:  MOVF   FED,F
08F2:  MOVFF  FEF,01
08F6:  MOVFF  03,02
08FA:  MOVLB  0
08FC:  BRA    0E8A
.................... 
.................... 		case I2C_REG_CH0_HVD_DISCONNECT:
.................... 			return (int16) channel[c].hvd_disconnect_delay_seconds;
08FE:  MOVLB  1
0900:  MOVF   x2E,W
0902:  MULLW  19
0904:  MOVF   FF3,W
0906:  CLRF   x30
0908:  MOVWF  x2F
090A:  MOVLW  0D
090C:  ADDWF  x2F,W
090E:  MOVWF  01
0910:  MOVLW  00
0912:  ADDWFC x30,W
0914:  MOVWF  03
0916:  MOVF   01,W
0918:  ADDLW  DA
091A:  MOVWF  FE9
091C:  MOVLW  00
091E:  ADDWFC 03,W
0920:  MOVWF  FEA
0922:  MOVFF  FEC,03
0926:  MOVF   FED,F
0928:  MOVFF  FEF,01
092C:  MOVFF  03,02
0930:  MOVLB  0
0932:  BRA    0E8A
.................... 		case I2C_REG_CH0_HVD_RECONNECT:
.................... 			return (int16) channel[c].hvd_reconnect_delay_seconds;
0934:  MOVLB  1
0936:  MOVF   x2E,W
0938:  MULLW  19
093A:  MOVF   FF3,W
093C:  CLRF   x30
093E:  MOVWF  x2F
0940:  MOVLW  0F
0942:  ADDWF  x2F,W
0944:  MOVWF  01
0946:  MOVLW  00
0948:  ADDWFC x30,W
094A:  MOVWF  03
094C:  MOVF   01,W
094E:  ADDLW  DA
0950:  MOVWF  FE9
0952:  MOVLW  00
0954:  ADDWFC 03,W
0956:  MOVWF  FEA
0958:  MOVFF  FEC,03
095C:  MOVF   FED,F
095E:  MOVFF  FEF,01
0962:  MOVFF  03,02
0966:  MOVLB  0
0968:  BRA    0E8A
.................... 
.................... 		case I2C_REG_CH0_LTD_DISCONNECT:
.................... 			return (int16) channel[c].ltd_disconnect_delay_seconds;
096A:  MOVLB  1
096C:  MOVF   x2E,W
096E:  MULLW  19
0970:  MOVF   FF3,W
0972:  CLRF   x30
0974:  MOVWF  x2F
0976:  MOVLW  11
0978:  ADDWF  x2F,W
097A:  MOVWF  01
097C:  MOVLW  00
097E:  ADDWFC x30,W
0980:  MOVWF  03
0982:  MOVF   01,W
0984:  ADDLW  DA
0986:  MOVWF  FE9
0988:  MOVLW  00
098A:  ADDWFC 03,W
098C:  MOVWF  FEA
098E:  MOVFF  FEC,03
0992:  MOVF   FED,F
0994:  MOVFF  FEF,01
0998:  MOVFF  03,02
099C:  MOVLB  0
099E:  BRA    0E8A
.................... 		case I2C_REG_CH0_LTD_RECONNECT:
.................... 			return (int16) channel[c].ltd_reconnect_delay_seconds;
09A0:  MOVLB  1
09A2:  MOVF   x2E,W
09A4:  MULLW  19
09A6:  MOVF   FF3,W
09A8:  CLRF   x30
09AA:  MOVWF  x2F
09AC:  MOVLW  13
09AE:  ADDWF  x2F,W
09B0:  MOVWF  01
09B2:  MOVLW  00
09B4:  ADDWFC x30,W
09B6:  MOVWF  03
09B8:  MOVF   01,W
09BA:  ADDLW  DA
09BC:  MOVWF  FE9
09BE:  MOVLW  00
09C0:  ADDWFC 03,W
09C2:  MOVWF  FEA
09C4:  MOVFF  FEC,03
09C8:  MOVF   FED,F
09CA:  MOVFF  FEF,01
09CE:  MOVFF  03,02
09D2:  MOVLB  0
09D4:  BRA    0E8A
.................... 
.................... 		case I2C_REG_CH0_HTD_DISCONNECT:
.................... 			return (int16) channel[c].htd_disconnect_delay_seconds;
09D6:  MOVLB  1
09D8:  MOVF   x2E,W
09DA:  MULLW  19
09DC:  MOVF   FF3,W
09DE:  CLRF   x30
09E0:  MOVWF  x2F
09E2:  MOVLW  15
09E4:  ADDWF  x2F,W
09E6:  MOVWF  01
09E8:  MOVLW  00
09EA:  ADDWFC x30,W
09EC:  MOVWF  03
09EE:  MOVF   01,W
09F0:  ADDLW  DA
09F2:  MOVWF  FE9
09F4:  MOVLW  00
09F6:  ADDWFC 03,W
09F8:  MOVWF  FEA
09FA:  MOVFF  FEC,03
09FE:  MOVF   FED,F
0A00:  MOVFF  FEF,01
0A04:  MOVFF  03,02
0A08:  MOVLB  0
0A0A:  BRA    0E8A
.................... 		case I2C_REG_CH0_HTD_RECONNECT:
.................... 			return (int16) channel[c].htd_reconnect_delay_seconds;
0A0C:  MOVLB  1
0A0E:  MOVF   x2E,W
0A10:  MULLW  19
0A12:  MOVF   FF3,W
0A14:  CLRF   x30
0A16:  MOVWF  x2F
0A18:  MOVLW  17
0A1A:  ADDWF  x2F,W
0A1C:  MOVWF  01
0A1E:  MOVLW  00
0A20:  ADDWFC x30,W
0A22:  MOVWF  03
0A24:  MOVF   01,W
0A26:  ADDLW  DA
0A28:  MOVWF  FE9
0A2A:  MOVLW  00
0A2C:  ADDWFC 03,W
0A2E:  MOVWF  FEA
0A30:  MOVFF  FEC,03
0A34:  MOVF   FED,F
0A36:  MOVFF  FEF,01
0A3A:  MOVFF  03,02
0A3E:  MOVLB  0
0A40:  BRA    0E8A
.................... 
.................... 		case I2C_REG_CH0_FUT_DISCONNECT:
.................... 		case I2C_REG_CH0_FUT_RECONNECT:
.................... 			return (int16) 0xffff; /* not yet implemented */
0A42:  MOVLW  FF
0A44:  MOVWF  01
0A46:  MOVWF  02
0A48:  BRA    0E8A
.................... 
.................... 
.................... 		/* non-channel based meta */
.................... 		case I2C_REG_SEQUENCE_NUMBER:
.................... 			return (int16) current.sequence_number;
0A4A:  MOVFF  C4,01
0A4E:  MOVFF  C5,02
0A52:  BRA    0E8A
.................... 		case I2C_REG_TIME_INTERVAL_MILLISECONDS:
.................... 			return (int16) current.interval_milliseconds;
0A54:  MOVFF  C8,01
0A58:  MOVFF  C9,02
0A5C:  BRA    0E8A
.................... 		case I2C_REG_TIME_UPTIME_MINUTES:
.................... 			return (int16) current.uptime_minutes;
0A5E:  MOVFF  C6,01
0A62:  MOVFF  C7,02
0A66:  BRA    0E8A
.................... 		case I2C_REG_DEFAULT_PARAMS_WRITTEN:
.................... 			return (int16) current.default_params_written;
0A68:  MOVFF  CE,01
0A6C:  CLRF   02
0A6E:  BRA    0E8A
.................... 
.................... 		/* channel based configuration */
.................... 		case I2C_REG_CH0_COMMAND_ON_HOLD_INITIAL:
.................... 			return (int16) config.ch[c].command_on_hold_time;
0A70:  MOVLB  1
0A72:  MOVF   x2E,W
0A74:  MULLW  24
0A76:  MOVF   FF3,W
0A78:  CLRF   x30
0A7A:  MOVWF  x2F
0A7C:  MOVLW  1B
0A7E:  ADDWF  x2F,W
0A80:  MOVWF  FE9
0A82:  MOVLW  00
0A84:  ADDWFC x30,W
0A86:  MOVWF  FEA
0A88:  MOVFF  FEC,03
0A8C:  MOVF   FED,F
0A8E:  MOVFF  FEF,01
0A92:  MOVFF  03,02
0A96:  MOVLB  0
0A98:  BRA    0E8A
.................... 
.................... 		case I2C_REG_CH0_COMMAND_OFF_HOLD_INITIAL:
.................... 			return (int16) config.ch[c].command_off_hold_time;
0A9A:  MOVLB  1
0A9C:  MOVF   x2E,W
0A9E:  MULLW  24
0AA0:  MOVF   FF3,W
0AA2:  CLRF   x30
0AA4:  MOVWF  x2F
0AA6:  MOVLW  02
0AA8:  ADDWF  x2F,W
0AAA:  MOVWF  01
0AAC:  MOVLW  00
0AAE:  ADDWFC x30,W
0AB0:  MOVWF  03
0AB2:  MOVF   01,W
0AB4:  ADDLW  1B
0AB6:  MOVWF  FE9
0AB8:  MOVLW  00
0ABA:  ADDWFC 03,W
0ABC:  MOVWF  FEA
0ABE:  MOVFF  FEC,03
0AC2:  MOVF   FED,F
0AC4:  MOVFF  FEF,01
0AC8:  MOVFF  03,02
0ACC:  MOVLB  0
0ACE:  BRA    0E8A
.................... 
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].lvd_disconnect_adc;
0AD0:  MOVLB  1
0AD2:  MOVF   x2E,W
0AD4:  MULLW  24
0AD6:  MOVF   FF3,W
0AD8:  CLRF   x30
0ADA:  MOVWF  x2F
0ADC:  MOVLW  04
0ADE:  ADDWF  x2F,W
0AE0:  MOVWF  01
0AE2:  MOVLW  00
0AE4:  ADDWFC x30,W
0AE6:  MOVWF  03
0AE8:  MOVF   01,W
0AEA:  ADDLW  1B
0AEC:  MOVWF  FE9
0AEE:  MOVLW  00
0AF0:  ADDWFC 03,W
0AF2:  MOVWF  FEA
0AF4:  MOVFF  FEC,03
0AF8:  MOVF   FED,F
0AFA:  MOVFF  FEF,01
0AFE:  MOVFF  03,02
0B02:  MOVLB  0
0B04:  BRA    0E8A
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].lvd_disconnect_delay;
0B06:  MOVLB  1
0B08:  MOVF   x2E,W
0B0A:  MULLW  24
0B0C:  MOVF   FF3,W
0B0E:  CLRF   x30
0B10:  MOVWF  x2F
0B12:  MOVLW  06
0B14:  ADDWF  x2F,W
0B16:  MOVWF  01
0B18:  MOVLW  00
0B1A:  ADDWFC x30,W
0B1C:  MOVWF  03
0B1E:  MOVF   01,W
0B20:  ADDLW  1B
0B22:  MOVWF  FE9
0B24:  MOVLW  00
0B26:  ADDWFC 03,W
0B28:  MOVWF  FEA
0B2A:  MOVFF  FEC,03
0B2E:  MOVF   FED,F
0B30:  MOVFF  FEF,01
0B34:  MOVFF  03,02
0B38:  MOVLB  0
0B3A:  BRA    0E8A
.................... 		case I2C_REG_CH0_LVD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].lvd_reconnect_adc;
0B3C:  MOVLB  1
0B3E:  MOVF   x2E,W
0B40:  MULLW  24
0B42:  MOVF   FF3,W
0B44:  CLRF   x30
0B46:  MOVWF  x2F
0B48:  MOVLW  08
0B4A:  ADDWF  x2F,W
0B4C:  MOVWF  01
0B4E:  MOVLW  00
0B50:  ADDWFC x30,W
0B52:  MOVWF  03
0B54:  MOVF   01,W
0B56:  ADDLW  1B
0B58:  MOVWF  FE9
0B5A:  MOVLW  00
0B5C:  ADDWFC 03,W
0B5E:  MOVWF  FEA
0B60:  MOVFF  FEC,03
0B64:  MOVF   FED,F
0B66:  MOVFF  FEF,01
0B6A:  MOVFF  03,02
0B6E:  MOVLB  0
0B70:  BRA    0E8A
.................... 		case I2C_REG_CH0_LVD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].lvd_reconnect_delay;
0B72:  MOVLB  1
0B74:  MOVF   x2E,W
0B76:  MULLW  24
0B78:  MOVF   FF3,W
0B7A:  CLRF   x30
0B7C:  MOVWF  x2F
0B7E:  MOVLW  0A
0B80:  ADDWF  x2F,W
0B82:  MOVWF  01
0B84:  MOVLW  00
0B86:  ADDWFC x30,W
0B88:  MOVWF  03
0B8A:  MOVF   01,W
0B8C:  ADDLW  1B
0B8E:  MOVWF  FE9
0B90:  MOVLW  00
0B92:  ADDWFC 03,W
0B94:  MOVWF  FEA
0B96:  MOVFF  FEC,03
0B9A:  MOVF   FED,F
0B9C:  MOVFF  FEF,01
0BA0:  MOVFF  03,02
0BA4:  MOVLB  0
0BA6:  BRA    0E8A
.................... 
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].hvd_disconnect_adc;
0BA8:  MOVLB  1
0BAA:  MOVF   x2E,W
0BAC:  MULLW  24
0BAE:  MOVF   FF3,W
0BB0:  CLRF   x30
0BB2:  MOVWF  x2F
0BB4:  MOVLW  0C
0BB6:  ADDWF  x2F,W
0BB8:  MOVWF  01
0BBA:  MOVLW  00
0BBC:  ADDWFC x30,W
0BBE:  MOVWF  03
0BC0:  MOVF   01,W
0BC2:  ADDLW  1B
0BC4:  MOVWF  FE9
0BC6:  MOVLW  00
0BC8:  ADDWFC 03,W
0BCA:  MOVWF  FEA
0BCC:  MOVFF  FEC,03
0BD0:  MOVF   FED,F
0BD2:  MOVFF  FEF,01
0BD6:  MOVFF  03,02
0BDA:  MOVLB  0
0BDC:  BRA    0E8A
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].hvd_disconnect_delay;
0BDE:  MOVLB  1
0BE0:  MOVF   x2E,W
0BE2:  MULLW  24
0BE4:  MOVF   FF3,W
0BE6:  CLRF   x30
0BE8:  MOVWF  x2F
0BEA:  MOVLW  0E
0BEC:  ADDWF  x2F,W
0BEE:  MOVWF  01
0BF0:  MOVLW  00
0BF2:  ADDWFC x30,W
0BF4:  MOVWF  03
0BF6:  MOVF   01,W
0BF8:  ADDLW  1B
0BFA:  MOVWF  FE9
0BFC:  MOVLW  00
0BFE:  ADDWFC 03,W
0C00:  MOVWF  FEA
0C02:  MOVFF  FEC,03
0C06:  MOVF   FED,F
0C08:  MOVFF  FEF,01
0C0C:  MOVFF  03,02
0C10:  MOVLB  0
0C12:  BRA    0E8A
.................... 		case I2C_REG_CH0_HVD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].hvd_reconnect_adc;
0C14:  MOVLB  1
0C16:  MOVF   x2E,W
0C18:  MULLW  24
0C1A:  MOVF   FF3,W
0C1C:  CLRF   x30
0C1E:  MOVWF  x2F
0C20:  MOVLW  10
0C22:  ADDWF  x2F,W
0C24:  MOVWF  01
0C26:  MOVLW  00
0C28:  ADDWFC x30,W
0C2A:  MOVWF  03
0C2C:  MOVF   01,W
0C2E:  ADDLW  1B
0C30:  MOVWF  FE9
0C32:  MOVLW  00
0C34:  ADDWFC 03,W
0C36:  MOVWF  FEA
0C38:  MOVFF  FEC,03
0C3C:  MOVF   FED,F
0C3E:  MOVFF  FEF,01
0C42:  MOVFF  03,02
0C46:  MOVLB  0
0C48:  BRA    0E8A
.................... 		case I2C_REG_CH0_HVD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].hvd_reconnect_delay;
0C4A:  MOVLB  1
0C4C:  MOVF   x2E,W
0C4E:  MULLW  24
0C50:  MOVF   FF3,W
0C52:  CLRF   x30
0C54:  MOVWF  x2F
0C56:  MOVLW  12
0C58:  ADDWF  x2F,W
0C5A:  MOVWF  01
0C5C:  MOVLW  00
0C5E:  ADDWFC x30,W
0C60:  MOVWF  03
0C62:  MOVF   01,W
0C64:  ADDLW  1B
0C66:  MOVWF  FE9
0C68:  MOVLW  00
0C6A:  ADDWFC 03,W
0C6C:  MOVWF  FEA
0C6E:  MOVFF  FEC,03
0C72:  MOVF   FED,F
0C74:  MOVFF  FEF,01
0C78:  MOVFF  03,02
0C7C:  MOVLB  0
0C7E:  BRA    0E8A
.................... 
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_disconnect_adc;
0C80:  MOVLB  1
0C82:  MOVF   x2E,W
0C84:  MULLW  24
0C86:  MOVF   FF3,W
0C88:  CLRF   x30
0C8A:  MOVWF  x2F
0C8C:  MOVLW  14
0C8E:  ADDWF  x2F,W
0C90:  MOVWF  01
0C92:  MOVLW  00
0C94:  ADDWFC x30,W
0C96:  MOVWF  03
0C98:  MOVF   01,W
0C9A:  ADDLW  1B
0C9C:  MOVWF  FE9
0C9E:  MOVLW  00
0CA0:  ADDWFC 03,W
0CA2:  MOVWF  FEA
0CA4:  MOVFF  FEC,03
0CA8:  MOVF   FED,F
0CAA:  MOVFF  FEF,01
0CAE:  MOVFF  03,02
0CB2:  MOVLB  0
0CB4:  BRA    0E8A
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_disconnect_delay;
0CB6:  MOVLB  1
0CB8:  MOVF   x2E,W
0CBA:  MULLW  24
0CBC:  MOVF   FF3,W
0CBE:  CLRF   x30
0CC0:  MOVWF  x2F
0CC2:  MOVLW  16
0CC4:  ADDWF  x2F,W
0CC6:  MOVWF  01
0CC8:  MOVLW  00
0CCA:  ADDWFC x30,W
0CCC:  MOVWF  03
0CCE:  MOVF   01,W
0CD0:  ADDLW  1B
0CD2:  MOVWF  FE9
0CD4:  MOVLW  00
0CD6:  ADDWFC 03,W
0CD8:  MOVWF  FEA
0CDA:  MOVFF  FEC,03
0CDE:  MOVF   FED,F
0CE0:  MOVFF  FEF,01
0CE4:  MOVFF  03,02
0CE8:  MOVLB  0
0CEA:  BRA    0E8A
.................... 		case I2C_REG_CH0_LTD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_reconnect_adc;
0CEC:  MOVLB  1
0CEE:  MOVF   x2E,W
0CF0:  MULLW  24
0CF2:  MOVF   FF3,W
0CF4:  CLRF   x30
0CF6:  MOVWF  x2F
0CF8:  MOVLW  18
0CFA:  ADDWF  x2F,W
0CFC:  MOVWF  01
0CFE:  MOVLW  00
0D00:  ADDWFC x30,W
0D02:  MOVWF  03
0D04:  MOVF   01,W
0D06:  ADDLW  1B
0D08:  MOVWF  FE9
0D0A:  MOVLW  00
0D0C:  ADDWFC 03,W
0D0E:  MOVWF  FEA
0D10:  MOVFF  FEC,03
0D14:  MOVF   FED,F
0D16:  MOVFF  FEF,01
0D1A:  MOVFF  03,02
0D1E:  MOVLB  0
0D20:  BRA    0E8A
.................... 		case I2C_REG_CH0_LTD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_reconnect_delay;
0D22:  MOVLB  1
0D24:  MOVF   x2E,W
0D26:  MULLW  24
0D28:  MOVF   FF3,W
0D2A:  CLRF   x30
0D2C:  MOVWF  x2F
0D2E:  MOVLW  1A
0D30:  ADDWF  x2F,W
0D32:  MOVWF  01
0D34:  MOVLW  00
0D36:  ADDWFC x30,W
0D38:  MOVWF  03
0D3A:  MOVF   01,W
0D3C:  ADDLW  1B
0D3E:  MOVWF  FE9
0D40:  MOVLW  00
0D42:  ADDWFC 03,W
0D44:  MOVWF  FEA
0D46:  MOVFF  FEC,03
0D4A:  MOVF   FED,F
0D4C:  MOVFF  FEF,01
0D50:  MOVFF  03,02
0D54:  MOVLB  0
0D56:  BRA    0E8A
.................... 
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_disconnect_adc;
0D58:  MOVLB  1
0D5A:  MOVF   x2E,W
0D5C:  MULLW  24
0D5E:  MOVF   FF3,W
0D60:  CLRF   x30
0D62:  MOVWF  x2F
0D64:  MOVLW  14
0D66:  ADDWF  x2F,W
0D68:  MOVWF  01
0D6A:  MOVLW  00
0D6C:  ADDWFC x30,W
0D6E:  MOVWF  03
0D70:  MOVF   01,W
0D72:  ADDLW  1B
0D74:  MOVWF  FE9
0D76:  MOVLW  00
0D78:  ADDWFC 03,W
0D7A:  MOVWF  FEA
0D7C:  MOVFF  FEC,03
0D80:  MOVF   FED,F
0D82:  MOVFF  FEF,01
0D86:  MOVFF  03,02
0D8A:  MOVLB  0
0D8C:  BRA    0E8A
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_disconnect_delay;
0D8E:  MOVLB  1
0D90:  MOVF   x2E,W
0D92:  MULLW  24
0D94:  MOVF   FF3,W
0D96:  CLRF   x30
0D98:  MOVWF  x2F
0D9A:  MOVLW  16
0D9C:  ADDWF  x2F,W
0D9E:  MOVWF  01
0DA0:  MOVLW  00
0DA2:  ADDWFC x30,W
0DA4:  MOVWF  03
0DA6:  MOVF   01,W
0DA8:  ADDLW  1B
0DAA:  MOVWF  FE9
0DAC:  MOVLW  00
0DAE:  ADDWFC 03,W
0DB0:  MOVWF  FEA
0DB2:  MOVFF  FEC,03
0DB6:  MOVF   FED,F
0DB8:  MOVFF  FEF,01
0DBC:  MOVFF  03,02
0DC0:  MOVLB  0
0DC2:  BRA    0E8A
.................... 		case I2C_REG_CH0_HTD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_reconnect_adc;
0DC4:  MOVLB  1
0DC6:  MOVF   x2E,W
0DC8:  MULLW  24
0DCA:  MOVF   FF3,W
0DCC:  CLRF   x30
0DCE:  MOVWF  x2F
0DD0:  MOVLW  18
0DD2:  ADDWF  x2F,W
0DD4:  MOVWF  01
0DD6:  MOVLW  00
0DD8:  ADDWFC x30,W
0DDA:  MOVWF  03
0DDC:  MOVF   01,W
0DDE:  ADDLW  1B
0DE0:  MOVWF  FE9
0DE2:  MOVLW  00
0DE4:  ADDWFC 03,W
0DE6:  MOVWF  FEA
0DE8:  MOVFF  FEC,03
0DEC:  MOVF   FED,F
0DEE:  MOVFF  FEF,01
0DF2:  MOVFF  03,02
0DF6:  MOVLB  0
0DF8:  BRA    0E8A
.................... 		case I2C_REG_CH0_HTD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_reconnect_delay;	
0DFA:  MOVLB  1
0DFC:  MOVF   x2E,W
0DFE:  MULLW  24
0E00:  MOVF   FF3,W
0E02:  CLRF   x30
0E04:  MOVWF  x2F
0E06:  MOVLW  1A
0E08:  ADDWF  x2F,W
0E0A:  MOVWF  01
0E0C:  MOVLW  00
0E0E:  ADDWFC x30,W
0E10:  MOVWF  03
0E12:  MOVF   01,W
0E14:  ADDLW  1B
0E16:  MOVWF  FE9
0E18:  MOVLW  00
0E1A:  ADDWFC 03,W
0E1C:  MOVWF  FEA
0E1E:  MOVFF  FEC,03
0E22:  MOVF   FED,F
0E24:  MOVFF  FEF,01
0E28:  MOVFF  03,02
0E2C:  MOVLB  0
0E2E:  BRA    0E8A
.................... 
.................... 		case I2C_REG_CH0_FUT_DISCONNECT_VALUE:
.................... 		case I2C_REG_CH0_FUT_DISCONNECT_DELAY:
.................... 		case I2C_REG_CH0_FUT_RECONNECT_VALUE:
.................... 		case I2C_REG_CH0_FUT_RECONNECT_DELAY:
.................... 			return (int16) 0xffff; /* not yet implemented */
0E30:  MOVLW  FF
0E32:  MOVWF  01
0E34:  MOVWF  02
0E36:  BRA    0E8A
.................... 		
.................... 		/* configuration */
.................... 		case I2C_REG_CONFIG_HARDWARE_MODEL: 
.................... 			return (int16) 'D';
0E38:  MOVLW  44
0E3A:  MOVWF  01
0E3C:  MOVLW  00
0E3E:  MOVWF  02
0E40:  BRA    0E8A
.................... 		case I2C_REG_CONFIG_HARDWARE_VERSION: 
.................... 			return (int16) '2';
0E42:  MOVLW  32
0E44:  MOVWF  01
0E46:  MOVLW  00
0E48:  MOVWF  02
0E4A:  BRA    0E8A
.................... 		case I2C_REG_CONFIG_SOFTWARE_MODEL: 
.................... 			return (int16) 'L';
0E4C:  MOVLW  4C
0E4E:  MOVWF  01
0E50:  MOVLW  00
0E52:  MOVWF  02
0E54:  BRA    0E8A
.................... 		case I2C_REG_CONFIG_SOFTWARE_VERSION: 
.................... 			return (int16) '0';
0E56:  MOVLW  30
0E58:  MOVWF  01
0E5A:  MOVLW  00
0E5C:  MOVWF  02
0E5E:  BRA    0E8A
.................... 		case I2C_REG_CONFIG_SOFTWARE_YEAR:
.................... 			return (int16) current.compile_year;
0E60:  MOVFF  CB,01
0E64:  CLRF   02
0E66:  BRA    0E8A
.................... 		case I2C_REG_CONFIG_SOFTWARE_MONTH:
.................... 			return (int16) current.compile_month;
0E68:  MOVFF  CC,01
0E6C:  CLRF   02
0E6E:  BRA    0E8A
.................... 		case I2C_REG_CONFIG_SOFTWARE_DAY:
.................... 			return (int16) current.compile_day;
0E70:  MOVFF  CD,01
0E74:  CLRF   02
0E76:  BRA    0E8A
.................... 
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			/* 1 if factory unlocked */ 
.................... 			return (int16) current.factory_unlocked; 	
0E78:  MOVFF  CA,01
0E7C:  CLRF   02
0E7E:  BRA    0E8A
.................... 
.................... 		/* we should have range checked, and never gotten here ... or read unimplemented (future) register */
.................... 		default: return (int16) addr;
0E80:  MOVLB  1
0E82:  MOVFF  12D,01
0E86:  CLRF   02
0E88:  MOVLB  0
.................... 	}
0E8A:  GOTO   0F42 (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... 
.................... 
.................... #include "interrupt_dcswc_module_latching_contactor.c"
.................... #int_timer2
.................... void isr_timer2() {
.................... 	timers.now_millisecond=1;
*
00D4:  BSF    xCF.2
.................... }
.................... 
.................... 
.................... 
.................... /* I2C slave interrupt */
00D6:  BCF    F9E.1
00D8:  GOTO   006C
.................... #byte SSPSTAT=GETENV("SFR:SSPSTAT")
.................... #INT_SSP
.................... void ssp_interrupt () {
.................... 	static int8 sstate;
.................... 	int8 state;
.................... 	int8 incoming;
.................... 	static int16 lastValue;
.................... 	static int8 lastMSB;
.................... 
.................... 	static int8 address; 
.................... 
.................... 	/* 
.................... 	our implementation of i2c_isr_state() that won't overflow and switch states
.................... 	but it will quit counting at 127 bytes. 
.................... 	If more bytes are needed, external counting variables can be used or the size of state can be made larger
.................... 	*/
.................... 
.................... 
.................... 	if ( ! bit_test(SSPSTAT,5) ) {
*
0EA4:  BTFSC  FC7.5
0EA6:  BRA    0EB4
.................... 		/* address */
.................... 		sstate=0;
0EA8:  MOVLB  1
0EAA:  CLRF   x0C
.................... 
.................... 		if ( bit_test(SSPSTAT,2) ) {
0EAC:  BTFSS  FC7.2
0EAE:  BRA    0EB2
.................... 			/* set high bit if read */
.................... 			bit_set(sstate,7);
0EB0:  BSF    x0C.7
.................... 		}
.................... 	} else {
0EB2:  MOVLB  0
.................... 		/* data */
.................... 	}
.................... 
.................... 	/* state variable used below is not incremented */
.................... 	state=sstate;
0EB4:  MOVFF  10C,12A
.................... 
.................... 	/* increment the state counter for next pass through unless it will overflow us into another state */
.................... 	if ( sstate != 0x7f && sstate != 0xff) {
0EB8:  MOVLB  1
0EBA:  MOVF   x0C,W
0EBC:  SUBLW  7F
0EBE:  BZ    0EC8
0EC0:  INCFSZ x0C,W
0EC2:  BRA    0EC6
0EC4:  BRA    0EC8
.................... 		sstate++;
0EC6:  INCF   x0C,F
.................... 	}
.................... 
.................... 	
.................... 	/* i2c_isr_state() return an 8 bit int
.................... 		0 - Address match received with R/W bit clear, perform i2c_read( ) to read the I2C address.
.................... 		1-0x7F - Master has written data; i2c_read() will immediately return the data
.................... 		0x80 - Address match received with R/W bit set; perform i2c_read( ) to read the I2C address,
.................... 		and use i2c_write( ) to pre-load the transmit buffer for the next transaction (next I2C read
.................... 		performed by master will read this byte).
.................... 		0x81-0xFF - Transmission completed and acknowledged; respond with i2c_write() to pre-load
.................... 		the transmit buffer for the next transition (the next I2C read performed by master will read this
.................... 		byte).
.................... 		Function:
.................... 		Returns the state of I2C communications in I2C slave mode after an SSP interrupt. The return
.................... 		value increments with each byte received or sent.
.................... 		If 0x00 or 0x80 is returned, an i2C_read( ) needs to be performed to read the I2C address that
.................... 		was sent (it will match the address configured by #USE I2C so this value can be ignored)
.................... 	*/
.................... 
.................... 	if ( state <= 0x80 ) {                      
0EC8:  MOVF   x2A,W
0ECA:  SUBLW  80
0ECC:  BNC   0F2A
.................... 		/* I2C master is sending us data */
.................... 		if ( 0x80 == state ) {
0ECE:  MOVF   x2A,W
0ED0:  SUBLW  80
0ED2:  BNZ   0EDA
.................... 			/* i2c_read(2) casues the function to read the SSPBUF without releasing the clock */
.................... 			incoming = i2c_read(STREAM_SLAVE,2);
0ED4:  MOVFF  FC9,12B
.................... 		} else {
0ED8:  BRA    0EE6
.................... 			incoming = i2c_read(STREAM_SLAVE);
0EDA:  BCF    FC6.6
0EDC:  BTFSS  FC7.0
0EDE:  BRA    0EDC
0EE0:  MOVF   FC9,W
0EE2:  BSF    FC6.4
0EE4:  MOVWF  x2B
.................... 		}
.................... 
.................... 		if ( 1 == state ) {             
0EE6:  DECFSZ x2A,W
0EE8:  BRA    0EF0
.................... 			/* first byte is address */                
.................... 			address = incoming;
0EEA:  MOVFF  12B,110
.................... 		} else if ( state >= 2 && 0x80 != state ) {
0EEE:  BRA    0F2A
0EF0:  MOVF   x2A,W
0EF2:  SUBLW  01
0EF4:  BC    0F2A
0EF6:  MOVF   x2A,W
0EF8:  SUBLW  80
0EFA:  BZ    0F2A
.................... 			/* received byte is data */
.................... 		
.................... 			/* save MSB and we'll process it on next */
.................... 			if ( 2 == state ) {
0EFC:  MOVF   x2A,W
0EFE:  SUBLW  02
0F00:  BNZ   0F08
.................... 				lastMSB=incoming;
0F02:  MOVFF  12B,10F
.................... 			} else if ( 3 == state ) {
0F06:  BRA    0F2A
0F08:  MOVF   x2A,W
0F0A:  SUBLW  03
0F0C:  BNZ   0F2A
.................... 				/* 16 bit value made of previous byte and this byte */
.................... 				write_i2c(address,make16(lastMSB,incoming));
0F0E:  MOVFF  10F,12D
0F12:  MOVFF  12B,12C
0F16:  MOVFF  110,12E
0F1A:  MOVFF  10F,130
0F1E:  MOVFF  12B,12F
0F22:  MOVLB  0
0F24:  GOTO   00E6
0F28:  MOVLB  1
.................... 			}
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	if ( state >= 0x80 ) {
0F2A:  MOVF   x2A,W
0F2C:  SUBLW  7F
0F2E:  BC    0F68
.................... 		/* I2C master is requesting data from us */
.................... 
.................... 		if ( ! bit_test(address,0) ) {
0F30:  BTFSC  x10.0
0F32:  BRA    0F58
.................... 			/* read 16 bit register (register address half of I2C address) on even address */
.................... 			lastValue=map_i2c(address>>1);
0F34:  BCF    FD8.0
0F36:  RRCF   x10,W
0F38:  MOVWF  x2C
0F3A:  MOVWF  x2D
0F3C:  MOVLB  0
0F3E:  GOTO   062A
0F42:  MOVFF  02,10E
0F46:  MOVFF  01,10D
.................... 
.................... 			/* send the MSB */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,1));
0F4A:  MOVFF  10E,12C
0F4E:  MOVFF  10E,12D
0F52:  RCALL  0E8E
.................... 		} else {
0F54:  BRA    0F64
0F56:  MOVLB  1
.................... 			/* send LSB of 16 bit register on odd address */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,0));
0F58:  MOVFF  10D,12C
0F5C:  MOVFF  10D,12D
0F60:  MOVLB  0
0F62:  RCALL  0E8E
.................... 		}
.................... 		address++;
0F64:  MOVLB  1
0F66:  INCF   x10,F
.................... 	}
.................... }
.................... 
.................... 
.................... 
.................... 
0F68:  BCF    F9E.3
0F6A:  MOVLB  0
0F6C:  GOTO   006C
.................... #include "debug_dcswc_module_latching_contactor.c"
.................... void debug_dump(void) {
.................... 
.................... 	int8 i;
.................... 
.................... 	
.................... 	restart_wdt();
*
2FFC:  CLRWDT
2FFE:  CLRF   19
3000:  BTFSC  FF2.7
3002:  BSF    19.7
3004:  BCF    FF2.7
.................... #if 0
.................... 	fprintf(STREAM_FTDI,"# '%s'\r\n",__DATE__);
.................... 	fprintf(STREAM_FTDI,"#  compile_year=%u\r\n",current.compile_year);
.................... 	fprintf(STREAM_FTDI,"# compile_month=%u\r\n",current.compile_month);
.................... 	fprintf(STREAM_FTDI,"#   compile_day=%u\r\n",current.compile_day);
.................... #endif
.................... 	fprintf(STREAM_FTDI,"#       vin adc=%lu\r\n",adc_get(0));
3006:  MOVLB  1
3008:  CLRF   x2F
300A:  MOVLB  0
300C:  CALL   05AA
3010:  BTFSC  19.7
3012:  BSF    FF2.7
3014:  MOVFF  02,11D
3018:  MOVFF  01,11C
301C:  MOVLW  70
301E:  MOVWF  FF6
3020:  MOVLW  0F
3022:  MOVWF  FF7
3024:  MOVLW  10
3026:  MOVLB  1
3028:  MOVWF  x20
302A:  MOVLB  0
302C:  CALL   1B5E
3030:  MOVLW  10
3032:  MOVWF  FE9
3034:  MOVFF  11D,121
3038:  MOVFF  11C,120
303C:  RCALL  2E5A
303E:  MOVLW  0D
3040:  BTFSS  F9E.4
3042:  BRA    3040
3044:  MOVWF  FAD
3046:  MOVLW  0A
3048:  BTFSS  F9E.4
304A:  BRA    3048
304C:  MOVWF  FAD
304E:  CLRF   19
3050:  BTFSC  FF2.7
3052:  BSF    19.7
3054:  BCF    FF2.7
.................... 	fprintf(STREAM_FTDI,"#      temp adc=%lu\r\n",adc_get(1));
3056:  MOVLW  01
3058:  MOVLB  1
305A:  MOVWF  x2F
305C:  MOVLB  0
305E:  CALL   05AA
3062:  BTFSC  19.7
3064:  BSF    FF2.7
3066:  MOVFF  02,11D
306A:  MOVFF  01,11C
306E:  MOVLW  86
3070:  MOVWF  FF6
3072:  MOVLW  0F
3074:  MOVWF  FF7
3076:  MOVLW  10
3078:  MOVLB  1
307A:  MOVWF  x20
307C:  MOVLB  0
307E:  CALL   1B5E
3082:  MOVLW  10
3084:  MOVWF  FE9
3086:  MOVFF  11D,121
308A:  MOVFF  11C,120
308E:  RCALL  2E5A
3090:  MOVLW  0D
3092:  BTFSS  F9E.4
3094:  BRA    3092
3096:  MOVWF  FAD
3098:  MOVLW  0A
309A:  BTFSS  F9E.4
309C:  BRA    309A
309E:  MOVWF  FAD
.................... 	fprintf(STREAM_FTDI,"#   ch[0].state=0x%2X\r\n",channel[0].state);
30A0:  MOVLW  9C
30A2:  MOVWF  FF6
30A4:  MOVLW  0F
30A6:  MOVWF  FF7
30A8:  MOVLW  12
30AA:  MOVLB  1
30AC:  MOVWF  x20
30AE:  MOVLB  0
30B0:  CALL   1B5E
30B4:  MOVFF  DA,11F
30B8:  MOVLW  37
30BA:  MOVLB  1
30BC:  MOVWF  x20
30BE:  MOVLB  0
30C0:  RCALL  2F0C
30C2:  MOVLW  0D
30C4:  BTFSS  F9E.4
30C6:  BRA    30C4
30C8:  MOVWF  FAD
30CA:  MOVLW  0A
30CC:  BTFSS  F9E.4
30CE:  BRA    30CC
30D0:  MOVWF  FAD
.................... 	fprintf(STREAM_FTDI,"#   ch[1].state=0x%2X\r\n",channel[1].state);
30D2:  MOVLW  B4
30D4:  MOVWF  FF6
30D6:  MOVLW  0F
30D8:  MOVWF  FF7
30DA:  MOVLW  12
30DC:  MOVLB  1
30DE:  MOVWF  x20
30E0:  MOVLB  0
30E2:  CALL   1B5E
30E6:  MOVFF  F3,11F
30EA:  MOVLW  37
30EC:  MOVLB  1
30EE:  MOVWF  x20
30F0:  MOVLB  0
30F2:  RCALL  2F0C
30F4:  MOVLW  0D
30F6:  BTFSS  F9E.4
30F8:  BRA    30F6
30FA:  MOVWF  FAD
30FC:  MOVLW  0A
30FE:  BTFSS  F9E.4
3100:  BRA    30FE
3102:  MOVWF  FAD
.................... //	fprintf(STREAM_FTDI,"# read_dip_sw()=%u\r\n",read_dip_switch());
.................... //	fprintf(STREAM_FTDI,"#    dip sw adc=%lu\r\n",adc_get(2));
.................... 
.................... 
.................... 	for ( i=0 ; i<2 ; i++ ) {
3104:  MOVLB  1
3106:  CLRF   x1B
3108:  MOVF   x1B,W
310A:  SUBLW  01
310C:  BTFSS  FD8.0
310E:  BRA    370A
.................... 		restart_wdt();
3110:  CLRWDT
.................... 		fprintf(STREAM_FTDI,"#-------\r\n");
3112:  MOVLW  CC
3114:  MOVWF  FF6
3116:  MOVLW  0F
3118:  MOVWF  FF7
311A:  MOVLB  0
311C:  CALL   1B88
.................... 		fprintf(STREAM_FTDI,"# config.ch[%u]\r\n",i);
3120:  MOVLW  D8
3122:  MOVWF  FF6
3124:  MOVLW  0F
3126:  MOVWF  FF7
3128:  MOVLW  0C
312A:  MOVLB  1
312C:  MOVWF  x20
312E:  MOVLB  0
3130:  CALL   1B5E
3134:  MOVFF  11B,11C
3138:  MOVLW  1B
313A:  MOVLB  1
313C:  MOVWF  x1D
313E:  MOVLB  0
3140:  RCALL  2F7E
3142:  MOVLW  E6
3144:  MOVWF  FF6
3146:  MOVLW  0F
3148:  MOVWF  FF7
314A:  MOVLW  03
314C:  MOVLB  1
314E:  MOVWF  x20
3150:  MOVLB  0
3152:  CALL   1B5E
.................... 		fprintf(STREAM_FTDI,"#  command_on_hold_time=%lu\r\n",config.ch[i].command_on_hold_time);
3156:  MOVLB  1
3158:  MOVF   x1B,W
315A:  MULLW  24
315C:  MOVF   FF3,W
315E:  CLRF   x1D
3160:  MOVWF  x1C
3162:  MOVLW  1B
3164:  ADDWF  x1C,W
3166:  MOVWF  FE9
3168:  MOVLW  00
316A:  ADDWFC x1D,W
316C:  MOVWF  FEA
316E:  MOVFF  FEC,11F
3172:  MOVF   FED,F
3174:  MOVFF  FEF,11E
3178:  MOVLW  EA
317A:  MOVWF  FF6
317C:  MOVLW  0F
317E:  MOVWF  FF7
3180:  MOVLW  18
3182:  MOVWF  x20
3184:  MOVLB  0
3186:  CALL   1B5E
318A:  MOVLW  10
318C:  MOVWF  FE9
318E:  MOVFF  11F,121
3192:  MOVFF  11E,120
3196:  RCALL  2E5A
3198:  MOVLW  0D
319A:  BTFSS  F9E.4
319C:  BRA    319A
319E:  MOVWF  FAD
31A0:  MOVLW  0A
31A2:  BTFSS  F9E.4
31A4:  BRA    31A2
31A6:  MOVWF  FAD
.................... 		fprintf(STREAM_FTDI,"# command_off_hold_time=%lu\r\n",config.ch[i].command_off_hold_time);
31A8:  MOVLB  1
31AA:  MOVF   x1B,W
31AC:  MULLW  24
31AE:  MOVF   FF3,W
31B0:  CLRF   x1D
31B2:  MOVWF  x1C
31B4:  MOVLW  02
31B6:  ADDWF  x1C,W
31B8:  MOVWF  01
31BA:  MOVLW  00
31BC:  ADDWFC x1D,W
31BE:  MOVWF  03
31C0:  MOVF   01,W
31C2:  ADDLW  1B
31C4:  MOVWF  FE9
31C6:  MOVLW  00
31C8:  ADDWFC 03,W
31CA:  MOVWF  FEA
31CC:  MOVFF  FEC,11D
31D0:  MOVF   FED,F
31D2:  MOVFF  FEF,11C
31D6:  MOVLW  08
31D8:  MOVWF  FF6
31DA:  MOVLW  10
31DC:  MOVWF  FF7
31DE:  MOVLW  18
31E0:  MOVWF  x20
31E2:  MOVLB  0
31E4:  CALL   1B5E
31E8:  MOVLW  10
31EA:  MOVWF  FE9
31EC:  MOVFF  11D,121
31F0:  MOVFF  11C,120
31F4:  RCALL  2E5A
31F6:  MOVLW  0D
31F8:  BTFSS  F9E.4
31FA:  BRA    31F8
31FC:  MOVWF  FAD
31FE:  MOVLW  0A
3200:  BTFSS  F9E.4
3202:  BRA    3200
3204:  MOVWF  FAD
.................... 
.................... #if 0
.................... 		fprintf(STREAM_FTDI,"#    lvd_disconnect_adc=%lu\r\n",config.ch[i].lvd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  lvd_disconnect_delay=%lu\r\n",config.ch[i].lvd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     lvd_reconnect_adc=%lu\r\n",config.ch[i].lvd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   lvd_reconnect_delay=%lu\r\n",config.ch[i].lvd_reconnect_delay);
.................... 
.................... 		fprintf(STREAM_FTDI,"#    hvd_disconnect_adc=%lu\r\n",config.ch[i].hvd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  hvd_disconnect_delay=%lu\r\n",config.ch[i].hvd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     hvd_reconnect_adc=%lu\r\n",config.ch[i].hvd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   hvd_reconnect_delay=%lu\r\n",config.ch[i].hvd_reconnect_delay);
.................... 
.................... 		restart_wdt();
.................... 		fprintf(STREAM_FTDI,"#    ltd_disconnect_adc=%lu\r\n",config.ch[i].ltd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  ltd_disconnect_delay=%lu\r\n",config.ch[i].ltd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     ltd_reconnect_adc=%lu\r\n",config.ch[i].ltd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   ltd_reconnect_delay=%lu\r\n",config.ch[i].ltd_reconnect_delay);
.................... 
.................... 		fprintf(STREAM_FTDI,"#    htd_disconnect_adc=%lu\r\n",config.ch[i].htd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  htd_disconnect_delay=%lu\r\n",config.ch[i].htd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     htd_reconnect_adc=%lu\r\n",config.ch[i].htd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   htd_reconnect_delay=%lu\r\n",config.ch[i].htd_reconnect_delay);
.................... #endif
.................... 
.................... 		restart_wdt();
3206:  CLRWDT
.................... 		fprintf(STREAM_FTDI,"#\r\n");
3208:  MOVLW  26
320A:  MOVWF  FF6
320C:  MOVLW  10
320E:  MOVWF  FF7
3210:  CALL   1B88
.................... 		fprintf(STREAM_FTDI,"# channel[%u]\r\n",i);
3214:  MOVLW  2A
3216:  MOVWF  FF6
3218:  MOVLW  10
321A:  MOVWF  FF7
321C:  MOVLW  0A
321E:  MOVLB  1
3220:  MOVWF  x20
3222:  MOVLB  0
3224:  CALL   1B5E
3228:  MOVFF  11B,11C
322C:  MOVLW  1B
322E:  MOVLB  1
3230:  MOVWF  x1D
3232:  MOVLB  0
3234:  RCALL  2F7E
3236:  MOVLW  36
3238:  MOVWF  FF6
323A:  MOVLW  10
323C:  MOVWF  FF7
323E:  MOVLW  03
3240:  MOVLB  1
3242:  MOVWF  x20
3244:  MOVLB  0
3246:  CALL   1B5E
.................... 		fprintf(STREAM_FTDI,"#                        state=0x%02x\r\n",channel[i].state);
324A:  MOVLB  1
324C:  MOVF   x1B,W
324E:  MULLW  19
3250:  MOVF   FF3,W
3252:  CLRF   x1D
3254:  MOVWF  x1C
3256:  MOVLW  DA
3258:  ADDWF  x1C,W
325A:  MOVWF  FE9
325C:  MOVLW  00
325E:  ADDWFC x1D,W
3260:  MOVWF  FEA
3262:  MOVFF  FEF,11E
3266:  MOVLW  3A
3268:  MOVWF  FF6
326A:  MOVLW  10
326C:  MOVWF  FF7
326E:  MOVLW  21
3270:  MOVWF  x20
3272:  MOVLB  0
3274:  CALL   1B5E
3278:  MOVFF  11E,11F
327C:  MOVLW  57
327E:  MOVLB  1
3280:  MOVWF  x20
3282:  MOVLB  0
3284:  RCALL  2F0C
3286:  MOVLW  0D
3288:  BTFSS  F9E.4
328A:  BRA    3288
328C:  MOVWF  FAD
328E:  MOVLW  0A
3290:  BTFSS  F9E.4
3292:  BRA    3290
3294:  MOVWF  FAD
.................... 		fprintf(STREAM_FTDI,"#           command_on_seconds=%lu\r\n",channel[i].command_on_seconds);
3296:  MOVLB  1
3298:  MOVF   x1B,W
329A:  MULLW  19
329C:  MOVF   FF3,W
329E:  CLRF   x1D
32A0:  MOVWF  x1C
32A2:  MOVLW  01
32A4:  ADDWF  x1C,W
32A6:  MOVWF  01
32A8:  MOVLW  00
32AA:  ADDWFC x1D,W
32AC:  MOVWF  03
32AE:  MOVF   01,W
32B0:  ADDLW  DA
32B2:  MOVWF  FE9
32B4:  MOVLW  00
32B6:  ADDWFC 03,W
32B8:  MOVWF  FEA
32BA:  MOVFF  FEC,11D
32BE:  MOVF   FED,F
32C0:  MOVFF  FEF,11C
32C4:  MOVLW  62
32C6:  MOVWF  FF6
32C8:  MOVLW  10
32CA:  MOVWF  FF7
32CC:  MOVLW  1F
32CE:  MOVWF  x20
32D0:  MOVLB  0
32D2:  CALL   1B5E
32D6:  MOVLW  10
32D8:  MOVWF  FE9
32DA:  MOVFF  11D,121
32DE:  MOVFF  11C,120
32E2:  RCALL  2E5A
32E4:  MOVLW  0D
32E6:  BTFSS  F9E.4
32E8:  BRA    32E6
32EA:  MOVWF  FAD
32EC:  MOVLW  0A
32EE:  BTFSS  F9E.4
32F0:  BRA    32EE
32F2:  MOVWF  FAD
.................... 		fprintf(STREAM_FTDI,"#      command_on_hold_seconds=%lu\r\n",channel[i].command_on_hold_seconds);
32F4:  MOVLB  1
32F6:  MOVF   x1B,W
32F8:  MULLW  19
32FA:  MOVF   FF3,W
32FC:  CLRF   x1D
32FE:  MOVWF  x1C
3300:  MOVLW  03
3302:  ADDWF  x1C,W
3304:  MOVWF  01
3306:  MOVLW  00
3308:  ADDWFC x1D,W
330A:  MOVWF  03
330C:  MOVF   01,W
330E:  ADDLW  DA
3310:  MOVWF  FE9
3312:  MOVLW  00
3314:  ADDWFC 03,W
3316:  MOVWF  FEA
3318:  MOVFF  FEC,11D
331C:  MOVF   FED,F
331E:  MOVFF  FEF,11C
3322:  MOVLW  88
3324:  MOVWF  FF6
3326:  MOVLW  10
3328:  MOVWF  FF7
332A:  MOVLW  1F
332C:  MOVWF  x20
332E:  MOVLB  0
3330:  CALL   1B5E
3334:  MOVLW  10
3336:  MOVWF  FE9
3338:  MOVFF  11D,121
333C:  MOVFF  11C,120
3340:  RCALL  2E5A
3342:  MOVLW  0D
3344:  BTFSS  F9E.4
3346:  BRA    3344
3348:  MOVWF  FAD
334A:  MOVLW  0A
334C:  BTFSS  F9E.4
334E:  BRA    334C
3350:  MOVWF  FAD
.................... 
.................... 		fprintf(STREAM_FTDI,"#          command_off_seconds=%lu\r\n",channel[i].command_off_seconds);
3352:  MOVLB  1
3354:  MOVF   x1B,W
3356:  MULLW  19
3358:  MOVF   FF3,W
335A:  CLRF   x1D
335C:  MOVWF  x1C
335E:  MOVLW  05
3360:  ADDWF  x1C,W
3362:  MOVWF  01
3364:  MOVLW  00
3366:  ADDWFC x1D,W
3368:  MOVWF  03
336A:  MOVF   01,W
336C:  ADDLW  DA
336E:  MOVWF  FE9
3370:  MOVLW  00
3372:  ADDWFC 03,W
3374:  MOVWF  FEA
3376:  MOVFF  FEC,11D
337A:  MOVF   FED,F
337C:  MOVFF  FEF,11C
3380:  MOVLW  AE
3382:  MOVWF  FF6
3384:  MOVLW  10
3386:  MOVWF  FF7
3388:  MOVLW  1F
338A:  MOVWF  x20
338C:  MOVLB  0
338E:  CALL   1B5E
3392:  MOVLW  10
3394:  MOVWF  FE9
3396:  MOVFF  11D,121
339A:  MOVFF  11C,120
339E:  RCALL  2E5A
33A0:  MOVLW  0D
33A2:  BTFSS  F9E.4
33A4:  BRA    33A2
33A6:  MOVWF  FAD
33A8:  MOVLW  0A
33AA:  BTFSS  F9E.4
33AC:  BRA    33AA
33AE:  MOVWF  FAD
.................... 		fprintf(STREAM_FTDI,"#     command_off_hold_seconds=%lu\r\n",channel[i].command_off_hold_seconds);
33B0:  MOVLB  1
33B2:  MOVF   x1B,W
33B4:  MULLW  19
33B6:  MOVF   FF3,W
33B8:  CLRF   x1D
33BA:  MOVWF  x1C
33BC:  MOVLW  07
33BE:  ADDWF  x1C,W
33C0:  MOVWF  01
33C2:  MOVLW  00
33C4:  ADDWFC x1D,W
33C6:  MOVWF  03
33C8:  MOVF   01,W
33CA:  ADDLW  DA
33CC:  MOVWF  FE9
33CE:  MOVLW  00
33D0:  ADDWFC 03,W
33D2:  MOVWF  FEA
33D4:  MOVFF  FEC,11D
33D8:  MOVF   FED,F
33DA:  MOVFF  FEF,11C
33DE:  MOVLW  D4
33E0:  MOVWF  FF6
33E2:  MOVLW  10
33E4:  MOVWF  FF7
33E6:  MOVLW  1F
33E8:  MOVWF  x20
33EA:  MOVLB  0
33EC:  CALL   1B5E
33F0:  MOVLW  10
33F2:  MOVWF  FE9
33F4:  MOVFF  11D,121
33F8:  MOVFF  11C,120
33FC:  RCALL  2E5A
33FE:  MOVLW  0D
3400:  BTFSS  F9E.4
3402:  BRA    3400
3404:  MOVWF  FAD
3406:  MOVLW  0A
3408:  BTFSS  F9E.4
340A:  BRA    3408
340C:  MOVWF  FAD
.................... 
.................... 		fprintf(STREAM_FTDI,"# lvd_disconnect_delay_seconds=%lu\r\n",channel[i].lvd_disconnect_delay_seconds);
340E:  MOVLB  1
3410:  MOVF   x1B,W
3412:  MULLW  19
3414:  MOVF   FF3,W
3416:  CLRF   x1D
3418:  MOVWF  x1C
341A:  MOVLW  09
341C:  ADDWF  x1C,W
341E:  MOVWF  01
3420:  MOVLW  00
3422:  ADDWFC x1D,W
3424:  MOVWF  03
3426:  MOVF   01,W
3428:  ADDLW  DA
342A:  MOVWF  FE9
342C:  MOVLW  00
342E:  ADDWFC 03,W
3430:  MOVWF  FEA
3432:  MOVFF  FEC,11D
3436:  MOVF   FED,F
3438:  MOVFF  FEF,11C
343C:  MOVLW  FA
343E:  MOVWF  FF6
3440:  MOVLW  10
3442:  MOVWF  FF7
3444:  MOVLW  1F
3446:  MOVWF  x20
3448:  MOVLB  0
344A:  CALL   1B5E
344E:  MOVLW  10
3450:  MOVWF  FE9
3452:  MOVFF  11D,121
3456:  MOVFF  11C,120
345A:  RCALL  2E5A
345C:  MOVLW  0D
345E:  BTFSS  F9E.4
3460:  BRA    345E
3462:  MOVWF  FAD
3464:  MOVLW  0A
3466:  BTFSS  F9E.4
3468:  BRA    3466
346A:  MOVWF  FAD
.................... 		fprintf(STREAM_FTDI,"#  lvd_reconnect_delay_seconds=%lu\r\n",channel[i].lvd_reconnect_delay_seconds);
346C:  MOVLB  1
346E:  MOVF   x1B,W
3470:  MULLW  19
3472:  MOVF   FF3,W
3474:  CLRF   x1D
3476:  MOVWF  x1C
3478:  MOVLW  0B
347A:  ADDWF  x1C,W
347C:  MOVWF  01
347E:  MOVLW  00
3480:  ADDWFC x1D,W
3482:  MOVWF  03
3484:  MOVF   01,W
3486:  ADDLW  DA
3488:  MOVWF  FE9
348A:  MOVLW  00
348C:  ADDWFC 03,W
348E:  MOVWF  FEA
3490:  MOVFF  FEC,11D
3494:  MOVF   FED,F
3496:  MOVFF  FEF,11C
349A:  MOVLW  20
349C:  MOVWF  FF6
349E:  MOVLW  11
34A0:  MOVWF  FF7
34A2:  MOVLW  1F
34A4:  MOVWF  x20
34A6:  MOVLB  0
34A8:  CALL   1B5E
34AC:  MOVLW  10
34AE:  MOVWF  FE9
34B0:  MOVFF  11D,121
34B4:  MOVFF  11C,120
34B8:  RCALL  2E5A
34BA:  MOVLW  0D
34BC:  BTFSS  F9E.4
34BE:  BRA    34BC
34C0:  MOVWF  FAD
34C2:  MOVLW  0A
34C4:  BTFSS  F9E.4
34C6:  BRA    34C4
34C8:  MOVWF  FAD
.................... 
.................... 		fprintf(STREAM_FTDI,"# hvd_disconnect_delay_seconds=%lu\r\n",channel[i].hvd_disconnect_delay_seconds);
34CA:  MOVLB  1
34CC:  MOVF   x1B,W
34CE:  MULLW  19
34D0:  MOVF   FF3,W
34D2:  CLRF   x1D
34D4:  MOVWF  x1C
34D6:  MOVLW  0D
34D8:  ADDWF  x1C,W
34DA:  MOVWF  01
34DC:  MOVLW  00
34DE:  ADDWFC x1D,W
34E0:  MOVWF  03
34E2:  MOVF   01,W
34E4:  ADDLW  DA
34E6:  MOVWF  FE9
34E8:  MOVLW  00
34EA:  ADDWFC 03,W
34EC:  MOVWF  FEA
34EE:  MOVFF  FEC,11D
34F2:  MOVF   FED,F
34F4:  MOVFF  FEF,11C
34F8:  MOVLW  46
34FA:  MOVWF  FF6
34FC:  MOVLW  11
34FE:  MOVWF  FF7
3500:  MOVLW  1F
3502:  MOVWF  x20
3504:  MOVLB  0
3506:  CALL   1B5E
350A:  MOVLW  10
350C:  MOVWF  FE9
350E:  MOVFF  11D,121
3512:  MOVFF  11C,120
3516:  RCALL  2E5A
3518:  MOVLW  0D
351A:  BTFSS  F9E.4
351C:  BRA    351A
351E:  MOVWF  FAD
3520:  MOVLW  0A
3522:  BTFSS  F9E.4
3524:  BRA    3522
3526:  MOVWF  FAD
.................... 		fprintf(STREAM_FTDI,"#  hvd_reconnect_delay_seconds=%lu\r\n",channel[i].hvd_reconnect_delay_seconds);
3528:  MOVLB  1
352A:  MOVF   x1B,W
352C:  MULLW  19
352E:  MOVF   FF3,W
3530:  CLRF   x1D
3532:  MOVWF  x1C
3534:  MOVLW  0F
3536:  ADDWF  x1C,W
3538:  MOVWF  01
353A:  MOVLW  00
353C:  ADDWFC x1D,W
353E:  MOVWF  03
3540:  MOVF   01,W
3542:  ADDLW  DA
3544:  MOVWF  FE9
3546:  MOVLW  00
3548:  ADDWFC 03,W
354A:  MOVWF  FEA
354C:  MOVFF  FEC,11D
3550:  MOVF   FED,F
3552:  MOVFF  FEF,11C
3556:  MOVLW  6C
3558:  MOVWF  FF6
355A:  MOVLW  11
355C:  MOVWF  FF7
355E:  MOVLW  1F
3560:  MOVWF  x20
3562:  MOVLB  0
3564:  CALL   1B5E
3568:  MOVLW  10
356A:  MOVWF  FE9
356C:  MOVFF  11D,121
3570:  MOVFF  11C,120
3574:  RCALL  2E5A
3576:  MOVLW  0D
3578:  BTFSS  F9E.4
357A:  BRA    3578
357C:  MOVWF  FAD
357E:  MOVLW  0A
3580:  BTFSS  F9E.4
3582:  BRA    3580
3584:  MOVWF  FAD
.................... 
.................... 		restart_wdt();
3586:  CLRWDT
.................... 		fprintf(STREAM_FTDI,"# ltd_disconnect_delay_seconds=%lu\r\n",channel[i].ltd_disconnect_delay_seconds);
3588:  MOVLB  1
358A:  MOVF   x1B,W
358C:  MULLW  19
358E:  MOVF   FF3,W
3590:  CLRF   x1D
3592:  MOVWF  x1C
3594:  MOVLW  11
3596:  ADDWF  x1C,W
3598:  MOVWF  01
359A:  MOVLW  00
359C:  ADDWFC x1D,W
359E:  MOVWF  03
35A0:  MOVF   01,W
35A2:  ADDLW  DA
35A4:  MOVWF  FE9
35A6:  MOVLW  00
35A8:  ADDWFC 03,W
35AA:  MOVWF  FEA
35AC:  MOVFF  FEC,11D
35B0:  MOVF   FED,F
35B2:  MOVFF  FEF,11C
35B6:  MOVLW  92
35B8:  MOVWF  FF6
35BA:  MOVLW  11
35BC:  MOVWF  FF7
35BE:  MOVLW  1F
35C0:  MOVWF  x20
35C2:  MOVLB  0
35C4:  CALL   1B5E
35C8:  MOVLW  10
35CA:  MOVWF  FE9
35CC:  MOVFF  11D,121
35D0:  MOVFF  11C,120
35D4:  RCALL  2E5A
35D6:  MOVLW  0D
35D8:  BTFSS  F9E.4
35DA:  BRA    35D8
35DC:  MOVWF  FAD
35DE:  MOVLW  0A
35E0:  BTFSS  F9E.4
35E2:  BRA    35E0
35E4:  MOVWF  FAD
.................... 		fprintf(STREAM_FTDI,"#  ltd_reconnect_delay_seconds=%lu\r\n",channel[i].ltd_reconnect_delay_seconds);
35E6:  MOVLB  1
35E8:  MOVF   x1B,W
35EA:  MULLW  19
35EC:  MOVF   FF3,W
35EE:  CLRF   x1D
35F0:  MOVWF  x1C
35F2:  MOVLW  13
35F4:  ADDWF  x1C,W
35F6:  MOVWF  01
35F8:  MOVLW  00
35FA:  ADDWFC x1D,W
35FC:  MOVWF  03
35FE:  MOVF   01,W
3600:  ADDLW  DA
3602:  MOVWF  FE9
3604:  MOVLW  00
3606:  ADDWFC 03,W
3608:  MOVWF  FEA
360A:  MOVFF  FEC,11D
360E:  MOVF   FED,F
3610:  MOVFF  FEF,11C
3614:  MOVLW  B8
3616:  MOVWF  FF6
3618:  MOVLW  11
361A:  MOVWF  FF7
361C:  MOVLW  1F
361E:  MOVWF  x20
3620:  MOVLB  0
3622:  CALL   1B5E
3626:  MOVLW  10
3628:  MOVWF  FE9
362A:  MOVFF  11D,121
362E:  MOVFF  11C,120
3632:  RCALL  2E5A
3634:  MOVLW  0D
3636:  BTFSS  F9E.4
3638:  BRA    3636
363A:  MOVWF  FAD
363C:  MOVLW  0A
363E:  BTFSS  F9E.4
3640:  BRA    363E
3642:  MOVWF  FAD
.................... 
.................... 		fprintf(STREAM_FTDI,"# htd_disconnect_delay_seconds=%lu\r\n",channel[i].htd_disconnect_delay_seconds);
3644:  MOVLB  1
3646:  MOVF   x1B,W
3648:  MULLW  19
364A:  MOVF   FF3,W
364C:  CLRF   x1D
364E:  MOVWF  x1C
3650:  MOVLW  15
3652:  ADDWF  x1C,W
3654:  MOVWF  01
3656:  MOVLW  00
3658:  ADDWFC x1D,W
365A:  MOVWF  03
365C:  MOVF   01,W
365E:  ADDLW  DA
3660:  MOVWF  FE9
3662:  MOVLW  00
3664:  ADDWFC 03,W
3666:  MOVWF  FEA
3668:  MOVFF  FEC,11D
366C:  MOVF   FED,F
366E:  MOVFF  FEF,11C
3672:  MOVLW  DE
3674:  MOVWF  FF6
3676:  MOVLW  11
3678:  MOVWF  FF7
367A:  MOVLW  1F
367C:  MOVWF  x20
367E:  MOVLB  0
3680:  CALL   1B5E
3684:  MOVLW  10
3686:  MOVWF  FE9
3688:  MOVFF  11D,121
368C:  MOVFF  11C,120
3690:  CALL   2E5A
3694:  MOVLW  0D
3696:  BTFSS  F9E.4
3698:  BRA    3696
369A:  MOVWF  FAD
369C:  MOVLW  0A
369E:  BTFSS  F9E.4
36A0:  BRA    369E
36A2:  MOVWF  FAD
.................... 		fprintf(STREAM_FTDI,"#  htd_reconnect_delay_seconds=%lu\r\n",channel[i].htd_reconnect_delay_seconds);
36A4:  MOVLB  1
36A6:  MOVF   x1B,W
36A8:  MULLW  19
36AA:  MOVF   FF3,W
36AC:  CLRF   x1D
36AE:  MOVWF  x1C
36B0:  MOVLW  17
36B2:  ADDWF  x1C,W
36B4:  MOVWF  01
36B6:  MOVLW  00
36B8:  ADDWFC x1D,W
36BA:  MOVWF  03
36BC:  MOVF   01,W
36BE:  ADDLW  DA
36C0:  MOVWF  FE9
36C2:  MOVLW  00
36C4:  ADDWFC 03,W
36C6:  MOVWF  FEA
36C8:  MOVFF  FEC,11D
36CC:  MOVF   FED,F
36CE:  MOVFF  FEF,11C
36D2:  MOVLW  04
36D4:  MOVWF  FF6
36D6:  MOVLW  12
36D8:  MOVWF  FF7
36DA:  MOVLW  1F
36DC:  MOVWF  x20
36DE:  MOVLB  0
36E0:  CALL   1B5E
36E4:  MOVLW  10
36E6:  MOVWF  FE9
36E8:  MOVFF  11D,121
36EC:  MOVFF  11C,120
36F0:  CALL   2E5A
36F4:  MOVLW  0D
36F6:  BTFSS  F9E.4
36F8:  BRA    36F6
36FA:  MOVWF  FAD
36FC:  MOVLW  0A
36FE:  BTFSS  F9E.4
3700:  BRA    36FE
3702:  MOVWF  FAD
3704:  MOVLB  1
3706:  INCF   x1B,F
3708:  BRA    3108
.................... 	}
370A:  MOVLB  0
370C:  GOTO   3908 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... void contactor_on(int8 c) {
.................... 	/* only turn on contactor if it isn't on or needs a refresh */
.................... 	if ( 1 == timers.contactor[c] ) {
*
2AB8:  CLRF   03
2ABA:  MOVLB  1
2ABC:  MOVF   x1E,W
2ABE:  ADDLW  D6
2AC0:  MOVWF  FE9
2AC2:  MOVLW  00
2AC4:  ADDWFC 03,W
2AC6:  MOVWF  FEA
2AC8:  MOVF   FEF,W
2ACA:  SUBLW  01
2ACC:  BNZ   2AD0
.................... 		return;
2ACE:  BRA    2B0A
.................... 	}
.................... 
.................... 	/* we start the powersave count down */
.................... 	timers.contactor_powersave[c]=CONTACTOR_POWER_SAVE_MS;
2AD0:  CLRF   03
2AD2:  MOVF   x1E,W
2AD4:  ADDLW  D8
2AD6:  MOVWF  FE9
2AD8:  MOVLW  00
2ADA:  ADDWFC 03,W
2ADC:  MOVWF  FEA
2ADE:  MOVLW  C8
2AE0:  MOVWF  FEF
.................... 
.................... 	/* control the actual coil depending on what channel we are on */
.................... 	if ( 0==c ) {
2AE2:  MOVF   x1E,F
2AE4:  BNZ   2AF0
.................... 		/* contactor A pins */
.................... 		output_low(BRIDGE_A_A);
2AE6:  BCF    F94.3
2AE8:  BCF    F8B.3
.................... 		output_high(BRIDGE_A_B);
2AEA:  BCF    F94.4
2AEC:  BSF    F8B.4
.................... 	} else {
2AEE:  BRA    2AF8
.................... 		/* contactor B pins */
.................... 		output_low(BRIDGE_B_A);
2AF0:  BCF    F94.5
2AF2:  BCF    F8B.5
.................... 		output_high(BRIDGE_B_B);
2AF4:  BCF    F94.6
2AF6:  BSF    F8B.6
.................... 	}
.................... 
.................... 	/* save state for next time */
.................... 	timers.contactor[c]=1;
2AF8:  CLRF   03
2AFA:  MOVF   x1E,W
2AFC:  ADDLW  D6
2AFE:  MOVWF  FE9
2B00:  MOVLW  00
2B02:  ADDWFC 03,W
2B04:  MOVWF  FEA
2B06:  MOVLW  01
2B08:  MOVWF  FEF
2B0A:  MOVLB  0
2B0C:  GOTO   2B72 (RETURN)
.................... }
.................... 
.................... void contactor_off(int8 c) {
.................... 	/* only turn off contactor if it isn't on or needs a refresh */
.................... 	if ( 0 == timers.contactor[c] ) {
*
164C:  CLRF   03
164E:  MOVLB  1
1650:  MOVF   x1E,W
1652:  ADDLW  D6
1654:  MOVWF  FE9
1656:  MOVLW  00
1658:  ADDWFC 03,W
165A:  MOVWF  FEA
165C:  MOVF   FEF,W
165E:  BNZ   1662
.................... 		return;
1660:  BRA    169A
.................... 	}
.................... 
.................... 	/* we start the powersave count down */
.................... 	timers.contactor_powersave[c]=CONTACTOR_POWER_SAVE_MS;
1662:  CLRF   03
1664:  MOVF   x1E,W
1666:  ADDLW  D8
1668:  MOVWF  FE9
166A:  MOVLW  00
166C:  ADDWFC 03,W
166E:  MOVWF  FEA
1670:  MOVLW  C8
1672:  MOVWF  FEF
.................... 
.................... 	/* control the actual coil depending on what channel we are on */
.................... 	if ( 0==c ) {
1674:  MOVF   x1E,F
1676:  BNZ   1682
.................... 		output_high(BRIDGE_A_A);
1678:  BCF    F94.3
167A:  BSF    F8B.3
.................... 		output_low(BRIDGE_A_B);
167C:  BCF    F94.4
167E:  BCF    F8B.4
.................... 	} else {
1680:  BRA    168A
.................... 		output_high(BRIDGE_B_A);
1682:  BCF    F94.5
1684:  BSF    F8B.5
.................... 		output_low(BRIDGE_B_B);
1686:  BCF    F94.6
1688:  BCF    F8B.6
.................... 	}
.................... 
.................... 	/* save state for next time */
.................... 	timers.contactor[c]=0;
168A:  CLRF   03
168C:  MOVF   x1E,W
168E:  ADDLW  D6
1690:  MOVWF  FE9
1692:  MOVLW  00
1694:  ADDWFC 03,W
1696:  MOVWF  FEA
1698:  CLRF   FEF
169A:  MOVLB  0
169C:  RETURN 0
.................... }
.................... 
.................... void contactor_set(int8 c) {
*
2B10:  MOVLW  01
2B12:  MOVLB  1
2B14:  MOVWF  x1D
.................... 	int8 state=1;
.................... 
.................... 	/* if nothing is set in channel[c].state, contactor is on */
.................... 	state=1; 
2B16:  MOVWF  x1D
.................... 
.................... 	if ( channel[c].state & CH_STATE_MASK_ON ) {
2B18:  MOVF   x1C,W
2B1A:  MULLW  19
2B1C:  MOVF   FF3,W
2B1E:  CLRF   x1F
2B20:  MOVWF  x1E
2B22:  MOVLW  DA
2B24:  ADDWF  x1E,W
2B26:  MOVWF  FE9
2B28:  MOVLW  00
2B2A:  ADDWFC x1F,W
2B2C:  MOVWF  FEA
2B2E:  MOVF   FEF,W
2B30:  ANDLW  03
2B32:  BZ    2B3A
.................... 		/* if override button (switch) is set or we are commanded on, then we will be on */
.................... 		state=1;
2B34:  MOVLW  01
2B36:  MOVWF  x1D
.................... 	} else if ( channel[c].state & CH_STATE_MASK_OFF ) {
2B38:  BRA    2B58
2B3A:  MOVF   x1C,W
2B3C:  MULLW  19
2B3E:  MOVF   FF3,W
2B40:  CLRF   x1F
2B42:  MOVWF  x1E
2B44:  MOVLW  DA
2B46:  ADDWF  x1E,W
2B48:  MOVWF  FE9
2B4A:  MOVLW  00
2B4C:  ADDWFC x1F,W
2B4E:  MOVWF  FEA
2B50:  MOVF   FEF,W
2B52:  ANDLW  7C
2B54:  BZ    2B58
.................... 		/* if one of the disconnect bits is set, we will be off */
.................... 		state=0;
2B56:  CLRF   x1D
.................... 	}
.................... 
.................... 	if ( 0==state ) {
2B58:  MOVF   x1D,F
2B5A:  BNZ   2B6A
.................... 		contactor_off(c);
2B5C:  MOVFF  11C,11E
2B60:  MOVLB  0
2B62:  CALL   164C
.................... 	} else {
2B66:  BRA    2B72
2B68:  MOVLB  1
.................... 		contactor_on(c);
2B6A:  MOVFF  11C,11E
2B6E:  MOVLB  0
2B70:  BRA    2AB8
.................... 	}
2B72:  RETURN 0
.................... 
.................... }
.................... 
.................... void contactor_logic(int8 c) {
.................... 	int16 adc;
.................... 
.................... 	/* override button / switch */
.................... 	if ( (0==c && 0==input(SW_OVERRIDE_A)) || (1==c && 0==input(SW_OVERRIDE_B)) ) {
*
1C74:  MOVLB  1
1C76:  MOVF   x1C,F
1C78:  BNZ   1C80
1C7A:  BSF    F92.5
1C7C:  BTFSS  F80.5
1C7E:  BRA    1C8A
1C80:  DECFSZ x1C,W
1C82:  BRA    1CA8
1C84:  BSF    F92.4
1C86:  BTFSC  F80.4
1C88:  BRA    1CA8
.................... 		bit_set(channel[c].state,CH_STATE_BIT_OVERRIDE);
1C8A:  MOVF   x1C,W
1C8C:  MULLW  19
1C8E:  MOVF   FF3,W
1C90:  CLRF   x20
1C92:  MOVWF  x1F
1C94:  MOVLW  DA
1C96:  ADDWF  x1F,W
1C98:  MOVWF  01
1C9A:  MOVLW  00
1C9C:  ADDWFC x20,W
1C9E:  MOVFF  01,FE9
1CA2:  MOVWF  FEA
1CA4:  BSF    FEF.0
.................... 	} else {
1CA6:  BRA    1CC4
.................... 		bit_clear(channel[c].state,CH_STATE_BIT_OVERRIDE);
1CA8:  MOVF   x1C,W
1CAA:  MULLW  19
1CAC:  MOVF   FF3,W
1CAE:  CLRF   x20
1CB0:  MOVWF  x1F
1CB2:  MOVLW  DA
1CB4:  ADDWF  x1F,W
1CB6:  MOVWF  01
1CB8:  MOVLW  00
1CBA:  ADDWFC x20,W
1CBC:  MOVFF  01,FE9
1CC0:  MOVWF  FEA
1CC2:  BCF    FEF.0
.................... 	}
.................... 
.................... 	/* command on. 65535 disables */
.................... 	if ( 65535 != channel[c].command_on_seconds ) {
1CC4:  MOVF   x1C,W
1CC6:  MULLW  19
1CC8:  MOVF   FF3,W
1CCA:  CLRF   x20
1CCC:  MOVWF  x1F
1CCE:  MOVLW  01
1CD0:  ADDWF  x1F,W
1CD2:  MOVWF  01
1CD4:  MOVLW  00
1CD6:  ADDWFC x20,W
1CD8:  MOVWF  03
1CDA:  MOVF   01,W
1CDC:  ADDLW  DA
1CDE:  MOVWF  FE9
1CE0:  MOVLW  00
1CE2:  ADDWFC 03,W
1CE4:  MOVWF  FEA
1CE6:  MOVFF  FEC,03
1CEA:  MOVF   FED,F
1CEC:  MOVF   FEF,W
1CEE:  SUBLW  FF
1CF0:  BNZ   1CF8
1CF2:  INCFSZ 03,W
1CF4:  BRA    1CF8
1CF6:  BRA    1E8E
.................... 		if ( channel[c].command_on_seconds > 0 ) {
1CF8:  MOVF   x1C,W
1CFA:  MULLW  19
1CFC:  MOVF   FF3,W
1CFE:  CLRF   x20
1D00:  MOVWF  x1F
1D02:  MOVLW  01
1D04:  ADDWF  x1F,W
1D06:  MOVWF  01
1D08:  MOVLW  00
1D0A:  ADDWFC x20,W
1D0C:  MOVWF  03
1D0E:  MOVF   01,W
1D10:  ADDLW  DA
1D12:  MOVWF  FE9
1D14:  MOVLW  00
1D16:  ADDWFC 03,W
1D18:  MOVWF  FEA
1D1A:  MOVFF  FEC,120
1D1E:  MOVF   FED,F
1D20:  MOVFF  FEF,11F
1D24:  MOVF   x1F,F
1D26:  BNZ   1D2C
1D28:  MOVF   x20,F
1D2A:  BZ    1D5A
.................... 			/* waiting to power on */
.................... 			channel[c].command_on_seconds--;
1D2C:  MOVF   x1C,W
1D2E:  MULLW  19
1D30:  MOVF   FF3,W
1D32:  CLRF   x20
1D34:  MOVWF  x1F
1D36:  MOVLW  01
1D38:  ADDWF  x1F,W
1D3A:  MOVWF  01
1D3C:  MOVLW  00
1D3E:  ADDWFC x20,W
1D40:  MOVWF  03
1D42:  MOVF   01,W
1D44:  ADDLW  DA
1D46:  MOVWF  FE9
1D48:  MOVLW  00
1D4A:  ADDWFC 03,W
1D4C:  MOVWF  FEA
1D4E:  MOVLW  FF
1D50:  ADDWF  FEF,F
1D52:  BC    1D58
1D54:  MOVF   FEE,F
1D56:  DECF   FED,F
.................... 		} else {
1D58:  BRA    1E8E
.................... 			/* timer at zero, ready to power on or already powered on */
.................... 			if ( ! bit_test(channel[c].state,CH_STATE_BIT_CMD_ON) ) {
1D5A:  MOVF   x1C,W
1D5C:  MULLW  19
1D5E:  MOVF   FF3,W
1D60:  CLRF   x20
1D62:  MOVWF  x1F
1D64:  MOVLW  DA
1D66:  ADDWF  x1F,W
1D68:  MOVWF  FE9
1D6A:  MOVLW  00
1D6C:  ADDWFC x20,W
1D6E:  MOVWF  FEA
1D70:  MOVFF  FEF,121
1D74:  BTFSC  x21.1
1D76:  BRA    1DEC
.................... 				/* not currently set, so we set it and start the countdown */
.................... 				bit_set(channel[c].state,CH_STATE_BIT_CMD_ON);
1D78:  MOVF   x1C,W
1D7A:  MULLW  19
1D7C:  MOVF   FF3,W
1D7E:  CLRF   x20
1D80:  MOVWF  x1F
1D82:  MOVLW  DA
1D84:  ADDWF  x1F,W
1D86:  MOVWF  01
1D88:  MOVLW  00
1D8A:  ADDWFC x20,W
1D8C:  MOVFF  01,FE9
1D90:  MOVWF  FEA
1D92:  BSF    FEF.1
.................... 				channel[c].command_on_hold_seconds=config.ch[c].command_on_hold_time;
1D94:  MOVF   x1C,W
1D96:  MULLW  19
1D98:  MOVF   FF3,W
1D9A:  CLRF   x20
1D9C:  MOVWF  x1F
1D9E:  MOVLW  03
1DA0:  ADDWF  x1F,W
1DA2:  MOVWF  01
1DA4:  MOVLW  00
1DA6:  ADDWFC x20,W
1DA8:  MOVWF  03
1DAA:  MOVF   01,W
1DAC:  ADDLW  DA
1DAE:  MOVWF  01
1DB0:  MOVLW  00
1DB2:  ADDWFC 03,F
1DB4:  MOVFF  03,120
1DB8:  MOVF   x1C,W
1DBA:  MULLW  24
1DBC:  MOVF   FF3,W
1DBE:  CLRF   x22
1DC0:  MOVWF  x21
1DC2:  MOVLW  1B
1DC4:  ADDWF  x21,W
1DC6:  MOVWF  FE9
1DC8:  MOVLW  00
1DCA:  ADDWFC x22,W
1DCC:  MOVWF  FEA
1DCE:  MOVFF  FEC,03
1DD2:  MOVF   FED,F
1DD4:  MOVFF  FEF,123
1DD8:  MOVFF  120,FEA
1DDC:  MOVFF  01,FE9
1DE0:  MOVFF  03,FEC
1DE4:  MOVF   FED,F
1DE6:  MOVFF  123,FEF
.................... 			} else {
1DEA:  BRA    1E8E
.................... 				/* set, so we clear it once countdown has elapsed */
.................... 				if ( 0==channel[c].command_on_hold_seconds ) {
1DEC:  MOVF   x1C,W
1DEE:  MULLW  19
1DF0:  MOVF   FF3,W
1DF2:  CLRF   x20
1DF4:  MOVWF  x1F
1DF6:  MOVLW  03
1DF8:  ADDWF  x1F,W
1DFA:  MOVWF  01
1DFC:  MOVLW  00
1DFE:  ADDWFC x20,W
1E00:  MOVWF  03
1E02:  MOVF   01,W
1E04:  ADDLW  DA
1E06:  MOVWF  FE9
1E08:  MOVLW  00
1E0A:  ADDWFC 03,W
1E0C:  MOVWF  FEA
1E0E:  MOVFF  FEC,03
1E12:  MOVF   FED,F
1E14:  MOVF   FEF,W
1E16:  BNZ   1E62
1E18:  MOVF   03,F
1E1A:  BNZ   1E62
.................... 					/* countdown elapsed, clear the flag and reset the timer */
.................... 					bit_clear(channel[c].state,CH_STATE_BIT_CMD_ON);
1E1C:  MOVF   x1C,W
1E1E:  MULLW  19
1E20:  MOVF   FF3,W
1E22:  CLRF   x20
1E24:  MOVWF  x1F
1E26:  MOVLW  DA
1E28:  ADDWF  x1F,W
1E2A:  MOVWF  01
1E2C:  MOVLW  00
1E2E:  ADDWFC x20,W
1E30:  MOVFF  01,FE9
1E34:  MOVWF  FEA
1E36:  BCF    FEF.1
.................... 					channel[c].command_on_seconds=65535;
1E38:  MOVF   x1C,W
1E3A:  MULLW  19
1E3C:  MOVF   FF3,W
1E3E:  CLRF   x20
1E40:  MOVWF  x1F
1E42:  MOVLW  01
1E44:  ADDWF  x1F,W
1E46:  MOVWF  01
1E48:  MOVLW  00
1E4A:  ADDWFC x20,W
1E4C:  MOVWF  03
1E4E:  MOVF   01,W
1E50:  ADDLW  DA
1E52:  MOVWF  FE9
1E54:  MOVLW  00
1E56:  ADDWFC 03,W
1E58:  MOVWF  FEA
1E5A:  SETF   FEC
1E5C:  MOVF   FED,F
1E5E:  SETF   FEF
.................... 				} else {
1E60:  BRA    1E8E
.................... 					channel[c].command_on_hold_seconds--;
1E62:  MOVF   x1C,W
1E64:  MULLW  19
1E66:  MOVF   FF3,W
1E68:  CLRF   x20
1E6A:  MOVWF  x1F
1E6C:  MOVLW  03
1E6E:  ADDWF  x1F,W
1E70:  MOVWF  01
1E72:  MOVLW  00
1E74:  ADDWFC x20,W
1E76:  MOVWF  03
1E78:  MOVF   01,W
1E7A:  ADDLW  DA
1E7C:  MOVWF  FE9
1E7E:  MOVLW  00
1E80:  ADDWFC 03,W
1E82:  MOVWF  FEA
1E84:  MOVLW  FF
1E86:  ADDWF  FEF,F
1E88:  BC    1E8E
1E8A:  MOVF   FEE,F
1E8C:  DECF   FED,F
.................... 				}
.................... 			}		
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	/* command off. 65535 disables */
.................... 	if ( 65535 != channel[c].command_off_seconds ) {
1E8E:  MOVF   x1C,W
1E90:  MULLW  19
1E92:  MOVF   FF3,W
1E94:  CLRF   x20
1E96:  MOVWF  x1F
1E98:  MOVLW  05
1E9A:  ADDWF  x1F,W
1E9C:  MOVWF  01
1E9E:  MOVLW  00
1EA0:  ADDWFC x20,W
1EA2:  MOVWF  03
1EA4:  MOVF   01,W
1EA6:  ADDLW  DA
1EA8:  MOVWF  FE9
1EAA:  MOVLW  00
1EAC:  ADDWFC 03,W
1EAE:  MOVWF  FEA
1EB0:  MOVFF  FEC,03
1EB4:  MOVF   FED,F
1EB6:  MOVF   FEF,W
1EB8:  SUBLW  FF
1EBA:  BNZ   1EC2
1EBC:  INCFSZ 03,W
1EBE:  BRA    1EC2
1EC0:  BRA    2068
.................... 		if ( channel[c].command_off_seconds > 0 ) {
1EC2:  MOVF   x1C,W
1EC4:  MULLW  19
1EC6:  MOVF   FF3,W
1EC8:  CLRF   x20
1ECA:  MOVWF  x1F
1ECC:  MOVLW  05
1ECE:  ADDWF  x1F,W
1ED0:  MOVWF  01
1ED2:  MOVLW  00
1ED4:  ADDWFC x20,W
1ED6:  MOVWF  03
1ED8:  MOVF   01,W
1EDA:  ADDLW  DA
1EDC:  MOVWF  FE9
1EDE:  MOVLW  00
1EE0:  ADDWFC 03,W
1EE2:  MOVWF  FEA
1EE4:  MOVFF  FEC,120
1EE8:  MOVF   FED,F
1EEA:  MOVFF  FEF,11F
1EEE:  MOVF   x1F,F
1EF0:  BNZ   1EF6
1EF2:  MOVF   x20,F
1EF4:  BZ    1F24
.................... 			/* waiting to power off */
.................... 			channel[c].command_off_seconds--;
1EF6:  MOVF   x1C,W
1EF8:  MULLW  19
1EFA:  MOVF   FF3,W
1EFC:  CLRF   x20
1EFE:  MOVWF  x1F
1F00:  MOVLW  05
1F02:  ADDWF  x1F,W
1F04:  MOVWF  01
1F06:  MOVLW  00
1F08:  ADDWFC x20,W
1F0A:  MOVWF  03
1F0C:  MOVF   01,W
1F0E:  ADDLW  DA
1F10:  MOVWF  FE9
1F12:  MOVLW  00
1F14:  ADDWFC 03,W
1F16:  MOVWF  FEA
1F18:  MOVLW  FF
1F1A:  ADDWF  FEF,F
1F1C:  BC    1F22
1F1E:  MOVF   FEE,F
1F20:  DECF   FED,F
.................... 		} else {
1F22:  BRA    2068
.................... 			/* timer at zero, ready to power off or already powered off */
.................... 			if ( ! bit_test(channel[c].state,CH_STATE_BIT_CMD_OFF) ) {
1F24:  MOVF   x1C,W
1F26:  MULLW  19
1F28:  MOVF   FF3,W
1F2A:  CLRF   x20
1F2C:  MOVWF  x1F
1F2E:  MOVLW  DA
1F30:  ADDWF  x1F,W
1F32:  MOVWF  FE9
1F34:  MOVLW  00
1F36:  ADDWFC x20,W
1F38:  MOVWF  FEA
1F3A:  MOVFF  FEF,121
1F3E:  BTFSC  x21.2
1F40:  BRA    1FC6
.................... 				/* not currently set, so we set it and start the countdown */
.................... 				bit_set(channel[c].state,CH_STATE_BIT_CMD_OFF);
1F42:  MOVF   x1C,W
1F44:  MULLW  19
1F46:  MOVF   FF3,W
1F48:  CLRF   x20
1F4A:  MOVWF  x1F
1F4C:  MOVLW  DA
1F4E:  ADDWF  x1F,W
1F50:  MOVWF  01
1F52:  MOVLW  00
1F54:  ADDWFC x20,W
1F56:  MOVFF  01,FE9
1F5A:  MOVWF  FEA
1F5C:  BSF    FEF.2
.................... 				channel[c].command_off_hold_seconds=config.ch[c].command_off_hold_time;
1F5E:  MOVF   x1C,W
1F60:  MULLW  19
1F62:  MOVF   FF3,W
1F64:  CLRF   x20
1F66:  MOVWF  x1F
1F68:  MOVLW  07
1F6A:  ADDWF  x1F,W
1F6C:  MOVWF  01
1F6E:  MOVLW  00
1F70:  ADDWFC x20,W
1F72:  MOVWF  03
1F74:  MOVF   01,W
1F76:  ADDLW  DA
1F78:  MOVWF  01
1F7A:  MOVLW  00
1F7C:  ADDWFC 03,F
1F7E:  MOVFF  01,11F
1F82:  MOVFF  03,120
1F86:  MOVF   x1C,W
1F88:  MULLW  24
1F8A:  MOVF   FF3,W
1F8C:  CLRF   x22
1F8E:  MOVWF  x21
1F90:  MOVLW  02
1F92:  ADDWF  x21,W
1F94:  MOVWF  01
1F96:  MOVLW  00
1F98:  ADDWFC x22,W
1F9A:  MOVWF  03
1F9C:  MOVF   01,W
1F9E:  ADDLW  1B
1FA0:  MOVWF  FE9
1FA2:  MOVLW  00
1FA4:  ADDWFC 03,W
1FA6:  MOVWF  FEA
1FA8:  MOVFF  FEC,03
1FAC:  MOVF   FED,F
1FAE:  MOVFF  FEF,121
1FB2:  MOVFF  120,FEA
1FB6:  MOVFF  11F,FE9
1FBA:  MOVFF  03,FEC
1FBE:  MOVF   FED,F
1FC0:  MOVFF  121,FEF
.................... 			} else {
1FC4:  BRA    2068
.................... 				/* set, so we clear it once countdown has elapsed */
.................... 				if ( 0==channel[c].command_off_hold_seconds ) {
1FC6:  MOVF   x1C,W
1FC8:  MULLW  19
1FCA:  MOVF   FF3,W
1FCC:  CLRF   x20
1FCE:  MOVWF  x1F
1FD0:  MOVLW  07
1FD2:  ADDWF  x1F,W
1FD4:  MOVWF  01
1FD6:  MOVLW  00
1FD8:  ADDWFC x20,W
1FDA:  MOVWF  03
1FDC:  MOVF   01,W
1FDE:  ADDLW  DA
1FE0:  MOVWF  FE9
1FE2:  MOVLW  00
1FE4:  ADDWFC 03,W
1FE6:  MOVWF  FEA
1FE8:  MOVFF  FEC,03
1FEC:  MOVF   FED,F
1FEE:  MOVF   FEF,W
1FF0:  BNZ   203C
1FF2:  MOVF   03,F
1FF4:  BNZ   203C
.................... 					/* countdown elapsed, clear the flag and reset the timer */
.................... 					bit_clear(channel[c].state,CH_STATE_BIT_CMD_OFF);
1FF6:  MOVF   x1C,W
1FF8:  MULLW  19
1FFA:  MOVF   FF3,W
1FFC:  CLRF   x20
1FFE:  MOVWF  x1F
2000:  MOVLW  DA
2002:  ADDWF  x1F,W
2004:  MOVWF  01
2006:  MOVLW  00
2008:  ADDWFC x20,W
200A:  MOVFF  01,FE9
200E:  MOVWF  FEA
2010:  BCF    FEF.2
.................... 					channel[c].command_off_seconds=65535;
2012:  MOVF   x1C,W
2014:  MULLW  19
2016:  MOVF   FF3,W
2018:  CLRF   x20
201A:  MOVWF  x1F
201C:  MOVLW  05
201E:  ADDWF  x1F,W
2020:  MOVWF  01
2022:  MOVLW  00
2024:  ADDWFC x20,W
2026:  MOVWF  03
2028:  MOVF   01,W
202A:  ADDLW  DA
202C:  MOVWF  FE9
202E:  MOVLW  00
2030:  ADDWFC 03,W
2032:  MOVWF  FEA
2034:  SETF   FEC
2036:  MOVF   FED,F
2038:  SETF   FEF
.................... 				} else {
203A:  BRA    2068
.................... 					channel[c].command_off_hold_seconds--;
203C:  MOVF   x1C,W
203E:  MULLW  19
2040:  MOVF   FF3,W
2042:  CLRF   x20
2044:  MOVWF  x1F
2046:  MOVLW  07
2048:  ADDWF  x1F,W
204A:  MOVWF  01
204C:  MOVLW  00
204E:  ADDWFC x20,W
2050:  MOVWF  03
2052:  MOVF   01,W
2054:  ADDLW  DA
2056:  MOVWF  FE9
2058:  MOVLW  00
205A:  ADDWFC 03,W
205C:  MOVWF  FEA
205E:  MOVLW  FF
2060:  ADDWF  FEF,F
2062:  BC    2068
2064:  MOVF   FEE,F
2066:  DECF   FED,F
.................... 				}
.................... 			}		
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	/* Low Voltage Disconnect. 65535 disables */
.................... 	if ( 65535 != config.ch[c].lvd_disconnect_delay ) {
2068:  MOVF   x1C,W
206A:  MULLW  24
206C:  MOVF   FF3,W
206E:  CLRF   x20
2070:  MOVWF  x1F
2072:  MOVLW  06
2074:  ADDWF  x1F,W
2076:  MOVWF  01
2078:  MOVLW  00
207A:  ADDWFC x20,W
207C:  MOVWF  03
207E:  MOVF   01,W
2080:  ADDLW  1B
2082:  MOVWF  FE9
2084:  MOVLW  00
2086:  ADDWFC 03,W
2088:  MOVWF  FEA
208A:  MOVFF  FEC,03
208E:  MOVF   FED,F
2090:  MOVF   FEF,W
2092:  SUBLW  FF
2094:  BNZ   209C
2096:  INCFSZ 03,W
2098:  BRA    209C
209A:  BRA    22FA
209C:  CLRF   19
209E:  BTFSC  FF2.7
20A0:  BSF    19.7
20A2:  BCF    FF2.7
.................... 		adc=adc_get(0);
20A4:  CLRF   x2F
20A6:  MOVLB  0
20A8:  CALL   05AA
20AC:  BTFSC  19.7
20AE:  BSF    FF2.7
20B0:  MOVFF  02,11E
20B4:  MOVFF  01,11D
.................... 
.................... 		if ( adc > config.ch[c].lvd_reconnect_adc ) {
20B8:  MOVLB  1
20BA:  MOVF   x1C,W
20BC:  MULLW  24
20BE:  MOVF   FF3,W
20C0:  CLRF   x20
20C2:  MOVWF  x1F
20C4:  MOVLW  08
20C6:  ADDWF  x1F,W
20C8:  MOVWF  01
20CA:  MOVLW  00
20CC:  ADDWFC x20,W
20CE:  MOVWF  03
20D0:  MOVF   01,W
20D2:  ADDLW  1B
20D4:  MOVWF  FE9
20D6:  MOVLW  00
20D8:  ADDWFC 03,W
20DA:  MOVWF  FEA
20DC:  MOVFF  FEC,03
20E0:  MOVF   FED,F
20E2:  MOVFF  FEF,01
20E6:  MOVF   03,W
20E8:  SUBWF  x1E,W
20EA:  BNC   2174
20EC:  BNZ   20F4
20EE:  MOVF   x1D,W
20F0:  SUBWF  01,W
20F2:  BC    2174
.................... 			if ( channel[c].lvd_reconnect_delay_seconds > 0 ) {
20F4:  MOVF   x1C,W
20F6:  MULLW  19
20F8:  MOVF   FF3,W
20FA:  CLRF   x20
20FC:  MOVWF  x1F
20FE:  MOVLW  0B
2100:  ADDWF  x1F,W
2102:  MOVWF  01
2104:  MOVLW  00
2106:  ADDWFC x20,W
2108:  MOVWF  03
210A:  MOVF   01,W
210C:  ADDLW  DA
210E:  MOVWF  FE9
2110:  MOVLW  00
2112:  ADDWFC 03,W
2114:  MOVWF  FEA
2116:  MOVFF  FEC,120
211A:  MOVF   FED,F
211C:  MOVFF  FEF,11F
2120:  MOVF   x1F,F
2122:  BNZ   2128
2124:  MOVF   x20,F
2126:  BZ    2156
.................... 				channel[c].lvd_reconnect_delay_seconds--;
2128:  MOVF   x1C,W
212A:  MULLW  19
212C:  MOVF   FF3,W
212E:  CLRF   x20
2130:  MOVWF  x1F
2132:  MOVLW  0B
2134:  ADDWF  x1F,W
2136:  MOVWF  01
2138:  MOVLW  00
213A:  ADDWFC x20,W
213C:  MOVWF  03
213E:  MOVF   01,W
2140:  ADDLW  DA
2142:  MOVWF  FE9
2144:  MOVLW  00
2146:  ADDWFC 03,W
2148:  MOVWF  FEA
214A:  MOVLW  FF
214C:  ADDWF  FEF,F
214E:  BC    2154
2150:  MOVF   FEE,F
2152:  DECF   FED,F
.................... 			} else {
2154:  BRA    2172
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_LVD);
2156:  MOVF   x1C,W
2158:  MULLW  19
215A:  MOVF   FF3,W
215C:  CLRF   x20
215E:  MOVWF  x1F
2160:  MOVLW  DA
2162:  ADDWF  x1F,W
2164:  MOVWF  01
2166:  MOVLW  00
2168:  ADDWFC x20,W
216A:  MOVFF  01,FE9
216E:  MOVWF  FEA
2170:  BCF    FEF.3
.................... 			}
.................... 		} else {
2172:  BRA    21DA
.................... 			channel[c].lvd_reconnect_delay_seconds=config.ch[c].lvd_reconnect_delay;
2174:  MOVF   x1C,W
2176:  MULLW  19
2178:  MOVF   FF3,W
217A:  CLRF   x20
217C:  MOVWF  x1F
217E:  MOVLW  0B
2180:  ADDWF  x1F,W
2182:  MOVWF  01
2184:  MOVLW  00
2186:  ADDWFC x20,W
2188:  MOVWF  03
218A:  MOVF   01,W
218C:  ADDLW  DA
218E:  MOVWF  01
2190:  MOVLW  00
2192:  ADDWFC 03,F
2194:  MOVFF  01,11F
2198:  MOVFF  03,120
219C:  MOVF   x1C,W
219E:  MULLW  24
21A0:  MOVF   FF3,W
21A2:  CLRF   x22
21A4:  MOVWF  x21
21A6:  MOVLW  0A
21A8:  ADDWF  x21,W
21AA:  MOVWF  01
21AC:  MOVLW  00
21AE:  ADDWFC x22,W
21B0:  MOVWF  03
21B2:  MOVF   01,W
21B4:  ADDLW  1B
21B6:  MOVWF  FE9
21B8:  MOVLW  00
21BA:  ADDWFC 03,W
21BC:  MOVWF  FEA
21BE:  MOVFF  FEC,03
21C2:  MOVF   FED,F
21C4:  MOVFF  FEF,121
21C8:  MOVFF  120,FEA
21CC:  MOVFF  11F,FE9
21D0:  MOVFF  03,FEC
21D4:  MOVF   FED,F
21D6:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc < config.ch[c].lvd_disconnect_adc ) {
21DA:  MOVF   x1C,W
21DC:  MULLW  24
21DE:  MOVF   FF3,W
21E0:  CLRF   x20
21E2:  MOVWF  x1F
21E4:  MOVLW  04
21E6:  ADDWF  x1F,W
21E8:  MOVWF  01
21EA:  MOVLW  00
21EC:  ADDWFC x20,W
21EE:  MOVWF  03
21F0:  MOVF   01,W
21F2:  ADDLW  1B
21F4:  MOVWF  FE9
21F6:  MOVLW  00
21F8:  ADDWFC 03,W
21FA:  MOVWF  FEA
21FC:  MOVFF  FEC,03
2200:  MOVF   FED,F
2202:  MOVFF  FEF,01
2206:  MOVF   x1E,W
2208:  SUBWF  03,W
220A:  BNC   2294
220C:  BNZ   2214
220E:  MOVF   01,W
2210:  SUBWF  x1D,W
2212:  BC    2294
.................... 			if ( channel[c].lvd_disconnect_delay_seconds > 0 ) {
2214:  MOVF   x1C,W
2216:  MULLW  19
2218:  MOVF   FF3,W
221A:  CLRF   x20
221C:  MOVWF  x1F
221E:  MOVLW  09
2220:  ADDWF  x1F,W
2222:  MOVWF  01
2224:  MOVLW  00
2226:  ADDWFC x20,W
2228:  MOVWF  03
222A:  MOVF   01,W
222C:  ADDLW  DA
222E:  MOVWF  FE9
2230:  MOVLW  00
2232:  ADDWFC 03,W
2234:  MOVWF  FEA
2236:  MOVFF  FEC,120
223A:  MOVF   FED,F
223C:  MOVFF  FEF,11F
2240:  MOVF   x1F,F
2242:  BNZ   2248
2244:  MOVF   x20,F
2246:  BZ    2276
.................... 				channel[c].lvd_disconnect_delay_seconds--;
2248:  MOVF   x1C,W
224A:  MULLW  19
224C:  MOVF   FF3,W
224E:  CLRF   x20
2250:  MOVWF  x1F
2252:  MOVLW  09
2254:  ADDWF  x1F,W
2256:  MOVWF  01
2258:  MOVLW  00
225A:  ADDWFC x20,W
225C:  MOVWF  03
225E:  MOVF   01,W
2260:  ADDLW  DA
2262:  MOVWF  FE9
2264:  MOVLW  00
2266:  ADDWFC 03,W
2268:  MOVWF  FEA
226A:  MOVLW  FF
226C:  ADDWF  FEF,F
226E:  BC    2274
2270:  MOVF   FEE,F
2272:  DECF   FED,F
.................... 			} else {
2274:  BRA    2292
.................... 				bit_set(channel[c].state,CH_STATE_BIT_LVD);
2276:  MOVF   x1C,W
2278:  MULLW  19
227A:  MOVF   FF3,W
227C:  CLRF   x20
227E:  MOVWF  x1F
2280:  MOVLW  DA
2282:  ADDWF  x1F,W
2284:  MOVWF  01
2286:  MOVLW  00
2288:  ADDWFC x20,W
228A:  MOVFF  01,FE9
228E:  MOVWF  FEA
2290:  BSF    FEF.3
.................... 			}
.................... 		} else {
2292:  BRA    22FA
.................... 			channel[c].lvd_disconnect_delay_seconds=config.ch[c].lvd_disconnect_delay;
2294:  MOVF   x1C,W
2296:  MULLW  19
2298:  MOVF   FF3,W
229A:  CLRF   x20
229C:  MOVWF  x1F
229E:  MOVLW  09
22A0:  ADDWF  x1F,W
22A2:  MOVWF  01
22A4:  MOVLW  00
22A6:  ADDWFC x20,W
22A8:  MOVWF  03
22AA:  MOVF   01,W
22AC:  ADDLW  DA
22AE:  MOVWF  01
22B0:  MOVLW  00
22B2:  ADDWFC 03,F
22B4:  MOVFF  01,11F
22B8:  MOVFF  03,120
22BC:  MOVF   x1C,W
22BE:  MULLW  24
22C0:  MOVF   FF3,W
22C2:  CLRF   x22
22C4:  MOVWF  x21
22C6:  MOVLW  06
22C8:  ADDWF  x21,W
22CA:  MOVWF  01
22CC:  MOVLW  00
22CE:  ADDWFC x22,W
22D0:  MOVWF  03
22D2:  MOVF   01,W
22D4:  ADDLW  1B
22D6:  MOVWF  FE9
22D8:  MOVLW  00
22DA:  ADDWFC 03,W
22DC:  MOVWF  FEA
22DE:  MOVFF  FEC,03
22E2:  MOVF   FED,F
22E4:  MOVFF  FEF,121
22E8:  MOVFF  120,FEA
22EC:  MOVFF  11F,FE9
22F0:  MOVFF  03,FEC
22F4:  MOVF   FED,F
22F6:  MOVFF  121,FEF
.................... 		}
.................... 	}
.................... 
.................... 	/* High Voltage Disconnect. 65535 disables */
.................... 	if ( 65535 != config.ch[c].hvd_disconnect_delay ) {
22FA:  MOVF   x1C,W
22FC:  MULLW  24
22FE:  MOVF   FF3,W
2300:  CLRF   x20
2302:  MOVWF  x1F
2304:  MOVLW  0E
2306:  ADDWF  x1F,W
2308:  MOVWF  01
230A:  MOVLW  00
230C:  ADDWFC x20,W
230E:  MOVWF  03
2310:  MOVF   01,W
2312:  ADDLW  1B
2314:  MOVWF  FE9
2316:  MOVLW  00
2318:  ADDWFC 03,W
231A:  MOVWF  FEA
231C:  MOVFF  FEC,03
2320:  MOVF   FED,F
2322:  MOVF   FEF,W
2324:  SUBLW  FF
2326:  BNZ   232E
2328:  INCFSZ 03,W
232A:  BRA    232E
232C:  BRA    258C
232E:  CLRF   19
2330:  BTFSC  FF2.7
2332:  BSF    19.7
2334:  BCF    FF2.7
.................... 		adc=adc_get(0);
2336:  CLRF   x2F
2338:  MOVLB  0
233A:  CALL   05AA
233E:  BTFSC  19.7
2340:  BSF    FF2.7
2342:  MOVFF  02,11E
2346:  MOVFF  01,11D
.................... 
.................... 		if ( adc < config.ch[c].hvd_reconnect_adc ) {
234A:  MOVLB  1
234C:  MOVF   x1C,W
234E:  MULLW  24
2350:  MOVF   FF3,W
2352:  CLRF   x20
2354:  MOVWF  x1F
2356:  MOVLW  10
2358:  ADDWF  x1F,W
235A:  MOVWF  01
235C:  MOVLW  00
235E:  ADDWFC x20,W
2360:  MOVWF  03
2362:  MOVF   01,W
2364:  ADDLW  1B
2366:  MOVWF  FE9
2368:  MOVLW  00
236A:  ADDWFC 03,W
236C:  MOVWF  FEA
236E:  MOVFF  FEC,03
2372:  MOVF   FED,F
2374:  MOVFF  FEF,01
2378:  MOVF   x1E,W
237A:  SUBWF  03,W
237C:  BNC   2406
237E:  BNZ   2386
2380:  MOVF   01,W
2382:  SUBWF  x1D,W
2384:  BC    2406
.................... 			if ( channel[c].hvd_reconnect_delay_seconds > 0 ) {
2386:  MOVF   x1C,W
2388:  MULLW  19
238A:  MOVF   FF3,W
238C:  CLRF   x20
238E:  MOVWF  x1F
2390:  MOVLW  0F
2392:  ADDWF  x1F,W
2394:  MOVWF  01
2396:  MOVLW  00
2398:  ADDWFC x20,W
239A:  MOVWF  03
239C:  MOVF   01,W
239E:  ADDLW  DA
23A0:  MOVWF  FE9
23A2:  MOVLW  00
23A4:  ADDWFC 03,W
23A6:  MOVWF  FEA
23A8:  MOVFF  FEC,120
23AC:  MOVF   FED,F
23AE:  MOVFF  FEF,11F
23B2:  MOVF   x1F,F
23B4:  BNZ   23BA
23B6:  MOVF   x20,F
23B8:  BZ    23E8
.................... 				channel[c].hvd_reconnect_delay_seconds--;
23BA:  MOVF   x1C,W
23BC:  MULLW  19
23BE:  MOVF   FF3,W
23C0:  CLRF   x20
23C2:  MOVWF  x1F
23C4:  MOVLW  0F
23C6:  ADDWF  x1F,W
23C8:  MOVWF  01
23CA:  MOVLW  00
23CC:  ADDWFC x20,W
23CE:  MOVWF  03
23D0:  MOVF   01,W
23D2:  ADDLW  DA
23D4:  MOVWF  FE9
23D6:  MOVLW  00
23D8:  ADDWFC 03,W
23DA:  MOVWF  FEA
23DC:  MOVLW  FF
23DE:  ADDWF  FEF,F
23E0:  BC    23E6
23E2:  MOVF   FEE,F
23E4:  DECF   FED,F
.................... 			} else {
23E6:  BRA    2404
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_HVD);
23E8:  MOVF   x1C,W
23EA:  MULLW  19
23EC:  MOVF   FF3,W
23EE:  CLRF   x20
23F0:  MOVWF  x1F
23F2:  MOVLW  DA
23F4:  ADDWF  x1F,W
23F6:  MOVWF  01
23F8:  MOVLW  00
23FA:  ADDWFC x20,W
23FC:  MOVFF  01,FE9
2400:  MOVWF  FEA
2402:  BCF    FEF.4
.................... 			}
.................... 		} else {
2404:  BRA    246C
.................... 			channel[c].hvd_reconnect_delay_seconds=config.ch[c].hvd_reconnect_delay;
2406:  MOVF   x1C,W
2408:  MULLW  19
240A:  MOVF   FF3,W
240C:  CLRF   x20
240E:  MOVWF  x1F
2410:  MOVLW  0F
2412:  ADDWF  x1F,W
2414:  MOVWF  01
2416:  MOVLW  00
2418:  ADDWFC x20,W
241A:  MOVWF  03
241C:  MOVF   01,W
241E:  ADDLW  DA
2420:  MOVWF  01
2422:  MOVLW  00
2424:  ADDWFC 03,F
2426:  MOVFF  01,11F
242A:  MOVFF  03,120
242E:  MOVF   x1C,W
2430:  MULLW  24
2432:  MOVF   FF3,W
2434:  CLRF   x22
2436:  MOVWF  x21
2438:  MOVLW  12
243A:  ADDWF  x21,W
243C:  MOVWF  01
243E:  MOVLW  00
2440:  ADDWFC x22,W
2442:  MOVWF  03
2444:  MOVF   01,W
2446:  ADDLW  1B
2448:  MOVWF  FE9
244A:  MOVLW  00
244C:  ADDWFC 03,W
244E:  MOVWF  FEA
2450:  MOVFF  FEC,03
2454:  MOVF   FED,F
2456:  MOVFF  FEF,121
245A:  MOVFF  120,FEA
245E:  MOVFF  11F,FE9
2462:  MOVFF  03,FEC
2466:  MOVF   FED,F
2468:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc > config.ch[c].hvd_disconnect_adc ) {
246C:  MOVF   x1C,W
246E:  MULLW  24
2470:  MOVF   FF3,W
2472:  CLRF   x20
2474:  MOVWF  x1F
2476:  MOVLW  0C
2478:  ADDWF  x1F,W
247A:  MOVWF  01
247C:  MOVLW  00
247E:  ADDWFC x20,W
2480:  MOVWF  03
2482:  MOVF   01,W
2484:  ADDLW  1B
2486:  MOVWF  FE9
2488:  MOVLW  00
248A:  ADDWFC 03,W
248C:  MOVWF  FEA
248E:  MOVFF  FEC,03
2492:  MOVF   FED,F
2494:  MOVFF  FEF,01
2498:  MOVF   03,W
249A:  SUBWF  x1E,W
249C:  BNC   2526
249E:  BNZ   24A6
24A0:  MOVF   x1D,W
24A2:  SUBWF  01,W
24A4:  BC    2526
.................... 			if ( channel[c].hvd_disconnect_delay_seconds > 0 ) {
24A6:  MOVF   x1C,W
24A8:  MULLW  19
24AA:  MOVF   FF3,W
24AC:  CLRF   x20
24AE:  MOVWF  x1F
24B0:  MOVLW  0D
24B2:  ADDWF  x1F,W
24B4:  MOVWF  01
24B6:  MOVLW  00
24B8:  ADDWFC x20,W
24BA:  MOVWF  03
24BC:  MOVF   01,W
24BE:  ADDLW  DA
24C0:  MOVWF  FE9
24C2:  MOVLW  00
24C4:  ADDWFC 03,W
24C6:  MOVWF  FEA
24C8:  MOVFF  FEC,120
24CC:  MOVF   FED,F
24CE:  MOVFF  FEF,11F
24D2:  MOVF   x1F,F
24D4:  BNZ   24DA
24D6:  MOVF   x20,F
24D8:  BZ    2508
.................... 				channel[c].hvd_disconnect_delay_seconds--;
24DA:  MOVF   x1C,W
24DC:  MULLW  19
24DE:  MOVF   FF3,W
24E0:  CLRF   x20
24E2:  MOVWF  x1F
24E4:  MOVLW  0D
24E6:  ADDWF  x1F,W
24E8:  MOVWF  01
24EA:  MOVLW  00
24EC:  ADDWFC x20,W
24EE:  MOVWF  03
24F0:  MOVF   01,W
24F2:  ADDLW  DA
24F4:  MOVWF  FE9
24F6:  MOVLW  00
24F8:  ADDWFC 03,W
24FA:  MOVWF  FEA
24FC:  MOVLW  FF
24FE:  ADDWF  FEF,F
2500:  BC    2506
2502:  MOVF   FEE,F
2504:  DECF   FED,F
.................... 			} else {
2506:  BRA    2524
.................... 				bit_set(channel[c].state,CH_STATE_BIT_HVD);
2508:  MOVF   x1C,W
250A:  MULLW  19
250C:  MOVF   FF3,W
250E:  CLRF   x20
2510:  MOVWF  x1F
2512:  MOVLW  DA
2514:  ADDWF  x1F,W
2516:  MOVWF  01
2518:  MOVLW  00
251A:  ADDWFC x20,W
251C:  MOVFF  01,FE9
2520:  MOVWF  FEA
2522:  BSF    FEF.4
.................... 			}
.................... 		} else {
2524:  BRA    258C
.................... 			channel[c].hvd_disconnect_delay_seconds=config.ch[c].hvd_disconnect_delay;
2526:  MOVF   x1C,W
2528:  MULLW  19
252A:  MOVF   FF3,W
252C:  CLRF   x20
252E:  MOVWF  x1F
2530:  MOVLW  0D
2532:  ADDWF  x1F,W
2534:  MOVWF  01
2536:  MOVLW  00
2538:  ADDWFC x20,W
253A:  MOVWF  03
253C:  MOVF   01,W
253E:  ADDLW  DA
2540:  MOVWF  01
2542:  MOVLW  00
2544:  ADDWFC 03,F
2546:  MOVFF  01,11F
254A:  MOVFF  03,120
254E:  MOVF   x1C,W
2550:  MULLW  24
2552:  MOVF   FF3,W
2554:  CLRF   x22
2556:  MOVWF  x21
2558:  MOVLW  0E
255A:  ADDWF  x21,W
255C:  MOVWF  01
255E:  MOVLW  00
2560:  ADDWFC x22,W
2562:  MOVWF  03
2564:  MOVF   01,W
2566:  ADDLW  1B
2568:  MOVWF  FE9
256A:  MOVLW  00
256C:  ADDWFC 03,W
256E:  MOVWF  FEA
2570:  MOVFF  FEC,03
2574:  MOVF   FED,F
2576:  MOVFF  FEF,121
257A:  MOVFF  120,FEA
257E:  MOVFF  11F,FE9
2582:  MOVFF  03,FEC
2586:  MOVF   FED,F
2588:  MOVFF  121,FEF
.................... 		}
.................... 	}
.................... 
.................... 	/* Low Temperature Disconnect. 65535 disables */
.................... 	if ( 65535 != config.ch[c].ltd_disconnect_delay ) {
258C:  MOVF   x1C,W
258E:  MULLW  24
2590:  MOVF   FF3,W
2592:  CLRF   x20
2594:  MOVWF  x1F
2596:  MOVLW  16
2598:  ADDWF  x1F,W
259A:  MOVWF  01
259C:  MOVLW  00
259E:  ADDWFC x20,W
25A0:  MOVWF  03
25A2:  MOVF   01,W
25A4:  ADDLW  1B
25A6:  MOVWF  FE9
25A8:  MOVLW  00
25AA:  ADDWFC 03,W
25AC:  MOVWF  FEA
25AE:  MOVFF  FEC,03
25B2:  MOVF   FED,F
25B4:  MOVF   FEF,W
25B6:  SUBLW  FF
25B8:  BNZ   25C0
25BA:  INCFSZ 03,W
25BC:  BRA    25C0
25BE:  BRA    2820
25C0:  CLRF   19
25C2:  BTFSC  FF2.7
25C4:  BSF    19.7
25C6:  BCF    FF2.7
.................... 		adc=adc_get(1);
25C8:  MOVLW  01
25CA:  MOVWF  x2F
25CC:  MOVLB  0
25CE:  CALL   05AA
25D2:  BTFSC  19.7
25D4:  BSF    FF2.7
25D6:  MOVFF  02,11E
25DA:  MOVFF  01,11D
.................... 
.................... 		if ( adc < config.ch[c].ltd_reconnect_adc ) {
25DE:  MOVLB  1
25E0:  MOVF   x1C,W
25E2:  MULLW  24
25E4:  MOVF   FF3,W
25E6:  CLRF   x20
25E8:  MOVWF  x1F
25EA:  MOVLW  18
25EC:  ADDWF  x1F,W
25EE:  MOVWF  01
25F0:  MOVLW  00
25F2:  ADDWFC x20,W
25F4:  MOVWF  03
25F6:  MOVF   01,W
25F8:  ADDLW  1B
25FA:  MOVWF  FE9
25FC:  MOVLW  00
25FE:  ADDWFC 03,W
2600:  MOVWF  FEA
2602:  MOVFF  FEC,03
2606:  MOVF   FED,F
2608:  MOVFF  FEF,01
260C:  MOVF   x1E,W
260E:  SUBWF  03,W
2610:  BNC   269A
2612:  BNZ   261A
2614:  MOVF   01,W
2616:  SUBWF  x1D,W
2618:  BC    269A
.................... 			/* above reconnect temperature */
.................... 			if ( channel[c].ltd_reconnect_delay_seconds > 0 ) {
261A:  MOVF   x1C,W
261C:  MULLW  19
261E:  MOVF   FF3,W
2620:  CLRF   x20
2622:  MOVWF  x1F
2624:  MOVLW  13
2626:  ADDWF  x1F,W
2628:  MOVWF  01
262A:  MOVLW  00
262C:  ADDWFC x20,W
262E:  MOVWF  03
2630:  MOVF   01,W
2632:  ADDLW  DA
2634:  MOVWF  FE9
2636:  MOVLW  00
2638:  ADDWFC 03,W
263A:  MOVWF  FEA
263C:  MOVFF  FEC,120
2640:  MOVF   FED,F
2642:  MOVFF  FEF,11F
2646:  MOVF   x1F,F
2648:  BNZ   264E
264A:  MOVF   x20,F
264C:  BZ    267C
.................... 				channel[c].ltd_reconnect_delay_seconds--;
264E:  MOVF   x1C,W
2650:  MULLW  19
2652:  MOVF   FF3,W
2654:  CLRF   x20
2656:  MOVWF  x1F
2658:  MOVLW  13
265A:  ADDWF  x1F,W
265C:  MOVWF  01
265E:  MOVLW  00
2660:  ADDWFC x20,W
2662:  MOVWF  03
2664:  MOVF   01,W
2666:  ADDLW  DA
2668:  MOVWF  FE9
266A:  MOVLW  00
266C:  ADDWFC 03,W
266E:  MOVWF  FEA
2670:  MOVLW  FF
2672:  ADDWF  FEF,F
2674:  BC    267A
2676:  MOVF   FEE,F
2678:  DECF   FED,F
.................... 			} else {
267A:  BRA    2698
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_LTD);
267C:  MOVF   x1C,W
267E:  MULLW  19
2680:  MOVF   FF3,W
2682:  CLRF   x20
2684:  MOVWF  x1F
2686:  MOVLW  DA
2688:  ADDWF  x1F,W
268A:  MOVWF  01
268C:  MOVLW  00
268E:  ADDWFC x20,W
2690:  MOVFF  01,FE9
2694:  MOVWF  FEA
2696:  BCF    FEF.5
.................... 			}
.................... 		} else {
2698:  BRA    2700
.................... 			channel[c].ltd_reconnect_delay_seconds=config.ch[c].ltd_reconnect_delay;
269A:  MOVF   x1C,W
269C:  MULLW  19
269E:  MOVF   FF3,W
26A0:  CLRF   x20
26A2:  MOVWF  x1F
26A4:  MOVLW  13
26A6:  ADDWF  x1F,W
26A8:  MOVWF  01
26AA:  MOVLW  00
26AC:  ADDWFC x20,W
26AE:  MOVWF  03
26B0:  MOVF   01,W
26B2:  ADDLW  DA
26B4:  MOVWF  01
26B6:  MOVLW  00
26B8:  ADDWFC 03,F
26BA:  MOVFF  01,11F
26BE:  MOVFF  03,120
26C2:  MOVF   x1C,W
26C4:  MULLW  24
26C6:  MOVF   FF3,W
26C8:  CLRF   x22
26CA:  MOVWF  x21
26CC:  MOVLW  1A
26CE:  ADDWF  x21,W
26D0:  MOVWF  01
26D2:  MOVLW  00
26D4:  ADDWFC x22,W
26D6:  MOVWF  03
26D8:  MOVF   01,W
26DA:  ADDLW  1B
26DC:  MOVWF  FE9
26DE:  MOVLW  00
26E0:  ADDWFC 03,W
26E2:  MOVWF  FEA
26E4:  MOVFF  FEC,03
26E8:  MOVF   FED,F
26EA:  MOVFF  FEF,121
26EE:  MOVFF  120,FEA
26F2:  MOVFF  11F,FE9
26F6:  MOVFF  03,FEC
26FA:  MOVF   FED,F
26FC:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc > config.ch[c].ltd_disconnect_adc ) {
2700:  MOVF   x1C,W
2702:  MULLW  24
2704:  MOVF   FF3,W
2706:  CLRF   x20
2708:  MOVWF  x1F
270A:  MOVLW  14
270C:  ADDWF  x1F,W
270E:  MOVWF  01
2710:  MOVLW  00
2712:  ADDWFC x20,W
2714:  MOVWF  03
2716:  MOVF   01,W
2718:  ADDLW  1B
271A:  MOVWF  FE9
271C:  MOVLW  00
271E:  ADDWFC 03,W
2720:  MOVWF  FEA
2722:  MOVFF  FEC,03
2726:  MOVF   FED,F
2728:  MOVFF  FEF,01
272C:  MOVF   03,W
272E:  SUBWF  x1E,W
2730:  BNC   27BA
2732:  BNZ   273A
2734:  MOVF   x1D,W
2736:  SUBWF  01,W
2738:  BC    27BA
.................... 			/* below disconnect temperature */
.................... 			if ( channel[c].ltd_disconnect_delay_seconds > 0 ) {
273A:  MOVF   x1C,W
273C:  MULLW  19
273E:  MOVF   FF3,W
2740:  CLRF   x20
2742:  MOVWF  x1F
2744:  MOVLW  11
2746:  ADDWF  x1F,W
2748:  MOVWF  01
274A:  MOVLW  00
274C:  ADDWFC x20,W
274E:  MOVWF  03
2750:  MOVF   01,W
2752:  ADDLW  DA
2754:  MOVWF  FE9
2756:  MOVLW  00
2758:  ADDWFC 03,W
275A:  MOVWF  FEA
275C:  MOVFF  FEC,120
2760:  MOVF   FED,F
2762:  MOVFF  FEF,11F
2766:  MOVF   x1F,F
2768:  BNZ   276E
276A:  MOVF   x20,F
276C:  BZ    279C
.................... 				channel[c].ltd_disconnect_delay_seconds--;
276E:  MOVF   x1C,W
2770:  MULLW  19
2772:  MOVF   FF3,W
2774:  CLRF   x20
2776:  MOVWF  x1F
2778:  MOVLW  11
277A:  ADDWF  x1F,W
277C:  MOVWF  01
277E:  MOVLW  00
2780:  ADDWFC x20,W
2782:  MOVWF  03
2784:  MOVF   01,W
2786:  ADDLW  DA
2788:  MOVWF  FE9
278A:  MOVLW  00
278C:  ADDWFC 03,W
278E:  MOVWF  FEA
2790:  MOVLW  FF
2792:  ADDWF  FEF,F
2794:  BC    279A
2796:  MOVF   FEE,F
2798:  DECF   FED,F
.................... 			} else {
279A:  BRA    27B8
.................... 				bit_set(channel[c].state,CH_STATE_BIT_LTD);
279C:  MOVF   x1C,W
279E:  MULLW  19
27A0:  MOVF   FF3,W
27A2:  CLRF   x20
27A4:  MOVWF  x1F
27A6:  MOVLW  DA
27A8:  ADDWF  x1F,W
27AA:  MOVWF  01
27AC:  MOVLW  00
27AE:  ADDWFC x20,W
27B0:  MOVFF  01,FE9
27B4:  MOVWF  FEA
27B6:  BSF    FEF.5
.................... 			}
.................... 		} else {
27B8:  BRA    2820
.................... 			channel[c].ltd_disconnect_delay_seconds=config.ch[c].ltd_disconnect_delay;
27BA:  MOVF   x1C,W
27BC:  MULLW  19
27BE:  MOVF   FF3,W
27C0:  CLRF   x20
27C2:  MOVWF  x1F
27C4:  MOVLW  11
27C6:  ADDWF  x1F,W
27C8:  MOVWF  01
27CA:  MOVLW  00
27CC:  ADDWFC x20,W
27CE:  MOVWF  03
27D0:  MOVF   01,W
27D2:  ADDLW  DA
27D4:  MOVWF  01
27D6:  MOVLW  00
27D8:  ADDWFC 03,F
27DA:  MOVFF  01,11F
27DE:  MOVFF  03,120
27E2:  MOVF   x1C,W
27E4:  MULLW  24
27E6:  MOVF   FF3,W
27E8:  CLRF   x22
27EA:  MOVWF  x21
27EC:  MOVLW  16
27EE:  ADDWF  x21,W
27F0:  MOVWF  01
27F2:  MOVLW  00
27F4:  ADDWFC x22,W
27F6:  MOVWF  03
27F8:  MOVF   01,W
27FA:  ADDLW  1B
27FC:  MOVWF  FE9
27FE:  MOVLW  00
2800:  ADDWFC 03,W
2802:  MOVWF  FEA
2804:  MOVFF  FEC,03
2808:  MOVF   FED,F
280A:  MOVFF  FEF,121
280E:  MOVFF  120,FEA
2812:  MOVFF  11F,FE9
2816:  MOVFF  03,FEC
281A:  MOVF   FED,F
281C:  MOVFF  121,FEF
.................... 		}
.................... 	}
.................... 
.................... 	/* High Temperature Disconnect. 65535 disables */
.................... 	if ( 65535 != config.ch[c].htd_disconnect_delay ) {
2820:  MOVF   x1C,W
2822:  MULLW  24
2824:  MOVF   FF3,W
2826:  CLRF   x20
2828:  MOVWF  x1F
282A:  MOVLW  1E
282C:  ADDWF  x1F,W
282E:  MOVWF  01
2830:  MOVLW  00
2832:  ADDWFC x20,W
2834:  MOVWF  03
2836:  MOVF   01,W
2838:  ADDLW  1B
283A:  MOVWF  FE9
283C:  MOVLW  00
283E:  ADDWFC 03,W
2840:  MOVWF  FEA
2842:  MOVFF  FEC,03
2846:  MOVF   FED,F
2848:  MOVF   FEF,W
284A:  SUBLW  FF
284C:  BNZ   2854
284E:  INCFSZ 03,W
2850:  BRA    2854
2852:  BRA    2AB4
2854:  CLRF   19
2856:  BTFSC  FF2.7
2858:  BSF    19.7
285A:  BCF    FF2.7
.................... 		adc=adc_get(1);
285C:  MOVLW  01
285E:  MOVWF  x2F
2860:  MOVLB  0
2862:  CALL   05AA
2866:  BTFSC  19.7
2868:  BSF    FF2.7
286A:  MOVFF  02,11E
286E:  MOVFF  01,11D
.................... 
.................... 		if ( adc > config.ch[c].htd_reconnect_adc ) {
2872:  MOVLB  1
2874:  MOVF   x1C,W
2876:  MULLW  24
2878:  MOVF   FF3,W
287A:  CLRF   x20
287C:  MOVWF  x1F
287E:  MOVLW  20
2880:  ADDWF  x1F,W
2882:  MOVWF  01
2884:  MOVLW  00
2886:  ADDWFC x20,W
2888:  MOVWF  03
288A:  MOVF   01,W
288C:  ADDLW  1B
288E:  MOVWF  FE9
2890:  MOVLW  00
2892:  ADDWFC 03,W
2894:  MOVWF  FEA
2896:  MOVFF  FEC,03
289A:  MOVF   FED,F
289C:  MOVFF  FEF,01
28A0:  MOVF   03,W
28A2:  SUBWF  x1E,W
28A4:  BNC   292E
28A6:  BNZ   28AE
28A8:  MOVF   x1D,W
28AA:  SUBWF  01,W
28AC:  BC    292E
.................... 			if ( channel[c].htd_reconnect_delay_seconds > 0 ) {
28AE:  MOVF   x1C,W
28B0:  MULLW  19
28B2:  MOVF   FF3,W
28B4:  CLRF   x20
28B6:  MOVWF  x1F
28B8:  MOVLW  17
28BA:  ADDWF  x1F,W
28BC:  MOVWF  01
28BE:  MOVLW  00
28C0:  ADDWFC x20,W
28C2:  MOVWF  03
28C4:  MOVF   01,W
28C6:  ADDLW  DA
28C8:  MOVWF  FE9
28CA:  MOVLW  00
28CC:  ADDWFC 03,W
28CE:  MOVWF  FEA
28D0:  MOVFF  FEC,120
28D4:  MOVF   FED,F
28D6:  MOVFF  FEF,11F
28DA:  MOVF   x1F,F
28DC:  BNZ   28E2
28DE:  MOVF   x20,F
28E0:  BZ    2910
.................... 				channel[c].htd_reconnect_delay_seconds--;
28E2:  MOVF   x1C,W
28E4:  MULLW  19
28E6:  MOVF   FF3,W
28E8:  CLRF   x20
28EA:  MOVWF  x1F
28EC:  MOVLW  17
28EE:  ADDWF  x1F,W
28F0:  MOVWF  01
28F2:  MOVLW  00
28F4:  ADDWFC x20,W
28F6:  MOVWF  03
28F8:  MOVF   01,W
28FA:  ADDLW  DA
28FC:  MOVWF  FE9
28FE:  MOVLW  00
2900:  ADDWFC 03,W
2902:  MOVWF  FEA
2904:  MOVLW  FF
2906:  ADDWF  FEF,F
2908:  BC    290E
290A:  MOVF   FEE,F
290C:  DECF   FED,F
.................... 			} else {
290E:  BRA    292C
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_HTD);
2910:  MOVF   x1C,W
2912:  MULLW  19
2914:  MOVF   FF3,W
2916:  CLRF   x20
2918:  MOVWF  x1F
291A:  MOVLW  DA
291C:  ADDWF  x1F,W
291E:  MOVWF  01
2920:  MOVLW  00
2922:  ADDWFC x20,W
2924:  MOVFF  01,FE9
2928:  MOVWF  FEA
292A:  BCF    FEF.6
.................... 			}
.................... 		} else {
292C:  BRA    2994
.................... 			channel[c].htd_reconnect_delay_seconds=config.ch[c].htd_reconnect_delay;
292E:  MOVF   x1C,W
2930:  MULLW  19
2932:  MOVF   FF3,W
2934:  CLRF   x20
2936:  MOVWF  x1F
2938:  MOVLW  17
293A:  ADDWF  x1F,W
293C:  MOVWF  01
293E:  MOVLW  00
2940:  ADDWFC x20,W
2942:  MOVWF  03
2944:  MOVF   01,W
2946:  ADDLW  DA
2948:  MOVWF  01
294A:  MOVLW  00
294C:  ADDWFC 03,F
294E:  MOVFF  01,11F
2952:  MOVFF  03,120
2956:  MOVF   x1C,W
2958:  MULLW  24
295A:  MOVF   FF3,W
295C:  CLRF   x22
295E:  MOVWF  x21
2960:  MOVLW  22
2962:  ADDWF  x21,W
2964:  MOVWF  01
2966:  MOVLW  00
2968:  ADDWFC x22,W
296A:  MOVWF  03
296C:  MOVF   01,W
296E:  ADDLW  1B
2970:  MOVWF  FE9
2972:  MOVLW  00
2974:  ADDWFC 03,W
2976:  MOVWF  FEA
2978:  MOVFF  FEC,03
297C:  MOVF   FED,F
297E:  MOVFF  FEF,121
2982:  MOVFF  120,FEA
2986:  MOVFF  11F,FE9
298A:  MOVFF  03,FEC
298E:  MOVF   FED,F
2990:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc < config.ch[c].htd_disconnect_adc ) {
2994:  MOVF   x1C,W
2996:  MULLW  24
2998:  MOVF   FF3,W
299A:  CLRF   x20
299C:  MOVWF  x1F
299E:  MOVLW  1C
29A0:  ADDWF  x1F,W
29A2:  MOVWF  01
29A4:  MOVLW  00
29A6:  ADDWFC x20,W
29A8:  MOVWF  03
29AA:  MOVF   01,W
29AC:  ADDLW  1B
29AE:  MOVWF  FE9
29B0:  MOVLW  00
29B2:  ADDWFC 03,W
29B4:  MOVWF  FEA
29B6:  MOVFF  FEC,03
29BA:  MOVF   FED,F
29BC:  MOVFF  FEF,01
29C0:  MOVF   x1E,W
29C2:  SUBWF  03,W
29C4:  BNC   2A4E
29C6:  BNZ   29CE
29C8:  MOVF   01,W
29CA:  SUBWF  x1D,W
29CC:  BC    2A4E
.................... 			if ( channel[c].htd_disconnect_delay_seconds > 0 ) {
29CE:  MOVF   x1C,W
29D0:  MULLW  19
29D2:  MOVF   FF3,W
29D4:  CLRF   x20
29D6:  MOVWF  x1F
29D8:  MOVLW  15
29DA:  ADDWF  x1F,W
29DC:  MOVWF  01
29DE:  MOVLW  00
29E0:  ADDWFC x20,W
29E2:  MOVWF  03
29E4:  MOVF   01,W
29E6:  ADDLW  DA
29E8:  MOVWF  FE9
29EA:  MOVLW  00
29EC:  ADDWFC 03,W
29EE:  MOVWF  FEA
29F0:  MOVFF  FEC,120
29F4:  MOVF   FED,F
29F6:  MOVFF  FEF,11F
29FA:  MOVF   x1F,F
29FC:  BNZ   2A02
29FE:  MOVF   x20,F
2A00:  BZ    2A30
.................... 				channel[c].htd_disconnect_delay_seconds--;
2A02:  MOVF   x1C,W
2A04:  MULLW  19
2A06:  MOVF   FF3,W
2A08:  CLRF   x20
2A0A:  MOVWF  x1F
2A0C:  MOVLW  15
2A0E:  ADDWF  x1F,W
2A10:  MOVWF  01
2A12:  MOVLW  00
2A14:  ADDWFC x20,W
2A16:  MOVWF  03
2A18:  MOVF   01,W
2A1A:  ADDLW  DA
2A1C:  MOVWF  FE9
2A1E:  MOVLW  00
2A20:  ADDWFC 03,W
2A22:  MOVWF  FEA
2A24:  MOVLW  FF
2A26:  ADDWF  FEF,F
2A28:  BC    2A2E
2A2A:  MOVF   FEE,F
2A2C:  DECF   FED,F
.................... 			} else {
2A2E:  BRA    2A4C
.................... 				bit_set(channel[c].state,CH_STATE_BIT_HTD);
2A30:  MOVF   x1C,W
2A32:  MULLW  19
2A34:  MOVF   FF3,W
2A36:  CLRF   x20
2A38:  MOVWF  x1F
2A3A:  MOVLW  DA
2A3C:  ADDWF  x1F,W
2A3E:  MOVWF  01
2A40:  MOVLW  00
2A42:  ADDWFC x20,W
2A44:  MOVFF  01,FE9
2A48:  MOVWF  FEA
2A4A:  BSF    FEF.6
.................... 			}
.................... 		} else {
2A4C:  BRA    2AB4
.................... 			channel[c].htd_disconnect_delay_seconds=config.ch[c].htd_disconnect_delay;
2A4E:  MOVF   x1C,W
2A50:  MULLW  19
2A52:  MOVF   FF3,W
2A54:  CLRF   x20
2A56:  MOVWF  x1F
2A58:  MOVLW  15
2A5A:  ADDWF  x1F,W
2A5C:  MOVWF  01
2A5E:  MOVLW  00
2A60:  ADDWFC x20,W
2A62:  MOVWF  03
2A64:  MOVF   01,W
2A66:  ADDLW  DA
2A68:  MOVWF  01
2A6A:  MOVLW  00
2A6C:  ADDWFC 03,F
2A6E:  MOVFF  01,11F
2A72:  MOVFF  03,120
2A76:  MOVF   x1C,W
2A78:  MULLW  24
2A7A:  MOVF   FF3,W
2A7C:  CLRF   x22
2A7E:  MOVWF  x21
2A80:  MOVLW  1E
2A82:  ADDWF  x21,W
2A84:  MOVWF  01
2A86:  MOVLW  00
2A88:  ADDWFC x22,W
2A8A:  MOVWF  03
2A8C:  MOVF   01,W
2A8E:  ADDLW  1B
2A90:  MOVWF  FE9
2A92:  MOVLW  00
2A94:  ADDWFC 03,W
2A96:  MOVWF  FEA
2A98:  MOVFF  FEC,03
2A9C:  MOVF   FED,F
2A9E:  MOVFF  FEF,121
2AA2:  MOVFF  120,FEA
2AA6:  MOVFF  11F,FE9
2AAA:  MOVFF  03,FEC
2AAE:  MOVF   FED,F
2AB0:  MOVFF  121,FEF
.................... 		}
.................... 	}
2AB4:  MOVLB  0
2AB6:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void led_status_update(void) {
.................... 	static int8 cycle=0;
.................... 	int8 led;
.................... 
.................... 	for ( led=0 ; led<2 ; led++ ) {
*
2B74:  MOVLB  1
2B76:  CLRF   x1C
2B78:  MOVF   x1C,W
2B7A:  SUBLW  01
2B7C:  BNC   2C52
.................... 		if ( cycle < 8 ) {
2B7E:  MOVF   x13,W
2B80:  SUBLW  07
2B82:  BNC   2BEA
.................... 			/* first 8 cycles are 8 bits of state bit field */
.................... 
.................... 			/* if bit is set, then we blink the number of times+1 of the bit we are in. So bit 1 set means we blink 2 times */
.................... 			if ( bit_test(channel[led].state,cycle) ) {
2B84:  MOVF   x1C,W
2B86:  MULLW  19
2B88:  MOVF   FF3,W
2B8A:  CLRF   x1E
2B8C:  MOVWF  x1D
2B8E:  MOVLW  DA
2B90:  ADDWF  x1D,W
2B92:  MOVWF  FE9
2B94:  MOVLW  00
2B96:  ADDWFC x1E,W
2B98:  MOVWF  FEA
2B9A:  MOVFF  FEF,00
2B9E:  MOVF   x13,W
2BA0:  MOVWF  01
2BA2:  BZ    2BAC
2BA4:  BCF    FD8.0
2BA6:  RRCF   00,F
2BA8:  DECFSZ 01,F
2BAA:  BRA    2BA4
2BAC:  BTFSS  00.0
2BAE:  BRA    2BD8
.................... 				timers.led_blink[led]=cycle+1;      /* number of blinks */
2BB0:  CLRF   03
2BB2:  MOVF   x1C,W
2BB4:  ADDLW  D0
2BB6:  MOVWF  FE9
2BB8:  MOVLW  00
2BBA:  ADDWFC 03,W
2BBC:  MOVWF  FEA
2BBE:  MOVLW  01
2BC0:  ADDWF  x13,W
2BC2:  MOVWF  FEF
.................... 				timers.led_on[led]=BLINK_ON_TIME;   /* how long to be on */
2BC4:  CLRF   03
2BC6:  MOVF   x1C,W
2BC8:  ADDLW  D2
2BCA:  MOVWF  FE9
2BCC:  MOVLW  00
2BCE:  ADDWFC 03,W
2BD0:  MOVWF  FEA
2BD2:  MOVLW  FE
2BD4:  MOVWF  FEF
.................... 			} else {
2BD6:  BRA    2BE8
.................... 				timers.led_blink[led]=0;
2BD8:  CLRF   03
2BDA:  MOVF   x1C,W
2BDC:  ADDLW  D0
2BDE:  MOVWF  FE9
2BE0:  MOVLW  00
2BE2:  ADDWFC 03,W
2BE4:  MOVWF  FEA
2BE6:  CLRF   FEF
.................... 			}
.................... 		} else if ( 8 == cycle ) {
2BE8:  BRA    2C4E
2BEA:  MOVF   x13,W
2BEC:  SUBLW  08
2BEE:  BNZ   2C02
.................... 			/* solid light to mark start of next cycle */
.................... 			timers.led_blink[led]=255;
2BF0:  CLRF   03
2BF2:  MOVF   x1C,W
2BF4:  ADDLW  D0
2BF6:  MOVWF  FE9
2BF8:  MOVLW  00
2BFA:  ADDWFC 03,W
2BFC:  MOVWF  FEA
2BFE:  SETF   FEF
.................... 		} else if ( 9 == cycle ) {
2C00:  BRA    2C4E
2C02:  MOVF   x13,W
2C04:  SUBLW  09
2C06:  BNZ   2C3E
.................... 			/* solid on if contactor state is on, otherwise off */
.................... 			if ( timers.contactor[led] ) {
2C08:  CLRF   03
2C0A:  MOVF   x1C,W
2C0C:  ADDLW  D6
2C0E:  MOVWF  FE9
2C10:  MOVLW  00
2C12:  ADDWFC 03,W
2C14:  MOVWF  FEA
2C16:  MOVF   FEF,F
2C18:  BZ    2C2C
.................... 				timers.led_blink[led]=255;
2C1A:  CLRF   03
2C1C:  MOVF   x1C,W
2C1E:  ADDLW  D0
2C20:  MOVWF  FE9
2C22:  MOVLW  00
2C24:  ADDWFC 03,W
2C26:  MOVWF  FEA
2C28:  SETF   FEF
.................... 			} else {
2C2A:  BRA    2C3C
.................... 				timers.led_blink[led]=0;
2C2C:  CLRF   03
2C2E:  MOVF   x1C,W
2C30:  ADDLW  D0
2C32:  MOVWF  FE9
2C34:  MOVLW  00
2C36:  ADDWFC 03,W
2C38:  MOVWF  FEA
2C3A:  CLRF   FEF
.................... 			}
.................... 		} else {
2C3C:  BRA    2C4E
.................... 			/* blank period before starting the bit field */
.................... 			timers.led_blink[led]=0;
2C3E:  CLRF   03
2C40:  MOVF   x1C,W
2C42:  ADDLW  D0
2C44:  MOVWF  FE9
2C46:  MOVLW  00
2C48:  ADDWFC 03,W
2C4A:  MOVWF  FEA
2C4C:  CLRF   FEF
.................... 		}
2C4E:  INCF   x1C,F
2C50:  BRA    2B78
.................... 	}
.................... 
.................... //	fprintf(STREAM_FTDI,"# LED %u A=%03u (0x%02X) B=%03u (0x%02X)\r\n",cycle,timers.led_blink[0],channel[0].state,timers.led_blink[1],channel[1].state);
.................... 
.................... 	if ( 10 == cycle ) {
2C52:  MOVF   x13,W
2C54:  SUBLW  0A
2C56:  BNZ   2C5C
.................... 		cycle=0; 
2C58:  CLRF   x13
.................... 	} else {
2C5A:  BRA    2C5E
.................... 		cycle++;
2C5C:  INCF   x13,F
.................... 	}
2C5E:  MOVLB  0
2C60:  GOTO   2E0E (RETURN)
.................... }
.................... 
.................... void led_on(int8 c) {
.................... 	if ( 0==c ) 
*
1C4C:  MOVLB  1
1C4E:  MOVF   x1C,F
1C50:  BNZ   1C58
.................... 		output_high(LED_A);
1C52:  BCF    F94.1
1C54:  BSF    F8B.1
1C56:  BRA    1C5C
.................... 	else
.................... 		output_high(LED_B);
1C58:  BCF    F94.2
1C5A:  BSF    F8B.2
1C5C:  MOVLB  0
1C5E:  RETURN 0
.................... }
.................... 
.................... void led_off(int8 c) {
.................... 	if ( 0==c ) 
1C60:  MOVLB  1
1C62:  MOVF   x1C,F
1C64:  BNZ   1C6C
.................... 		output_low(LED_A);
1C66:  BCF    F94.1
1C68:  BCF    F8B.1
1C6A:  BRA    1C70
.................... 	else
.................... 		output_low(LED_B);
1C6C:  BCF    F94.2
1C6E:  BCF    F8B.2
1C70:  MOVLB  0
1C72:  RETURN 0
.................... }
.................... 
.................... void periodic_millisecond(void) {
.................... 	static int8  uptimeTicks=0;
.................... 	static int8  statusTicks=0;
.................... 	static int16 adcTicks=0;
.................... 	static int16 ticks=0;
.................... 
.................... 	int8 i;
.................... 
.................... 
.................... 	timers.now_millisecond=0;
*
2C64:  BCF    xCF.2
.................... 
.................... 	/* set LED output */
.................... 	for ( i=0 ; i<2 ; i++ ) {
2C66:  MOVLB  1
2C68:  CLRF   x1B
2C6A:  MOVF   x1B,W
2C6C:  SUBLW  01
2C6E:  BTFSS  FD8.0
2C70:  BRA    2D70
.................... 		if ( 255 == timers.led_blink[i] ) {
2C72:  CLRF   03
2C74:  MOVF   x1B,W
2C76:  ADDLW  D0
2C78:  MOVWF  FE9
2C7A:  MOVLW  00
2C7C:  ADDWFC 03,W
2C7E:  MOVWF  FEA
2C80:  MOVF   FEF,W
2C82:  SUBLW  FF
2C84:  BNZ   2C94
.................... 			led_on(i);
2C86:  MOVFF  11B,11C
2C8A:  MOVLB  0
2C8C:  CALL   1C4C
.................... 		} else if ( 0 == timers.led_blink[i] ) {
2C90:  BRA    2D6A
2C92:  MOVLB  1
2C94:  CLRF   03
2C96:  MOVF   x1B,W
2C98:  ADDLW  D0
2C9A:  MOVWF  FE9
2C9C:  MOVLW  00
2C9E:  ADDWFC 03,W
2CA0:  MOVWF  FEA
2CA2:  MOVF   FEF,W
2CA4:  BNZ   2CB4
.................... 			led_off(i);
2CA6:  MOVFF  11B,11C
2CAA:  MOVLB  0
2CAC:  CALL   1C60
.................... 		} else {
2CB0:  BRA    2D6A
2CB2:  MOVLB  1
.................... 			/* led_blink[i] is somewhere between 1 and 254 */
.................... 			if ( timers.led_on[i] > 0 ) {
2CB4:  CLRF   03
2CB6:  MOVF   x1B,W
2CB8:  ADDLW  D2
2CBA:  MOVWF  FE9
2CBC:  MOVLW  00
2CBE:  ADDWFC 03,W
2CC0:  MOVWF  FEA
2CC2:  MOVF   FEF,F
2CC4:  BZ    2D06
.................... 				led_on(i);
2CC6:  MOVFF  11B,11C
2CCA:  MOVLB  0
2CCC:  CALL   1C4C
.................... 				timers.led_on[i]--;
2CD0:  CLRF   03
2CD2:  MOVLB  1
2CD4:  MOVF   x1B,W
2CD6:  ADDLW  D2
2CD8:  MOVWF  FE9
2CDA:  MOVLW  00
2CDC:  ADDWFC 03,W
2CDE:  MOVWF  FEA
2CE0:  DECF   FEF,F
.................... 
.................... 				if ( 0==timers.led_on[i] ) {
2CE2:  CLRF   03
2CE4:  MOVF   x1B,W
2CE6:  ADDLW  D2
2CE8:  MOVWF  FE9
2CEA:  MOVLW  00
2CEC:  ADDWFC 03,W
2CEE:  MOVWF  FEA
2CF0:  MOVF   FEF,W
2CF2:  BNZ   2D06
.................... 					/* hit zero, switch to our off timer */
.................... 					timers.led_off[i]=BLINK_OFF_TIME;
2CF4:  CLRF   03
2CF6:  MOVF   x1B,W
2CF8:  ADDLW  D4
2CFA:  MOVWF  FE9
2CFC:  MOVLW  00
2CFE:  ADDWFC 03,W
2D00:  MOVWF  FEA
2D02:  MOVLW  C8
2D04:  MOVWF  FEF
.................... 				}
.................... 			}
.................... 
.................... 			if ( timers.led_off[i] > 0 ) {
2D06:  CLRF   03
2D08:  MOVF   x1B,W
2D0A:  ADDLW  D4
2D0C:  MOVWF  FE9
2D0E:  MOVLW  00
2D10:  ADDWFC 03,W
2D12:  MOVWF  FEA
2D14:  MOVF   FEF,F
2D16:  BZ    2D68
.................... 				led_off(i);
2D18:  MOVFF  11B,11C
2D1C:  MOVLB  0
2D1E:  CALL   1C60
.................... 				timers.led_off[i]--;
2D22:  CLRF   03
2D24:  MOVLB  1
2D26:  MOVF   x1B,W
2D28:  ADDLW  D4
2D2A:  MOVWF  FE9
2D2C:  MOVLW  00
2D2E:  ADDWFC 03,W
2D30:  MOVWF  FEA
2D32:  DECF   FEF,F
.................... 
.................... 				if ( 0==timers.led_off[i] ) {
2D34:  CLRF   03
2D36:  MOVF   x1B,W
2D38:  ADDLW  D4
2D3A:  MOVWF  FE9
2D3C:  MOVLW  00
2D3E:  ADDWFC 03,W
2D40:  MOVWF  FEA
2D42:  MOVF   FEF,W
2D44:  BNZ   2D68
.................... 					/* hit zero, preload for next */
.................... 					timers.led_on[i]=BLINK_ON_TIME;
2D46:  CLRF   03
2D48:  MOVF   x1B,W
2D4A:  ADDLW  D2
2D4C:  MOVWF  FE9
2D4E:  MOVLW  00
2D50:  ADDWFC 03,W
2D52:  MOVWF  FEA
2D54:  MOVLW  FE
2D56:  MOVWF  FEF
.................... 					/* done with this blink cycle */	
.................... 					timers.led_blink[i]--;
2D58:  CLRF   03
2D5A:  MOVF   x1B,W
2D5C:  ADDLW  D0
2D5E:  MOVWF  FE9
2D60:  MOVLW  00
2D62:  ADDWFC 03,W
2D64:  MOVWF  FEA
2D66:  DECF   FEF,F
2D68:  MOVLB  0
.................... 				}
.................... 			}
.................... 		}
2D6A:  MOVLB  1
2D6C:  INCF   x1B,F
2D6E:  BRA    2C6A
.................... 	}
.................... 
.................... 
.................... 	/* some other random stuff that we don't need to do every cycle in main */
.................... 	if ( current.interval_milliseconds < 65535 ) {
2D70:  MOVLB  0
2D72:  INCFSZ xC8,W
2D74:  BRA    2D7C
2D76:  INCFSZ xC9,W
2D78:  BRA    2D7C
2D7A:  BRA    2D82
.................... 		current.interval_milliseconds++;
2D7C:  INCF   xC8,F
2D7E:  BTFSC  FD8.2
2D80:  INCF   xC9,F
.................... 	}
.................... 
.................... 
.................... 	/* contactor timeout */
.................... 	if ( 0 == timers.contactor_powersave[0] ) {
2D82:  MOVF   xD8,F
2D84:  BNZ   2D90
.................... 		output_low(BRIDGE_A_A);
2D86:  BCF    F94.3
2D88:  BCF    F8B.3
.................... 		output_low(BRIDGE_A_B);
2D8A:  BCF    F94.4
2D8C:  BCF    F8B.4
.................... 	} else {
2D8E:  BRA    2D92
.................... 		timers.contactor_powersave[0]--;
2D90:  DECF   xD8,F
.................... 	}
.................... 	if ( 0 == timers.contactor_powersave[1] ) {
2D92:  MOVF   xD9,F
2D94:  BNZ   2DA0
.................... 		output_low(BRIDGE_B_A);
2D96:  BCF    F94.5
2D98:  BCF    F8B.5
.................... 		output_low(BRIDGE_B_B);
2D9A:  BCF    F94.6
2D9C:  BCF    F8B.6
.................... 	} else {
2D9E:  BRA    2DA2
.................... 		timers.contactor_powersave[1]--;
2DA0:  DECF   xD9,F
.................... 	}
.................... 
.................... 
.................... 
.................... 
.................... 	/* seconds */
.................... 	ticks++;
2DA2:  MOVLB  1
2DA4:  INCF   x18,F
2DA6:  BTFSC  FD8.2
2DA8:  INCF   x19,F
.................... 	if ( 1000 == ticks ) {
2DAA:  MOVF   x18,W
2DAC:  SUBLW  E8
2DAE:  BNZ   2E10
2DB0:  MOVF   x19,W
2DB2:  SUBLW  03
2DB4:  BNZ   2E10
.................... 		ticks=0;
2DB6:  CLRF   x19
2DB8:  CLRF   x18
.................... 
.................... 		/* set channe[n].state based on logic */
.................... 		contactor_logic(0);
2DBA:  CLRF   x1C
2DBC:  MOVLB  0
2DBE:  CALL   1C74
.................... 		contactor_logic(1);
2DC2:  MOVLW  01
2DC4:  MOVLB  1
2DC6:  MOVWF  x1C
2DC8:  MOVLB  0
2DCA:  CALL   1C74
.................... 
.................... 		/* set contactor outputs based on their state bit field */
.................... 		contactor_set(0);
2DCE:  MOVLB  1
2DD0:  CLRF   x1C
2DD2:  MOVLB  0
2DD4:  RCALL  2B10
.................... 		contactor_set(1);		
2DD6:  MOVLW  01
2DD8:  MOVLB  1
2DDA:  MOVWF  x1C
2DDC:  MOVLB  0
2DDE:  RCALL  2B10
.................... 
.................... 		/* uptime counter */
.................... 		uptimeTicks++;
2DE0:  MOVLB  1
2DE2:  INCF   x14,F
.................... 		if ( 60 == uptimeTicks ) {
2DE4:  MOVF   x14,W
2DE6:  SUBLW  3C
2DE8:  BNZ   2E00
.................... 			uptimeTicks=0;
2DEA:  CLRF   x14
.................... 			if ( current.uptime_minutes < 65535 ) 
2DEC:  MOVLB  0
2DEE:  INCFSZ xC6,W
2DF0:  BRA    2DF8
2DF2:  INCFSZ xC7,W
2DF4:  BRA    2DF8
2DF6:  BRA    2DFE
.................... 				current.uptime_minutes++;
2DF8:  INCF   xC6,F
2DFA:  BTFSC  FD8.2
2DFC:  INCF   xC7,F
2DFE:  MOVLB  1
.................... 		}
.................... 
.................... 		/* LED status update every 4 seconds */
.................... 		statusTicks++;
2E00:  INCF   x15,F
.................... 		if ( 4 == statusTicks ) {
2E02:  MOVF   x15,W
2E04:  SUBLW  04
2E06:  BNZ   2E10
.................... 			/* LED state display update */
.................... 			statusTicks=0;
2E08:  CLRF   x15
.................... 			led_status_update();
2E0A:  MOVLB  0
2E0C:  BRA    2B74
2E0E:  MOVLB  1
.................... 		}
.................... 
.................... 
.................... 	}
.................... 
.................... 	/* ADC sample counter */
.................... 	if ( timers.now_adc_reset_count ) {
2E10:  MOVLB  0
2E12:  BTFSS  xCF.1
2E14:  BRA    2E20
.................... 		timers.now_adc_reset_count=0;
2E16:  BCF    xCF.1
.................... 		adcTicks=0;
2E18:  MOVLB  1
2E1A:  CLRF   x17
2E1C:  CLRF   x16
2E1E:  MOVLB  0
.................... 	}
.................... 
.................... 	/* ADC sampling trigger */
.................... 	adcTicks++;
2E20:  MOVLB  1
2E22:  INCF   x16,F
2E24:  BTFSC  FD8.2
2E26:  INCF   x17,F
.................... 	if ( ADC_SAMPLE_TICKS == adcTicks ) {
2E28:  MOVF   x16,W
2E2A:  SUBLW  14
2E2C:  BNZ   2E3C
2E2E:  MOVF   x17,F
2E30:  BNZ   2E3C
.................... 		adcTicks=0;
2E32:  CLRF   x17
2E34:  CLRF   x16
.................... 		timers.now_adc_sample=1;
2E36:  MOVLB  0
2E38:  BSF    xCF.0
2E3A:  MOVLB  1
.................... 	}
2E3C:  MOVLB  0
2E3E:  GOTO   38F4 (RETURN)
.................... 
.................... }
.................... 
.................... void init(void) {
.................... 	int8 i;
.................... 	int8 buff[10];
.................... 	setup_oscillator(OSC_16MHZ);
*
1372:  MOVLW  70
1374:  MOVWF  FD3
1376:  BCF    F9B.6
1378:  BCF    F9B.7
.................... 
.................... 	setup_adc(ADC_CLOCK_DIV_16);
137A:  MOVF   FC0,W
137C:  ANDLW  C0
137E:  IORLW  05
1380:  MOVWF  FC0
1382:  BSF    FC0.7
1384:  BSF    FC2.0
.................... 	/* NTC thermistor on sAN2, input voltage divider on sAN4, DIP switch analog on sAN9
.................... 	voltage spans between 0 and Vdd */
.................... 	setup_adc_ports(sAN2 | sAN4 | sAN9,VSS_VDD);
1386:  MOVLW  14
1388:  MOVWF  F7E
138A:  BCF    FC1.0
138C:  BCF    FC1.1
138E:  BCF    FC1.2
1390:  BCF    FC1.3
1392:  MOVLW  02
1394:  MOVWF  F7F
.................... 
.................... 	setup_wdt(WDT_512MS); /* forces the fuse to WDT128 */
1396:  BSF    FD1.0
.................... 
.................... 	set_tris_a(0b00111111);
1398:  MOVLW  3F
139A:  MOVWF  F92
.................... 	set_tris_b(0b01110000);
139C:  MOVLW  70
139E:  MOVWF  F93
.................... 	set_tris_c(0b10000001);
13A0:  MOVLW  81
13A2:  MOVWF  F94
.................... //               76543210
.................... 
.................... 	port_a_pullups(0b00110000);
13A4:  MOVLW  30
13A6:  MOVWF  F77
13A8:  BCF    FF1.7
.................... 	port_b_pullups(0b00000000);
13AA:  CLRF   F78
.................... //                   76543210
.................... 
.................... 	/* data structure initialization */
.................... 	/* all initialized to 0 on declaration. Just do this if need non-zero */
.................... 	for ( i=0 ; i<=1 ; i++ ) {
13AC:  MOVLB  1
13AE:  CLRF   x1B
13B0:  MOVF   x1B,W
13B2:  SUBLW  01
13B4:  BNC   1422
.................... 		channel[i].command_off_seconds=65535;
13B6:  MOVF   x1B,W
13B8:  MULLW  19
13BA:  MOVF   FF3,W
13BC:  CLRF   x27
13BE:  MOVWF  x26
13C0:  MOVLW  05
13C2:  ADDWF  x26,W
13C4:  MOVWF  01
13C6:  MOVLW  00
13C8:  ADDWFC x27,W
13CA:  MOVWF  03
13CC:  MOVF   01,W
13CE:  ADDLW  DA
13D0:  MOVWF  FE9
13D2:  MOVLW  00
13D4:  ADDWFC 03,W
13D6:  MOVWF  FEA
13D8:  SETF   FEC
13DA:  MOVF   FED,F
13DC:  SETF   FEF
.................... 		channel[i].command_on_seconds =65535;
13DE:  MOVF   x1B,W
13E0:  MULLW  19
13E2:  MOVF   FF3,W
13E4:  CLRF   x27
13E6:  MOVWF  x26
13E8:  MOVLW  01
13EA:  ADDWF  x26,W
13EC:  MOVWF  01
13EE:  MOVLW  00
13F0:  ADDWFC x27,W
13F2:  MOVWF  03
13F4:  MOVF   01,W
13F6:  ADDLW  DA
13F8:  MOVWF  FE9
13FA:  MOVLW  00
13FC:  ADDWFC 03,W
13FE:  MOVWF  FEA
1400:  SETF   FEC
1402:  MOVF   FED,F
1404:  SETF   FEF
.................... 		channel[i].state=0;
1406:  MOVF   x1B,W
1408:  MULLW  19
140A:  MOVF   FF3,W
140C:  CLRF   x27
140E:  MOVWF  x26
1410:  MOVLW  DA
1412:  ADDWF  x26,W
1414:  MOVWF  FE9
1416:  MOVLW  00
1418:  ADDWFC x27,W
141A:  MOVWF  FEA
141C:  CLRF   FEF
141E:  INCF   x1B,F
1420:  BRA    13B0
.................... 	}
.................... 
.................... 	/* get our compiled date from constant  
.................... 	'5-Feb-22'
.................... 	 01234567
.................... 
.................... 	'25-Feb-22'
.................... 	 012345678
.................... 	*/
.................... 	strcpy(buff,__DATE__);
1422:  MOVLW  01
1424:  MOVWF  FEA
1426:  MOVLW  1C
1428:  MOVWF  FE9
142A:  MOVLW  00
142C:  MOVLB  0
142E:  CALL   00BA
1432:  TBLRD*-
1434:  TBLRD*+
1436:  MOVF   FF5,W
1438:  MOVWF  FEE
143A:  IORLW  00
143C:  BNZ   1434
.................... 	i=0;
143E:  MOVLB  1
1440:  CLRF   x1B
.................... 	if ( '-' != buff[1] ) {
1442:  MOVF   x1D,W
1444:  SUBLW  2D
1446:  BZ    1466
.................... 		/* day can be one or two digits */
.................... 		current.compile_day =(buff[i]-'0')*10;
1448:  CLRF   03
144A:  MOVF   x1B,W
144C:  ADDLW  1C
144E:  MOVWF  FE9
1450:  MOVLW  01
1452:  ADDWFC 03,W
1454:  MOVWF  FEA
1456:  MOVLW  30
1458:  SUBWF  FEF,W
145A:  MULLW  0A
145C:  MOVFF  FF3,CD
1460:  MOVLB  0
.................... 		i++;
1462:  MOVLB  1
1464:  INCF   x1B,F
.................... 	}
.................... 	current.compile_day+=(buff[i]-'0');
1466:  CLRF   03
1468:  MOVF   x1B,W
146A:  ADDLW  1C
146C:  MOVWF  FE9
146E:  MOVLW  01
1470:  ADDWFC 03,W
1472:  MOVWF  FEA
1474:  MOVLW  30
1476:  SUBWF  FEF,W
1478:  MOVLB  0
147A:  ADDWF  xCD,F
.................... 	i+=2; /* now points to month */
147C:  MOVLW  02
147E:  MOVLB  1
1480:  ADDWF  x1B,F
.................... 
.................... 	/* determine month ... how annoying */
.................... 	if ( 'J'==buff[i+0] ) {
1482:  CLRF   03
1484:  MOVF   x1B,W
1486:  ADDLW  1C
1488:  MOVWF  FE9
148A:  MOVLW  01
148C:  ADDWFC 03,W
148E:  MOVWF  FEA
1490:  MOVF   FEF,W
1492:  SUBLW  4A
1494:  BNZ   14E0
.................... 		if ( 'A'==buff[i+1] )
1496:  MOVLW  01
1498:  ADDWF  x1B,W
149A:  CLRF   03
149C:  ADDLW  1C
149E:  MOVWF  FE9
14A0:  MOVLW  01
14A2:  ADDWFC 03,W
14A4:  MOVWF  FEA
14A6:  MOVF   FEF,W
14A8:  SUBLW  41
14AA:  BNZ   14B6
.................... 			current.compile_month=1;
14AC:  MOVLW  01
14AE:  MOVLB  0
14B0:  MOVWF  xCC
14B2:  BRA    14DC
14B4:  MOVLB  1
.................... 		else if ( 'N'==buff[i+2] )
14B6:  MOVLW  02
14B8:  ADDWF  x1B,W
14BA:  CLRF   03
14BC:  ADDLW  1C
14BE:  MOVWF  FE9
14C0:  MOVLW  01
14C2:  ADDWFC 03,W
14C4:  MOVWF  FEA
14C6:  MOVF   FEF,W
14C8:  SUBLW  4E
14CA:  BNZ   14D6
.................... 			current.compile_month=6;
14CC:  MOVLW  06
14CE:  MOVLB  0
14D0:  MOVWF  xCC
14D2:  BRA    14DC
14D4:  MOVLB  1
.................... 		else
.................... 			current.compile_month=7;
14D6:  MOVLW  07
14D8:  MOVLB  0
14DA:  MOVWF  xCC
.................... 	} else if ( 'A'==buff[i+0] ) {
14DC:  BRA    15F6
14DE:  MOVLB  1
14E0:  CLRF   03
14E2:  MOVF   x1B,W
14E4:  ADDLW  1C
14E6:  MOVWF  FE9
14E8:  MOVLW  01
14EA:  ADDWFC 03,W
14EC:  MOVWF  FEA
14EE:  MOVF   FEF,W
14F0:  SUBLW  41
14F2:  BNZ   151E
.................... 		if ( 'P'==buff[i+1] )
14F4:  MOVLW  01
14F6:  ADDWF  x1B,W
14F8:  CLRF   03
14FA:  ADDLW  1C
14FC:  MOVWF  FE9
14FE:  MOVLW  01
1500:  ADDWFC 03,W
1502:  MOVWF  FEA
1504:  MOVF   FEF,W
1506:  SUBLW  50
1508:  BNZ   1514
.................... 			current.compile_month=4;
150A:  MOVLW  04
150C:  MOVLB  0
150E:  MOVWF  xCC
1510:  BRA    151A
1512:  MOVLB  1
.................... 		else
.................... 			current.compile_month=8;
1514:  MOVLW  08
1516:  MOVLB  0
1518:  MOVWF  xCC
.................... 	} else if ( 'M'==buff[i+0] ) {
151A:  BRA    15F6
151C:  MOVLB  1
151E:  CLRF   03
1520:  MOVF   x1B,W
1522:  ADDLW  1C
1524:  MOVWF  FE9
1526:  MOVLW  01
1528:  ADDWFC 03,W
152A:  MOVWF  FEA
152C:  MOVF   FEF,W
152E:  SUBLW  4D
1530:  BNZ   155C
.................... 		if ( 'R'==buff[i+2] )
1532:  MOVLW  02
1534:  ADDWF  x1B,W
1536:  CLRF   03
1538:  ADDLW  1C
153A:  MOVWF  FE9
153C:  MOVLW  01
153E:  ADDWFC 03,W
1540:  MOVWF  FEA
1542:  MOVF   FEF,W
1544:  SUBLW  52
1546:  BNZ   1552
.................... 			current.compile_month=3;
1548:  MOVLW  03
154A:  MOVLB  0
154C:  MOVWF  xCC
154E:  BRA    1558
1550:  MOVLB  1
.................... 		else
.................... 			current.compile_month=5;
1552:  MOVLW  05
1554:  MOVLB  0
1556:  MOVWF  xCC
.................... 	} else if ( 'F'==buff[i+0] ) {
1558:  BRA    15F6
155A:  MOVLB  1
155C:  CLRF   03
155E:  MOVF   x1B,W
1560:  ADDLW  1C
1562:  MOVWF  FE9
1564:  MOVLW  01
1566:  ADDWFC 03,W
1568:  MOVWF  FEA
156A:  MOVF   FEF,W
156C:  SUBLW  46
156E:  BNZ   157A
.................... 		current.compile_month=2;
1570:  MOVLW  02
1572:  MOVLB  0
1574:  MOVWF  xCC
.................... 	} else if ( 'S'==buff[i+0] ) {
1576:  BRA    15F6
1578:  MOVLB  1
157A:  CLRF   03
157C:  MOVF   x1B,W
157E:  ADDLW  1C
1580:  MOVWF  FE9
1582:  MOVLW  01
1584:  ADDWFC 03,W
1586:  MOVWF  FEA
1588:  MOVF   FEF,W
158A:  SUBLW  53
158C:  BNZ   1598
.................... 		current.compile_month=9;
158E:  MOVLW  09
1590:  MOVLB  0
1592:  MOVWF  xCC
.................... 	} else if ( 'O'==buff[i+0] ) {
1594:  BRA    15F6
1596:  MOVLB  1
1598:  CLRF   03
159A:  MOVF   x1B,W
159C:  ADDLW  1C
159E:  MOVWF  FE9
15A0:  MOVLW  01
15A2:  ADDWFC 03,W
15A4:  MOVWF  FEA
15A6:  MOVF   FEF,W
15A8:  SUBLW  4F
15AA:  BNZ   15B6
.................... 		current.compile_month=10;
15AC:  MOVLW  0A
15AE:  MOVLB  0
15B0:  MOVWF  xCC
.................... 	} else if ( 'N'==buff[i+0] ) {
15B2:  BRA    15F6
15B4:  MOVLB  1
15B6:  CLRF   03
15B8:  MOVF   x1B,W
15BA:  ADDLW  1C
15BC:  MOVWF  FE9
15BE:  MOVLW  01
15C0:  ADDWFC 03,W
15C2:  MOVWF  FEA
15C4:  MOVF   FEF,W
15C6:  SUBLW  4E
15C8:  BNZ   15D4
.................... 		current.compile_month=11;
15CA:  MOVLW  0B
15CC:  MOVLB  0
15CE:  MOVWF  xCC
.................... 	} else if ( 'D'==buff[i+0] ) {
15D0:  BRA    15F6
15D2:  MOVLB  1
15D4:  CLRF   03
15D6:  MOVF   x1B,W
15D8:  ADDLW  1C
15DA:  MOVWF  FE9
15DC:  MOVLW  01
15DE:  ADDWFC 03,W
15E0:  MOVWF  FEA
15E2:  MOVF   FEF,W
15E4:  SUBLW  44
15E6:  BNZ   15F2
.................... 		current.compile_month=12;
15E8:  MOVLW  0C
15EA:  MOVLB  0
15EC:  MOVWF  xCC
.................... 	} else {
15EE:  BRA    15F6
15F0:  MOVLB  1
.................... 		/* error parsing, shouldn't happen */
.................... 		current.compile_month=255;
15F2:  MOVLB  0
15F4:  SETF   xCC
.................... 	}
.................... 	current.compile_year =(buff[i+4]-'0')*10;
15F6:  MOVLW  04
15F8:  MOVLB  1
15FA:  ADDWF  x1B,W
15FC:  CLRF   03
15FE:  ADDLW  1C
1600:  MOVWF  FE9
1602:  MOVLW  01
1604:  ADDWFC 03,W
1606:  MOVWF  FEA
1608:  MOVLW  30
160A:  SUBWF  FEF,W
160C:  MULLW  0A
160E:  MOVFF  FF3,CB
1612:  MOVLB  0
.................... 	current.compile_year+=(buff[i+5]-'0');
1614:  MOVLW  05
1616:  MOVLB  1
1618:  ADDWF  x1B,W
161A:  CLRF   03
161C:  ADDLW  1C
161E:  MOVWF  FE9
1620:  MOVLW  01
1622:  ADDWFC 03,W
1624:  MOVWF  FEA
1626:  MOVLW  30
1628:  SUBWF  FEF,W
162A:  MOVLB  0
162C:  ADDWF  xCB,F
.................... 
.................... 
.................... 	/* one periodic interrupt @ 1mS. Generated from system 16 MHz clock */
.................... 	/* prescale=16, match=249, postscale=1. Match is 249 because when match occurs, one cycle is lost */
.................... 	setup_timer_2(T2_DIV_BY_16,249,1);
162E:  MOVLW  00
1630:  IORLW  06
1632:  MOVWF  FCA
1634:  MOVLW  F9
1636:  MOVWF  FCB
.................... 
.................... 	enable_interrupts(INT_TIMER2);
1638:  BSF    F9D.1
.................... 
.................... 	/* set I2C slave address, which is always an even number */
.................... 	i2c_slaveaddr(STREAM_SLAVE,0x3e + (read_dip_switch()<<1) );
163A:  BRA    1300
163C:  BCF    FD8.0
163E:  RLCF   01,W
1640:  ADDLW  3E
1642:  MOVLB  1
1644:  MOVWF  FC8
1646:  MOVLB  0
1648:  GOTO   37A2 (RETURN)
.................... }
.................... 
.................... 
.................... void main(void) {
*
3710:  CLRF   FF8
3712:  BCF    FD0.7
3714:  BSF    07.7
3716:  BSF    F93.6
3718:  BSF    F93.4
371A:  CLRF   FC8
371C:  MOVLW  36
371E:  MOVWF  FC6
3720:  BSF    FC5.0
3722:  BSF    FC5.7
3724:  CLRF   1A
3726:  BSF    FB8.3
3728:  MOVLW  44
372A:  MOVWF  FAF
372C:  MOVLW  00
372E:  MOVWF  FB0
3730:  MOVLW  A6
3732:  MOVWF  FAC
3734:  MOVLW  90
3736:  MOVWF  FAB
3738:  MOVLB  1
373A:  CLRF   x12
373C:  CLRF   x11
373E:  MOVLW  00
3740:  MOVWF  F7E
3742:  BCF    FC1.0
3744:  BCF    FC1.1
3746:  BCF    FC1.2
3748:  BCF    FC1.3
374A:  MOVWF  F7F
374C:  CLRF   F6C
374E:  CLRF   F6B
3750:  CLRF   F6D
3752:  BRA    375E
3754:  DATA F6,40
3756:  DATA 1B,00
3758:  DATA 07,41
375A:  DATA 13,00
375C:  DATA 00,00
375E:  MOVLW  00
3760:  MOVWF  FF8
3762:  MOVLW  37
3764:  MOVWF  FF7
3766:  MOVLW  54
3768:  MOVWF  FF6
376A:  TBLRD*+
376C:  MOVF   FF5,W
376E:  MOVWF  00
3770:  XORLW  00
3772:  BZ    379A
3774:  TBLRD*+
3776:  MOVF   FF5,W
3778:  MOVWF  01
377A:  BTFSC  FE8.7
377C:  BRA    3788
377E:  ANDLW  3F
3780:  MOVWF  FEA
3782:  TBLRD*+
3784:  MOVFF  FF5,FE9
3788:  BTFSC  01.6
378A:  TBLRD*+
378C:  BTFSS  01.6
378E:  TBLRD*+
3790:  MOVFF  FF5,FEE
3794:  DCFSNZ 00,F
3796:  BRA    376A
3798:  BRA    378C
379A:  CLRF   FF8
.................... 	int8 i;
.................... 
.................... 	init();
379C:  MOVLB  0
379E:  GOTO   1372
.................... 
.................... 	/* force off both contactors */
.................... 	timers.contactor[0]=1;
37A2:  MOVLW  01
37A4:  MOVWF  xD6
.................... 	timers.contactor[1]=1;
37A6:  MOVWF  xD7
.................... 	contactor_off(0);
37A8:  MOVLB  1
37AA:  CLRF   x1E
37AC:  MOVLB  0
37AE:  CALL   164C
.................... 	contactor_off(1);
37B2:  MOVLW  01
37B4:  MOVLB  1
37B6:  MOVWF  x1E
37B8:  MOVLB  0
37BA:  CALL   164C
.................... 
.................... 
.................... 	/* read parameters from EEPROM and write defaults if CRC doesn't match */
.................... 	read_param_file();
37BE:  GOTO   1B18
.................... 
.................... 
.................... 	/* flash on startup */
.................... 	for ( i=0 ; i<5 ; i++ ) {
37C2:  MOVLB  1
37C4:  CLRF   x1A
37C6:  MOVF   x1A,W
37C8:  SUBLW  04
37CA:  BNC   37F2
.................... 		restart_wdt();
37CC:  CLRWDT
.................... 		output_high(LED_A);
37CE:  BCF    F94.1
37D0:  BSF    F8B.1
.................... 		delay_ms(200);
37D2:  MOVLW  C8
37D4:  MOVWF  x28
37D6:  MOVLB  0
37D8:  CALL   12D6
.................... 		output_low(LED_A);
37DC:  BCF    F94.1
37DE:  BCF    F8B.1
.................... 		delay_ms(200);
37E0:  MOVLW  C8
37E2:  MOVLB  1
37E4:  MOVWF  x28
37E6:  MOVLB  0
37E8:  CALL   12D6
37EC:  MOVLB  1
37EE:  INCF   x1A,F
37F0:  BRA    37C6
.................... 	}
.................... 
.................... 	fprintf(STREAM_FTDI,"# dcswc_module_latching_contactor %s\r\n# ",__DATE__);
37F2:  MOVLW  2A
37F4:  MOVWF  FF6
37F6:  MOVLW  12
37F8:  MOVWF  FF7
37FA:  MOVLW  22
37FC:  MOVWF  x20
37FE:  MOVLB  0
3800:  CALL   1B5E
3804:  MOVLW  54
3806:  MOVWF  FF6
3808:  MOVLW  12
380A:  MOVWF  FF7
380C:  CALL   1B88
3810:  MOVLW  4E
3812:  MOVWF  FF6
3814:  MOVLW  12
3816:  MOVWF  FF7
3818:  MOVLW  04
381A:  MOVLB  1
381C:  MOVWF  x20
381E:  MOVLB  0
3820:  CALL   1B5E
.................... 	switch ( restart_cause ) {
3824:  MOVLW  07
3826:  SUBWF  00,W
3828:  BZ    384E
382A:  MOVLW  0B
382C:  SUBWF  00,W
382E:  BZ    385C
3830:  MOVLW  0F
3832:  SUBWF  00,W
3834:  BZ    386A
3836:  MOVLW  0C
3838:  SUBWF  00,W
383A:  BZ    3878
383C:  MOVLW  0E
383E:  SUBWF  00,W
3840:  BZ    3886
3842:  MOVLW  03
3844:  SUBWF  00,W
3846:  BZ    3894
3848:  MOVF   00,F
384A:  BZ    38A2
384C:  BRA    38B0
.................... 		case WDT_TIMEOUT:       fprintf(STREAM_FTDI,"WDT TIMEOUT"); break;
384E:  MOVLW  5E
3850:  MOVWF  FF6
3852:  MOVLW  12
3854:  MOVWF  FF7
3856:  CALL   1B88
385A:  BRA    38BC
.................... 		case MCLR_FROM_SLEEP:   fprintf(STREAM_FTDI,"MCLR FROM SLEEP"); break;
385C:  MOVLW  6A
385E:  MOVWF  FF6
3860:  MOVLW  12
3862:  MOVWF  FF7
3864:  CALL   1B88
3868:  BRA    38BC
.................... 		case MCLR_FROM_RUN:     fprintf(STREAM_FTDI,"MCLR FROM RUN"); break;
386A:  MOVLW  7A
386C:  MOVWF  FF6
386E:  MOVLW  12
3870:  MOVWF  FF7
3872:  CALL   1B88
3876:  BRA    38BC
.................... 		case NORMAL_POWER_UP:   fprintf(STREAM_FTDI,"NORMAL POWER UP"); break;
3878:  MOVLW  88
387A:  MOVWF  FF6
387C:  MOVLW  12
387E:  MOVWF  FF7
3880:  CALL   1B88
3884:  BRA    38BC
.................... 		case BROWNOUT_RESTART:  fprintf(STREAM_FTDI,"BROWNOUT RESTART"); break;
3886:  MOVLW  98
3888:  MOVWF  FF6
388A:  MOVLW  12
388C:  MOVWF  FF7
388E:  CALL   1B88
3892:  BRA    38BC
.................... 		case WDT_FROM_SLEEP:    fprintf(STREAM_FTDI,"WDT FROM SLEEP"); break;
3894:  MOVLW  AA
3896:  MOVWF  FF6
3898:  MOVLW  12
389A:  MOVWF  FF7
389C:  CALL   1B88
38A0:  BRA    38BC
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_FTDI,"RESET INSTRUCTION"); break;
38A2:  MOVLW  BA
38A4:  MOVWF  FF6
38A6:  MOVLW  12
38A8:  MOVWF  FF7
38AA:  CALL   1B88
38AE:  BRA    38BC
.................... 		default:                fprintf(STREAM_FTDI,"UNKNOWN!");
38B0:  MOVLW  CC
38B2:  MOVWF  FF6
38B4:  MOVLW  12
38B6:  MOVWF  FF7
38B8:  CALL   1B88
.................... 	}
.................... 	fprintf(STREAM_FTDI,"\r\n");
38BC:  MOVLW  0D
38BE:  BTFSS  F9E.4
38C0:  BRA    38BE
38C2:  MOVWF  FAD
38C4:  MOVLW  0A
38C6:  BTFSS  F9E.4
38C8:  BRA    38C6
38CA:  MOVWF  FAD
.................... 
.................... 	enable_interrupts(GLOBAL);
38CC:  MOVLW  C0
38CE:  IORWF  FF2,F
.................... 
.................... 	/* Prime ADC filter */
.................... 	for ( i=0 ; i<30 ; i++ ) {
38D0:  MOVLB  1
38D2:  CLRF   x1A
38D4:  MOVF   x1A,W
38D6:  SUBLW  1D
38D8:  BNC   38E6
.................... 		adc_update();
38DA:  MOVLB  0
38DC:  CALL   1BAA
38E0:  MOVLB  1
38E2:  INCF   x1A,F
38E4:  BRA    38D4
.................... 	}
.................... 
.................... 
.................... 	/* enable I2C slave interrupt */
.................... 	enable_interrupts(INT_SSP);
38E6:  BSF    F9D.3
.................... 
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
38E8:  CLRWDT
.................... 
.................... 		if ( timers.now_millisecond ) {
38EA:  MOVLB  0
38EC:  BTFSS  xCF.2
38EE:  BRA    38F4
.................... 			periodic_millisecond();
38F0:  GOTO   2C64
.................... 		}
.................... 
.................... 		if ( kbhit() ) {
38F4:  BTFSS  F9E.5
38F6:  BRA    38FE
.................... 			getc();
38F8:  GOTO   2E42
.................... 			timers.now_debug_dump=1;
38FC:  BSF    xCF.5
.................... 		}
.................... 
.................... 		if ( timers.now_debug_dump ) {
38FE:  BTFSS  xCF.5
3900:  BRA    3908
.................... 			timers.now_debug_dump=0;
3902:  BCF    xCF.5
.................... 
.................... 			debug_dump();
3904:  GOTO   2FFC
.................... 		}
.................... 
.................... 		if ( timers.now_adc_sample ) {
3908:  BTFSS  xCF.0
390A:  BRA    3912
.................... 			timers.now_adc_sample=0;
390C:  BCF    xCF.0
.................... 			adc_update();
390E:  CALL   1BAA
.................... 		}
.................... 
.................... 		if ( timers.now_write_config ) {
3912:  BTFSS  xCF.3
3914:  BRA    391C
.................... 			timers.now_write_config=0;
3916:  BCF    xCF.3
.................... 			write_param_file();
3918:  CALL   17BE
.................... 		}
.................... 		if ( timers.now_reset_config ) {
391C:  BTFSS  xCF.4
391E:  BRA    3926
.................... 			timers.now_reset_config=0;
3920:  BCF    xCF.4
.................... 			write_default_param_file();
3922:  CALL   180A
.................... 		}
3926:  MOVLB  1
3928:  BRA    38E8
.................... 
.................... 
.................... 	}
.................... 
.................... 
.................... }
392A:  SLEEP 

Configuration Fuses:
   Word  1: 0800   INTRC_IO NOPLLEN NOPCLKEN NOFCMEN NOIESO
   Word  2: 0F07   NOPUT BROWNOUT BORV30 WDT WDT128
   Word  3: 0000   NOHFOFST NOMCLR
   Word  4: 0081   STVREN NOLVP BBSIZ1K NOXINST NODEBUG
   Word  5: C003   NOPROTECT NOCPB NOCPD
   Word  6: E003   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 4003   NOEBTR NOEBTRB

ROM data:
F00000: 00 00 40 00                                        ..@.
