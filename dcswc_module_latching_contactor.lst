CCS PCH C Compiler, Version 5.090, 49113               05-Feb-22 15:12

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\dcswc_module_latching_contactor\dcswc_module_latching_contactor.lst

               ROM used:   10224 bytes (66%)
                           Largest free fragment is 5328
               RAM used:   276 (54%) at main() level
                           321 (63%) worst case
               Stack used: 4 locations (2 in main + 2 for interrupts)
               Stack size: 30

0000:  GOTO   20EA
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   00D4
0060:  BTFSS  F9D.3
0062:  GOTO   006C
0066:  BTFSC  F9E.3
0068:  GOTO   09C4
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include "dcswc_module_latching_contactor.h"
.................... #include <18F14K22.h>
.................... //////////// Standard Header file for the PIC18F14K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F14K22
00BA:  CLRF   FF7
00BC:  ADDLW  CA
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  RETURN 0
00CA:  DATA 35,2D
00CC:  DATA 46,65
00CE:  DATA 62,2D
00D0:  DATA 32,32
00D2:  DATA 00,00
*
0A96:  DATA 23,20
0A98:  DATA 64,63
0A9A:  DATA 73,77
0A9C:  DATA 63,5F
0A9E:  DATA 6D,6F
0AA0:  DATA 64,75
0AA2:  DATA 6C,65
0AA4:  DATA 5F,6C
0AA6:  DATA 61,74
0AA8:  DATA 63,68
0AAA:  DATA 69,6E
0AAC:  DATA 67,5F
0AAE:  DATA 63,6F
0AB0:  DATA 6E,74
0AB2:  DATA 61,63
0AB4:  DATA 74,6F
0AB6:  DATA 72,20
0AB8:  DATA 25,73
0ABA:  DATA 0D,0A
0ABC:  DATA 23,20
0ABE:  DATA 00,00
0AC0:  DATA 35,2D
0AC2:  DATA 46,65
0AC4:  DATA 62,2D
0AC6:  DATA 32,32
0AC8:  DATA 00,00
0ACA:  DATA 57,44
0ACC:  DATA 54,20
0ACE:  DATA 54,49
0AD0:  DATA 4D,45
0AD2:  DATA 4F,55
0AD4:  DATA 54,00
0AD6:  DATA 4D,43
0AD8:  DATA 4C,52
0ADA:  DATA 20,46
0ADC:  DATA 52,4F
0ADE:  DATA 4D,20
0AE0:  DATA 53,4C
0AE2:  DATA 45,45
0AE4:  DATA 50,00
0AE6:  DATA 4D,43
0AE8:  DATA 4C,52
0AEA:  DATA 20,46
0AEC:  DATA 52,4F
0AEE:  DATA 4D,20
0AF0:  DATA 52,55
0AF2:  DATA 4E,00
0AF4:  DATA 4E,4F
0AF6:  DATA 52,4D
0AF8:  DATA 41,4C
0AFA:  DATA 20,50
0AFC:  DATA 4F,57
0AFE:  DATA 45,52
0B00:  DATA 20,55
0B02:  DATA 50,00
0B04:  DATA 42,52
0B06:  DATA 4F,57
0B08:  DATA 4E,4F
0B0A:  DATA 55,54
0B0C:  DATA 20,52
0B0E:  DATA 45,53
0B10:  DATA 54,41
0B12:  DATA 52,54
0B14:  DATA 00,00
0B16:  DATA 57,44
0B18:  DATA 54,20
0B1A:  DATA 46,52
0B1C:  DATA 4F,4D
0B1E:  DATA 20,53
0B20:  DATA 4C,45
0B22:  DATA 45,50
0B24:  DATA 00,00
0B26:  DATA 52,45
0B28:  DATA 53,45
0B2A:  DATA 54,20
0B2C:  DATA 49,4E
0B2E:  DATA 53,54
0B30:  DATA 52,55
0B32:  DATA 43,54
0B34:  DATA 49,4F
0B36:  DATA 4E,00
0B38:  DATA 55,4E
0B3A:  DATA 4B,4E
0B3C:  DATA 4F,57
0B3E:  DATA 4E,21
0B40:  DATA 00,00
0B42:  DATA 23,20
0B44:  DATA 72,65
0B46:  DATA 61,64
0B48:  DATA 5F,64
0B4A:  DATA 69,70
0B4C:  DATA 5F,73
0B4E:  DATA 77,69
0B50:  DATA 74,63
0B52:  DATA 68,28
0B54:  DATA 29,3D
0B56:  DATA 25,75
0B58:  DATA 0D,0A
0B5A:  DATA 00,00
0B5C:  DATA 23,20
0B5E:  DATA 20,20
0B60:  DATA 20,76
0B62:  DATA 69,6E
0B64:  DATA 20,61
0B66:  DATA 64,63
0B68:  DATA 3D,25
0B6A:  DATA 6C,75
0B6C:  DATA 0D,0A
0B6E:  DATA 00,00
0B70:  DATA 23,20
0B72:  DATA 20,20
0B74:  DATA 74,65
0B76:  DATA 6D,70
0B78:  DATA 20,61
0B7A:  DATA 64,63
0B7C:  DATA 3D,25
0B7E:  DATA 6C,75
0B80:  DATA 0D,0A
0B82:  DATA 00,00
0B84:  DATA 23,20
0B86:  DATA 64,69
0B88:  DATA 70,20
0B8A:  DATA 73,77
0B8C:  DATA 20,61
0B8E:  DATA 64,63
0B90:  DATA 3D,25
0B92:  DATA 6C,75
0B94:  DATA 0D,0A
0B96:  DATA 00,00
0B98:  DATA 23,20
0B9A:  DATA 63,68
0B9C:  DATA 61,6E
0B9E:  DATA 6E,65
0BA0:  DATA 6C,5B
0BA2:  DATA 25,75
0BA4:  DATA 5D,0D
0BA6:  DATA 0A,00
0BA8:  DATA 23,20
0BAA:  DATA 20,20
0BAC:  DATA 20,20
0BAE:  DATA 20,20
0BB0:  DATA 20,20
0BB2:  DATA 20,20
0BB4:  DATA 20,20
0BB6:  DATA 20,20
0BB8:  DATA 20,20
0BBA:  DATA 20,20
0BBC:  DATA 20,20
0BBE:  DATA 20,20
0BC0:  DATA 20,73
0BC2:  DATA 74,61
0BC4:  DATA 74,65
0BC6:  DATA 3D,30
0BC8:  DATA 78,25
0BCA:  DATA 30,32
0BCC:  DATA 78,0D
0BCE:  DATA 0A,00
0BD0:  DATA 23,20
0BD2:  DATA 20,20
0BD4:  DATA 20,20
0BD6:  DATA 20,20
0BD8:  DATA 20,20
0BDA:  DATA 20,20
0BDC:  DATA 63,6F
0BDE:  DATA 6D,6D
0BE0:  DATA 61,6E
0BE2:  DATA 64,5F
0BE4:  DATA 6F,6E
0BE6:  DATA 5F,73
0BE8:  DATA 65,63
0BEA:  DATA 6F,6E
0BEC:  DATA 64,73
0BEE:  DATA 3D,25
0BF0:  DATA 6C,75
0BF2:  DATA 0D,0A
0BF4:  DATA 00,00
0BF6:  DATA 23,20
0BF8:  DATA 20,20
0BFA:  DATA 20,20
0BFC:  DATA 20,63
0BFE:  DATA 6F,6D
0C00:  DATA 6D,61
0C02:  DATA 6E,64
0C04:  DATA 5F,6F
0C06:  DATA 6E,5F
0C08:  DATA 68,6F
0C0A:  DATA 6C,64
0C0C:  DATA 5F,73
0C0E:  DATA 65,63
0C10:  DATA 6F,6E
0C12:  DATA 64,73
0C14:  DATA 3D,25
0C16:  DATA 6C,75
0C18:  DATA 0D,0A
0C1A:  DATA 00,00
0C1C:  DATA 23,20
0C1E:  DATA 20,20
0C20:  DATA 20,20
0C22:  DATA 20,20
0C24:  DATA 20,20
0C26:  DATA 20,63
0C28:  DATA 6F,6D
0C2A:  DATA 6D,61
0C2C:  DATA 6E,64
0C2E:  DATA 5F,6F
0C30:  DATA 66,66
0C32:  DATA 5F,73
0C34:  DATA 65,63
0C36:  DATA 6F,6E
0C38:  DATA 64,73
0C3A:  DATA 3D,25
0C3C:  DATA 6C,75
0C3E:  DATA 0D,0A
0C40:  DATA 00,00
0C42:  DATA 23,20
0C44:  DATA 20,20
0C46:  DATA 20,20
0C48:  DATA 63,6F
0C4A:  DATA 6D,6D
0C4C:  DATA 61,6E
0C4E:  DATA 64,5F
0C50:  DATA 6F,66
0C52:  DATA 66,5F
0C54:  DATA 68,6F
0C56:  DATA 6C,64
0C58:  DATA 5F,73
0C5A:  DATA 65,63
0C5C:  DATA 6F,6E
0C5E:  DATA 64,73
0C60:  DATA 3D,25
0C62:  DATA 6C,75
0C64:  DATA 0D,0A
0C66:  DATA 00,00
0C68:  DATA 23,20
0C6A:  DATA 6C,76
0C6C:  DATA 64,5F
0C6E:  DATA 64,69
0C70:  DATA 73,63
0C72:  DATA 6F,6E
0C74:  DATA 6E,65
0C76:  DATA 63,74
0C78:  DATA 5F,64
0C7A:  DATA 65,6C
0C7C:  DATA 61,79
0C7E:  DATA 5F,73
0C80:  DATA 65,63
0C82:  DATA 6F,6E
0C84:  DATA 64,73
0C86:  DATA 3D,25
0C88:  DATA 6C,75
0C8A:  DATA 0D,0A
0C8C:  DATA 00,00
0C8E:  DATA 23,20
0C90:  DATA 20,6C
0C92:  DATA 76,64
0C94:  DATA 5F,72
0C96:  DATA 65,63
0C98:  DATA 6F,6E
0C9A:  DATA 6E,65
0C9C:  DATA 63,74
0C9E:  DATA 5F,64
0CA0:  DATA 65,6C
0CA2:  DATA 61,79
0CA4:  DATA 5F,73
0CA6:  DATA 65,63
0CA8:  DATA 6F,6E
0CAA:  DATA 64,73
0CAC:  DATA 3D,25
0CAE:  DATA 75,0D
0CB0:  DATA 0A,00
0CB2:  DATA 23,20
0CB4:  DATA 68,76
0CB6:  DATA 64,5F
0CB8:  DATA 64,69
0CBA:  DATA 73,63
0CBC:  DATA 6F,6E
0CBE:  DATA 6E,65
0CC0:  DATA 63,74
0CC2:  DATA 5F,64
0CC4:  DATA 65,6C
0CC6:  DATA 61,79
0CC8:  DATA 5F,73
0CCA:  DATA 65,63
0CCC:  DATA 6F,6E
0CCE:  DATA 64,73
0CD0:  DATA 3D,25
0CD2:  DATA 6C,75
0CD4:  DATA 0D,0A
0CD6:  DATA 00,00
0CD8:  DATA 23,20
0CDA:  DATA 20,68
0CDC:  DATA 76,64
0CDE:  DATA 5F,72
0CE0:  DATA 65,63
0CE2:  DATA 6F,6E
0CE4:  DATA 6E,65
0CE6:  DATA 63,74
0CE8:  DATA 5F,64
0CEA:  DATA 65,6C
0CEC:  DATA 61,79
0CEE:  DATA 5F,73
0CF0:  DATA 65,63
0CF2:  DATA 6F,6E
0CF4:  DATA 64,73
0CF6:  DATA 3D,25
0CF8:  DATA 75,0D
0CFA:  DATA 0A,00
*
11E4:  TBLRD*+
11E6:  MOVFF  FF6,115
11EA:  MOVFF  FF7,116
11EE:  MOVF   FF5,W
11F0:  BTFSS  F9E.4
11F2:  BRA    11F0
11F4:  MOVWF  FAD
11F6:  MOVFF  115,FF6
11FA:  MOVFF  116,FF7
11FE:  MOVLB  1
1200:  DECFSZ x14,F
1202:  BRA    1206
1204:  BRA    120A
1206:  MOVLB  0
1208:  BRA    11E4
120A:  MOVLB  0
120C:  RETURN 0
120E:  TBLRD*+
1210:  MOVF   FF5,F
1212:  BZ    122E
1214:  MOVFF  FF6,111
1218:  MOVFF  FF7,112
121C:  MOVF   FF5,W
121E:  BTFSS  F9E.4
1220:  BRA    121E
1222:  MOVWF  FAD
1224:  MOVFF  111,FF6
1228:  MOVFF  112,FF7
122C:  BRA    120E
122E:  RETURN 0
*
1EE6:  MOVLB  1
1EE8:  MOVF   x15,W
1EEA:  CLRF   01
1EEC:  SUBWF  x14,W
1EEE:  BC    1EF6
1EF0:  MOVFF  114,00
1EF4:  BRA    1F0E
1EF6:  CLRF   00
1EF8:  MOVLW  08
1EFA:  MOVWF  x16
1EFC:  RLCF   x14,F
1EFE:  RLCF   00,F
1F00:  MOVF   x15,W
1F02:  SUBWF  00,W
1F04:  BTFSC  FD8.0
1F06:  MOVWF  00
1F08:  RLCF   01,F
1F0A:  DECFSZ x16,F
1F0C:  BRA    1EFC
1F0E:  MOVLB  0
1F10:  RETURN 0
1F12:  MOVF   01,W
1F14:  MOVFF  112,114
1F18:  MOVLW  64
1F1A:  MOVLB  1
1F1C:  MOVWF  x15
1F1E:  MOVLB  0
1F20:  RCALL  1EE6
1F22:  MOVFF  00,112
1F26:  MOVF   01,W
1F28:  MOVLW  30
1F2A:  BNZ   1F3C
1F2C:  MOVLB  1
1F2E:  BTFSS  x13.1
1F30:  BRA    1F4E
1F32:  BTFSC  x13.3
1F34:  BRA    1F4E
1F36:  BTFSC  x13.4
1F38:  MOVLW  20
1F3A:  BRA    1F44
1F3C:  MOVLB  1
1F3E:  BCF    x13.3
1F40:  BCF    x13.4
1F42:  BSF    x13.0
1F44:  ADDWF  01,F
1F46:  MOVF   01,W
1F48:  BTFSS  F9E.4
1F4A:  BRA    1F48
1F4C:  MOVWF  FAD
1F4E:  MOVFF  112,114
1F52:  MOVLW  0A
1F54:  MOVWF  x15
1F56:  MOVLB  0
1F58:  RCALL  1EE6
1F5A:  MOVFF  00,112
1F5E:  MOVF   01,W
1F60:  MOVLW  30
1F62:  BNZ   1F74
1F64:  MOVLB  1
1F66:  BTFSC  x13.3
1F68:  BRA    1F80
1F6A:  BTFSS  x13.0
1F6C:  BRA    1F80
1F6E:  BTFSC  x13.4
1F70:  MOVLW  20
1F72:  MOVLB  0
1F74:  ADDWF  01,F
1F76:  MOVF   01,W
1F78:  BTFSS  F9E.4
1F7A:  BRA    1F78
1F7C:  MOVWF  FAD
1F7E:  MOVLB  1
1F80:  MOVLW  30
1F82:  ADDWF  x12,F
1F84:  MOVF   x12,W
1F86:  BTFSS  F9E.4
1F88:  BRA    1F86
1F8A:  MOVWF  FAD
1F8C:  MOVLB  0
1F8E:  RETURN 0
1F90:  MOVFF  FEA,11B
1F94:  MOVFF  FE9,11A
1F98:  MOVLB  1
1F9A:  SWAPF  x14,W
1F9C:  IORLW  F0
1F9E:  MOVWF  x16
1FA0:  ADDWF  x16,F
1FA2:  ADDLW  E2
1FA4:  MOVWF  x17
1FA6:  ADDLW  32
1FA8:  MOVWF  x19
1FAA:  MOVF   x14,W
1FAC:  ANDLW  0F
1FAE:  ADDWF  x17,F
1FB0:  ADDWF  x17,F
1FB2:  ADDWF  x19,F
1FB4:  ADDLW  E9
1FB6:  MOVWF  x18
1FB8:  ADDWF  x18,F
1FBA:  ADDWF  x18,F
1FBC:  SWAPF  x13,W
1FBE:  ANDLW  0F
1FC0:  ADDWF  x18,F
1FC2:  ADDWF  x19,F
1FC4:  RLCF   x18,F
1FC6:  RLCF   x19,F
1FC8:  COMF   x19,F
1FCA:  RLCF   x19,F
1FCC:  MOVF   x13,W
1FCE:  ANDLW  0F
1FD0:  ADDWF  x19,F
1FD2:  RLCF   x16,F
1FD4:  MOVLW  07
1FD6:  MOVWF  x15
1FD8:  MOVLW  0A
1FDA:  DECF   x18,F
1FDC:  ADDWF  x19,F
1FDE:  BNC   1FDA
1FE0:  DECF   x17,F
1FE2:  ADDWF  x18,F
1FE4:  BNC   1FE0
1FE6:  DECF   x16,F
1FE8:  ADDWF  x17,F
1FEA:  BNC   1FE6
1FEC:  DECF   x15,F
1FEE:  ADDWF  x16,F
1FF0:  BNC   1FEC
1FF2:  MOVLW  01
1FF4:  MOVWF  FEA
1FF6:  MOVLW  15
1FF8:  MOVWF  FE9
1FFA:  MOVLW  07
1FFC:  ANDWF  x1A,W
1FFE:  BCF    x1A.6
2000:  ADDWF  FE9,F
2002:  MOVLW  00
2004:  ADDWFC FEA,F
2006:  MOVF   FE9,W
2008:  SUBLW  19
200A:  BNZ   2012
200C:  DECFSZ FEA,W
200E:  BRA    2012
2010:  BSF    x1A.6
2012:  MOVF   FEF,W
2014:  MOVWF  00
2016:  BNZ   2028
2018:  BTFSC  x1A.6
201A:  BRA    2028
201C:  BTFSC  x1A.4
201E:  BRA    2038
2020:  BTFSC  x1A.3
2022:  BRA    2028
2024:  MOVLW  20
2026:  BRA    202E
2028:  BSF    x1A.3
202A:  BCF    x1A.4
202C:  MOVLW  30
202E:  ADDWF  00,F
2030:  MOVF   00,W
2032:  BTFSS  F9E.4
2034:  BRA    2032
2036:  MOVWF  FAD
2038:  MOVF   FEE,W
203A:  BTFSS  x1A.6
203C:  BRA    2006
203E:  MOVLB  0
2040:  RETURN 0
2042:  MOVLB  1
2044:  BTFSC  x15.7
2046:  BRA    2068
2048:  MOVLW  0F
204A:  MOVWF  00
204C:  SWAPF  x14,W
204E:  ANDWF  00,F
2050:  MOVLW  0A
2052:  SUBWF  00,W
2054:  BC    205C
2056:  MOVLW  30
2058:  ADDWF  00,F
205A:  BRA    2060
205C:  MOVF   x15,W
205E:  ADDWF  00,F
2060:  MOVF   00,W
2062:  BTFSS  F9E.4
2064:  BRA    2062
2066:  MOVWF  FAD
2068:  MOVLW  0F
206A:  ANDWF  x14,F
206C:  MOVLW  0A
206E:  SUBWF  x14,W
2070:  BC    2076
2072:  MOVLW  30
2074:  BRA    207A
2076:  BCF    x15.7
2078:  MOVF   x15,W
207A:  ADDWF  x14,F
207C:  MOVF   x14,W
207E:  BTFSS  F9E.4
2080:  BRA    207E
2082:  MOVWF  FAD
2084:  MOVLB  0
2086:  GOTO   2472 (RETURN)
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #device *=16
.................... #use delay(clock=16MHz)
*
0CFC:  MOVLW  01
0CFE:  MOVWF  FEA
0D00:  MOVLW  33
0D02:  MOVWF  FE9
0D04:  MOVF   FEF,W
0D06:  BZ    0D24
0D08:  MOVLW  05
0D0A:  MOVWF  01
0D0C:  CLRF   00
0D0E:  DECFSZ 00,F
0D10:  BRA    0D0E
0D12:  DECFSZ 01,F
0D14:  BRA    0D0C
0D16:  MOVLW  2E
0D18:  MOVWF  00
0D1A:  DECFSZ 00,F
0D1C:  BRA    0D1A
0D1E:  BRA    0D20
0D20:  DECFSZ FEF,F
0D22:  BRA    0D08
0D24:  RETURN 0
.................... 
.................... /* hardware I2C port is slave and is connected to DCSWC bus */
.................... #use i2c(stream=STREAM_SLAVE,SLAVE, I2C1, FORCE_HW)
*
09AE:  MOVF   FC9,W
09B0:  MOVFF  137,FC9
09B4:  BSF    FC6.4
09B6:  BCF    F9E.3
09B8:  BTFSC  FC7.0
09BA:  BRA    09B8
09BC:  CLRF   01
09BE:  BTFSS  FC5.6
09C0:  INCF   01,F
09C2:  RETURN 0
.................... /* slave address set based on dip switch in init() */
.................... 
.................... 
.................... #fuses INTRC_IO
.................... #fuses NOPLLEN
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses PUT
.................... #fuses BROWNOUT
.................... #fuses WDT512
.................... #fuses NOHFOFST
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses NOLVP
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... #fuses NOPROTECT
.................... #fuses NOWRT
.................... #fuses NOWRTC 
.................... #fuses NOWRTB
.................... #fuses NOWRTD
.................... #fuses NOEBTR
.................... #fuses NOEBTRB
.................... 
.................... #use standard_io(ALL)
.................... 
.................... #use rs232(UART1,stream=STREAM_FTDI,baud=9600,errors)	
*
1ECE:  BTFSS  F9E.5
1ED0:  BRA    1ECE
1ED2:  MOVFF  FAB,1A
1ED6:  MOVFF  FAE,01
1EDA:  BTFSS  1A.1
1EDC:  BRA    1EE2
1EDE:  BCF    FAB.4
1EE0:  BSF    FAB.4
1EE2:  GOTO   22C6 (RETURN)
.................... 
.................... /* program config CRC of 0 and a serial_prefix of 'A' ... that will trigger a write default on first boot */
.................... #ROM 0xF00000 = { 0x00, 0x00, 0x40, 0x00 }
.................... 
.................... 
.................... 
.................... 
.................... #define SW_OVERRIDE_A        PIN_A5
.................... #define SW_OVERRIDE_B        PIN_A4
.................... #define BRIDGE_B_A           PIN_C5
.................... #define BRIDGE_A_B           PIN_C4
.................... #define BRIDGE_A_A           PIN_C3
.................... #define BRIDGE_B_B           PIN_C6
.................... #define AN_DIP               PIN_C7
.................... #define SER_TO_PC            PIN_B7
.................... #define AN_VTEMP             PIN_A2
.................... #define AN_IN_VOLTS          PIN_C0
.................... #define LED_A                PIN_C1
.................... #define LED_B                PIN_C2
.................... #define I2C_SDA              PIN_B4
.................... #define SER_FROM_PC          PIN_B5
.................... #define I2C_SCL              PIN_B6
.................... 
.................... 
.................... /* 
.................... Parameters are stored in EEPROM
.................... */
.................... #define PARAM_CRC_ADDRESS  0x00
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2
.................... 
.................... 
.................... 
.................... /* bit positions for a channel state byte */
.................... #define CH_STATE_BIT_FUTURE   7  /* reserved for future use */
.................... #define CH_STATE_BIT_HTD      6  /* high temperature disconnect */
.................... #define CH_STATE_BIT_LTD      5  /* low temperature disconnect */
.................... #define CH_STATE_BIT_HVD      4  /* high voltage disconnect */
.................... #define CH_STATE_BIT_LVD      3  /* low voltage disconnect */
.................... #define CH_STATE_BIT_CMD_OFF  2  /* commanded off */
.................... #define CH_STATE_BIT_CMD_ON   1  /* commanded on (takes presedence over commanded off) */
.................... #define CH_STATE_BIT_OVERRIDE 0  /* override switch */
....................       
.................... 
.................... #define ADC_SAMPLE_TICKS              20
.................... #define CONTACTOR_POWER_SAVE_MS       200 /* milliseconds for contactor be on. Must be >0 and <= 255 */
.................... 
.................... 
.................... typedef struct {
.................... 	/* command on hold time */
.................... 	int16 command_on_hold_time;
.................... 
.................... 	/* command off hold time */
.................... 	int16 command_off_hold_time;
.................... 
.................... 	/* low voltage disconnect */
.................... 	int16 lvd_disconnect_adc;
.................... 	int16 lvd_disconnect_delay;
.................... 	int16 lvd_reconnect_adc;
.................... 	int16 lvd_reconnect_delay;
.................... 
.................... 	/* high voltage disconnect */
.................... 	int16 hvd_disconnect_adc;
.................... 	int16 hvd_disconnect_delay;
.................... 	int16 hvd_reconnect_adc;
.................... 	int16 hvd_reconnect_delay;
.................... 
.................... 	/* low temperature disconnect */
.................... 	int16 ltd_disconnect_adc;
.................... 	int16 ltd_disconnect_delay;
.................... 	int16 ltd_reconnect_adc;
.................... 	int16 ltd_reconnect_delay;
.................... 
.................... 	/* high temperature disconnect */
.................... 	int16 htd_disconnect_adc;
.................... 	int16 htd_disconnect_delay;
.................... 	int16 htd_reconnect_adc;
.................... 	int16 htd_reconnect_delay;
.................... } struct_config_channel;
.................... 
.................... typedef struct {
.................... 	/* not much going on here */
.................... 	struct_config_channel ch[2];
.................... } struct_config;
.................... 
.................... 
.................... typedef struct {
.................... 	int8 state;
.................... 
.................... 	int16 command_on_seconds;			/* counts down. Off at zero. */
.................... 	int16 command_on_hold_seconds;      /* counts down. Off at zero. */
.................... 
.................... 	int16 command_off_seconds;			/* counts down. Off at zero. */
.................... 	int16 command_off_hold_seconds;     /* counts down. Off at zero. */
.................... 
.................... 	int16 lvd_disconnect_delay_seconds;	/* counts down */
.................... 	int8  lvd_reconnect_delay_seconds;	/* counts down */
.................... 
.................... 	int16 hvd_disconnect_delay_seconds;	/* counts down */
.................... 	int8  hvd_reconnect_delay_seconds;	/* counts down */
.................... 
.................... 	int16 ltd_disconnect_delay_seconds; /* counts down */
.................... 	int16 ltd_reconnect_delay_seconds;  /* counts down */
.................... 
.................... 	int16 htd_disconnect_delay_seconds; /* counts down */
.................... 	int16 htd_reconnect_delay_seconds;  /* counts down */
.................... } struct_channel;
.................... 
.................... typedef struct {
.................... 	/* circular buffer for ADC readings */
.................... 	int16 adc_buffer[3][16];
.................... 	int8  adc_buffer_index;
.................... 
.................... 	int16 sequence_number;
.................... 	int16 uptime_minutes;
.................... 	int16 interval_milliseconds;
.................... 
.................... 	int8 factory_unlocked;
.................... 
.................... 
.................... 	int8 compile_year;
.................... 	int8 compile_month;
.................... 	int8 compile_day;
.................... 
.................... 
.................... 	int8 default_params_written;
.................... } struct_current;
.................... 
.................... typedef struct {
.................... 	/* action flags */
.................... 	int1 now_adc_sample;
.................... 	int1 now_adc_reset_count;
.................... 
.................... 	int1 now_millisecond;
.................... 
.................... 	int1 now_write_config;
.................... 	int1 now_reset_config;
.................... 
.................... 	/* contactor states */
.................... 	int1 contactor_a;
.................... 	int1 contactor_b;
.................... 
.................... 	/* timers */
.................... 	int8 led_on_a;
.................... 	int8 led_on_b;
.................... 
.................... 	int8  contactor_a_powersave;        /* counts down. Off at zero. */
.................... 	int8  contactor_b_powersave;        /* counts down. Off at zero. */
.................... } struct_time_keep;
.................... 
.................... /* global structures */
.................... struct_config config={0};
.................... struct_current current={0};
.................... struct_time_keep timers={0};
.................... struct_channel channel[2]={0};
.................... 
.................... #include "adc_dcswc_module_latching_contactor.c"
.................... int16 adc_get(int8 ch) {
.................... 	int16 sum;
.................... 	int8 i;
.................... 
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */
.................... 	int16 *p;
.................... 	p = current.adc_buffer[ch];
*
00DC:  MOVLB  1
00DE:  MOVF   x39,W
00E0:  MULLW  20
00E2:  MOVF   FF3,W
00E4:  CLRF   03
00E6:  ADDLW  63
00E8:  MOVWF  x3D
00EA:  MOVLW  00
00EC:  ADDWFC 03,W
00EE:  MOVWF  x3E
.................... 
.................... 	// Calculate the mean.  This is done by summing up the
.................... 	// values and dividing by the number of elements.
.................... 	sum = 0;
00F0:  CLRF   x3B
00F2:  CLRF   x3A
.................... 	for( i = 0; i < 16 ; i++ ) {
00F4:  CLRF   x3C
00F6:  MOVF   x3C,W
00F8:  SUBLW  0F
00FA:  BNC   0126
.................... //		sum += current.adc_buffer[ch][i];
.................... 		sum += p[i];
00FC:  CLRF   03
00FE:  MOVFF  13C,02
0102:  BCF    FD8.0
0104:  RLCF   02,F
0106:  RLCF   03,F
0108:  MOVF   02,W
010A:  ADDWF  x3D,W
010C:  MOVWF  FE9
010E:  MOVF   x3E,W
0110:  ADDWFC 03,W
0112:  MOVWF  FEA
0114:  MOVFF  FEC,03
0118:  MOVF   FED,F
011A:  MOVF   FEF,W
011C:  ADDWF  x3A,F
011E:  MOVF   03,W
0120:  ADDWFC x3B,F
0122:  INCF   x3C,F
0124:  BRA    00F6
.................... 	}
.................... 
.................... 	/* divide sum by our 16 samples and round by adding 8 */
.................... 	return ( (sum+8) >> 4 );
0126:  MOVLW  08
0128:  ADDWF  x3A,W
012A:  MOVWF  x3F
012C:  MOVLW  00
012E:  ADDWFC x3B,W
0130:  MOVWF  x40
0132:  RRCF   x40,W
0134:  MOVWF  03
0136:  RRCF   x3F,W
0138:  MOVWF  02
013A:  RRCF   03,F
013C:  RRCF   02,F
013E:  RRCF   03,F
0140:  RRCF   02,F
0142:  RRCF   03,F
0144:  RRCF   02,F
0146:  MOVLW  0F
0148:  ANDWF  03,F
014A:  MOVFF  02,01
014E:  MOVFF  03,02
0152:  MOVLB  0
0154:  RETURN 0
.................... }
.................... 
.................... 
.................... void adc_update(void) {
.................... 
.................... 	/* wrap buffer around */
.................... 	current.adc_buffer_index++;
*
1230:  INCF   xC3,F
.................... 	if ( current.adc_buffer_index >= 16 )
1232:  MOVF   xC3,W
1234:  SUBLW  0F
1236:  BC    123A
.................... 		current.adc_buffer_index=0;
1238:  CLRF   xC3
.................... 
.................... 	set_adc_channel(4);
123A:  MOVLW  10
123C:  MOVWF  01
123E:  MOVF   FC2,W
1240:  ANDLW  C3
1242:  IORWF  01,W
1244:  MOVWF  FC2
.................... 	current.adc_buffer[0][current.adc_buffer_index] = read_adc();
1246:  BCF    FD8.0
1248:  RLCF   xC3,W
124A:  CLRF   03
124C:  ADDLW  63
124E:  MOVWF  FE9
1250:  MOVLW  00
1252:  ADDWFC 03,W
1254:  MOVWF  FEA
1256:  BSF    FC2.1
1258:  BTFSC  FC2.1
125A:  BRA    1258
125C:  MOVFF  FC3,FEF
1260:  MOVFF  FC4,FEC
.................... 
.................... 
.................... 	set_adc_channel(2);
1264:  MOVLW  08
1266:  MOVWF  01
1268:  MOVF   FC2,W
126A:  ANDLW  C3
126C:  IORWF  01,W
126E:  MOVWF  FC2
.................... 	delay_ms(1);
1270:  MOVLW  01
1272:  MOVLB  1
1274:  MOVWF  x33
1276:  MOVLB  0
1278:  RCALL  0CFC
.................... 	current.adc_buffer[1][current.adc_buffer_index] = read_adc();
127A:  BCF    FD8.0
127C:  RLCF   xC3,W
127E:  CLRF   03
1280:  ADDLW  83
1282:  MOVWF  FE9
1284:  MOVLW  00
1286:  ADDWFC 03,W
1288:  MOVWF  FEA
128A:  BSF    FC2.1
128C:  BTFSC  FC2.1
128E:  BRA    128C
1290:  MOVFF  FC3,FEF
1294:  MOVFF  FC4,FEC
.................... 
.................... 	set_adc_channel(9);
1298:  MOVLW  24
129A:  MOVWF  01
129C:  MOVF   FC2,W
129E:  ANDLW  C3
12A0:  IORWF  01,W
12A2:  MOVWF  FC2
.................... 	delay_ms(1);
12A4:  MOVLW  01
12A6:  MOVLB  1
12A8:  MOVWF  x33
12AA:  MOVLB  0
12AC:  RCALL  0CFC
.................... 	current.adc_buffer[2][current.adc_buffer_index] = read_adc();
12AE:  BCF    FD8.0
12B0:  RLCF   xC3,W
12B2:  CLRF   03
12B4:  ADDLW  A3
12B6:  MOVWF  FE9
12B8:  MOVLW  00
12BA:  ADDWFC 03,W
12BC:  MOVWF  FEA
12BE:  BSF    FC2.1
12C0:  BTFSC  FC2.1
12C2:  BRA    12C0
12C4:  MOVFF  FC3,FEF
12C8:  MOVFF  FC4,FEC
12CC:  RETURN 0
.................... }
.................... 
.................... #include "param_dcswc_module_latching_contactor.c"
.................... #inline
.................... char xor_crc(char oldcrc, char data) {
.................... 	return oldcrc ^ data;
*
0F76:  MOVF   x1E,W
0F78:  XORWF  x1F,W
0F7A:  MOVWF  01
*
0FC4:  MOVF   x1E,W
0FC6:  XORWF  x1F,W
0FC8:  MOVWF  01
.................... }
.................... 
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) {
*
0F0E:  MOVLB  1
0F10:  CLRF   x1A
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
0F12:  MOVFF  119,11C
0F16:  MOVF   x18,W
0F18:  BTFSC  FD8.2
0F1A:  DECF   x19,F
0F1C:  DECF   x18,F
0F1E:  MOVWF  x1B
0F20:  MOVF   x1B,F
0F22:  BNZ   0F28
0F24:  MOVF   x1C,F
0F26:  BZ    0F88
.................... 		*data = read_eeprom( address++ );
0F28:  MOVFF  117,03
0F2C:  MOVF   x16,W
0F2E:  MOVWF  FE9
0F30:  MOVFF  03,FEA
0F34:  MOVF   x15,W
0F36:  MOVWF  03
0F38:  MOVF   x14,W
0F3A:  INCF   x14,F
0F3C:  BTFSC  FD8.2
0F3E:  INCF   x15,F
0F40:  MOVWF  x1D
0F42:  MOVFF  03,11E
0F46:  MOVFF  FF2,11F
0F4A:  BCF    FF2.7
0F4C:  MOVFF  11D,FA9
0F50:  BCF    FA6.6
0F52:  BCF    FA6.7
0F54:  BSF    FA6.0
0F56:  MOVF   FA8,W
0F58:  BTFSC  x1F.7
0F5A:  BSF    FF2.7
0F5C:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data);
0F5E:  MOVFF  117,03
0F62:  MOVF   x16,W
0F64:  MOVWF  FE9
0F66:  MOVFF  03,FEA
0F6A:  MOVFF  FEF,11B
0F6E:  MOVFF  11A,11E
0F72:  MOVFF  11B,11F
*
0F7C:  MOVFF  01,11A
.................... 		data++;
0F80:  INCF   x16,F
0F82:  BTFSC  FD8.2
0F84:  INCF   x17,F
0F86:  BRA    0F12
.................... 	}
.................... 	return crc;
0F88:  MOVFF  11A,01
0F8C:  MOVLB  0
0F8E:  GOTO   11BA (RETURN)
.................... }
.................... 
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) {
0F92:  MOVLB  1
0F94:  CLRF   x1C
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
0F96:  MOVFF  11B,11E
0F9A:  MOVF   x1A,W
0F9C:  BTFSC  FD8.2
0F9E:  DECF   x1B,F
0FA0:  DECF   x1A,F
0FA2:  MOVWF  x1D
0FA4:  MOVF   x1D,F
0FA6:  BNZ   0FAC
0FA8:  MOVF   x1E,F
0FAA:  BZ    1024
.................... 		/* restart_wdt() */
.................... 		crc = xor_crc(crc,*data);
0FAC:  MOVFF  119,03
0FB0:  MOVF   x18,W
0FB2:  MOVWF  FE9
0FB4:  MOVFF  03,FEA
0FB8:  MOVFF  FEF,11D
0FBC:  MOVFF  11C,11E
0FC0:  MOVFF  11D,11F
*
0FCA:  MOVFF  01,11C
.................... 		write_eeprom( address++, *data++ );
0FCE:  MOVF   x17,W
0FD0:  MOVWF  03
0FD2:  MOVF   x16,W
0FD4:  INCF   x16,F
0FD6:  BTFSC  FD8.2
0FD8:  INCF   x17,F
0FDA:  MOVWF  x1D
0FDC:  MOVFF  03,11E
0FE0:  MOVF   x19,W
0FE2:  MOVWF  03
0FE4:  MOVF   x18,W
0FE6:  INCF   x18,F
0FE8:  BTFSC  FD8.2
0FEA:  INCF   x19,F
0FEC:  MOVWF  FE9
0FEE:  MOVFF  03,FEA
0FF2:  MOVFF  FEF,11F
0FF6:  MOVF   FF2,W
0FF8:  MOVWF  00
0FFA:  BCF    FF2.7
0FFC:  MOVFF  11D,FA9
1000:  MOVFF  11F,FA8
1004:  BCF    FA6.6
1006:  BCF    FA6.7
1008:  BSF    FA6.2
100A:  MOVLB  F
100C:  MOVLW  55
100E:  MOVWF  FA7
1010:  MOVLW  AA
1012:  MOVWF  FA7
1014:  BSF    FA6.1
1016:  BTFSC  FA6.1
1018:  BRA    1016
101A:  BCF    FA6.2
101C:  MOVF   00,W
101E:  IORWF  FF2,F
1020:  MOVLB  1
1022:  BRA    0F96
.................... 	}
.................... 
.................... 	return crc;
1024:  MOVFF  11C,01
1028:  MOVLB  0
102A:  GOTO   104A (RETURN)
.................... }
.................... 
.................... void write_param_file() {
.................... 	int8 crc;
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config));
102E:  MOVLB  1
1030:  MOVLW  1B
1032:  MOVWF  x14
1034:  CLRF   x17
1036:  MOVLW  02
1038:  MOVWF  x16
103A:  CLRF   x19
103C:  MOVFF  114,118
1040:  CLRF   x1B
1042:  MOVLW  48
1044:  MOVWF  x1A
1046:  MOVLB  0
1048:  BRA    0F92
104A:  MOVFF  01,113
.................... 	/* write the CRC was calculated on the structure */
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc);
104E:  MOVF   FF2,W
1050:  MOVWF  00
1052:  BCF    FF2.7
1054:  CLRF   FA9
1056:  MOVFF  113,FA8
105A:  BCF    FA6.6
105C:  BCF    FA6.7
105E:  BSF    FA6.2
1060:  MOVLB  F
1062:  MOVLW  55
1064:  MOVWF  FA7
1066:  MOVLW  AA
1068:  MOVWF  FA7
106A:  BSF    FA6.1
106C:  BTFSC  FA6.1
106E:  BRA    106C
1070:  BCF    FA6.2
1072:  MOVF   00,W
1074:  IORWF  FF2,F
1076:  MOVLB  0
1078:  RETURN 0
.................... }
.................... 
.................... void write_default_param_file() {
.................... 	int8 i;
.................... 
.................... 	current.default_params_written=1;
107A:  MOVLW  01
107C:  MOVWF  xCE
.................... 
.................... 	/* both LEDs on */
.................... 	timers.led_on_a=150;
107E:  MOVLW  96
1080:  MOVWF  xD0
.................... 	timers.led_on_b=150;
1082:  MOVWF  xD1
.................... 
.................... 
.................... 	for ( i=0 ; i<2 ; i++ ) {
1084:  MOVLB  1
1086:  CLRF   x12
1088:  MOVF   x12,W
108A:  SUBLW  01
108C:  BTFSS  FD8.0
108E:  BRA    1198
.................... 		config.ch[i].lvd_disconnect_adc=303;
1090:  MOVF   x12,W
1092:  MULLW  24
1094:  MOVF   FF3,W
1096:  CLRF   x14
1098:  MOVWF  x13
109A:  MOVLW  04
109C:  ADDWF  x13,W
109E:  MOVWF  01
10A0:  MOVLW  00
10A2:  ADDWFC x14,W
10A4:  MOVWF  03
10A6:  MOVF   01,W
10A8:  ADDLW  1B
10AA:  MOVWF  FE9
10AC:  MOVLW  00
10AE:  ADDWFC 03,W
10B0:  MOVWF  FEA
10B2:  MOVLW  01
10B4:  MOVWF  FEC
10B6:  MOVF   FED,F
10B8:  MOVLW  2F
10BA:  MOVWF  FEF
.................... 		config.ch[i].lvd_disconnect_delay=40;
10BC:  MOVF   x12,W
10BE:  MULLW  24
10C0:  MOVF   FF3,W
10C2:  CLRF   x14
10C4:  MOVWF  x13
10C6:  MOVLW  06
10C8:  ADDWF  x13,W
10CA:  MOVWF  01
10CC:  MOVLW  00
10CE:  ADDWFC x14,W
10D0:  MOVWF  03
10D2:  MOVF   01,W
10D4:  ADDLW  1B
10D6:  MOVWF  FE9
10D8:  MOVLW  00
10DA:  ADDWFC 03,W
10DC:  MOVWF  FEA
10DE:  CLRF   FEC
10E0:  MOVF   FED,F
10E2:  MOVLW  28
10E4:  MOVWF  FEF
.................... 		config.ch[i].lvd_reconnect_adc=308;
10E6:  MOVF   x12,W
10E8:  MULLW  24
10EA:  MOVF   FF3,W
10EC:  CLRF   x14
10EE:  MOVWF  x13
10F0:  MOVLW  08
10F2:  ADDWF  x13,W
10F4:  MOVWF  01
10F6:  MOVLW  00
10F8:  ADDWFC x14,W
10FA:  MOVWF  03
10FC:  MOVF   01,W
10FE:  ADDLW  1B
1100:  MOVWF  FE9
1102:  MOVLW  00
1104:  ADDWFC 03,W
1106:  MOVWF  FEA
1108:  MOVLW  01
110A:  MOVWF  FEC
110C:  MOVF   FED,F
110E:  MOVLW  34
1110:  MOVWF  FEF
.................... 
.................... 		config.ch[i].hvd_disconnect_adc=410;
1112:  MOVF   x12,W
1114:  MULLW  24
1116:  MOVF   FF3,W
1118:  CLRF   x14
111A:  MOVWF  x13
111C:  MOVLW  0C
111E:  ADDWF  x13,W
1120:  MOVWF  01
1122:  MOVLW  00
1124:  ADDWFC x14,W
1126:  MOVWF  03
1128:  MOVF   01,W
112A:  ADDLW  1B
112C:  MOVWF  FE9
112E:  MOVLW  00
1130:  ADDWFC 03,W
1132:  MOVWF  FEA
1134:  MOVLW  01
1136:  MOVWF  FEC
1138:  MOVF   FED,F
113A:  MOVLW  9A
113C:  MOVWF  FEF
.................... 		config.ch[i].hvd_disconnect_delay=15;
113E:  MOVF   x12,W
1140:  MULLW  24
1142:  MOVF   FF3,W
1144:  CLRF   x14
1146:  MOVWF  x13
1148:  MOVLW  0E
114A:  ADDWF  x13,W
114C:  MOVWF  01
114E:  MOVLW  00
1150:  ADDWFC x14,W
1152:  MOVWF  03
1154:  MOVF   01,W
1156:  ADDLW  1B
1158:  MOVWF  FE9
115A:  MOVLW  00
115C:  ADDWFC 03,W
115E:  MOVWF  FEA
1160:  CLRF   FEC
1162:  MOVF   FED,F
1164:  MOVLW  0F
1166:  MOVWF  FEF
.................... 		config.ch[i].hvd_reconnect_adc=385;
1168:  MOVF   x12,W
116A:  MULLW  24
116C:  MOVF   FF3,W
116E:  CLRF   x14
1170:  MOVWF  x13
1172:  MOVLW  10
1174:  ADDWF  x13,W
1176:  MOVWF  01
1178:  MOVLW  00
117A:  ADDWFC x14,W
117C:  MOVWF  03
117E:  MOVF   01,W
1180:  ADDLW  1B
1182:  MOVWF  FE9
1184:  MOVLW  00
1186:  ADDWFC 03,W
1188:  MOVWF  FEA
118A:  MOVLW  01
118C:  MOVWF  FEC
118E:  MOVF   FED,F
1190:  MOVLW  81
1192:  MOVWF  FEF
1194:  INCF   x12,F
1196:  BRA    1088
.................... 	}
.................... 	
.................... 	/* write them so next time we use from EEPROM */
.................... 	write_param_file();
1198:  MOVLB  0
119A:  RCALL  102E
119C:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void read_param_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config)); 
119E:  MOVLB  1
11A0:  MOVLW  1B
11A2:  MOVWF  x12
11A4:  CLRF   x15
11A6:  MOVLW  02
11A8:  MOVWF  x14
11AA:  CLRF   x17
11AC:  MOVFF  112,116
11B0:  CLRF   x19
11B2:  MOVLW  48
11B4:  MOVWF  x18
11B6:  MOVLB  0
11B8:  BRA    0F0E
11BA:  MOVFF  01,111
.................... 		
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) {
11BE:  MOVFF  FF2,112
11C2:  BCF    FF2.7
11C4:  CLRF   FA9
11C6:  BCF    FA6.6
11C8:  BCF    FA6.7
11CA:  BSF    FA6.0
11CC:  MOVF   FA8,W
11CE:  MOVLB  1
11D0:  BTFSC  x12.7
11D2:  BSF    FF2.7
11D4:  SUBWF  x11,W
11D6:  BZ    11DE
.................... 		write_default_param_file();
11D8:  MOVLB  0
11DA:  RCALL  107A
11DC:  MOVLB  1
.................... 	}
11DE:  MOVLB  0
11E0:  GOTO   217C (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... #include "i2c_handler_dcswc_module_latching_contactor.c"
.................... #include "registers_dcswc_module_latching_contactor.h"
.................... 
.................... /* first two or three registers will give enough information for telemetry */
.................... /* 10 bit input voltage ADC averaged value */
.................... #define I2C_REG_VOLTAGE_INPUT_AVG             0  
.................... /* two 8 bit channel states (A is MSB / B is LSB) */
.................... #define I2C_REG_STATE_CONTACTORS              1 
.................... /* 10 bit NTC thermistor ADC averaged value */
.................... #define I2C_REG_TEMPERATURE_BOARD_AVG         2
.................... 
....................   
.................... /* channel 0 / A */
.................... /* command can only come from I2C interface */
.................... #define I2C_REG_CH0_COMMAND_ON                3 /* R/W seconds */
.................... #define I2C_REG_CH0_COMMAND_ON_HOLD           4
.................... 
.................... #define I2C_REG_CH0_COMMAND_OFF               5 /* R/W seconds */
.................... #define I2C_REG_CH0_COMMAND_OFF_HOLD          6
.................... 
.................... /* low voltage disconnect */
.................... #define I2C_REG_CH0_LVD_DISCONNECT            7  /* R seconds */
.................... #define I2C_REG_CH0_LVD_RECONNECT             8 
.................... 
.................... /* high voltage disconnect */
.................... #define I2C_REG_CH0_HVD_DISCONNECT            9 /* R seconds */
.................... #define I2C_REG_CH0_HVD_RECONNECT             10
.................... 
.................... /* low temperature disconnect */
.................... #define I2C_REG_CH0_LTD_DISCONNECT            11  /* R seconds */
.................... #define I2C_REG_CH0_LTD_RECONNECT             12
.................... 
.................... /* high temperature disconnect */
.................... #define I2C_REG_CH0_HTD_DISCONNECT            13 /* R seconds */
.................... #define I2C_REG_CH0_HTD_RECONNECT             14
.................... 
.................... /* reserved for future, unimplemented */
.................... #define I2C_REG_CH0_FUT_DISCONNECT            15 /* R seconds */
.................... #define I2C_REG_CH0_FUT_RECONNECT             16
.................... 
.................... /* channel 1 / B */
.................... /* command can only come from I2C interface */
.................... #define I2C_REG_CH1_COMMAND_ON                17 /* R/W seconds */
.................... #define I2C_REG_CH1_COMMAND_ON_HOLD           18
.................... 
.................... #define I2C_REG_CH1_COMMAND_OFF               19 /* R/W seconds */
.................... #define I2C_REG_CH1_COMMAND_OFF_HOLD          20
.................... 
.................... /* low voltage disconnect */
.................... #define I2C_REG_CH1_LVD_DISCONNECT            21 /* R seconds */
.................... #define I2C_REG_CH1_LVD_RECONNECT             22 
.................... 
.................... /* high voltage disconnect */
.................... #define I2C_REG_CH1_HVD_DISCONNECT            23 /* R seconds */
.................... #define I2C_REG_CH1_HVD_RECONNECT             24
.................... 
.................... /* low temperature disconnect */
.................... #define I2C_REG_CH1_LTD_DISCONNECT            25  /* R seconds */
.................... #define I2C_REG_CH1_LTD_RECONNECT             26
.................... 
.................... /* high temperature disconnect */
.................... #define I2C_REG_CH1_HTD_DISCONNECT            27 /* R seconds */
.................... #define I2C_REG_CH1_HTD_RECONNECT             28
.................... 
.................... /* reserved for future, unimplemented */
.................... #define I2C_REG_CH1_FUT_DISCONNECT            29 /* R seconds */
.................... #define I2C_REG_CH1_FUT_RECONNECT             30
.................... 
.................... /* meta */
.................... #define I2C_REG_SEQUENCE_NUMBER               31 /* R */
.................... #define I2C_REG_TIME_INTERVAL_MILLISECONDS    32
.................... #define I2C_REG_TIME_UPTIME_MINUTES           33
.................... #define I2C_REG_DEFAULT_PARAMS_WRITTEN        34
.................... 
.................... /* channel configuration */
.................... /* channel 0 / A */
.................... #define I2C_REG_CH0_COMMAND_ON_HOLD_INITIAL   64
.................... 
.................... #define I2C_REG_CH0_COMMAND_OFF_HOLD_INITIAL  65
.................... 
.................... #define I2C_REG_CH0_LVD_DISCONNECT_ADC        66
.................... #define I2C_REG_CH0_LVD_DISCONNECT_DELAY      67
.................... #define I2C_REG_CH0_LVD_RECONNECT_ADC         68
.................... #define I2C_REG_CH0_LVD_RECONNECT_DELAY       69
.................... 
.................... #define I2C_REG_CH0_HVD_DISCONNECT_ADC        70
.................... #define I2C_REG_CH0_HVD_DISCONNECT_DELAY      71
.................... #define I2C_REG_CH0_HVD_RECONNECT_ADC         72
.................... #define I2C_REG_CH0_HVD_RECONNECT_DELAY       73
.................... 
.................... #define I2C_REG_CH0_LTD_DISCONNECT_ADC        74
.................... #define I2C_REG_CH0_LTD_DISCONNECT_DELAY      75
.................... #define I2C_REG_CH0_LTD_RECONNECT_ADC         76
.................... #define I2C_REG_CH0_LTD_RECONNECT_DELAY       77
.................... 
.................... #define I2C_REG_CH0_HTD_DISCONNECT_ADC        78
.................... #define I2C_REG_CH0_HTD_DISCONNECT_DELAY      79
.................... #define I2C_REG_CH0_HTD_RECONNECT_ADC         80
.................... #define I2C_REG_CH0_HTD_RECONNECT_DELAY       81
.................... 
.................... #define I2C_REG_CH0_FUT_DISCONNECT_VALUE      82
.................... #define I2C_REG_CH0_FUT_DISCONNECT_DELAY      83
.................... #define I2C_REG_CH0_FUT_RECONNECT_VALUE       84
.................... #define I2C_REG_CH0_FUT_RECONNECT_DELAY       85
.................... 
.................... /* channel 1 / B */
.................... #define I2C_REG_CH1_COMMAND_ON_HOLD_INITIAL   86
.................... 
.................... #define I2C_REG_CH1_COMMAND_OFF_HOLD_INITIAL  87
.................... 
.................... #define I2C_REG_CH1_LVD_DISCONNECT_ADC        88
.................... #define I2C_REG_CH1_LVD_DISCONNECT_DELAY      89
.................... #define I2C_REG_CH1_LVD_RECONNECT_ADC         90
.................... #define I2C_REG_CH1_LVD_RECONNECT_DELAY       91
.................... 
.................... #define I2C_REG_CH1_HVD_DISCONNECT_ADC        92
.................... #define I2C_REG_CH1_HVD_DISCONNECT_DELAY      93
.................... #define I2C_REG_CH1_HVD_RECONNECT_ADC         94
.................... #define I2C_REG_CH1_HVD_RECONNECT_DELAY       95
.................... 
.................... #define I2C_REG_CH1_LTD_DISCONNECT_ADC        96
.................... #define I2C_REG_CH1_LTD_DISCONNECT_DELAY      97
.................... #define I2C_REG_CH1_LTD_RECONNECT_ADC         98
.................... #define I2C_REG_CH1_LTD_RECONNECT_DELAY       99
.................... 
.................... #define I2C_REG_CH1_HTD_DISCONNECT_ADC        100
.................... #define I2C_REG_CH1_HTD_DISCONNECT_DELAY      101
.................... #define I2C_REG_CH1_HTD_RECONNECT_ADC         102
.................... #define I2C_REG_CH1_HTD_RECONNECT_DELAY       103
.................... 
.................... #define I2C_REG_CH1_FUT_DISCONNECT_VALUE      104
.................... #define I2C_REG_CH1_FUT_DISCONNECT_DELAY      105
.................... #define I2C_REG_CH1_FUT_RECONNECT_VALUE       106
.................... #define I2C_REG_CH1_FUT_RECONNECT_DELAY       107
.................... 
.................... 
.................... /* configuration */
.................... #define I2C_REG_CONFIG_HARDWARE_MODEL              128 /* R */
.................... #define I2C_REG_CONFIG_HARDWARE_VERSION            129
.................... #define I2C_REG_CONFIG_SOFTWARE_MODEL              130
.................... #define I2C_REG_CONFIG_SOFTWARE_VERSION            131
.................... #define I2C_REG_CONFIG_SOFTWARE_YEAR               132
.................... #define I2C_REG_CONFIG_SOFTWARE_MONTH              133
.................... #define I2C_REG_CONFIG_SOFTWARE_DAY                134
.................... 
.................... #define I2C_REG_CONFIG_PARAM_WRITE                 135 /* R / W */
.................... 
.................... 
.................... 
.................... void write_i2c(int8 address, int16 value) {
.................... 
.................... #if 0
*
0004:  GOTO   0A4E (RETURN)
.................... 		case I2C_REG_COMMAND_OFF:
.................... 			timers.command_off_seconds=value;
.................... 			break;
.................... 
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			if ( 1 == value ) {
.................... 				timers.now_write_config=1;
.................... 			} else if ( 2 == value ) {
.................... 				timers.now_reset_config=1;
.................... 			} else if ( 1802 == value ) {
.................... 				current.factory_unlocked =1;
.................... 			} else if ( 65535 == value ) {
.................... 				reset_cpu();
.................... 			}
.................... 			break;
.................... 		case I2C_REG_CONFIG_TICKS_ADC:
.................... 			config.adc_sample_ticks=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_STARTUP_POWER_ON_DELAY:
.................... 			config.startup_power_on_delay=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_COMMAND_OFF_HOLD_TIME:
.................... 			config.command_off_hold_time=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_LVD_DISCONNECT_VOLTAGE:
.................... 			config.lvd_disconnect_adc=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_LVD_DISCONNECT_DELAY:
.................... 			config.lvd_disconnect_delay=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_LVD_RECONNECT_VOLTAGE:
.................... 			config.lvd_reconnect_adc=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_HVD_DISCONNECT_VOLTAGE:
.................... 			config.hvd_disconnect_adc=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_HVD_DISCONNECT_DELAY:
.................... 			config.hvd_disconnect_delay=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_HVD_RECONNECT_VOLTAGE:
.................... 			config.hvd_reconnect_adc=value;
.................... 			break;
.................... 		default:
.................... 			/* do nothing */
.................... 	}
.................... #endif
.................... 
.................... }
.................... 
.................... 
.................... int16 map_i2c(int8 addr) {
.................... 	int8 c;
.................... 
.................... 	/* c is the channel we are accessing based on register range */
.................... 	if ( addr >= I2C_REG_CH1_COMMAND_ON && addr <= I2C_REG_CH1_FUT_RECONNECT ) {
*
0156:  MOVLB  1
0158:  MOVF   x37,W
015A:  SUBLW  10
015C:  BC    016E
015E:  MOVF   x37,W
0160:  SUBLW  1E
0162:  BNC   016E
.................... 		/* channel 1 status region */
.................... 		c=1;
0164:  MOVLW  01
0166:  MOVWF  x38
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON - I2C_REG_CH0_COMMAND_ON);
0168:  MOVLW  0E
016A:  SUBWF  x37,F
.................... 	} else if ( addr >= I2C_REG_CH1_COMMAND_ON_HOLD && addr <= I2C_REG_CH1_FUT_RECONNECT_DELAY ) {
016C:  BRA    0186
016E:  MOVF   x37,W
0170:  SUBLW  11
0172:  BC    0184
0174:  MOVF   x37,W
0176:  SUBLW  6B
0178:  BNC   0184
.................... 		/* channel 1 configuration region */
.................... 		c=1;
017A:  MOVLW  01
017C:  MOVWF  x38
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON_HOLD - I2C_REG_CH0_COMMAND_ON_HOLD );
017E:  MOVLW  0E
0180:  SUBWF  x37,F
.................... 	} else {
0182:  BRA    0186
.................... 		c=0;
0184:  CLRF   x38
.................... 	}
.................... 
.................... 	timers.led_on_a=100;
0186:  MOVLW  64
0188:  MOVLB  0
018A:  MOVWF  xD0
.................... 
.................... 	switch ( addr ) {
018C:  MOVLB  1
018E:  MOVF   x37,W
0190:  XORLW  00
0192:  MOVLB  0
0194:  BTFSC  FD8.2
0196:  BRA    02C6
0198:  XORLW  01
019A:  BTFSC  FD8.2
019C:  BRA    02D2
019E:  XORLW  03
01A0:  BTFSC  FD8.2
01A2:  BRA    02E0
01A4:  XORLW  01
01A6:  BTFSC  FD8.2
01A8:  BRA    02EE
01AA:  XORLW  07
01AC:  BTFSC  FD8.2
01AE:  BRA    0324
01B0:  XORLW  01
01B2:  BTFSC  FD8.2
01B4:  BRA    035A
01B6:  XORLW  03
01B8:  BTFSC  FD8.2
01BA:  BRA    0390
01BC:  XORLW  01
01BE:  BTFSC  FD8.2
01C0:  BRA    03C6
01C2:  XORLW  0F
01C4:  BTFSC  FD8.2
01C6:  BRA    03FC
01C8:  XORLW  01
01CA:  BTFSC  FD8.2
01CC:  BRA    042A
01CE:  XORLW  03
01D0:  BTFSC  FD8.2
01D2:  BRA    0460
01D4:  XORLW  01
01D6:  BTFSC  FD8.2
01D8:  BRA    048E
01DA:  XORLW  07
01DC:  BTFSC  FD8.2
01DE:  BRA    04C4
01E0:  XORLW  01
01E2:  BTFSC  FD8.2
01E4:  BRA    04FA
01E6:  XORLW  03
01E8:  BTFSC  FD8.2
01EA:  BRA    0530
01EC:  XORLW  01
01EE:  BTFSC  FD8.2
01F0:  BRA    0566
01F2:  XORLW  1F
01F4:  BTFSC  FD8.2
01F6:  BRA    0566
01F8:  XORLW  0F
01FA:  BTFSC  FD8.2
01FC:  BRA    056E
01FE:  XORLW  3F
0200:  BTFSC  FD8.2
0202:  BRA    0578
0204:  XORLW  01
0206:  BTFSC  FD8.2
0208:  BRA    0582
020A:  XORLW  03
020C:  BTFSC  FD8.2
020E:  BRA    058C
0210:  XORLW  62
0212:  BTFSC  FD8.2
0214:  BRA    0594
0216:  XORLW  01
0218:  BTFSC  FD8.2
021A:  BRA    05BE
021C:  XORLW  03
021E:  BTFSC  FD8.2
0220:  BRA    05F4
0222:  XORLW  01
0224:  BTFSC  FD8.2
0226:  BRA    062A
0228:  XORLW  07
022A:  BTFSC  FD8.2
022C:  BRA    0660
022E:  XORLW  01
0230:  BTFSC  FD8.2
0232:  BRA    0696
0234:  XORLW  03
0236:  BTFSC  FD8.2
0238:  BRA    06CC
023A:  XORLW  01
023C:  BTFSC  FD8.2
023E:  BRA    0702
0240:  XORLW  0F
0242:  BTFSC  FD8.2
0244:  BRA    0738
0246:  XORLW  01
0248:  BTFSC  FD8.2
024A:  BRA    076E
024C:  XORLW  03
024E:  BTFSC  FD8.2
0250:  BRA    07A4
0252:  XORLW  01
0254:  BTFSC  FD8.2
0256:  BRA    07DA
0258:  XORLW  07
025A:  BTFSC  FD8.2
025C:  BRA    0810
025E:  XORLW  01
0260:  BTFSC  FD8.2
0262:  BRA    0846
0264:  XORLW  03
0266:  BTFSC  FD8.2
0268:  BRA    087C
026A:  XORLW  01
026C:  BTFSC  FD8.2
026E:  BRA    08B2
0270:  XORLW  1F
0272:  BTFSC  FD8.2
0274:  BRA    08E8
0276:  XORLW  01
0278:  BTFSC  FD8.2
027A:  BRA    091E
027C:  XORLW  03
027E:  BTFSC  FD8.2
0280:  BRA    0954
0282:  XORLW  01
0284:  BTFSC  FD8.2
0286:  BRA    0954
0288:  XORLW  07
028A:  BTFSC  FD8.2
028C:  BRA    0954
028E:  XORLW  01
0290:  BTFSC  FD8.2
0292:  BRA    0954
0294:  XORLW  D5
0296:  BTFSC  FD8.2
0298:  BRA    095C
029A:  XORLW  01
029C:  BTFSC  FD8.2
029E:  BRA    0966
02A0:  XORLW  03
02A2:  BTFSC  FD8.2
02A4:  BRA    0970
02A6:  XORLW  01
02A8:  BTFSC  FD8.2
02AA:  BRA    097A
02AC:  XORLW  07
02AE:  BTFSC  FD8.2
02B0:  BRA    0984
02B2:  XORLW  01
02B4:  BTFSC  FD8.2
02B6:  BRA    098C
02B8:  XORLW  03
02BA:  BTFSC  FD8.2
02BC:  BRA    0994
02BE:  XORLW  01
02C0:  BTFSC  FD8.2
02C2:  BRA    099C
02C4:  BRA    09A4
.................... 		/* not channel based */
.................... 		case I2C_REG_VOLTAGE_INPUT_AVG: 
.................... 			return (int16) adc_get(0);
02C6:  MOVLB  1
02C8:  CLRF   x39
02CA:  MOVLB  0
02CC:  RCALL  00DC
02CE:  MOVF   02,W
02D0:  BRA    09AA
.................... 		case I2C_REG_STATE_CONTACTORS:
.................... 			return (int16) make16(channel[0].state,channel[1].state);
02D2:  MOVFF  D4,03
02D6:  MOVFF  EB,01
02DA:  MOVFF  D4,02
02DE:  BRA    09AA
.................... 		case I2C_REG_TEMPERATURE_BOARD_AVG: 
.................... 			return (int16) adc_get(1);
02E0:  MOVLW  01
02E2:  MOVLB  1
02E4:  MOVWF  x39
02E6:  MOVLB  0
02E8:  RCALL  00DC
02EA:  MOVF   02,W
02EC:  BRA    09AA
.................... 
.................... 		/* status based on channel value c */
.................... 		case I2C_REG_CH0_COMMAND_ON :
.................... 			return (int16) channel[c].command_on_seconds;
02EE:  MOVLB  1
02F0:  MOVF   x38,W
02F2:  MULLW  17
02F4:  MOVF   FF3,W
02F6:  CLRF   x3A
02F8:  MOVWF  x39
02FA:  MOVLW  01
02FC:  ADDWF  x39,W
02FE:  MOVWF  01
0300:  MOVLW  00
0302:  ADDWFC x3A,W
0304:  MOVWF  03
0306:  MOVF   01,W
0308:  ADDLW  D4
030A:  MOVWF  FE9
030C:  MOVLW  00
030E:  ADDWFC 03,W
0310:  MOVWF  FEA
0312:  MOVFF  FEC,03
0316:  MOVF   FED,F
0318:  MOVFF  FEF,01
031C:  MOVFF  03,02
0320:  MOVLB  0
0322:  BRA    09AA
.................... 		case I2C_REG_CH0_COMMAND_ON_HOLD:
.................... 			return (int16) channel[c].command_on_hold_seconds;
0324:  MOVLB  1
0326:  MOVF   x38,W
0328:  MULLW  17
032A:  MOVF   FF3,W
032C:  CLRF   x3A
032E:  MOVWF  x39
0330:  MOVLW  03
0332:  ADDWF  x39,W
0334:  MOVWF  01
0336:  MOVLW  00
0338:  ADDWFC x3A,W
033A:  MOVWF  03
033C:  MOVF   01,W
033E:  ADDLW  D4
0340:  MOVWF  FE9
0342:  MOVLW  00
0344:  ADDWFC 03,W
0346:  MOVWF  FEA
0348:  MOVFF  FEC,03
034C:  MOVF   FED,F
034E:  MOVFF  FEF,01
0352:  MOVFF  03,02
0356:  MOVLB  0
0358:  BRA    09AA
.................... 
.................... 		case I2C_REG_CH0_COMMAND_OFF:
.................... 			return (int16) channel[c].command_off_seconds;
035A:  MOVLB  1
035C:  MOVF   x38,W
035E:  MULLW  17
0360:  MOVF   FF3,W
0362:  CLRF   x3A
0364:  MOVWF  x39
0366:  MOVLW  05
0368:  ADDWF  x39,W
036A:  MOVWF  01
036C:  MOVLW  00
036E:  ADDWFC x3A,W
0370:  MOVWF  03
0372:  MOVF   01,W
0374:  ADDLW  D4
0376:  MOVWF  FE9
0378:  MOVLW  00
037A:  ADDWFC 03,W
037C:  MOVWF  FEA
037E:  MOVFF  FEC,03
0382:  MOVF   FED,F
0384:  MOVFF  FEF,01
0388:  MOVFF  03,02
038C:  MOVLB  0
038E:  BRA    09AA
.................... 		case I2C_REG_CH0_COMMAND_OFF_HOLD:
.................... 			return (int16) channel[c].command_off_hold_seconds;
0390:  MOVLB  1
0392:  MOVF   x38,W
0394:  MULLW  17
0396:  MOVF   FF3,W
0398:  CLRF   x3A
039A:  MOVWF  x39
039C:  MOVLW  07
039E:  ADDWF  x39,W
03A0:  MOVWF  01
03A2:  MOVLW  00
03A4:  ADDWFC x3A,W
03A6:  MOVWF  03
03A8:  MOVF   01,W
03AA:  ADDLW  D4
03AC:  MOVWF  FE9
03AE:  MOVLW  00
03B0:  ADDWFC 03,W
03B2:  MOVWF  FEA
03B4:  MOVFF  FEC,03
03B8:  MOVF   FED,F
03BA:  MOVFF  FEF,01
03BE:  MOVFF  03,02
03C2:  MOVLB  0
03C4:  BRA    09AA
.................... 
.................... 		case I2C_REG_CH0_LVD_DISCONNECT:
.................... 			return (int16) channel[c].lvd_disconnect_delay_seconds;
03C6:  MOVLB  1
03C8:  MOVF   x38,W
03CA:  MULLW  17
03CC:  MOVF   FF3,W
03CE:  CLRF   x3A
03D0:  MOVWF  x39
03D2:  MOVLW  09
03D4:  ADDWF  x39,W
03D6:  MOVWF  01
03D8:  MOVLW  00
03DA:  ADDWFC x3A,W
03DC:  MOVWF  03
03DE:  MOVF   01,W
03E0:  ADDLW  D4
03E2:  MOVWF  FE9
03E4:  MOVLW  00
03E6:  ADDWFC 03,W
03E8:  MOVWF  FEA
03EA:  MOVFF  FEC,03
03EE:  MOVF   FED,F
03F0:  MOVFF  FEF,01
03F4:  MOVFF  03,02
03F8:  MOVLB  0
03FA:  BRA    09AA
.................... 		case I2C_REG_CH0_LVD_RECONNECT:
.................... 			return (int16) channel[c].lvd_reconnect_delay_seconds;
03FC:  MOVLB  1
03FE:  MOVF   x38,W
0400:  MULLW  17
0402:  MOVF   FF3,W
0404:  CLRF   x3A
0406:  MOVWF  x39
0408:  MOVLW  0B
040A:  ADDWF  x39,W
040C:  MOVWF  01
040E:  MOVLW  00
0410:  ADDWFC x3A,W
0412:  MOVWF  03
0414:  MOVF   01,W
0416:  ADDLW  D4
0418:  MOVWF  FE9
041A:  MOVLW  00
041C:  ADDWFC 03,W
041E:  MOVWF  FEA
0420:  MOVF   FEF,W
0422:  MOVWF  01
0424:  CLRF   02
0426:  MOVLB  0
0428:  BRA    09AA
.................... 
.................... 		case I2C_REG_CH0_HVD_DISCONNECT:
.................... 			return (int16) channel[c].hvd_disconnect_delay_seconds;
042A:  MOVLB  1
042C:  MOVF   x38,W
042E:  MULLW  17
0430:  MOVF   FF3,W
0432:  CLRF   x3A
0434:  MOVWF  x39
0436:  MOVLW  0C
0438:  ADDWF  x39,W
043A:  MOVWF  01
043C:  MOVLW  00
043E:  ADDWFC x3A,W
0440:  MOVWF  03
0442:  MOVF   01,W
0444:  ADDLW  D4
0446:  MOVWF  FE9
0448:  MOVLW  00
044A:  ADDWFC 03,W
044C:  MOVWF  FEA
044E:  MOVFF  FEC,03
0452:  MOVF   FED,F
0454:  MOVFF  FEF,01
0458:  MOVFF  03,02
045C:  MOVLB  0
045E:  BRA    09AA
.................... 		case I2C_REG_CH0_HVD_RECONNECT:
.................... 			return (int16) channel[c].hvd_reconnect_delay_seconds;
0460:  MOVLB  1
0462:  MOVF   x38,W
0464:  MULLW  17
0466:  MOVF   FF3,W
0468:  CLRF   x3A
046A:  MOVWF  x39
046C:  MOVLW  0E
046E:  ADDWF  x39,W
0470:  MOVWF  01
0472:  MOVLW  00
0474:  ADDWFC x3A,W
0476:  MOVWF  03
0478:  MOVF   01,W
047A:  ADDLW  D4
047C:  MOVWF  FE9
047E:  MOVLW  00
0480:  ADDWFC 03,W
0482:  MOVWF  FEA
0484:  MOVF   FEF,W
0486:  MOVWF  01
0488:  CLRF   02
048A:  MOVLB  0
048C:  BRA    09AA
.................... 
.................... 		case I2C_REG_CH0_LTD_DISCONNECT:
.................... 			return (int16) channel[c].ltd_disconnect_delay_seconds;
048E:  MOVLB  1
0490:  MOVF   x38,W
0492:  MULLW  17
0494:  MOVF   FF3,W
0496:  CLRF   x3A
0498:  MOVWF  x39
049A:  MOVLW  0F
049C:  ADDWF  x39,W
049E:  MOVWF  01
04A0:  MOVLW  00
04A2:  ADDWFC x3A,W
04A4:  MOVWF  03
04A6:  MOVF   01,W
04A8:  ADDLW  D4
04AA:  MOVWF  FE9
04AC:  MOVLW  00
04AE:  ADDWFC 03,W
04B0:  MOVWF  FEA
04B2:  MOVFF  FEC,03
04B6:  MOVF   FED,F
04B8:  MOVFF  FEF,01
04BC:  MOVFF  03,02
04C0:  MOVLB  0
04C2:  BRA    09AA
.................... 		case I2C_REG_CH0_LTD_RECONNECT:
.................... 			return (int16) channel[c].ltd_reconnect_delay_seconds;
04C4:  MOVLB  1
04C6:  MOVF   x38,W
04C8:  MULLW  17
04CA:  MOVF   FF3,W
04CC:  CLRF   x3A
04CE:  MOVWF  x39
04D0:  MOVLW  11
04D2:  ADDWF  x39,W
04D4:  MOVWF  01
04D6:  MOVLW  00
04D8:  ADDWFC x3A,W
04DA:  MOVWF  03
04DC:  MOVF   01,W
04DE:  ADDLW  D4
04E0:  MOVWF  FE9
04E2:  MOVLW  00
04E4:  ADDWFC 03,W
04E6:  MOVWF  FEA
04E8:  MOVFF  FEC,03
04EC:  MOVF   FED,F
04EE:  MOVFF  FEF,01
04F2:  MOVFF  03,02
04F6:  MOVLB  0
04F8:  BRA    09AA
.................... 
.................... 		case I2C_REG_CH0_HTD_DISCONNECT:
.................... 			return (int16) channel[c].htd_disconnect_delay_seconds;
04FA:  MOVLB  1
04FC:  MOVF   x38,W
04FE:  MULLW  17
0500:  MOVF   FF3,W
0502:  CLRF   x3A
0504:  MOVWF  x39
0506:  MOVLW  13
0508:  ADDWF  x39,W
050A:  MOVWF  01
050C:  MOVLW  00
050E:  ADDWFC x3A,W
0510:  MOVWF  03
0512:  MOVF   01,W
0514:  ADDLW  D4
0516:  MOVWF  FE9
0518:  MOVLW  00
051A:  ADDWFC 03,W
051C:  MOVWF  FEA
051E:  MOVFF  FEC,03
0522:  MOVF   FED,F
0524:  MOVFF  FEF,01
0528:  MOVFF  03,02
052C:  MOVLB  0
052E:  BRA    09AA
.................... 		case I2C_REG_CH0_HTD_RECONNECT:
.................... 			return (int16) channel[c].htd_reconnect_delay_seconds;
0530:  MOVLB  1
0532:  MOVF   x38,W
0534:  MULLW  17
0536:  MOVF   FF3,W
0538:  CLRF   x3A
053A:  MOVWF  x39
053C:  MOVLW  15
053E:  ADDWF  x39,W
0540:  MOVWF  01
0542:  MOVLW  00
0544:  ADDWFC x3A,W
0546:  MOVWF  03
0548:  MOVF   01,W
054A:  ADDLW  D4
054C:  MOVWF  FE9
054E:  MOVLW  00
0550:  ADDWFC 03,W
0552:  MOVWF  FEA
0554:  MOVFF  FEC,03
0558:  MOVF   FED,F
055A:  MOVFF  FEF,01
055E:  MOVFF  03,02
0562:  MOVLB  0
0564:  BRA    09AA
.................... 
.................... 		case I2C_REG_CH0_FUT_DISCONNECT:
.................... 		case I2C_REG_CH0_FUT_RECONNECT:
.................... 			return (int16) 0xffff; /* not yet implemented */
0566:  MOVLW  FF
0568:  MOVWF  01
056A:  MOVWF  02
056C:  BRA    09AA
.................... 
.................... 
.................... 		/* non-channel based meta */
.................... 		case I2C_REG_SEQUENCE_NUMBER:
.................... 			return (int16) current.sequence_number;
056E:  MOVFF  C4,01
0572:  MOVFF  C5,02
0576:  BRA    09AA
.................... 		case I2C_REG_TIME_INTERVAL_MILLISECONDS:
.................... 			return (int16) current.interval_milliseconds;
0578:  MOVFF  C8,01
057C:  MOVFF  C9,02
0580:  BRA    09AA
.................... 		case I2C_REG_TIME_UPTIME_MINUTES:
.................... 			return (int16) current.uptime_minutes;
0582:  MOVFF  C6,01
0586:  MOVFF  C7,02
058A:  BRA    09AA
.................... 		case I2C_REG_DEFAULT_PARAMS_WRITTEN:
.................... 			return (int16) current.default_params_written;
058C:  MOVFF  CE,01
0590:  CLRF   02
0592:  BRA    09AA
.................... 
.................... 		/* channel based configuration */
.................... 		case I2C_REG_CH0_COMMAND_ON_HOLD_INITIAL:
.................... 			return (int16) config.ch[c].command_on_hold_time;
0594:  MOVLB  1
0596:  MOVF   x38,W
0598:  MULLW  24
059A:  MOVF   FF3,W
059C:  CLRF   x3A
059E:  MOVWF  x39
05A0:  MOVLW  1B
05A2:  ADDWF  x39,W
05A4:  MOVWF  FE9
05A6:  MOVLW  00
05A8:  ADDWFC x3A,W
05AA:  MOVWF  FEA
05AC:  MOVFF  FEC,03
05B0:  MOVF   FED,F
05B2:  MOVFF  FEF,01
05B6:  MOVFF  03,02
05BA:  MOVLB  0
05BC:  BRA    09AA
.................... 
.................... 		case I2C_REG_CH0_COMMAND_OFF_HOLD_INITIAL:
.................... 			return (int16) config.ch[c].command_off_hold_time;
05BE:  MOVLB  1
05C0:  MOVF   x38,W
05C2:  MULLW  24
05C4:  MOVF   FF3,W
05C6:  CLRF   x3A
05C8:  MOVWF  x39
05CA:  MOVLW  02
05CC:  ADDWF  x39,W
05CE:  MOVWF  01
05D0:  MOVLW  00
05D2:  ADDWFC x3A,W
05D4:  MOVWF  03
05D6:  MOVF   01,W
05D8:  ADDLW  1B
05DA:  MOVWF  FE9
05DC:  MOVLW  00
05DE:  ADDWFC 03,W
05E0:  MOVWF  FEA
05E2:  MOVFF  FEC,03
05E6:  MOVF   FED,F
05E8:  MOVFF  FEF,01
05EC:  MOVFF  03,02
05F0:  MOVLB  0
05F2:  BRA    09AA
.................... 
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].lvd_disconnect_adc;
05F4:  MOVLB  1
05F6:  MOVF   x38,W
05F8:  MULLW  24
05FA:  MOVF   FF3,W
05FC:  CLRF   x3A
05FE:  MOVWF  x39
0600:  MOVLW  04
0602:  ADDWF  x39,W
0604:  MOVWF  01
0606:  MOVLW  00
0608:  ADDWFC x3A,W
060A:  MOVWF  03
060C:  MOVF   01,W
060E:  ADDLW  1B
0610:  MOVWF  FE9
0612:  MOVLW  00
0614:  ADDWFC 03,W
0616:  MOVWF  FEA
0618:  MOVFF  FEC,03
061C:  MOVF   FED,F
061E:  MOVFF  FEF,01
0622:  MOVFF  03,02
0626:  MOVLB  0
0628:  BRA    09AA
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].lvd_disconnect_delay;
062A:  MOVLB  1
062C:  MOVF   x38,W
062E:  MULLW  24
0630:  MOVF   FF3,W
0632:  CLRF   x3A
0634:  MOVWF  x39
0636:  MOVLW  06
0638:  ADDWF  x39,W
063A:  MOVWF  01
063C:  MOVLW  00
063E:  ADDWFC x3A,W
0640:  MOVWF  03
0642:  MOVF   01,W
0644:  ADDLW  1B
0646:  MOVWF  FE9
0648:  MOVLW  00
064A:  ADDWFC 03,W
064C:  MOVWF  FEA
064E:  MOVFF  FEC,03
0652:  MOVF   FED,F
0654:  MOVFF  FEF,01
0658:  MOVFF  03,02
065C:  MOVLB  0
065E:  BRA    09AA
.................... 		case I2C_REG_CH0_LVD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].lvd_reconnect_adc;
0660:  MOVLB  1
0662:  MOVF   x38,W
0664:  MULLW  24
0666:  MOVF   FF3,W
0668:  CLRF   x3A
066A:  MOVWF  x39
066C:  MOVLW  08
066E:  ADDWF  x39,W
0670:  MOVWF  01
0672:  MOVLW  00
0674:  ADDWFC x3A,W
0676:  MOVWF  03
0678:  MOVF   01,W
067A:  ADDLW  1B
067C:  MOVWF  FE9
067E:  MOVLW  00
0680:  ADDWFC 03,W
0682:  MOVWF  FEA
0684:  MOVFF  FEC,03
0688:  MOVF   FED,F
068A:  MOVFF  FEF,01
068E:  MOVFF  03,02
0692:  MOVLB  0
0694:  BRA    09AA
.................... 		case I2C_REG_CH0_LVD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].lvd_reconnect_delay;
0696:  MOVLB  1
0698:  MOVF   x38,W
069A:  MULLW  24
069C:  MOVF   FF3,W
069E:  CLRF   x3A
06A0:  MOVWF  x39
06A2:  MOVLW  0A
06A4:  ADDWF  x39,W
06A6:  MOVWF  01
06A8:  MOVLW  00
06AA:  ADDWFC x3A,W
06AC:  MOVWF  03
06AE:  MOVF   01,W
06B0:  ADDLW  1B
06B2:  MOVWF  FE9
06B4:  MOVLW  00
06B6:  ADDWFC 03,W
06B8:  MOVWF  FEA
06BA:  MOVFF  FEC,03
06BE:  MOVF   FED,F
06C0:  MOVFF  FEF,01
06C4:  MOVFF  03,02
06C8:  MOVLB  0
06CA:  BRA    09AA
.................... 
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].hvd_disconnect_adc;
06CC:  MOVLB  1
06CE:  MOVF   x38,W
06D0:  MULLW  24
06D2:  MOVF   FF3,W
06D4:  CLRF   x3A
06D6:  MOVWF  x39
06D8:  MOVLW  0C
06DA:  ADDWF  x39,W
06DC:  MOVWF  01
06DE:  MOVLW  00
06E0:  ADDWFC x3A,W
06E2:  MOVWF  03
06E4:  MOVF   01,W
06E6:  ADDLW  1B
06E8:  MOVWF  FE9
06EA:  MOVLW  00
06EC:  ADDWFC 03,W
06EE:  MOVWF  FEA
06F0:  MOVFF  FEC,03
06F4:  MOVF   FED,F
06F6:  MOVFF  FEF,01
06FA:  MOVFF  03,02
06FE:  MOVLB  0
0700:  BRA    09AA
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].hvd_disconnect_delay;
0702:  MOVLB  1
0704:  MOVF   x38,W
0706:  MULLW  24
0708:  MOVF   FF3,W
070A:  CLRF   x3A
070C:  MOVWF  x39
070E:  MOVLW  0E
0710:  ADDWF  x39,W
0712:  MOVWF  01
0714:  MOVLW  00
0716:  ADDWFC x3A,W
0718:  MOVWF  03
071A:  MOVF   01,W
071C:  ADDLW  1B
071E:  MOVWF  FE9
0720:  MOVLW  00
0722:  ADDWFC 03,W
0724:  MOVWF  FEA
0726:  MOVFF  FEC,03
072A:  MOVF   FED,F
072C:  MOVFF  FEF,01
0730:  MOVFF  03,02
0734:  MOVLB  0
0736:  BRA    09AA
.................... 		case I2C_REG_CH0_HVD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].hvd_reconnect_adc;
0738:  MOVLB  1
073A:  MOVF   x38,W
073C:  MULLW  24
073E:  MOVF   FF3,W
0740:  CLRF   x3A
0742:  MOVWF  x39
0744:  MOVLW  10
0746:  ADDWF  x39,W
0748:  MOVWF  01
074A:  MOVLW  00
074C:  ADDWFC x3A,W
074E:  MOVWF  03
0750:  MOVF   01,W
0752:  ADDLW  1B
0754:  MOVWF  FE9
0756:  MOVLW  00
0758:  ADDWFC 03,W
075A:  MOVWF  FEA
075C:  MOVFF  FEC,03
0760:  MOVF   FED,F
0762:  MOVFF  FEF,01
0766:  MOVFF  03,02
076A:  MOVLB  0
076C:  BRA    09AA
.................... 		case I2C_REG_CH0_HVD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].hvd_reconnect_delay;
076E:  MOVLB  1
0770:  MOVF   x38,W
0772:  MULLW  24
0774:  MOVF   FF3,W
0776:  CLRF   x3A
0778:  MOVWF  x39
077A:  MOVLW  12
077C:  ADDWF  x39,W
077E:  MOVWF  01
0780:  MOVLW  00
0782:  ADDWFC x3A,W
0784:  MOVWF  03
0786:  MOVF   01,W
0788:  ADDLW  1B
078A:  MOVWF  FE9
078C:  MOVLW  00
078E:  ADDWFC 03,W
0790:  MOVWF  FEA
0792:  MOVFF  FEC,03
0796:  MOVF   FED,F
0798:  MOVFF  FEF,01
079C:  MOVFF  03,02
07A0:  MOVLB  0
07A2:  BRA    09AA
.................... 
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_disconnect_adc;
07A4:  MOVLB  1
07A6:  MOVF   x38,W
07A8:  MULLW  24
07AA:  MOVF   FF3,W
07AC:  CLRF   x3A
07AE:  MOVWF  x39
07B0:  MOVLW  14
07B2:  ADDWF  x39,W
07B4:  MOVWF  01
07B6:  MOVLW  00
07B8:  ADDWFC x3A,W
07BA:  MOVWF  03
07BC:  MOVF   01,W
07BE:  ADDLW  1B
07C0:  MOVWF  FE9
07C2:  MOVLW  00
07C4:  ADDWFC 03,W
07C6:  MOVWF  FEA
07C8:  MOVFF  FEC,03
07CC:  MOVF   FED,F
07CE:  MOVFF  FEF,01
07D2:  MOVFF  03,02
07D6:  MOVLB  0
07D8:  BRA    09AA
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_disconnect_delay;
07DA:  MOVLB  1
07DC:  MOVF   x38,W
07DE:  MULLW  24
07E0:  MOVF   FF3,W
07E2:  CLRF   x3A
07E4:  MOVWF  x39
07E6:  MOVLW  16
07E8:  ADDWF  x39,W
07EA:  MOVWF  01
07EC:  MOVLW  00
07EE:  ADDWFC x3A,W
07F0:  MOVWF  03
07F2:  MOVF   01,W
07F4:  ADDLW  1B
07F6:  MOVWF  FE9
07F8:  MOVLW  00
07FA:  ADDWFC 03,W
07FC:  MOVWF  FEA
07FE:  MOVFF  FEC,03
0802:  MOVF   FED,F
0804:  MOVFF  FEF,01
0808:  MOVFF  03,02
080C:  MOVLB  0
080E:  BRA    09AA
.................... 		case I2C_REG_CH0_LTD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_reconnect_adc;
0810:  MOVLB  1
0812:  MOVF   x38,W
0814:  MULLW  24
0816:  MOVF   FF3,W
0818:  CLRF   x3A
081A:  MOVWF  x39
081C:  MOVLW  18
081E:  ADDWF  x39,W
0820:  MOVWF  01
0822:  MOVLW  00
0824:  ADDWFC x3A,W
0826:  MOVWF  03
0828:  MOVF   01,W
082A:  ADDLW  1B
082C:  MOVWF  FE9
082E:  MOVLW  00
0830:  ADDWFC 03,W
0832:  MOVWF  FEA
0834:  MOVFF  FEC,03
0838:  MOVF   FED,F
083A:  MOVFF  FEF,01
083E:  MOVFF  03,02
0842:  MOVLB  0
0844:  BRA    09AA
.................... 		case I2C_REG_CH0_LTD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_reconnect_delay;
0846:  MOVLB  1
0848:  MOVF   x38,W
084A:  MULLW  24
084C:  MOVF   FF3,W
084E:  CLRF   x3A
0850:  MOVWF  x39
0852:  MOVLW  1A
0854:  ADDWF  x39,W
0856:  MOVWF  01
0858:  MOVLW  00
085A:  ADDWFC x3A,W
085C:  MOVWF  03
085E:  MOVF   01,W
0860:  ADDLW  1B
0862:  MOVWF  FE9
0864:  MOVLW  00
0866:  ADDWFC 03,W
0868:  MOVWF  FEA
086A:  MOVFF  FEC,03
086E:  MOVF   FED,F
0870:  MOVFF  FEF,01
0874:  MOVFF  03,02
0878:  MOVLB  0
087A:  BRA    09AA
.................... 
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_disconnect_adc;
087C:  MOVLB  1
087E:  MOVF   x38,W
0880:  MULLW  24
0882:  MOVF   FF3,W
0884:  CLRF   x3A
0886:  MOVWF  x39
0888:  MOVLW  14
088A:  ADDWF  x39,W
088C:  MOVWF  01
088E:  MOVLW  00
0890:  ADDWFC x3A,W
0892:  MOVWF  03
0894:  MOVF   01,W
0896:  ADDLW  1B
0898:  MOVWF  FE9
089A:  MOVLW  00
089C:  ADDWFC 03,W
089E:  MOVWF  FEA
08A0:  MOVFF  FEC,03
08A4:  MOVF   FED,F
08A6:  MOVFF  FEF,01
08AA:  MOVFF  03,02
08AE:  MOVLB  0
08B0:  BRA    09AA
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_disconnect_delay;
08B2:  MOVLB  1
08B4:  MOVF   x38,W
08B6:  MULLW  24
08B8:  MOVF   FF3,W
08BA:  CLRF   x3A
08BC:  MOVWF  x39
08BE:  MOVLW  16
08C0:  ADDWF  x39,W
08C2:  MOVWF  01
08C4:  MOVLW  00
08C6:  ADDWFC x3A,W
08C8:  MOVWF  03
08CA:  MOVF   01,W
08CC:  ADDLW  1B
08CE:  MOVWF  FE9
08D0:  MOVLW  00
08D2:  ADDWFC 03,W
08D4:  MOVWF  FEA
08D6:  MOVFF  FEC,03
08DA:  MOVF   FED,F
08DC:  MOVFF  FEF,01
08E0:  MOVFF  03,02
08E4:  MOVLB  0
08E6:  BRA    09AA
.................... 		case I2C_REG_CH0_HTD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_reconnect_adc;
08E8:  MOVLB  1
08EA:  MOVF   x38,W
08EC:  MULLW  24
08EE:  MOVF   FF3,W
08F0:  CLRF   x3A
08F2:  MOVWF  x39
08F4:  MOVLW  18
08F6:  ADDWF  x39,W
08F8:  MOVWF  01
08FA:  MOVLW  00
08FC:  ADDWFC x3A,W
08FE:  MOVWF  03
0900:  MOVF   01,W
0902:  ADDLW  1B
0904:  MOVWF  FE9
0906:  MOVLW  00
0908:  ADDWFC 03,W
090A:  MOVWF  FEA
090C:  MOVFF  FEC,03
0910:  MOVF   FED,F
0912:  MOVFF  FEF,01
0916:  MOVFF  03,02
091A:  MOVLB  0
091C:  BRA    09AA
.................... 		case I2C_REG_CH0_HTD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_reconnect_delay;	
091E:  MOVLB  1
0920:  MOVF   x38,W
0922:  MULLW  24
0924:  MOVF   FF3,W
0926:  CLRF   x3A
0928:  MOVWF  x39
092A:  MOVLW  1A
092C:  ADDWF  x39,W
092E:  MOVWF  01
0930:  MOVLW  00
0932:  ADDWFC x3A,W
0934:  MOVWF  03
0936:  MOVF   01,W
0938:  ADDLW  1B
093A:  MOVWF  FE9
093C:  MOVLW  00
093E:  ADDWFC 03,W
0940:  MOVWF  FEA
0942:  MOVFF  FEC,03
0946:  MOVF   FED,F
0948:  MOVFF  FEF,01
094C:  MOVFF  03,02
0950:  MOVLB  0
0952:  BRA    09AA
.................... 
.................... 		case I2C_REG_CH0_FUT_DISCONNECT_VALUE:
.................... 		case I2C_REG_CH0_FUT_DISCONNECT_DELAY:
.................... 		case I2C_REG_CH0_FUT_RECONNECT_VALUE:
.................... 		case I2C_REG_CH0_FUT_RECONNECT_DELAY:
.................... 			return (int16) 0xffff; /* not yet implemented */
0954:  MOVLW  FF
0956:  MOVWF  01
0958:  MOVWF  02
095A:  BRA    09AA
.................... 		
.................... 		/* configuration */
.................... 		case I2C_REG_CONFIG_HARDWARE_MODEL: 
.................... 			return (int16) 'D';
095C:  MOVLW  44
095E:  MOVWF  01
0960:  MOVLW  00
0962:  MOVWF  02
0964:  BRA    09AA
.................... 		case I2C_REG_CONFIG_HARDWARE_VERSION: 
.................... 			return (int16) '2';
0966:  MOVLW  32
0968:  MOVWF  01
096A:  MOVLW  00
096C:  MOVWF  02
096E:  BRA    09AA
.................... 		case I2C_REG_CONFIG_SOFTWARE_MODEL: 
.................... 			return (int16) 'L';
0970:  MOVLW  4C
0972:  MOVWF  01
0974:  MOVLW  00
0976:  MOVWF  02
0978:  BRA    09AA
.................... 		case I2C_REG_CONFIG_SOFTWARE_VERSION: 
.................... 			return (int16) '0';
097A:  MOVLW  30
097C:  MOVWF  01
097E:  MOVLW  00
0980:  MOVWF  02
0982:  BRA    09AA
.................... 		case I2C_REG_CONFIG_SOFTWARE_YEAR:
.................... 			return (int16) current.compile_year;
0984:  MOVFF  CB,01
0988:  CLRF   02
098A:  BRA    09AA
.................... 		case I2C_REG_CONFIG_SOFTWARE_MONTH:
.................... 			return (int16) current.compile_month;
098C:  MOVFF  CC,01
0990:  CLRF   02
0992:  BRA    09AA
.................... 		case I2C_REG_CONFIG_SOFTWARE_DAY:
.................... 			return (int16) current.compile_day;
0994:  MOVFF  CD,01
0998:  CLRF   02
099A:  BRA    09AA
.................... 
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			/* 1 if factory unlocked */ 
.................... 			return (int16) current.factory_unlocked; 	
099C:  MOVFF  CA,01
09A0:  CLRF   02
09A2:  BRA    09AA
.................... 
.................... 		/* we should have range checked, and never gotten here ... or read unimplemented (future) register */
.................... 		default: return (int16) 0xffff;
09A4:  MOVLW  FF
09A6:  MOVWF  01
09A8:  MOVWF  02
.................... 	}
09AA:  GOTO   0A68 (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... 
.................... 
.................... #include "interrupt_dcswc_module_latching_contactor.c"
.................... #int_timer2
.................... void isr_timer2() {
.................... 	timers.now_millisecond=1;
*
00D4:  BSF    xCF.2
.................... }
.................... 
.................... 
.................... 
.................... /* I2C slave interrupt */
00D6:  BCF    F9E.1
00D8:  GOTO   006C
.................... #byte SSPSTAT=GETENV("SFR:SSPSTAT")
.................... #INT_SSP
.................... void ssp_interrupt () {
.................... 	static int8 sstate;
.................... 	int8 state;
.................... 	int8 incoming;
.................... 	static int16 lastValue;
.................... 	static int8 lastMSB;
.................... 
.................... 	static int8 address; 
.................... 
.................... 	/* 
.................... 	our implementation of i2c_isr_state() that won't overflow and switch states
.................... 	but it will quit counting at 127 bytes. 
.................... 	If more bytes are needed, external counting variables can be used or the size of state can be made larger
.................... 	*/
.................... 
.................... 
.................... 	if ( ! bit_test(SSPSTAT,5) ) {
*
09C4:  BTFSC  FC7.5
09C6:  BRA    09D4
.................... 		/* address */
.................... 		sstate=0;
09C8:  MOVLB  1
09CA:  CLRF   x02
.................... 
.................... 		if ( bit_test(SSPSTAT,2) ) {
09CC:  BTFSS  FC7.2
09CE:  BRA    09D2
.................... 			/* set high bit if read */
.................... 			bit_set(sstate,7);
09D0:  BSF    x02.7
.................... 		}
.................... 	} else {
09D2:  MOVLB  0
.................... 		/* data */
.................... 	}
.................... 
.................... 	/* state variable used below is not incremented */
.................... 	state=sstate;
09D4:  MOVFF  102,134
.................... 
.................... 	/* increment the state counter for next pass through unless it will overflow us into another state */
.................... 	if ( sstate != 0x7f && sstate != 0xff) {
09D8:  MOVLB  1
09DA:  MOVF   x02,W
09DC:  SUBLW  7F
09DE:  BZ    09E8
09E0:  INCFSZ x02,W
09E2:  BRA    09E6
09E4:  BRA    09E8
.................... 		sstate++;
09E6:  INCF   x02,F
.................... 	}
.................... 
.................... 	
.................... 	/* i2c_isr_state() return an 8 bit int
.................... 		0 - Address match received with R/W bit clear, perform i2c_read( ) to read the I2C address.
.................... 		1-0x7F - Master has written data; i2c_read() will immediately return the data
.................... 		0x80 - Address match received with R/W bit set; perform i2c_read( ) to read the I2C address,
.................... 		and use i2c_write( ) to pre-load the transmit buffer for the next transaction (next I2C read
.................... 		performed by master will read this byte).
.................... 		0x81-0xFF - Transmission completed and acknowledged; respond with i2c_write() to pre-load
.................... 		the transmit buffer for the next transition (the next I2C read performed by master will read this
.................... 		byte).
.................... 		Function:
.................... 		Returns the state of I2C communications in I2C slave mode after an SSP interrupt. The return
.................... 		value increments with each byte received or sent.
.................... 		If 0x00 or 0x80 is returned, an i2C_read( ) needs to be performed to read the I2C address that
.................... 		was sent (it will match the address configured by #USE I2C so this value can be ignored)
.................... 	*/
.................... 
.................... 	if ( state <= 0x80 ) {                      
09E8:  MOVF   x34,W
09EA:  SUBLW  80
09EC:  BNC   0A50
.................... 		/* I2C master is sending us data */
.................... 		if ( 0x80 == state ) {
09EE:  MOVF   x34,W
09F0:  SUBLW  80
09F2:  BNZ   09FA
.................... 			/* i2c_read(2) casues the function to read the SSPBUF without releasing the clock */
.................... 			incoming = i2c_read(STREAM_SLAVE,2);
09F4:  MOVFF  FC9,135
.................... 		} else {
09F8:  BRA    0A06
.................... 			incoming = i2c_read(STREAM_SLAVE);
09FA:  BCF    FC6.6
09FC:  BTFSS  FC7.0
09FE:  BRA    09FC
0A00:  MOVF   FC9,W
0A02:  BSF    FC6.4
0A04:  MOVWF  x35
.................... 		}
.................... 
.................... 		if ( 1 == state ) {             
0A06:  DECFSZ x34,W
0A08:  BRA    0A12
.................... 			address = incoming<<1;
0A0A:  BCF    FD8.0
0A0C:  RLCF   x35,W
0A0E:  MOVWF  x06
.................... 		} else if ( state >= 2 && 0x80 != state ) {
0A10:  BRA    0A50
0A12:  MOVF   x34,W
0A14:  SUBLW  01
0A16:  BC    0A50
0A18:  MOVF   x34,W
0A1A:  SUBLW  80
0A1C:  BZ    0A50
.................... 			/* received byte is data */
.................... 		
.................... 			/* save MSB and we'll process it on next */
.................... 			if ( 2 == state ) {
0A1E:  MOVF   x34,W
0A20:  SUBLW  02
0A22:  BNZ   0A2A
.................... 				lastMSB=incoming;
0A24:  MOVFF  135,105
.................... 			} else if ( 3 == state ) {
0A28:  BRA    0A50
0A2A:  MOVF   x34,W
0A2C:  SUBLW  03
0A2E:  BNZ   0A50
.................... 				/* 16 bit value made of previous byte and this byte */
.................... 				write_i2c(address>>1,make16(lastMSB,incoming));
0A30:  BCF    FD8.0
0A32:  RRCF   x06,W
0A34:  MOVWF  x36
0A36:  MOVFF  105,138
0A3A:  MOVFF  135,137
0A3E:  MOVWF  x39
0A40:  MOVFF  105,13B
0A44:  MOVFF  135,13A
0A48:  MOVLB  0
0A4A:  GOTO   0004
0A4E:  MOVLB  1
.................... 
.................... 				/* this write only works for a single register per I2C transaction */
.................... 				/* this is not a BUG, but it would need to be implemented if this functionality is needed */
.................... 			}
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	if ( state >= 0x80 ) {
0A50:  MOVF   x34,W
0A52:  SUBLW  7F
0A54:  BC    0A8E
.................... 		/* I2C master is requesting data from us */
.................... 
.................... 		if ( ! bit_test(address,0) ) {
0A56:  BTFSC  x06.0
0A58:  BRA    0A7E
.................... 			/* read 16 bit register (register address half of I2C address) on even address */
.................... 			lastValue=map_i2c(address>>1);
0A5A:  BCF    FD8.0
0A5C:  RRCF   x06,W
0A5E:  MOVWF  x36
0A60:  MOVWF  x37
0A62:  MOVLB  0
0A64:  GOTO   0156
0A68:  MOVFF  02,104
0A6C:  MOVFF  01,103
.................... 
.................... 			/* send the MSB */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,1));
0A70:  MOVFF  104,136
0A74:  MOVFF  104,137
0A78:  RCALL  09AE
.................... 		} else {
0A7A:  BRA    0A8A
0A7C:  MOVLB  1
.................... 			/* send LSB of 16 bit register on odd address */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,0));
0A7E:  MOVFF  103,136
0A82:  MOVFF  103,137
0A86:  MOVLB  0
0A88:  RCALL  09AE
.................... 		}
.................... 		address++;
0A8A:  MOVLB  1
0A8C:  INCF   x06,F
.................... 	}
0A8E:  BCF    F9E.3
0A90:  MOVLB  0
0A92:  GOTO   006C
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... int8 read_dip_switch(void) {
.................... 	int16 adc;
.................... 
.................... 	set_adc_channel(9);
*
0D26:  MOVLW  24
0D28:  MOVWF  01
0D2A:  MOVF   FC2,W
0D2C:  ANDLW  C3
0D2E:  IORWF  01,W
0D30:  MOVWF  FC2
.................... 	delay_ms(1);
0D32:  MOVLW  01
0D34:  MOVLB  1
0D36:  MOVWF  x33
0D38:  MOVLB  0
0D3A:  RCALL  0CFC
.................... 	adc=read_adc();
0D3C:  BSF    FC2.1
0D3E:  BTFSC  FC2.1
0D40:  BRA    0D3E
0D42:  MOVFF  FC4,132
0D46:  MOVFF  FC3,131
.................... 
.................... 	/* (note that table is sorted by vout reading 
.................... 	SW3.1 (LSB) SW3.2 (MSB) VALUE ADC
....................     OFF         OFF         0     1023
.................... 	OFF         ON          2     682
....................     ON          OFF         1     511
.................... 	ON          ON          3     409
.................... 	*/
.................... 
.................... 	if ( adc > (1023-64) )
0D4A:  MOVLB  1
0D4C:  MOVF   x32,W
0D4E:  SUBLW  02
0D50:  BC    0D62
0D52:  XORLW  FF
0D54:  BNZ   0D5C
0D56:  MOVF   x31,W
0D58:  SUBLW  BF
0D5A:  BC    0D62
.................... 		return 0;
0D5C:  MOVLW  00
0D5E:  MOVWF  01
0D60:  BRA    0D92
.................... 	if ( adc > (682-64) )
0D62:  MOVF   x32,W
0D64:  SUBLW  01
0D66:  BC    0D78
0D68:  XORLW  FF
0D6A:  BNZ   0D72
0D6C:  MOVF   x31,W
0D6E:  SUBLW  6A
0D70:  BC    0D78
.................... 		return 2;
0D72:  MOVLW  02
0D74:  MOVWF  01
0D76:  BRA    0D92
.................... 	if ( adc > (511-64) )
0D78:  MOVF   x32,W
0D7A:  SUBLW  00
0D7C:  BC    0D8E
0D7E:  XORLW  FF
0D80:  BNZ   0D88
0D82:  MOVF   x31,W
0D84:  SUBLW  BF
0D86:  BC    0D8E
.................... 		return 1;
0D88:  MOVLW  01
0D8A:  MOVWF  01
0D8C:  BRA    0D92
.................... 
.................... 	return 3;
0D8E:  MOVLW  03
0D90:  MOVWF  01
0D92:  MOVLB  0
0D94:  RETURN 0
.................... }
.................... 
.................... void contactor_on_a(void) {
.................... 	/* only turn on contactor if it isn't on or needs a refresh */
.................... 	if ( 1 == timers.contactor_a )
*
208A:  BTFSS  xCF.5
208C:  BRA    2090
.................... 		return;
208E:  BRA    209E
.................... 
.................... 	timers.contactor_a_powersave=CONTACTOR_POWER_SAVE_MS;
2090:  MOVLW  C8
2092:  MOVWF  xD2
.................... 
.................... 	output_high(BRIDGE_A_A);
2094:  BCF    F94.3
2096:  BSF    F8B.3
.................... 	output_low(BRIDGE_A_B);
2098:  BCF    F94.4
209A:  BCF    F8B.4
.................... 
.................... 	timers.contactor_a=1;
209C:  BSF    xCF.5
209E:  GOTO   2792 (RETURN)
.................... }
.................... 
.................... void contactor_off_a(void) {
.................... 	/* only turn off contactor if it isn't on or needs a refresh */
.................... 	if ( 0 == timers.contactor_a )
20A2:  BTFSC  xCF.5
20A4:  BRA    20A8
.................... 		return;
20A6:  BRA    20B6
.................... 
.................... 	timers.contactor_a_powersave=CONTACTOR_POWER_SAVE_MS;
20A8:  MOVLW  C8
20AA:  MOVWF  xD2
.................... 
.................... 	output_low(BRIDGE_A_A);
20AC:  BCF    F94.3
20AE:  BCF    F8B.3
.................... 	output_high(BRIDGE_A_B);
20B0:  BCF    F94.4
20B2:  BSF    F8B.4
.................... 
.................... 	timers.contactor_a=0;
20B4:  BCF    xCF.5
20B6:  GOTO   279C (RETURN)
.................... }
.................... 
.................... void contactor_on_b(void) {
.................... 	/* only turn on contactor if it isn't on or needs a refresh */
.................... 	if ( 1 == timers.contactor_b )
20BA:  BTFSS  xCF.6
20BC:  BRA    20C0
.................... 		return;
20BE:  BRA    20CE
.................... 
.................... 	timers.contactor_b_powersave=CONTACTOR_POWER_SAVE_MS;
20C0:  MOVLW  C8
20C2:  MOVWF  xD3
.................... 
.................... 	output_high(BRIDGE_B_A);
20C4:  BCF    F94.5
20C6:  BSF    F8B.5
.................... 	output_low(BRIDGE_B_B);
20C8:  BCF    F94.6
20CA:  BCF    F8B.6
.................... 
.................... 	timers.contactor_b=1;
20CC:  BSF    xCF.6
20CE:  GOTO   27BE (RETURN)
.................... }
.................... 
.................... void contactor_off_b(void) {
.................... 	/* only turn off contactor if it isn't on or needs a refresh */
.................... 	if ( 0 == timers.contactor_b )
20D2:  BTFSC  xCF.6
20D4:  BRA    20D8
.................... 		return;
20D6:  BRA    20E6
.................... 
.................... 	timers.contactor_b_powersave=CONTACTOR_POWER_SAVE_MS;
20D8:  MOVLW  C8
20DA:  MOVWF  xD3
.................... 
.................... 	output_low(BRIDGE_B_A);
20DC:  BCF    F94.5
20DE:  BCF    F8B.5
.................... 	output_high(BRIDGE_B_B);
20E0:  BCF    F94.6
20E2:  BSF    F8B.6
.................... 
.................... 	timers.contactor_b=0;
20E4:  BCF    xCF.6
20E6:  GOTO   27C8 (RETURN)
.................... }
.................... 
.................... void contactor_logic(int8 c) {
.................... 	int16 adc;
.................... 
.................... 	/* command on. 65535 disables */
.................... 	if ( 65535 != channel[c].command_on_seconds ) {
*
12CE:  MOVLB  1
12D0:  MOVF   x11,W
12D2:  MULLW  17
12D4:  MOVF   FF3,W
12D6:  CLRF   x15
12D8:  MOVWF  x14
12DA:  MOVLW  01
12DC:  ADDWF  x14,W
12DE:  MOVWF  01
12E0:  MOVLW  00
12E2:  ADDWFC x15,W
12E4:  MOVWF  03
12E6:  MOVF   01,W
12E8:  ADDLW  D4
12EA:  MOVWF  FE9
12EC:  MOVLW  00
12EE:  ADDWFC 03,W
12F0:  MOVWF  FEA
12F2:  MOVFF  FEC,03
12F6:  MOVF   FED,F
12F8:  MOVF   FEF,W
12FA:  SUBLW  FF
12FC:  BNZ   1304
12FE:  INCFSZ 03,W
1300:  BRA    1304
1302:  BRA    149A
.................... 		if ( channel[c].command_on_seconds > 0 ) {
1304:  MOVF   x11,W
1306:  MULLW  17
1308:  MOVF   FF3,W
130A:  CLRF   x15
130C:  MOVWF  x14
130E:  MOVLW  01
1310:  ADDWF  x14,W
1312:  MOVWF  01
1314:  MOVLW  00
1316:  ADDWFC x15,W
1318:  MOVWF  03
131A:  MOVF   01,W
131C:  ADDLW  D4
131E:  MOVWF  FE9
1320:  MOVLW  00
1322:  ADDWFC 03,W
1324:  MOVWF  FEA
1326:  MOVFF  FEC,115
132A:  MOVF   FED,F
132C:  MOVFF  FEF,114
1330:  MOVF   x14,F
1332:  BNZ   1338
1334:  MOVF   x15,F
1336:  BZ    1366
.................... 			/* waiting to power on */
.................... 			channel[c].command_on_seconds--;
1338:  MOVF   x11,W
133A:  MULLW  17
133C:  MOVF   FF3,W
133E:  CLRF   x15
1340:  MOVWF  x14
1342:  MOVLW  01
1344:  ADDWF  x14,W
1346:  MOVWF  01
1348:  MOVLW  00
134A:  ADDWFC x15,W
134C:  MOVWF  03
134E:  MOVF   01,W
1350:  ADDLW  D4
1352:  MOVWF  FE9
1354:  MOVLW  00
1356:  ADDWFC 03,W
1358:  MOVWF  FEA
135A:  MOVLW  FF
135C:  ADDWF  FEF,F
135E:  BC    1364
1360:  MOVF   FEE,F
1362:  DECF   FED,F
.................... 		} else {
1364:  BRA    149A
.................... 			/* timer at zero, ready to power on or already powered on */
.................... 			if ( ! bit_test(channel[c].state,CH_STATE_BIT_CMD_ON) ) {
1366:  MOVF   x11,W
1368:  MULLW  17
136A:  MOVF   FF3,W
136C:  CLRF   x15
136E:  MOVWF  x14
1370:  MOVLW  D4
1372:  ADDWF  x14,W
1374:  MOVWF  FE9
1376:  MOVLW  00
1378:  ADDWFC x15,W
137A:  MOVWF  FEA
137C:  MOVFF  FEF,116
1380:  BTFSC  x16.1
1382:  BRA    13F8
.................... 				/* not currently set, so we set it and start the countdown */
.................... 				bit_set(channel[c].state,CH_STATE_BIT_CMD_ON);
1384:  MOVF   x11,W
1386:  MULLW  17
1388:  MOVF   FF3,W
138A:  CLRF   x15
138C:  MOVWF  x14
138E:  MOVLW  D4
1390:  ADDWF  x14,W
1392:  MOVWF  01
1394:  MOVLW  00
1396:  ADDWFC x15,W
1398:  MOVFF  01,FE9
139C:  MOVWF  FEA
139E:  BSF    FEF.1
.................... 				channel[c].command_on_hold_seconds=config.ch[c].command_on_hold_time;
13A0:  MOVF   x11,W
13A2:  MULLW  17
13A4:  MOVF   FF3,W
13A6:  CLRF   x15
13A8:  MOVWF  x14
13AA:  MOVLW  03
13AC:  ADDWF  x14,W
13AE:  MOVWF  01
13B0:  MOVLW  00
13B2:  ADDWFC x15,W
13B4:  MOVWF  03
13B6:  MOVF   01,W
13B8:  ADDLW  D4
13BA:  MOVWF  01
13BC:  MOVLW  00
13BE:  ADDWFC 03,F
13C0:  MOVFF  03,115
13C4:  MOVF   x11,W
13C6:  MULLW  24
13C8:  MOVF   FF3,W
13CA:  CLRF   x17
13CC:  MOVWF  x16
13CE:  MOVLW  1B
13D0:  ADDWF  x16,W
13D2:  MOVWF  FE9
13D4:  MOVLW  00
13D6:  ADDWFC x17,W
13D8:  MOVWF  FEA
13DA:  MOVFF  FEC,03
13DE:  MOVF   FED,F
13E0:  MOVFF  FEF,118
13E4:  MOVFF  115,FEA
13E8:  MOVFF  01,FE9
13EC:  MOVFF  03,FEC
13F0:  MOVF   FED,F
13F2:  MOVFF  118,FEF
.................... 			} else {
13F6:  BRA    149A
.................... 				/* set, so we clear it once countdown has elapsed */
.................... 				if ( 0==channel[c].command_on_hold_seconds ) {
13F8:  MOVF   x11,W
13FA:  MULLW  17
13FC:  MOVF   FF3,W
13FE:  CLRF   x15
1400:  MOVWF  x14
1402:  MOVLW  03
1404:  ADDWF  x14,W
1406:  MOVWF  01
1408:  MOVLW  00
140A:  ADDWFC x15,W
140C:  MOVWF  03
140E:  MOVF   01,W
1410:  ADDLW  D4
1412:  MOVWF  FE9
1414:  MOVLW  00
1416:  ADDWFC 03,W
1418:  MOVWF  FEA
141A:  MOVFF  FEC,03
141E:  MOVF   FED,F
1420:  MOVF   FEF,W
1422:  BNZ   146E
1424:  MOVF   03,F
1426:  BNZ   146E
.................... 					/* countdown elapsed, clear the flag and reset the timer */
.................... 					bit_clear(channel[c].state,CH_STATE_BIT_CMD_ON);
1428:  MOVF   x11,W
142A:  MULLW  17
142C:  MOVF   FF3,W
142E:  CLRF   x15
1430:  MOVWF  x14
1432:  MOVLW  D4
1434:  ADDWF  x14,W
1436:  MOVWF  01
1438:  MOVLW  00
143A:  ADDWFC x15,W
143C:  MOVFF  01,FE9
1440:  MOVWF  FEA
1442:  BCF    FEF.1
.................... 					channel[c].command_on_seconds=65535;
1444:  MOVF   x11,W
1446:  MULLW  17
1448:  MOVF   FF3,W
144A:  CLRF   x15
144C:  MOVWF  x14
144E:  MOVLW  01
1450:  ADDWF  x14,W
1452:  MOVWF  01
1454:  MOVLW  00
1456:  ADDWFC x15,W
1458:  MOVWF  03
145A:  MOVF   01,W
145C:  ADDLW  D4
145E:  MOVWF  FE9
1460:  MOVLW  00
1462:  ADDWFC 03,W
1464:  MOVWF  FEA
1466:  SETF   FEC
1468:  MOVF   FED,F
146A:  SETF   FEF
.................... 				} else {
146C:  BRA    149A
.................... 					channel[c].command_on_hold_seconds--;
146E:  MOVF   x11,W
1470:  MULLW  17
1472:  MOVF   FF3,W
1474:  CLRF   x15
1476:  MOVWF  x14
1478:  MOVLW  03
147A:  ADDWF  x14,W
147C:  MOVWF  01
147E:  MOVLW  00
1480:  ADDWFC x15,W
1482:  MOVWF  03
1484:  MOVF   01,W
1486:  ADDLW  D4
1488:  MOVWF  FE9
148A:  MOVLW  00
148C:  ADDWFC 03,W
148E:  MOVWF  FEA
1490:  MOVLW  FF
1492:  ADDWF  FEF,F
1494:  BC    149A
1496:  MOVF   FEE,F
1498:  DECF   FED,F
.................... 				}
.................... 			}		
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	/* command off. 65535 disables */
.................... 	if ( 65535 != channel[c].command_off_seconds ) {
149A:  MOVF   x11,W
149C:  MULLW  17
149E:  MOVF   FF3,W
14A0:  CLRF   x15
14A2:  MOVWF  x14
14A4:  MOVLW  05
14A6:  ADDWF  x14,W
14A8:  MOVWF  01
14AA:  MOVLW  00
14AC:  ADDWFC x15,W
14AE:  MOVWF  03
14B0:  MOVF   01,W
14B2:  ADDLW  D4
14B4:  MOVWF  FE9
14B6:  MOVLW  00
14B8:  ADDWFC 03,W
14BA:  MOVWF  FEA
14BC:  MOVFF  FEC,03
14C0:  MOVF   FED,F
14C2:  MOVF   FEF,W
14C4:  SUBLW  FF
14C6:  BNZ   14CE
14C8:  INCFSZ 03,W
14CA:  BRA    14CE
14CC:  BRA    1674
.................... 		if ( channel[c].command_off_seconds > 0 ) {
14CE:  MOVF   x11,W
14D0:  MULLW  17
14D2:  MOVF   FF3,W
14D4:  CLRF   x15
14D6:  MOVWF  x14
14D8:  MOVLW  05
14DA:  ADDWF  x14,W
14DC:  MOVWF  01
14DE:  MOVLW  00
14E0:  ADDWFC x15,W
14E2:  MOVWF  03
14E4:  MOVF   01,W
14E6:  ADDLW  D4
14E8:  MOVWF  FE9
14EA:  MOVLW  00
14EC:  ADDWFC 03,W
14EE:  MOVWF  FEA
14F0:  MOVFF  FEC,115
14F4:  MOVF   FED,F
14F6:  MOVFF  FEF,114
14FA:  MOVF   x14,F
14FC:  BNZ   1502
14FE:  MOVF   x15,F
1500:  BZ    1530
.................... 			/* waiting to power off */
.................... 			channel[c].command_off_seconds--;
1502:  MOVF   x11,W
1504:  MULLW  17
1506:  MOVF   FF3,W
1508:  CLRF   x15
150A:  MOVWF  x14
150C:  MOVLW  05
150E:  ADDWF  x14,W
1510:  MOVWF  01
1512:  MOVLW  00
1514:  ADDWFC x15,W
1516:  MOVWF  03
1518:  MOVF   01,W
151A:  ADDLW  D4
151C:  MOVWF  FE9
151E:  MOVLW  00
1520:  ADDWFC 03,W
1522:  MOVWF  FEA
1524:  MOVLW  FF
1526:  ADDWF  FEF,F
1528:  BC    152E
152A:  MOVF   FEE,F
152C:  DECF   FED,F
.................... 		} else {
152E:  BRA    1674
.................... 			/* timer at zero, ready to power off or already powered off */
.................... 			if ( ! bit_test(channel[c].state,CH_STATE_BIT_CMD_OFF) ) {
1530:  MOVF   x11,W
1532:  MULLW  17
1534:  MOVF   FF3,W
1536:  CLRF   x15
1538:  MOVWF  x14
153A:  MOVLW  D4
153C:  ADDWF  x14,W
153E:  MOVWF  FE9
1540:  MOVLW  00
1542:  ADDWFC x15,W
1544:  MOVWF  FEA
1546:  MOVFF  FEF,116
154A:  BTFSC  x16.2
154C:  BRA    15D2
.................... 				/* not currently set, so we set it and start the countdown */
.................... 				bit_set(channel[c].state,CH_STATE_BIT_CMD_OFF);
154E:  MOVF   x11,W
1550:  MULLW  17
1552:  MOVF   FF3,W
1554:  CLRF   x15
1556:  MOVWF  x14
1558:  MOVLW  D4
155A:  ADDWF  x14,W
155C:  MOVWF  01
155E:  MOVLW  00
1560:  ADDWFC x15,W
1562:  MOVFF  01,FE9
1566:  MOVWF  FEA
1568:  BSF    FEF.2
.................... 				channel[c].command_off_hold_seconds=config.ch[c].command_off_hold_time;
156A:  MOVF   x11,W
156C:  MULLW  17
156E:  MOVF   FF3,W
1570:  CLRF   x15
1572:  MOVWF  x14
1574:  MOVLW  07
1576:  ADDWF  x14,W
1578:  MOVWF  01
157A:  MOVLW  00
157C:  ADDWFC x15,W
157E:  MOVWF  03
1580:  MOVF   01,W
1582:  ADDLW  D4
1584:  MOVWF  01
1586:  MOVLW  00
1588:  ADDWFC 03,F
158A:  MOVFF  01,114
158E:  MOVFF  03,115
1592:  MOVF   x11,W
1594:  MULLW  24
1596:  MOVF   FF3,W
1598:  CLRF   x17
159A:  MOVWF  x16
159C:  MOVLW  02
159E:  ADDWF  x16,W
15A0:  MOVWF  01
15A2:  MOVLW  00
15A4:  ADDWFC x17,W
15A6:  MOVWF  03
15A8:  MOVF   01,W
15AA:  ADDLW  1B
15AC:  MOVWF  FE9
15AE:  MOVLW  00
15B0:  ADDWFC 03,W
15B2:  MOVWF  FEA
15B4:  MOVFF  FEC,03
15B8:  MOVF   FED,F
15BA:  MOVFF  FEF,116
15BE:  MOVFF  115,FEA
15C2:  MOVFF  114,FE9
15C6:  MOVFF  03,FEC
15CA:  MOVF   FED,F
15CC:  MOVFF  116,FEF
.................... 			} else {
15D0:  BRA    1674
.................... 				/* set, so we clear it once countdown has elapsed */
.................... 				if ( 0==channel[c].command_off_hold_seconds ) {
15D2:  MOVF   x11,W
15D4:  MULLW  17
15D6:  MOVF   FF3,W
15D8:  CLRF   x15
15DA:  MOVWF  x14
15DC:  MOVLW  07
15DE:  ADDWF  x14,W
15E0:  MOVWF  01
15E2:  MOVLW  00
15E4:  ADDWFC x15,W
15E6:  MOVWF  03
15E8:  MOVF   01,W
15EA:  ADDLW  D4
15EC:  MOVWF  FE9
15EE:  MOVLW  00
15F0:  ADDWFC 03,W
15F2:  MOVWF  FEA
15F4:  MOVFF  FEC,03
15F8:  MOVF   FED,F
15FA:  MOVF   FEF,W
15FC:  BNZ   1648
15FE:  MOVF   03,F
1600:  BNZ   1648
.................... 					/* countdown elapsed, clear the flag and reset the timer */
.................... 					bit_clear(channel[c].state,CH_STATE_BIT_CMD_OFF);
1602:  MOVF   x11,W
1604:  MULLW  17
1606:  MOVF   FF3,W
1608:  CLRF   x15
160A:  MOVWF  x14
160C:  MOVLW  D4
160E:  ADDWF  x14,W
1610:  MOVWF  01
1612:  MOVLW  00
1614:  ADDWFC x15,W
1616:  MOVFF  01,FE9
161A:  MOVWF  FEA
161C:  BCF    FEF.2
.................... 					channel[c].command_off_seconds=65535;
161E:  MOVF   x11,W
1620:  MULLW  17
1622:  MOVF   FF3,W
1624:  CLRF   x15
1626:  MOVWF  x14
1628:  MOVLW  05
162A:  ADDWF  x14,W
162C:  MOVWF  01
162E:  MOVLW  00
1630:  ADDWFC x15,W
1632:  MOVWF  03
1634:  MOVF   01,W
1636:  ADDLW  D4
1638:  MOVWF  FE9
163A:  MOVLW  00
163C:  ADDWFC 03,W
163E:  MOVWF  FEA
1640:  SETF   FEC
1642:  MOVF   FED,F
1644:  SETF   FEF
.................... 				} else {
1646:  BRA    1674
.................... 					channel[c].command_off_hold_seconds--;
1648:  MOVF   x11,W
164A:  MULLW  17
164C:  MOVF   FF3,W
164E:  CLRF   x15
1650:  MOVWF  x14
1652:  MOVLW  07
1654:  ADDWF  x14,W
1656:  MOVWF  01
1658:  MOVLW  00
165A:  ADDWFC x15,W
165C:  MOVWF  03
165E:  MOVF   01,W
1660:  ADDLW  D4
1662:  MOVWF  FE9
1664:  MOVLW  00
1666:  ADDWFC 03,W
1668:  MOVWF  FEA
166A:  MOVLW  FF
166C:  ADDWF  FEF,F
166E:  BC    1674
1670:  MOVF   FEE,F
1672:  DECF   FED,F
.................... 				}
.................... 			}		
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	/* LVD. 65535 disables */
.................... 	if ( 65535 != config.ch[c].lvd_disconnect_delay ) {
1674:  MOVF   x11,W
1676:  MULLW  24
1678:  MOVF   FF3,W
167A:  CLRF   x15
167C:  MOVWF  x14
167E:  MOVLW  06
1680:  ADDWF  x14,W
1682:  MOVWF  01
1684:  MOVLW  00
1686:  ADDWFC x15,W
1688:  MOVWF  03
168A:  MOVF   01,W
168C:  ADDLW  1B
168E:  MOVWF  FE9
1690:  MOVLW  00
1692:  ADDWFC 03,W
1694:  MOVWF  FEA
1696:  MOVFF  FEC,03
169A:  MOVF   FED,F
169C:  MOVF   FEF,W
169E:  SUBLW  FF
16A0:  BNZ   16A8
16A2:  INCFSZ 03,W
16A4:  BRA    16A8
16A6:  BRA    18EA
16A8:  CLRF   19
16AA:  BTFSC  FF2.7
16AC:  BSF    19.7
16AE:  BCF    FF2.7
.................... 		adc=adc_get(0);
16B0:  CLRF   x39
16B2:  MOVLB  0
16B4:  CALL   00DC
16B8:  BTFSC  19.7
16BA:  BSF    FF2.7
16BC:  MOVFF  02,113
16C0:  MOVFF  01,112
.................... 
.................... 		if ( adc > config.ch[c].lvd_reconnect_adc ) {
16C4:  MOVLB  1
16C6:  MOVF   x11,W
16C8:  MULLW  24
16CA:  MOVF   FF3,W
16CC:  CLRF   x15
16CE:  MOVWF  x14
16D0:  MOVLW  08
16D2:  ADDWF  x14,W
16D4:  MOVWF  01
16D6:  MOVLW  00
16D8:  ADDWFC x15,W
16DA:  MOVWF  03
16DC:  MOVF   01,W
16DE:  ADDLW  1B
16E0:  MOVWF  FE9
16E2:  MOVLW  00
16E4:  ADDWFC 03,W
16E6:  MOVWF  FEA
16E8:  MOVFF  FEC,03
16EC:  MOVF   FED,F
16EE:  MOVFF  FEF,01
16F2:  MOVF   03,W
16F4:  SUBWF  x13,W
16F6:  BNC   176A
16F8:  BNZ   1700
16FA:  MOVF   x12,W
16FC:  SUBWF  01,W
16FE:  BC    176A
.................... 			if ( channel[c].lvd_reconnect_delay_seconds > 0 ) {
1700:  MOVF   x11,W
1702:  MULLW  17
1704:  MOVF   FF3,W
1706:  CLRF   x15
1708:  MOVWF  x14
170A:  MOVLW  0B
170C:  ADDWF  x14,W
170E:  MOVWF  01
1710:  MOVLW  00
1712:  ADDWFC x15,W
1714:  MOVWF  03
1716:  MOVF   01,W
1718:  ADDLW  D4
171A:  MOVWF  FE9
171C:  MOVLW  00
171E:  ADDWFC 03,W
1720:  MOVWF  FEA
1722:  MOVF   FEF,F
1724:  BZ    174C
.................... 				channel[c].lvd_reconnect_delay_seconds--;
1726:  MOVF   x11,W
1728:  MULLW  17
172A:  MOVF   FF3,W
172C:  CLRF   x15
172E:  MOVWF  x14
1730:  MOVLW  0B
1732:  ADDWF  x14,W
1734:  MOVWF  01
1736:  MOVLW  00
1738:  ADDWFC x15,W
173A:  MOVWF  03
173C:  MOVF   01,W
173E:  ADDLW  D4
1740:  MOVWF  FE9
1742:  MOVLW  00
1744:  ADDWFC 03,W
1746:  MOVWF  FEA
1748:  DECF   FEF,F
.................... 			} else {
174A:  BRA    1768
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_LVD);
174C:  MOVF   x11,W
174E:  MULLW  17
1750:  MOVF   FF3,W
1752:  CLRF   x15
1754:  MOVWF  x14
1756:  MOVLW  D4
1758:  ADDWF  x14,W
175A:  MOVWF  01
175C:  MOVLW  00
175E:  ADDWFC x15,W
1760:  MOVFF  01,FE9
1764:  MOVWF  FEA
1766:  BCF    FEF.3
.................... 			}
.................... 		} else {
1768:  BRA    17CA
.................... 			channel[c].lvd_reconnect_delay_seconds=config.ch[c].lvd_reconnect_delay;
176A:  MOVF   x11,W
176C:  MULLW  17
176E:  MOVF   FF3,W
1770:  CLRF   x15
1772:  MOVWF  x14
1774:  MOVLW  0B
1776:  ADDWF  x14,W
1778:  MOVWF  01
177A:  MOVLW  00
177C:  ADDWFC x15,W
177E:  MOVWF  03
1780:  MOVF   01,W
1782:  ADDLW  D4
1784:  MOVWF  01
1786:  MOVLW  00
1788:  ADDWFC 03,F
178A:  MOVFF  01,114
178E:  MOVFF  03,115
1792:  MOVF   x11,W
1794:  MULLW  24
1796:  MOVF   FF3,W
1798:  CLRF   x17
179A:  MOVWF  x16
179C:  MOVLW  0A
179E:  ADDWF  x16,W
17A0:  MOVWF  01
17A2:  MOVLW  00
17A4:  ADDWFC x17,W
17A6:  MOVWF  03
17A8:  MOVF   01,W
17AA:  ADDLW  1B
17AC:  MOVWF  FE9
17AE:  MOVLW  00
17B0:  ADDWFC 03,W
17B2:  MOVWF  FEA
17B4:  MOVFF  FEC,03
17B8:  MOVF   FED,F
17BA:  MOVFF  FEF,116
17BE:  MOVFF  115,FEA
17C2:  MOVFF  114,FE9
17C6:  MOVFF  116,FEF
.................... 		}
.................... 
.................... 		if ( adc < config.ch[c].lvd_disconnect_adc ) {
17CA:  MOVF   x11,W
17CC:  MULLW  24
17CE:  MOVF   FF3,W
17D0:  CLRF   x15
17D2:  MOVWF  x14
17D4:  MOVLW  04
17D6:  ADDWF  x14,W
17D8:  MOVWF  01
17DA:  MOVLW  00
17DC:  ADDWFC x15,W
17DE:  MOVWF  03
17E0:  MOVF   01,W
17E2:  ADDLW  1B
17E4:  MOVWF  FE9
17E6:  MOVLW  00
17E8:  ADDWFC 03,W
17EA:  MOVWF  FEA
17EC:  MOVFF  FEC,03
17F0:  MOVF   FED,F
17F2:  MOVFF  FEF,01
17F6:  MOVF   x13,W
17F8:  SUBWF  03,W
17FA:  BNC   1884
17FC:  BNZ   1804
17FE:  MOVF   01,W
1800:  SUBWF  x12,W
1802:  BC    1884
.................... 			if ( channel[c].lvd_disconnect_delay_seconds > 0 ) {
1804:  MOVF   x11,W
1806:  MULLW  17
1808:  MOVF   FF3,W
180A:  CLRF   x15
180C:  MOVWF  x14
180E:  MOVLW  09
1810:  ADDWF  x14,W
1812:  MOVWF  01
1814:  MOVLW  00
1816:  ADDWFC x15,W
1818:  MOVWF  03
181A:  MOVF   01,W
181C:  ADDLW  D4
181E:  MOVWF  FE9
1820:  MOVLW  00
1822:  ADDWFC 03,W
1824:  MOVWF  FEA
1826:  MOVFF  FEC,115
182A:  MOVF   FED,F
182C:  MOVFF  FEF,114
1830:  MOVF   x14,F
1832:  BNZ   1838
1834:  MOVF   x15,F
1836:  BZ    1866
.................... 				channel[c].lvd_disconnect_delay_seconds--;
1838:  MOVF   x11,W
183A:  MULLW  17
183C:  MOVF   FF3,W
183E:  CLRF   x15
1840:  MOVWF  x14
1842:  MOVLW  09
1844:  ADDWF  x14,W
1846:  MOVWF  01
1848:  MOVLW  00
184A:  ADDWFC x15,W
184C:  MOVWF  03
184E:  MOVF   01,W
1850:  ADDLW  D4
1852:  MOVWF  FE9
1854:  MOVLW  00
1856:  ADDWFC 03,W
1858:  MOVWF  FEA
185A:  MOVLW  FF
185C:  ADDWF  FEF,F
185E:  BC    1864
1860:  MOVF   FEE,F
1862:  DECF   FED,F
.................... 			} else {
1864:  BRA    1882
.................... 				bit_set(channel[c].state,CH_STATE_BIT_LVD);
1866:  MOVF   x11,W
1868:  MULLW  17
186A:  MOVF   FF3,W
186C:  CLRF   x15
186E:  MOVWF  x14
1870:  MOVLW  D4
1872:  ADDWF  x14,W
1874:  MOVWF  01
1876:  MOVLW  00
1878:  ADDWFC x15,W
187A:  MOVFF  01,FE9
187E:  MOVWF  FEA
1880:  BSF    FEF.3
.................... 			}
.................... 		} else {
1882:  BRA    18EA
.................... 			channel[c].lvd_disconnect_delay_seconds=config.ch[c].lvd_disconnect_delay;
1884:  MOVF   x11,W
1886:  MULLW  17
1888:  MOVF   FF3,W
188A:  CLRF   x15
188C:  MOVWF  x14
188E:  MOVLW  09
1890:  ADDWF  x14,W
1892:  MOVWF  01
1894:  MOVLW  00
1896:  ADDWFC x15,W
1898:  MOVWF  03
189A:  MOVF   01,W
189C:  ADDLW  D4
189E:  MOVWF  01
18A0:  MOVLW  00
18A2:  ADDWFC 03,F
18A4:  MOVFF  01,114
18A8:  MOVFF  03,115
18AC:  MOVF   x11,W
18AE:  MULLW  24
18B0:  MOVF   FF3,W
18B2:  CLRF   x17
18B4:  MOVWF  x16
18B6:  MOVLW  06
18B8:  ADDWF  x16,W
18BA:  MOVWF  01
18BC:  MOVLW  00
18BE:  ADDWFC x17,W
18C0:  MOVWF  03
18C2:  MOVF   01,W
18C4:  ADDLW  1B
18C6:  MOVWF  FE9
18C8:  MOVLW  00
18CA:  ADDWFC 03,W
18CC:  MOVWF  FEA
18CE:  MOVFF  FEC,03
18D2:  MOVF   FED,F
18D4:  MOVFF  FEF,116
18D8:  MOVFF  115,FEA
18DC:  MOVFF  114,FE9
18E0:  MOVFF  03,FEC
18E4:  MOVF   FED,F
18E6:  MOVFF  116,FEF
.................... 		}
.................... 	}
.................... 
.................... 	/* HVD. 65535 disables */
.................... 	if ( 65535 != config.ch[c].hvd_disconnect_delay ) {
18EA:  MOVF   x11,W
18EC:  MULLW  24
18EE:  MOVF   FF3,W
18F0:  CLRF   x15
18F2:  MOVWF  x14
18F4:  MOVLW  0E
18F6:  ADDWF  x14,W
18F8:  MOVWF  01
18FA:  MOVLW  00
18FC:  ADDWFC x15,W
18FE:  MOVWF  03
1900:  MOVF   01,W
1902:  ADDLW  1B
1904:  MOVWF  FE9
1906:  MOVLW  00
1908:  ADDWFC 03,W
190A:  MOVWF  FEA
190C:  MOVFF  FEC,03
1910:  MOVF   FED,F
1912:  MOVF   FEF,W
1914:  SUBLW  FF
1916:  BNZ   191E
1918:  INCFSZ 03,W
191A:  BRA    191E
191C:  BRA    1B60
191E:  CLRF   19
1920:  BTFSC  FF2.7
1922:  BSF    19.7
1924:  BCF    FF2.7
.................... 		adc=adc_get(0);
1926:  CLRF   x39
1928:  MOVLB  0
192A:  CALL   00DC
192E:  BTFSC  19.7
1930:  BSF    FF2.7
1932:  MOVFF  02,113
1936:  MOVFF  01,112
.................... 
.................... 		if ( adc < config.ch[c].hvd_reconnect_adc ) {
193A:  MOVLB  1
193C:  MOVF   x11,W
193E:  MULLW  24
1940:  MOVF   FF3,W
1942:  CLRF   x15
1944:  MOVWF  x14
1946:  MOVLW  10
1948:  ADDWF  x14,W
194A:  MOVWF  01
194C:  MOVLW  00
194E:  ADDWFC x15,W
1950:  MOVWF  03
1952:  MOVF   01,W
1954:  ADDLW  1B
1956:  MOVWF  FE9
1958:  MOVLW  00
195A:  ADDWFC 03,W
195C:  MOVWF  FEA
195E:  MOVFF  FEC,03
1962:  MOVF   FED,F
1964:  MOVFF  FEF,01
1968:  MOVF   x13,W
196A:  SUBWF  03,W
196C:  BNC   19E0
196E:  BNZ   1976
1970:  MOVF   01,W
1972:  SUBWF  x12,W
1974:  BC    19E0
.................... 			if ( channel[c].hvd_reconnect_delay_seconds > 0 ) {
1976:  MOVF   x11,W
1978:  MULLW  17
197A:  MOVF   FF3,W
197C:  CLRF   x15
197E:  MOVWF  x14
1980:  MOVLW  0E
1982:  ADDWF  x14,W
1984:  MOVWF  01
1986:  MOVLW  00
1988:  ADDWFC x15,W
198A:  MOVWF  03
198C:  MOVF   01,W
198E:  ADDLW  D4
1990:  MOVWF  FE9
1992:  MOVLW  00
1994:  ADDWFC 03,W
1996:  MOVWF  FEA
1998:  MOVF   FEF,F
199A:  BZ    19C2
.................... 				channel[c].hvd_reconnect_delay_seconds--;
199C:  MOVF   x11,W
199E:  MULLW  17
19A0:  MOVF   FF3,W
19A2:  CLRF   x15
19A4:  MOVWF  x14
19A6:  MOVLW  0E
19A8:  ADDWF  x14,W
19AA:  MOVWF  01
19AC:  MOVLW  00
19AE:  ADDWFC x15,W
19B0:  MOVWF  03
19B2:  MOVF   01,W
19B4:  ADDLW  D4
19B6:  MOVWF  FE9
19B8:  MOVLW  00
19BA:  ADDWFC 03,W
19BC:  MOVWF  FEA
19BE:  DECF   FEF,F
.................... 			} else {
19C0:  BRA    19DE
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_HVD);
19C2:  MOVF   x11,W
19C4:  MULLW  17
19C6:  MOVF   FF3,W
19C8:  CLRF   x15
19CA:  MOVWF  x14
19CC:  MOVLW  D4
19CE:  ADDWF  x14,W
19D0:  MOVWF  01
19D2:  MOVLW  00
19D4:  ADDWFC x15,W
19D6:  MOVFF  01,FE9
19DA:  MOVWF  FEA
19DC:  BCF    FEF.4
.................... 			}
.................... 		} else {
19DE:  BRA    1A40
.................... 			channel[c].hvd_reconnect_delay_seconds=config.ch[c].hvd_reconnect_delay;
19E0:  MOVF   x11,W
19E2:  MULLW  17
19E4:  MOVF   FF3,W
19E6:  CLRF   x15
19E8:  MOVWF  x14
19EA:  MOVLW  0E
19EC:  ADDWF  x14,W
19EE:  MOVWF  01
19F0:  MOVLW  00
19F2:  ADDWFC x15,W
19F4:  MOVWF  03
19F6:  MOVF   01,W
19F8:  ADDLW  D4
19FA:  MOVWF  01
19FC:  MOVLW  00
19FE:  ADDWFC 03,F
1A00:  MOVFF  01,114
1A04:  MOVFF  03,115
1A08:  MOVF   x11,W
1A0A:  MULLW  24
1A0C:  MOVF   FF3,W
1A0E:  CLRF   x17
1A10:  MOVWF  x16
1A12:  MOVLW  12
1A14:  ADDWF  x16,W
1A16:  MOVWF  01
1A18:  MOVLW  00
1A1A:  ADDWFC x17,W
1A1C:  MOVWF  03
1A1E:  MOVF   01,W
1A20:  ADDLW  1B
1A22:  MOVWF  FE9
1A24:  MOVLW  00
1A26:  ADDWFC 03,W
1A28:  MOVWF  FEA
1A2A:  MOVFF  FEC,03
1A2E:  MOVF   FED,F
1A30:  MOVFF  FEF,116
1A34:  MOVFF  115,FEA
1A38:  MOVFF  114,FE9
1A3C:  MOVFF  116,FEF
.................... 		}
.................... 
.................... 		if ( adc > config.ch[c].hvd_disconnect_adc ) {
1A40:  MOVF   x11,W
1A42:  MULLW  24
1A44:  MOVF   FF3,W
1A46:  CLRF   x15
1A48:  MOVWF  x14
1A4A:  MOVLW  0C
1A4C:  ADDWF  x14,W
1A4E:  MOVWF  01
1A50:  MOVLW  00
1A52:  ADDWFC x15,W
1A54:  MOVWF  03
1A56:  MOVF   01,W
1A58:  ADDLW  1B
1A5A:  MOVWF  FE9
1A5C:  MOVLW  00
1A5E:  ADDWFC 03,W
1A60:  MOVWF  FEA
1A62:  MOVFF  FEC,03
1A66:  MOVF   FED,F
1A68:  MOVFF  FEF,01
1A6C:  MOVF   03,W
1A6E:  SUBWF  x13,W
1A70:  BNC   1AFA
1A72:  BNZ   1A7A
1A74:  MOVF   x12,W
1A76:  SUBWF  01,W
1A78:  BC    1AFA
.................... 			if ( channel[c].hvd_disconnect_delay_seconds > 0 ) {
1A7A:  MOVF   x11,W
1A7C:  MULLW  17
1A7E:  MOVF   FF3,W
1A80:  CLRF   x15
1A82:  MOVWF  x14
1A84:  MOVLW  0C
1A86:  ADDWF  x14,W
1A88:  MOVWF  01
1A8A:  MOVLW  00
1A8C:  ADDWFC x15,W
1A8E:  MOVWF  03
1A90:  MOVF   01,W
1A92:  ADDLW  D4
1A94:  MOVWF  FE9
1A96:  MOVLW  00
1A98:  ADDWFC 03,W
1A9A:  MOVWF  FEA
1A9C:  MOVFF  FEC,115
1AA0:  MOVF   FED,F
1AA2:  MOVFF  FEF,114
1AA6:  MOVF   x14,F
1AA8:  BNZ   1AAE
1AAA:  MOVF   x15,F
1AAC:  BZ    1ADC
.................... 				channel[c].hvd_disconnect_delay_seconds--;
1AAE:  MOVF   x11,W
1AB0:  MULLW  17
1AB2:  MOVF   FF3,W
1AB4:  CLRF   x15
1AB6:  MOVWF  x14
1AB8:  MOVLW  0C
1ABA:  ADDWF  x14,W
1ABC:  MOVWF  01
1ABE:  MOVLW  00
1AC0:  ADDWFC x15,W
1AC2:  MOVWF  03
1AC4:  MOVF   01,W
1AC6:  ADDLW  D4
1AC8:  MOVWF  FE9
1ACA:  MOVLW  00
1ACC:  ADDWFC 03,W
1ACE:  MOVWF  FEA
1AD0:  MOVLW  FF
1AD2:  ADDWF  FEF,F
1AD4:  BC    1ADA
1AD6:  MOVF   FEE,F
1AD8:  DECF   FED,F
.................... 			} else {
1ADA:  BRA    1AF8
.................... 				bit_set(channel[c].state,CH_STATE_BIT_HVD);
1ADC:  MOVF   x11,W
1ADE:  MULLW  17
1AE0:  MOVF   FF3,W
1AE2:  CLRF   x15
1AE4:  MOVWF  x14
1AE6:  MOVLW  D4
1AE8:  ADDWF  x14,W
1AEA:  MOVWF  01
1AEC:  MOVLW  00
1AEE:  ADDWFC x15,W
1AF0:  MOVFF  01,FE9
1AF4:  MOVWF  FEA
1AF6:  BSF    FEF.4
.................... 			}
.................... 		} else {
1AF8:  BRA    1B60
.................... 			channel[c].hvd_disconnect_delay_seconds=config.ch[c].hvd_disconnect_delay;
1AFA:  MOVF   x11,W
1AFC:  MULLW  17
1AFE:  MOVF   FF3,W
1B00:  CLRF   x15
1B02:  MOVWF  x14
1B04:  MOVLW  0C
1B06:  ADDWF  x14,W
1B08:  MOVWF  01
1B0A:  MOVLW  00
1B0C:  ADDWFC x15,W
1B0E:  MOVWF  03
1B10:  MOVF   01,W
1B12:  ADDLW  D4
1B14:  MOVWF  01
1B16:  MOVLW  00
1B18:  ADDWFC 03,F
1B1A:  MOVFF  01,114
1B1E:  MOVFF  03,115
1B22:  MOVF   x11,W
1B24:  MULLW  24
1B26:  MOVF   FF3,W
1B28:  CLRF   x17
1B2A:  MOVWF  x16
1B2C:  MOVLW  0E
1B2E:  ADDWF  x16,W
1B30:  MOVWF  01
1B32:  MOVLW  00
1B34:  ADDWFC x17,W
1B36:  MOVWF  03
1B38:  MOVF   01,W
1B3A:  ADDLW  1B
1B3C:  MOVWF  FE9
1B3E:  MOVLW  00
1B40:  ADDWFC 03,W
1B42:  MOVWF  FEA
1B44:  MOVFF  FEC,03
1B48:  MOVF   FED,F
1B4A:  MOVFF  FEF,116
1B4E:  MOVFF  115,FEA
1B52:  MOVFF  114,FE9
1B56:  MOVFF  03,FEC
1B5A:  MOVF   FED,F
1B5C:  MOVFF  116,FEF
.................... 		}
.................... 	}
.................... 
.................... 	/* LTD. 65535 disables */
.................... 	if ( 65535 != config.ch[c].ltd_disconnect_delay ) {
1B60:  MOVF   x11,W
1B62:  MULLW  24
1B64:  MOVF   FF3,W
1B66:  CLRF   x15
1B68:  MOVWF  x14
1B6A:  MOVLW  16
1B6C:  ADDWF  x14,W
1B6E:  MOVWF  01
1B70:  MOVLW  00
1B72:  ADDWFC x15,W
1B74:  MOVWF  03
1B76:  MOVF   01,W
1B78:  ADDLW  1B
1B7A:  MOVWF  FE9
1B7C:  MOVLW  00
1B7E:  ADDWFC 03,W
1B80:  MOVWF  FEA
1B82:  MOVFF  FEC,03
1B86:  MOVF   FED,F
1B88:  MOVF   FEF,W
1B8A:  SUBLW  FF
1B8C:  BNZ   1B94
1B8E:  INCFSZ 03,W
1B90:  BRA    1B94
1B92:  BRA    1DF4
1B94:  CLRF   19
1B96:  BTFSC  FF2.7
1B98:  BSF    19.7
1B9A:  BCF    FF2.7
.................... 		adc=adc_get(1);
1B9C:  MOVLW  01
1B9E:  MOVWF  x39
1BA0:  MOVLB  0
1BA2:  CALL   00DC
1BA6:  BTFSC  19.7
1BA8:  BSF    FF2.7
1BAA:  MOVFF  02,113
1BAE:  MOVFF  01,112
.................... 
.................... 		if ( adc < config.ch[c].ltd_reconnect_adc ) {
1BB2:  MOVLB  1
1BB4:  MOVF   x11,W
1BB6:  MULLW  24
1BB8:  MOVF   FF3,W
1BBA:  CLRF   x15
1BBC:  MOVWF  x14
1BBE:  MOVLW  18
1BC0:  ADDWF  x14,W
1BC2:  MOVWF  01
1BC4:  MOVLW  00
1BC6:  ADDWFC x15,W
1BC8:  MOVWF  03
1BCA:  MOVF   01,W
1BCC:  ADDLW  1B
1BCE:  MOVWF  FE9
1BD0:  MOVLW  00
1BD2:  ADDWFC 03,W
1BD4:  MOVWF  FEA
1BD6:  MOVFF  FEC,03
1BDA:  MOVF   FED,F
1BDC:  MOVFF  FEF,01
1BE0:  MOVF   x13,W
1BE2:  SUBWF  03,W
1BE4:  BNC   1C6E
1BE6:  BNZ   1BEE
1BE8:  MOVF   01,W
1BEA:  SUBWF  x12,W
1BEC:  BC    1C6E
.................... 			if ( channel[c].ltd_reconnect_delay_seconds > 0 ) {
1BEE:  MOVF   x11,W
1BF0:  MULLW  17
1BF2:  MOVF   FF3,W
1BF4:  CLRF   x15
1BF6:  MOVWF  x14
1BF8:  MOVLW  11
1BFA:  ADDWF  x14,W
1BFC:  MOVWF  01
1BFE:  MOVLW  00
1C00:  ADDWFC x15,W
1C02:  MOVWF  03
1C04:  MOVF   01,W
1C06:  ADDLW  D4
1C08:  MOVWF  FE9
1C0A:  MOVLW  00
1C0C:  ADDWFC 03,W
1C0E:  MOVWF  FEA
1C10:  MOVFF  FEC,115
1C14:  MOVF   FED,F
1C16:  MOVFF  FEF,114
1C1A:  MOVF   x14,F
1C1C:  BNZ   1C22
1C1E:  MOVF   x15,F
1C20:  BZ    1C50
.................... 				channel[c].ltd_reconnect_delay_seconds--;
1C22:  MOVF   x11,W
1C24:  MULLW  17
1C26:  MOVF   FF3,W
1C28:  CLRF   x15
1C2A:  MOVWF  x14
1C2C:  MOVLW  11
1C2E:  ADDWF  x14,W
1C30:  MOVWF  01
1C32:  MOVLW  00
1C34:  ADDWFC x15,W
1C36:  MOVWF  03
1C38:  MOVF   01,W
1C3A:  ADDLW  D4
1C3C:  MOVWF  FE9
1C3E:  MOVLW  00
1C40:  ADDWFC 03,W
1C42:  MOVWF  FEA
1C44:  MOVLW  FF
1C46:  ADDWF  FEF,F
1C48:  BC    1C4E
1C4A:  MOVF   FEE,F
1C4C:  DECF   FED,F
.................... 			} else {
1C4E:  BRA    1C6C
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_LTD);
1C50:  MOVF   x11,W
1C52:  MULLW  17
1C54:  MOVF   FF3,W
1C56:  CLRF   x15
1C58:  MOVWF  x14
1C5A:  MOVLW  D4
1C5C:  ADDWF  x14,W
1C5E:  MOVWF  01
1C60:  MOVLW  00
1C62:  ADDWFC x15,W
1C64:  MOVFF  01,FE9
1C68:  MOVWF  FEA
1C6A:  BCF    FEF.5
.................... 			}
.................... 		} else {
1C6C:  BRA    1CD4
.................... 			channel[c].ltd_reconnect_delay_seconds=config.ch[c].ltd_reconnect_delay;
1C6E:  MOVF   x11,W
1C70:  MULLW  17
1C72:  MOVF   FF3,W
1C74:  CLRF   x15
1C76:  MOVWF  x14
1C78:  MOVLW  11
1C7A:  ADDWF  x14,W
1C7C:  MOVWF  01
1C7E:  MOVLW  00
1C80:  ADDWFC x15,W
1C82:  MOVWF  03
1C84:  MOVF   01,W
1C86:  ADDLW  D4
1C88:  MOVWF  01
1C8A:  MOVLW  00
1C8C:  ADDWFC 03,F
1C8E:  MOVFF  01,114
1C92:  MOVFF  03,115
1C96:  MOVF   x11,W
1C98:  MULLW  24
1C9A:  MOVF   FF3,W
1C9C:  CLRF   x17
1C9E:  MOVWF  x16
1CA0:  MOVLW  1A
1CA2:  ADDWF  x16,W
1CA4:  MOVWF  01
1CA6:  MOVLW  00
1CA8:  ADDWFC x17,W
1CAA:  MOVWF  03
1CAC:  MOVF   01,W
1CAE:  ADDLW  1B
1CB0:  MOVWF  FE9
1CB2:  MOVLW  00
1CB4:  ADDWFC 03,W
1CB6:  MOVWF  FEA
1CB8:  MOVFF  FEC,03
1CBC:  MOVF   FED,F
1CBE:  MOVFF  FEF,116
1CC2:  MOVFF  115,FEA
1CC6:  MOVFF  114,FE9
1CCA:  MOVFF  03,FEC
1CCE:  MOVF   FED,F
1CD0:  MOVFF  116,FEF
.................... 		}
.................... 
.................... 		if ( adc > config.ch[c].ltd_disconnect_adc ) {
1CD4:  MOVF   x11,W
1CD6:  MULLW  24
1CD8:  MOVF   FF3,W
1CDA:  CLRF   x15
1CDC:  MOVWF  x14
1CDE:  MOVLW  14
1CE0:  ADDWF  x14,W
1CE2:  MOVWF  01
1CE4:  MOVLW  00
1CE6:  ADDWFC x15,W
1CE8:  MOVWF  03
1CEA:  MOVF   01,W
1CEC:  ADDLW  1B
1CEE:  MOVWF  FE9
1CF0:  MOVLW  00
1CF2:  ADDWFC 03,W
1CF4:  MOVWF  FEA
1CF6:  MOVFF  FEC,03
1CFA:  MOVF   FED,F
1CFC:  MOVFF  FEF,01
1D00:  MOVF   03,W
1D02:  SUBWF  x13,W
1D04:  BNC   1D8E
1D06:  BNZ   1D0E
1D08:  MOVF   x12,W
1D0A:  SUBWF  01,W
1D0C:  BC    1D8E
.................... 			if ( channel[c].ltd_disconnect_delay_seconds > 0 ) {
1D0E:  MOVF   x11,W
1D10:  MULLW  17
1D12:  MOVF   FF3,W
1D14:  CLRF   x15
1D16:  MOVWF  x14
1D18:  MOVLW  0F
1D1A:  ADDWF  x14,W
1D1C:  MOVWF  01
1D1E:  MOVLW  00
1D20:  ADDWFC x15,W
1D22:  MOVWF  03
1D24:  MOVF   01,W
1D26:  ADDLW  D4
1D28:  MOVWF  FE9
1D2A:  MOVLW  00
1D2C:  ADDWFC 03,W
1D2E:  MOVWF  FEA
1D30:  MOVFF  FEC,115
1D34:  MOVF   FED,F
1D36:  MOVFF  FEF,114
1D3A:  MOVF   x14,F
1D3C:  BNZ   1D42
1D3E:  MOVF   x15,F
1D40:  BZ    1D70
.................... 				channel[c].ltd_disconnect_delay_seconds--;
1D42:  MOVF   x11,W
1D44:  MULLW  17
1D46:  MOVF   FF3,W
1D48:  CLRF   x15
1D4A:  MOVWF  x14
1D4C:  MOVLW  0F
1D4E:  ADDWF  x14,W
1D50:  MOVWF  01
1D52:  MOVLW  00
1D54:  ADDWFC x15,W
1D56:  MOVWF  03
1D58:  MOVF   01,W
1D5A:  ADDLW  D4
1D5C:  MOVWF  FE9
1D5E:  MOVLW  00
1D60:  ADDWFC 03,W
1D62:  MOVWF  FEA
1D64:  MOVLW  FF
1D66:  ADDWF  FEF,F
1D68:  BC    1D6E
1D6A:  MOVF   FEE,F
1D6C:  DECF   FED,F
.................... 			} else {
1D6E:  BRA    1D8C
.................... 				bit_set(channel[c].state,CH_STATE_BIT_LTD);
1D70:  MOVF   x11,W
1D72:  MULLW  17
1D74:  MOVF   FF3,W
1D76:  CLRF   x15
1D78:  MOVWF  x14
1D7A:  MOVLW  D4
1D7C:  ADDWF  x14,W
1D7E:  MOVWF  01
1D80:  MOVLW  00
1D82:  ADDWFC x15,W
1D84:  MOVFF  01,FE9
1D88:  MOVWF  FEA
1D8A:  BSF    FEF.5
.................... 			}
.................... 		} else {
1D8C:  BRA    1DF4
.................... 			channel[c].ltd_disconnect_delay_seconds=config.ch[c].ltd_disconnect_delay;
1D8E:  MOVF   x11,W
1D90:  MULLW  17
1D92:  MOVF   FF3,W
1D94:  CLRF   x15
1D96:  MOVWF  x14
1D98:  MOVLW  0F
1D9A:  ADDWF  x14,W
1D9C:  MOVWF  01
1D9E:  MOVLW  00
1DA0:  ADDWFC x15,W
1DA2:  MOVWF  03
1DA4:  MOVF   01,W
1DA6:  ADDLW  D4
1DA8:  MOVWF  01
1DAA:  MOVLW  00
1DAC:  ADDWFC 03,F
1DAE:  MOVFF  01,114
1DB2:  MOVFF  03,115
1DB6:  MOVF   x11,W
1DB8:  MULLW  24
1DBA:  MOVF   FF3,W
1DBC:  CLRF   x17
1DBE:  MOVWF  x16
1DC0:  MOVLW  16
1DC2:  ADDWF  x16,W
1DC4:  MOVWF  01
1DC6:  MOVLW  00
1DC8:  ADDWFC x17,W
1DCA:  MOVWF  03
1DCC:  MOVF   01,W
1DCE:  ADDLW  1B
1DD0:  MOVWF  FE9
1DD2:  MOVLW  00
1DD4:  ADDWFC 03,W
1DD6:  MOVWF  FEA
1DD8:  MOVFF  FEC,03
1DDC:  MOVF   FED,F
1DDE:  MOVFF  FEF,116
1DE2:  MOVFF  115,FEA
1DE6:  MOVFF  114,FE9
1DEA:  MOVFF  03,FEC
1DEE:  MOVF   FED,F
1DF0:  MOVFF  116,FEF
.................... 		}
.................... 	}
1DF4:  MOVLB  0
1DF6:  RETURN 0
.................... 
.................... 
.................... 	/* TODO: implement Low Temperature Disconnect (LTD) and High Temperature Disconnect (HTD) */
.................... }
.................... 
.................... void contactor_set() {
1DF8:  GOTO   1E7C (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... 
.................... void periodic_millisecond(void) {
.................... 	static int8 uptimeticks=0;
.................... 	static int16 adcTicks=0;
.................... 	static int16 ticks=0;
.................... 
.................... 
.................... 	timers.now_millisecond=0;
1DFC:  BCF    xCF.2
.................... 
.................... 	/* LED control */
.................... 	if ( 0==timers.led_on_a ) {
1DFE:  MOVF   xD0,F
1E00:  BNZ   1E08
.................... 		output_low(LED_A);
1E02:  BCF    F94.1
1E04:  BCF    F8B.1
.................... 	} else {
1E06:  BRA    1E0E
.................... 		output_high(LED_A);
1E08:  BCF    F94.1
1E0A:  BSF    F8B.1
.................... 		timers.led_on_a--;
1E0C:  DECF   xD0,F
.................... 	}
.................... 	if ( 0==timers.led_on_b ) {
1E0E:  MOVF   xD1,F
1E10:  BNZ   1E18
.................... 		output_low(LED_B);
1E12:  BCF    F94.2
1E14:  BCF    F8B.2
.................... 	} else {
1E16:  BRA    1E1E
.................... 		output_high(LED_B);
1E18:  BCF    F94.2
1E1A:  BSF    F8B.2
.................... 		timers.led_on_b--;
1E1C:  DECF   xD1,F
.................... 	}
.................... 
.................... 	/* some other random stuff that we don't need to do every cycle in main */
.................... 	if ( current.interval_milliseconds < 65535 ) {
1E1E:  INCFSZ xC8,W
1E20:  BRA    1E28
1E22:  INCFSZ xC9,W
1E24:  BRA    1E28
1E26:  BRA    1E2E
.................... 		current.interval_milliseconds++;
1E28:  INCF   xC8,F
1E2A:  BTFSC  FD8.2
1E2C:  INCF   xC9,F
.................... 	}
.................... 
.................... 	/* contactor timeout */
.................... 	if ( 0 == timers.contactor_a_powersave ) {
1E2E:  MOVF   xD2,F
1E30:  BNZ   1E3C
.................... 		output_low(BRIDGE_A_A);
1E32:  BCF    F94.3
1E34:  BCF    F8B.3
.................... 		output_low(BRIDGE_A_B);
1E36:  BCF    F94.4
1E38:  BCF    F8B.4
.................... 	} else {
1E3A:  BRA    1E3E
.................... 		timers.contactor_a_powersave--;
1E3C:  DECF   xD2,F
.................... 	}
.................... 	if ( 0 == timers.contactor_b_powersave ) {
1E3E:  MOVF   xD3,F
1E40:  BNZ   1E4C
.................... 		output_low(BRIDGE_B_A);
1E42:  BCF    F94.5
1E44:  BCF    F8B.5
.................... 		output_low(BRIDGE_B_B);
1E46:  BCF    F94.6
1E48:  BCF    F8B.6
.................... 	} else {
1E4A:  BRA    1E4E
.................... 		timers.contactor_b_powersave--;
1E4C:  DECF   xD3,F
.................... 	}
.................... 
.................... 
.................... 
.................... 
.................... 	/* seconds */
.................... 	ticks++;
1E4E:  MOVLB  1
1E50:  INCF   x0A,F
1E52:  BTFSC  FD8.2
1E54:  INCF   x0B,F
.................... 	if ( 1000 == ticks ) {
1E56:  MOVF   x0A,W
1E58:  SUBLW  E8
1E5A:  BNZ   1E9C
1E5C:  MOVF   x0B,W
1E5E:  SUBLW  03
1E60:  BNZ   1E9C
.................... 		ticks=0;
1E62:  CLRF   x0B
1E64:  CLRF   x0A
.................... 
.................... 		/* set channe[n].state based on logic */
.................... 		contactor_logic(0);
1E66:  CLRF   x11
1E68:  MOVLB  0
1E6A:  CALL   12CE
.................... 		contactor_logic(1);
1E6E:  MOVLW  01
1E70:  MOVLB  1
1E72:  MOVWF  x11
1E74:  MOVLB  0
1E76:  CALL   12CE
.................... 
.................... 		/* set contactor outputs */
.................... 		contactor_set();
1E7A:  BRA    1DF8
.................... 		
.................... 		/* uptime counter */
.................... 		uptimeTicks++;
1E7C:  MOVLB  1
1E7E:  INCF   x07,F
.................... 		if ( 60 == uptimeTicks ) {
1E80:  MOVF   x07,W
1E82:  SUBLW  3C
1E84:  BNZ   1E9C
.................... 			uptimeTicks=0;
1E86:  CLRF   x07
.................... 			if ( current.uptime_minutes < 65535 ) 
1E88:  MOVLB  0
1E8A:  INCFSZ xC6,W
1E8C:  BRA    1E94
1E8E:  INCFSZ xC7,W
1E90:  BRA    1E94
1E92:  BRA    1E9A
.................... 				current.uptime_minutes++;
1E94:  INCF   xC6,F
1E96:  BTFSC  FD8.2
1E98:  INCF   xC7,F
1E9A:  MOVLB  1
.................... 		}
.................... 	}
.................... 
.................... 	/* ADC sample counter */
.................... 	if ( timers.now_adc_reset_count ) {
1E9C:  MOVLB  0
1E9E:  BTFSS  xCF.1
1EA0:  BRA    1EAC
.................... 		timers.now_adc_reset_count=0;
1EA2:  BCF    xCF.1
.................... 		adcTicks=0;
1EA4:  MOVLB  1
1EA6:  CLRF   x09
1EA8:  CLRF   x08
1EAA:  MOVLB  0
.................... 	}
.................... 
.................... 	/* ADC sampling trigger */
.................... 	adcTicks++;
1EAC:  MOVLB  1
1EAE:  INCF   x08,F
1EB0:  BTFSC  FD8.2
1EB2:  INCF   x09,F
.................... 	if ( ADC_SAMPLE_TICKS == adcTicks ) {
1EB4:  MOVF   x08,W
1EB6:  SUBLW  14
1EB8:  BNZ   1EC8
1EBA:  MOVF   x09,F
1EBC:  BNZ   1EC8
.................... 		adcTicks=0;
1EBE:  CLRF   x09
1EC0:  CLRF   x08
.................... 		timers.now_adc_sample=1;
1EC2:  MOVLB  0
1EC4:  BSF    xCF.0
1EC6:  MOVLB  1
.................... 	}
1EC8:  MOVLB  0
1ECA:  GOTO   22C0 (RETURN)
.................... 
.................... }
.................... 
.................... void init(void) {
.................... 	int8 buff[32];
.................... 	setup_oscillator(OSC_16MHZ);
*
0D96:  MOVLW  70
0D98:  MOVWF  FD3
0D9A:  BCF    F9B.6
0D9C:  BCF    F9B.7
.................... 
.................... 	setup_adc(ADC_CLOCK_DIV_16);
0D9E:  MOVF   FC0,W
0DA0:  ANDLW  C0
0DA2:  IORLW  05
0DA4:  MOVWF  FC0
0DA6:  BSF    FC0.7
0DA8:  BSF    FC2.0
.................... 	/* NTC thermistor on sAN2, input voltage divider on sAN4, DIP switch analog on sAN9
.................... 	voltage spans between 0 and Vdd */
.................... 	setup_adc_ports(sAN2 | sAN4 | sAN9,VSS_VDD);
0DAA:  MOVLW  14
0DAC:  MOVWF  F7E
0DAE:  BCF    FC1.0
0DB0:  BCF    FC1.1
0DB2:  BCF    FC1.2
0DB4:  BCF    FC1.3
0DB6:  MOVLW  02
0DB8:  MOVWF  F7F
.................... 
.................... 	setup_wdt(WDT_512MS);
0DBA:  BSF    FD1.0
.................... 
.................... 	set_tris_a(0b00111111);
0DBC:  MOVLW  3F
0DBE:  MOVWF  F92
.................... 	set_tris_b(0b01110000);
0DC0:  MOVLW  70
0DC2:  MOVWF  F93
.................... 	set_tris_c(0b10000001);
0DC4:  MOVLW  81
0DC6:  MOVWF  F94
.................... //               76543210
.................... 
.................... 	port_a_pullups(0b00110000);
0DC8:  MOVLW  30
0DCA:  MOVWF  F77
0DCC:  BCF    FF1.7
.................... 	port_b_pullups(0b00000000);
0DCE:  CLRF   F78
.................... //                   76543210
.................... 
.................... 	/* data structure initialization */
.................... 	/* all initialized to 0 on declaration. Just do this if need non-zero */
.................... 	channel[0].command_off_seconds=65535;
0DD0:  SETF   xDA
0DD2:  SETF   xD9
.................... 	channel[1].command_off_seconds=65535;
0DD4:  SETF   xF1
0DD6:  SETF   xF0
.................... 	channel[0].command_on_seconds =65535;
0DD8:  SETF   xD6
0DDA:  SETF   xD5
.................... 	channel[1].command_on_seconds =65535;
0DDC:  SETF   xED
0DDE:  SETF   xEC
.................... 
.................... 
.................... 	/* get our compiled date from constant */
.................... 	strcpy(buff,__DATE__);
0DE0:  MOVLW  01
0DE2:  MOVWF  FEA
0DE4:  MOVLW  11
0DE6:  MOVWF  FE9
0DE8:  MOVLW  00
0DEA:  CALL   00BA
0DEE:  TBLRD*-
0DF0:  TBLRD*+
0DF2:  MOVF   FF5,W
0DF4:  MOVWF  FEE
0DF6:  IORLW  00
0DF8:  BNZ   0DF0
.................... 	current.compile_day =(buff[0]-'0')*10;
0DFA:  MOVLW  30
0DFC:  MOVLB  1
0DFE:  SUBWF  x11,W
0E00:  MULLW  0A
0E02:  MOVFF  FF3,CD
0E06:  MOVLB  0
.................... 	current.compile_day+=(buff[1]-'0');
0E08:  MOVLW  30
0E0A:  MOVLB  1
0E0C:  SUBWF  x12,W
0E0E:  MOVLB  0
0E10:  ADDWF  xCD,F
.................... 	/* determine month ... how annoying */
.................... 	if ( 'J'==buff[3] ) {
0E12:  MOVLB  1
0E14:  MOVF   x14,W
0E16:  SUBLW  4A
0E18:  BNZ   0E44
.................... 		if ( 'A'==buff[4] )
0E1A:  MOVF   x15,W
0E1C:  SUBLW  41
0E1E:  BNZ   0E2A
.................... 			current.compile_month=1;
0E20:  MOVLW  01
0E22:  MOVLB  0
0E24:  MOVWF  xCC
0E26:  BRA    0E40
0E28:  MOVLB  1
.................... 		else if ( 'N'==buff[5] )
0E2A:  MOVF   x16,W
0E2C:  SUBLW  4E
0E2E:  BNZ   0E3A
.................... 			current.compile_month=6;
0E30:  MOVLW  06
0E32:  MOVLB  0
0E34:  MOVWF  xCC
0E36:  BRA    0E40
0E38:  MOVLB  1
.................... 		else
.................... 			current.compile_month=7;
0E3A:  MOVLW  07
0E3C:  MOVLB  0
0E3E:  MOVWF  xCC
.................... 	} else if ( 'A'==buff[3] ) {
0E40:  BRA    0ED8
0E42:  MOVLB  1
0E44:  MOVF   x14,W
0E46:  SUBLW  41
0E48:  BNZ   0E64
.................... 		if ( 'P'==buff[4] )
0E4A:  MOVF   x15,W
0E4C:  SUBLW  50
0E4E:  BNZ   0E5A
.................... 			current.compile_month=4;
0E50:  MOVLW  04
0E52:  MOVLB  0
0E54:  MOVWF  xCC
0E56:  BRA    0E60
0E58:  MOVLB  1
.................... 		else
.................... 			current.compile_month=8;
0E5A:  MOVLW  08
0E5C:  MOVLB  0
0E5E:  MOVWF  xCC
.................... 	} else if ( 'M'==buff[3] ) {
0E60:  BRA    0ED8
0E62:  MOVLB  1
0E64:  MOVF   x14,W
0E66:  SUBLW  4D
0E68:  BNZ   0E84
.................... 		if ( 'R'==buff[5] )
0E6A:  MOVF   x16,W
0E6C:  SUBLW  52
0E6E:  BNZ   0E7A
.................... 			current.compile_month=3;
0E70:  MOVLW  03
0E72:  MOVLB  0
0E74:  MOVWF  xCC
0E76:  BRA    0E80
0E78:  MOVLB  1
.................... 		else
.................... 			current.compile_month=5;
0E7A:  MOVLW  05
0E7C:  MOVLB  0
0E7E:  MOVWF  xCC
.................... 	} else if ( 'F'==buff[3] ) {
0E80:  BRA    0ED8
0E82:  MOVLB  1
0E84:  MOVF   x14,W
0E86:  SUBLW  46
0E88:  BNZ   0E94
.................... 		current.compile_month=2;
0E8A:  MOVLW  02
0E8C:  MOVLB  0
0E8E:  MOVWF  xCC
.................... 	} else if ( 'S'==buff[3] ) {
0E90:  BRA    0ED8
0E92:  MOVLB  1
0E94:  MOVF   x14,W
0E96:  SUBLW  53
0E98:  BNZ   0EA4
.................... 		current.compile_month=9;
0E9A:  MOVLW  09
0E9C:  MOVLB  0
0E9E:  MOVWF  xCC
.................... 	} else if ( 'O'==buff[3] ) {
0EA0:  BRA    0ED8
0EA2:  MOVLB  1
0EA4:  MOVF   x14,W
0EA6:  SUBLW  4F
0EA8:  BNZ   0EB4
.................... 		current.compile_month=10;
0EAA:  MOVLW  0A
0EAC:  MOVLB  0
0EAE:  MOVWF  xCC
.................... 	} else if ( 'N'==buff[3] ) {
0EB0:  BRA    0ED8
0EB2:  MOVLB  1
0EB4:  MOVF   x14,W
0EB6:  SUBLW  4E
0EB8:  BNZ   0EC4
.................... 		current.compile_month=11;
0EBA:  MOVLW  0B
0EBC:  MOVLB  0
0EBE:  MOVWF  xCC
.................... 	} else if ( 'D'==buff[3] ) {
0EC0:  BRA    0ED8
0EC2:  MOVLB  1
0EC4:  MOVF   x14,W
0EC6:  SUBLW  44
0EC8:  BNZ   0ED4
.................... 		current.compile_month=12;
0ECA:  MOVLW  0C
0ECC:  MOVLB  0
0ECE:  MOVWF  xCC
.................... 	} else {
0ED0:  BRA    0ED8
0ED2:  MOVLB  1
.................... 		/* error parsing, shouldn't happen */
.................... 		current.compile_month=255;
0ED4:  MOVLB  0
0ED6:  SETF   xCC
.................... 	}
.................... 	current.compile_year =(buff[7]-'0')*10;
0ED8:  MOVLW  30
0EDA:  MOVLB  1
0EDC:  SUBWF  x18,W
0EDE:  MULLW  0A
0EE0:  MOVFF  FF3,CB
0EE4:  MOVLB  0
.................... 	current.compile_year+=(buff[8]-'0');
0EE6:  MOVLW  30
0EE8:  MOVLB  1
0EEA:  SUBWF  x19,W
0EEC:  MOVLB  0
0EEE:  ADDWF  xCB,F
.................... 
.................... 
.................... 	/* one periodic interrupt @ 1mS. Generated from system 16 MHz clock */
.................... 	/* prescale=16, match=249, postscale=1. Match is 249 because when match occurs, one cycle is lost */
.................... 	setup_timer_2(T2_DIV_BY_16,249,1);
0EF0:  MOVLW  00
0EF2:  IORLW  06
0EF4:  MOVWF  FCA
0EF6:  MOVLW  F9
0EF8:  MOVWF  FCB
.................... 
.................... 	enable_interrupts(INT_TIMER2);
0EFA:  BSF    F9D.1
.................... 
.................... 	/* set I2C slave address, which is always an even number */
.................... 	i2c_slaveaddr(STREAM_SLAVE,0x3e + (read_dip_switch()<<1) );
0EFC:  RCALL  0D26
0EFE:  BCF    FD8.0
0F00:  RLCF   01,W
0F02:  ADDLW  3E
0F04:  MOVLB  1
0F06:  MOVWF  FC8
0F08:  MOVLB  0
0F0A:  GOTO   2178 (RETURN)
.................... }
.................... 
.................... 
.................... void main(void) {
*
20EA:  CLRF   FF8
20EC:  BCF    FD0.7
20EE:  BSF    07.7
20F0:  BSF    F93.6
20F2:  BSF    F93.4
20F4:  CLRF   FC8
20F6:  MOVLW  36
20F8:  MOVWF  FC6
20FA:  BSF    FC5.0
20FC:  BSF    FC5.7
20FE:  CLRF   1A
2100:  BSF    FB8.3
2102:  MOVLW  A0
2104:  MOVWF  FAF
2106:  MOVLW  01
2108:  MOVWF  FB0
210A:  MOVLW  A6
210C:  MOVWF  FAC
210E:  MOVLW  90
2110:  MOVWF  FAB
2112:  MOVLB  1
2114:  CLRF   x0D
2116:  CLRF   x0C
2118:  MOVLW  00
211A:  MOVWF  F7E
211C:  BCF    FC1.0
211E:  BCF    FC1.1
2120:  BCF    FC1.2
2122:  BCF    FC1.3
2124:  MOVWF  F7F
2126:  CLRF   F6C
2128:  CLRF   F6B
212A:  CLRF   F6D
212C:  BRA    2134
212E:  DATA F1,40
2130:  DATA 1B,00
2132:  DATA 00,00
2134:  MOVLW  00
2136:  MOVWF  FF8
2138:  MOVLW  21
213A:  MOVWF  FF7
213C:  MOVLW  2E
213E:  MOVWF  FF6
2140:  TBLRD*+
2142:  MOVF   FF5,W
2144:  MOVWF  00
2146:  XORLW  00
2148:  BZ    2170
214A:  TBLRD*+
214C:  MOVF   FF5,W
214E:  MOVWF  01
2150:  BTFSC  FE8.7
2152:  BRA    215E
2154:  ANDLW  3F
2156:  MOVWF  FEA
2158:  TBLRD*+
215A:  MOVFF  FF5,FE9
215E:  BTFSC  01.6
2160:  TBLRD*+
2162:  BTFSS  01.6
2164:  TBLRD*+
2166:  MOVFF  FF5,FEE
216A:  DCFSNZ 00,F
216C:  BRA    2140
216E:  BRA    2162
2170:  CLRF   FF8
.................... 	int8 i;
.................... 	int8 last_a, last_b;
.................... 
.................... 	init();
2172:  MOVLB  0
2174:  GOTO   0D96
.................... 
.................... 
.................... 	/* read parameters from EEPROM and write defaults if CRC doesn't match */
.................... 	read_param_file();
2178:  GOTO   119E
.................... 
.................... 
.................... 	/* flash on startup */
.................... 	for ( i=0 ; i<5 ; i++ ) {
217C:  MOVLB  1
217E:  CLRF   x0E
2180:  MOVF   x0E,W
2182:  SUBLW  04
2184:  BNC   21AC
.................... 		restart_wdt();
2186:  CLRWDT
.................... 		output_high(LED_A);
2188:  BCF    F94.1
218A:  BSF    F8B.1
.................... 		delay_ms(200);
218C:  MOVLW  C8
218E:  MOVWF  x33
2190:  MOVLB  0
2192:  CALL   0CFC
.................... 		output_low(LED_A);
2196:  BCF    F94.1
2198:  BCF    F8B.1
.................... 		delay_ms(200);
219A:  MOVLW  C8
219C:  MOVLB  1
219E:  MOVWF  x33
21A0:  MOVLB  0
21A2:  CALL   0CFC
21A6:  MOVLB  1
21A8:  INCF   x0E,F
21AA:  BRA    2180
.................... 	}
.................... 
.................... 	fprintf(STREAM_FTDI,"# dcswc_module_latching_contactor %s\r\n# ",__DATE__);
21AC:  MOVLW  96
21AE:  MOVWF  FF6
21B0:  MOVLW  0A
21B2:  MOVWF  FF7
21B4:  MOVLW  22
21B6:  MOVWF  x14
21B8:  MOVLB  0
21BA:  CALL   11E4
21BE:  MOVLW  C0
21C0:  MOVWF  FF6
21C2:  MOVLW  0A
21C4:  MOVWF  FF7
21C6:  CALL   120E
21CA:  MOVLW  BA
21CC:  MOVWF  FF6
21CE:  MOVLW  0A
21D0:  MOVWF  FF7
21D2:  MOVLW  04
21D4:  MOVLB  1
21D6:  MOVWF  x14
21D8:  MOVLB  0
21DA:  CALL   11E4
.................... 	switch ( restart_cause ) {
21DE:  MOVLW  07
21E0:  SUBWF  00,W
21E2:  BZ    2208
21E4:  MOVLW  0B
21E6:  SUBWF  00,W
21E8:  BZ    2216
21EA:  MOVLW  0F
21EC:  SUBWF  00,W
21EE:  BZ    2224
21F0:  MOVLW  0C
21F2:  SUBWF  00,W
21F4:  BZ    2232
21F6:  MOVLW  0E
21F8:  SUBWF  00,W
21FA:  BZ    2240
21FC:  MOVLW  03
21FE:  SUBWF  00,W
2200:  BZ    224E
2202:  MOVF   00,F
2204:  BZ    225C
2206:  BRA    226A
.................... 		case WDT_TIMEOUT:       fprintf(STREAM_FTDI,"WDT TIMEOUT"); break;
2208:  MOVLW  CA
220A:  MOVWF  FF6
220C:  MOVLW  0A
220E:  MOVWF  FF7
2210:  CALL   120E
2214:  BRA    2276
.................... 		case MCLR_FROM_SLEEP:   fprintf(STREAM_FTDI,"MCLR FROM SLEEP"); break;
2216:  MOVLW  D6
2218:  MOVWF  FF6
221A:  MOVLW  0A
221C:  MOVWF  FF7
221E:  CALL   120E
2222:  BRA    2276
.................... 		case MCLR_FROM_RUN:     fprintf(STREAM_FTDI,"MCLR FROM RUN"); break;
2224:  MOVLW  E6
2226:  MOVWF  FF6
2228:  MOVLW  0A
222A:  MOVWF  FF7
222C:  CALL   120E
2230:  BRA    2276
.................... 		case NORMAL_POWER_UP:   fprintf(STREAM_FTDI,"NORMAL POWER UP"); break;
2232:  MOVLW  F4
2234:  MOVWF  FF6
2236:  MOVLW  0A
2238:  MOVWF  FF7
223A:  CALL   120E
223E:  BRA    2276
.................... 		case BROWNOUT_RESTART:  fprintf(STREAM_FTDI,"BROWNOUT RESTART"); break;
2240:  MOVLW  04
2242:  MOVWF  FF6
2244:  MOVLW  0B
2246:  MOVWF  FF7
2248:  CALL   120E
224C:  BRA    2276
.................... 		case WDT_FROM_SLEEP:    fprintf(STREAM_FTDI,"WDT FROM SLEEP"); break;
224E:  MOVLW  16
2250:  MOVWF  FF6
2252:  MOVLW  0B
2254:  MOVWF  FF7
2256:  CALL   120E
225A:  BRA    2276
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_FTDI,"RESET INSTRUCTION"); break;
225C:  MOVLW  26
225E:  MOVWF  FF6
2260:  MOVLW  0B
2262:  MOVWF  FF7
2264:  CALL   120E
2268:  BRA    2276
.................... 		default:                fprintf(STREAM_FTDI,"UNKNOWN!");
226A:  MOVLW  38
226C:  MOVWF  FF6
226E:  MOVLW  0B
2270:  MOVWF  FF7
2272:  CALL   120E
.................... 	}
.................... 	fprintf(STREAM_FTDI,"\r\n");
2276:  MOVLW  0D
2278:  BTFSS  F9E.4
227A:  BRA    2278
227C:  MOVWF  FAD
227E:  MOVLW  0A
2280:  BTFSS  F9E.4
2282:  BRA    2280
2284:  MOVWF  FAD
.................... 
.................... 	timers.led_on_a=500;
2286:  MOVLW  F4
2288:  MOVWF  xD0
.................... 
.................... 	enable_interrupts(GLOBAL);
228A:  MOVLW  C0
228C:  IORWF  FF2,F
.................... 
.................... 	/* Prime ADC filter */
.................... 	for ( i=0 ; i<30 ; i++ ) {
228E:  MOVLB  1
2290:  CLRF   x0E
2292:  MOVF   x0E,W
2294:  SUBLW  1D
2296:  BNC   22A4
.................... 		adc_update();
2298:  MOVLB  0
229A:  CALL   1230
229E:  MOVLB  1
22A0:  INCF   x0E,F
22A2:  BRA    2292
.................... 	}
.................... 
.................... 	last_a = ! input(SW_OVERRIDE_A);
22A4:  BSF    F92.5
22A6:  CLRF   x0F
22A8:  BTFSS  F80.5
22AA:  INCF   x0F,F
.................... 	last_b = ! input(SW_OVERRIDE_B);
22AC:  BSF    F92.4
22AE:  CLRF   x10
22B0:  BTFSS  F80.4
22B2:  INCF   x10,F
.................... 
.................... 
.................... 	/* enable I2C slave interrupt */
.................... 	enable_interrupts(INT_SSP);
22B4:  BSF    F9D.3
.................... 
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
22B6:  CLRWDT
.................... 
.................... 		if ( timers.now_millisecond ) {
22B8:  MOVLB  0
22BA:  BTFSS  xCF.2
22BC:  BRA    22C0
.................... 			periodic_millisecond();
22BE:  BRA    1DFC
.................... 		}
.................... 
.................... 		if ( kbhit() ) {
22C0:  BTFSS  F9E.5
22C2:  BRA    2770
.................... 			getc();
22C4:  BRA    1ECE
.................... 			fprintf(STREAM_FTDI,"# read_dip_switch()=%u\r\n",read_dip_switch());
22C6:  CALL   0D26
22CA:  MOVFF  01,111
22CE:  MOVLW  42
22D0:  MOVWF  FF6
22D2:  MOVLW  0B
22D4:  MOVWF  FF7
22D6:  MOVLW  14
22D8:  MOVLB  1
22DA:  MOVWF  x14
22DC:  MOVLB  0
22DE:  CALL   11E4
22E2:  MOVFF  111,112
22E6:  MOVLW  1B
22E8:  MOVLB  1
22EA:  MOVWF  x13
22EC:  MOVLB  0
22EE:  RCALL  1F12
22F0:  MOVLW  0D
22F2:  BTFSS  F9E.4
22F4:  BRA    22F2
22F6:  MOVWF  FAD
22F8:  MOVLW  0A
22FA:  BTFSS  F9E.4
22FC:  BRA    22FA
22FE:  MOVWF  FAD
2300:  CLRF   19
2302:  BTFSC  FF2.7
2304:  BSF    19.7
2306:  BCF    FF2.7
.................... 			fprintf(STREAM_FTDI,"#    vin adc=%lu\r\n",adc_get(0));
2308:  MOVLB  1
230A:  CLRF   x39
230C:  MOVLB  0
230E:  CALL   00DC
2312:  BTFSC  19.7
2314:  BSF    FF2.7
2316:  MOVFF  02,112
231A:  MOVFF  01,111
231E:  MOVLW  5C
2320:  MOVWF  FF6
2322:  MOVLW  0B
2324:  MOVWF  FF7
2326:  MOVLW  0D
2328:  MOVLB  1
232A:  MOVWF  x14
232C:  MOVLB  0
232E:  CALL   11E4
2332:  MOVLW  10
2334:  MOVWF  FE9
2336:  MOVFF  112,114
233A:  MOVFF  111,113
233E:  RCALL  1F90
2340:  MOVLW  0D
2342:  BTFSS  F9E.4
2344:  BRA    2342
2346:  MOVWF  FAD
2348:  MOVLW  0A
234A:  BTFSS  F9E.4
234C:  BRA    234A
234E:  MOVWF  FAD
2350:  CLRF   19
2352:  BTFSC  FF2.7
2354:  BSF    19.7
2356:  BCF    FF2.7
.................... 			fprintf(STREAM_FTDI,"#   temp adc=%lu\r\n",adc_get(1));
2358:  MOVLW  01
235A:  MOVLB  1
235C:  MOVWF  x39
235E:  MOVLB  0
2360:  CALL   00DC
2364:  BTFSC  19.7
2366:  BSF    FF2.7
2368:  MOVFF  02,112
236C:  MOVFF  01,111
2370:  MOVLW  70
2372:  MOVWF  FF6
2374:  MOVLW  0B
2376:  MOVWF  FF7
2378:  MOVLW  0D
237A:  MOVLB  1
237C:  MOVWF  x14
237E:  MOVLB  0
2380:  CALL   11E4
2384:  MOVLW  10
2386:  MOVWF  FE9
2388:  MOVFF  112,114
238C:  MOVFF  111,113
2390:  RCALL  1F90
2392:  MOVLW  0D
2394:  BTFSS  F9E.4
2396:  BRA    2394
2398:  MOVWF  FAD
239A:  MOVLW  0A
239C:  BTFSS  F9E.4
239E:  BRA    239C
23A0:  MOVWF  FAD
23A2:  CLRF   19
23A4:  BTFSC  FF2.7
23A6:  BSF    19.7
23A8:  BCF    FF2.7
.................... 			fprintf(STREAM_FTDI,"# dip sw adc=%lu\r\n",adc_get(2));
23AA:  MOVLW  02
23AC:  MOVLB  1
23AE:  MOVWF  x39
23B0:  MOVLB  0
23B2:  CALL   00DC
23B6:  BTFSC  19.7
23B8:  BSF    FF2.7
23BA:  MOVFF  02,112
23BE:  MOVFF  01,111
23C2:  MOVLW  84
23C4:  MOVWF  FF6
23C6:  MOVLW  0B
23C8:  MOVWF  FF7
23CA:  MOVLW  0D
23CC:  MOVLB  1
23CE:  MOVWF  x14
23D0:  MOVLB  0
23D2:  CALL   11E4
23D6:  MOVLW  10
23D8:  MOVWF  FE9
23DA:  MOVFF  112,114
23DE:  MOVFF  111,113
23E2:  RCALL  1F90
23E4:  MOVLW  0D
23E6:  BTFSS  F9E.4
23E8:  BRA    23E6
23EA:  MOVWF  FAD
23EC:  MOVLW  0A
23EE:  BTFSS  F9E.4
23F0:  BRA    23EE
23F2:  MOVWF  FAD
.................... 
.................... 			for ( i=0 ; i<2 ; i++ ) {
23F4:  MOVLB  1
23F6:  CLRF   x0E
23F8:  MOVF   x0E,W
23FA:  SUBLW  01
23FC:  BTFSS  FD8.0
23FE:  BRA    276E
.................... 				restart_wdt();
2400:  CLRWDT
.................... 				fprintf(STREAM_FTDI,"# channel[%u]\r\n",i);
2402:  MOVLW  98
2404:  MOVWF  FF6
2406:  MOVLW  0B
2408:  MOVWF  FF7
240A:  MOVLW  0A
240C:  MOVWF  x14
240E:  MOVLB  0
2410:  CALL   11E4
2414:  MOVFF  10E,112
2418:  MOVLW  1B
241A:  MOVLB  1
241C:  MOVWF  x13
241E:  MOVLB  0
2420:  RCALL  1F12
2422:  MOVLW  A4
2424:  MOVWF  FF6
2426:  MOVLW  0B
2428:  MOVWF  FF7
242A:  MOVLW  03
242C:  MOVLB  1
242E:  MOVWF  x14
2430:  MOVLB  0
2432:  CALL   11E4
.................... 				fprintf(STREAM_FTDI,"#                        state=0x%02x\r\n",channel[i].state);
2436:  MOVLB  1
2438:  MOVF   x0E,W
243A:  MULLW  17
243C:  MOVF   FF3,W
243E:  CLRF   x12
2440:  MOVWF  x11
2442:  MOVLW  D4
2444:  ADDWF  x11,W
2446:  MOVWF  FE9
2448:  MOVLW  00
244A:  ADDWFC x12,W
244C:  MOVWF  FEA
244E:  MOVFF  FEF,113
2452:  MOVLW  A8
2454:  MOVWF  FF6
2456:  MOVLW  0B
2458:  MOVWF  FF7
245A:  MOVLW  21
245C:  MOVWF  x14
245E:  MOVLB  0
2460:  CALL   11E4
2464:  MOVFF  113,114
2468:  MOVLW  57
246A:  MOVLB  1
246C:  MOVWF  x15
246E:  MOVLB  0
2470:  BRA    2042
2472:  MOVLW  0D
2474:  BTFSS  F9E.4
2476:  BRA    2474
2478:  MOVWF  FAD
247A:  MOVLW  0A
247C:  BTFSS  F9E.4
247E:  BRA    247C
2480:  MOVWF  FAD
.................... 				fprintf(STREAM_FTDI,"#           command_on_seconds=%lu\r\n",channel[i].command_on_seconds);
2482:  MOVLB  1
2484:  MOVF   x0E,W
2486:  MULLW  17
2488:  MOVF   FF3,W
248A:  CLRF   x12
248C:  MOVWF  x11
248E:  MOVLW  01
2490:  ADDWF  x11,W
2492:  MOVWF  01
2494:  MOVLW  00
2496:  ADDWFC x12,W
2498:  MOVWF  03
249A:  MOVF   01,W
249C:  ADDLW  D4
249E:  MOVWF  FE9
24A0:  MOVLW  00
24A2:  ADDWFC 03,W
24A4:  MOVWF  FEA
24A6:  MOVFF  FEC,112
24AA:  MOVF   FED,F
24AC:  MOVFF  FEF,111
24B0:  MOVLW  D0
24B2:  MOVWF  FF6
24B4:  MOVLW  0B
24B6:  MOVWF  FF7
24B8:  MOVLW  1F
24BA:  MOVWF  x14
24BC:  MOVLB  0
24BE:  CALL   11E4
24C2:  MOVLW  10
24C4:  MOVWF  FE9
24C6:  MOVFF  112,114
24CA:  MOVFF  111,113
24CE:  RCALL  1F90
24D0:  MOVLW  0D
24D2:  BTFSS  F9E.4
24D4:  BRA    24D2
24D6:  MOVWF  FAD
24D8:  MOVLW  0A
24DA:  BTFSS  F9E.4
24DC:  BRA    24DA
24DE:  MOVWF  FAD
.................... 				fprintf(STREAM_FTDI,"#      command_on_hold_seconds=%lu\r\n",channel[i].command_on_hold_seconds);
24E0:  MOVLB  1
24E2:  MOVF   x0E,W
24E4:  MULLW  17
24E6:  MOVF   FF3,W
24E8:  CLRF   x12
24EA:  MOVWF  x11
24EC:  MOVLW  03
24EE:  ADDWF  x11,W
24F0:  MOVWF  01
24F2:  MOVLW  00
24F4:  ADDWFC x12,W
24F6:  MOVWF  03
24F8:  MOVF   01,W
24FA:  ADDLW  D4
24FC:  MOVWF  FE9
24FE:  MOVLW  00
2500:  ADDWFC 03,W
2502:  MOVWF  FEA
2504:  MOVFF  FEC,112
2508:  MOVF   FED,F
250A:  MOVFF  FEF,111
250E:  MOVLW  F6
2510:  MOVWF  FF6
2512:  MOVLW  0B
2514:  MOVWF  FF7
2516:  MOVLW  1F
2518:  MOVWF  x14
251A:  MOVLB  0
251C:  CALL   11E4
2520:  MOVLW  10
2522:  MOVWF  FE9
2524:  MOVFF  112,114
2528:  MOVFF  111,113
252C:  RCALL  1F90
252E:  MOVLW  0D
2530:  BTFSS  F9E.4
2532:  BRA    2530
2534:  MOVWF  FAD
2536:  MOVLW  0A
2538:  BTFSS  F9E.4
253A:  BRA    2538
253C:  MOVWF  FAD
.................... 
.................... 				fprintf(STREAM_FTDI,"#          command_off_seconds=%lu\r\n",channel[i].command_off_seconds);
253E:  MOVLB  1
2540:  MOVF   x0E,W
2542:  MULLW  17
2544:  MOVF   FF3,W
2546:  CLRF   x12
2548:  MOVWF  x11
254A:  MOVLW  05
254C:  ADDWF  x11,W
254E:  MOVWF  01
2550:  MOVLW  00
2552:  ADDWFC x12,W
2554:  MOVWF  03
2556:  MOVF   01,W
2558:  ADDLW  D4
255A:  MOVWF  FE9
255C:  MOVLW  00
255E:  ADDWFC 03,W
2560:  MOVWF  FEA
2562:  MOVFF  FEC,112
2566:  MOVF   FED,F
2568:  MOVFF  FEF,111
256C:  MOVLW  1C
256E:  MOVWF  FF6
2570:  MOVLW  0C
2572:  MOVWF  FF7
2574:  MOVLW  1F
2576:  MOVWF  x14
2578:  MOVLB  0
257A:  CALL   11E4
257E:  MOVLW  10
2580:  MOVWF  FE9
2582:  MOVFF  112,114
2586:  MOVFF  111,113
258A:  RCALL  1F90
258C:  MOVLW  0D
258E:  BTFSS  F9E.4
2590:  BRA    258E
2592:  MOVWF  FAD
2594:  MOVLW  0A
2596:  BTFSS  F9E.4
2598:  BRA    2596
259A:  MOVWF  FAD
.................... 				fprintf(STREAM_FTDI,"#     command_off_hold_seconds=%lu\r\n",channel[i].command_off_hold_seconds);
259C:  MOVLB  1
259E:  MOVF   x0E,W
25A0:  MULLW  17
25A2:  MOVF   FF3,W
25A4:  CLRF   x12
25A6:  MOVWF  x11
25A8:  MOVLW  07
25AA:  ADDWF  x11,W
25AC:  MOVWF  01
25AE:  MOVLW  00
25B0:  ADDWFC x12,W
25B2:  MOVWF  03
25B4:  MOVF   01,W
25B6:  ADDLW  D4
25B8:  MOVWF  FE9
25BA:  MOVLW  00
25BC:  ADDWFC 03,W
25BE:  MOVWF  FEA
25C0:  MOVFF  FEC,112
25C4:  MOVF   FED,F
25C6:  MOVFF  FEF,111
25CA:  MOVLW  42
25CC:  MOVWF  FF6
25CE:  MOVLW  0C
25D0:  MOVWF  FF7
25D2:  MOVLW  1F
25D4:  MOVWF  x14
25D6:  MOVLB  0
25D8:  CALL   11E4
25DC:  MOVLW  10
25DE:  MOVWF  FE9
25E0:  MOVFF  112,114
25E4:  MOVFF  111,113
25E8:  RCALL  1F90
25EA:  MOVLW  0D
25EC:  BTFSS  F9E.4
25EE:  BRA    25EC
25F0:  MOVWF  FAD
25F2:  MOVLW  0A
25F4:  BTFSS  F9E.4
25F6:  BRA    25F4
25F8:  MOVWF  FAD
.................... 
.................... 				fprintf(STREAM_FTDI,"# lvd_disconnect_delay_seconds=%lu\r\n",channel[i].lvd_disconnect_delay_seconds);
25FA:  MOVLB  1
25FC:  MOVF   x0E,W
25FE:  MULLW  17
2600:  MOVF   FF3,W
2602:  CLRF   x12
2604:  MOVWF  x11
2606:  MOVLW  09
2608:  ADDWF  x11,W
260A:  MOVWF  01
260C:  MOVLW  00
260E:  ADDWFC x12,W
2610:  MOVWF  03
2612:  MOVF   01,W
2614:  ADDLW  D4
2616:  MOVWF  FE9
2618:  MOVLW  00
261A:  ADDWFC 03,W
261C:  MOVWF  FEA
261E:  MOVFF  FEC,112
2622:  MOVF   FED,F
2624:  MOVFF  FEF,111
2628:  MOVLW  68
262A:  MOVWF  FF6
262C:  MOVLW  0C
262E:  MOVWF  FF7
2630:  MOVLW  1F
2632:  MOVWF  x14
2634:  MOVLB  0
2636:  CALL   11E4
263A:  MOVLW  10
263C:  MOVWF  FE9
263E:  MOVFF  112,114
2642:  MOVFF  111,113
2646:  RCALL  1F90
2648:  MOVLW  0D
264A:  BTFSS  F9E.4
264C:  BRA    264A
264E:  MOVWF  FAD
2650:  MOVLW  0A
2652:  BTFSS  F9E.4
2654:  BRA    2652
2656:  MOVWF  FAD
.................... 				fprintf(STREAM_FTDI,"#  lvd_reconnect_delay_seconds=%u\r\n",channel[i].lvd_reconnect_delay_seconds);
2658:  MOVLB  1
265A:  MOVF   x0E,W
265C:  MULLW  17
265E:  MOVF   FF3,W
2660:  CLRF   x12
2662:  MOVWF  x11
2664:  MOVLW  0B
2666:  ADDWF  x11,W
2668:  MOVWF  01
266A:  MOVLW  00
266C:  ADDWFC x12,W
266E:  MOVWF  03
2670:  MOVF   01,W
2672:  ADDLW  D4
2674:  MOVWF  FE9
2676:  MOVLW  00
2678:  ADDWFC 03,W
267A:  MOVWF  FEA
267C:  MOVFF  FEF,111
2680:  MOVLW  8E
2682:  MOVWF  FF6
2684:  MOVLW  0C
2686:  MOVWF  FF7
2688:  MOVLW  1F
268A:  MOVWF  x14
268C:  MOVLB  0
268E:  CALL   11E4
2692:  MOVFF  111,112
2696:  MOVLW  1B
2698:  MOVLB  1
269A:  MOVWF  x13
269C:  MOVLB  0
269E:  RCALL  1F12
26A0:  MOVLW  0D
26A2:  BTFSS  F9E.4
26A4:  BRA    26A2
26A6:  MOVWF  FAD
26A8:  MOVLW  0A
26AA:  BTFSS  F9E.4
26AC:  BRA    26AA
26AE:  MOVWF  FAD
.................... 
.................... 				fprintf(STREAM_FTDI,"# hvd_disconnect_delay_seconds=%lu\r\n",channel[i].hvd_disconnect_delay_seconds);
26B0:  MOVLB  1
26B2:  MOVF   x0E,W
26B4:  MULLW  17
26B6:  MOVF   FF3,W
26B8:  CLRF   x12
26BA:  MOVWF  x11
26BC:  MOVLW  0C
26BE:  ADDWF  x11,W
26C0:  MOVWF  01
26C2:  MOVLW  00
26C4:  ADDWFC x12,W
26C6:  MOVWF  03
26C8:  MOVF   01,W
26CA:  ADDLW  D4
26CC:  MOVWF  FE9
26CE:  MOVLW  00
26D0:  ADDWFC 03,W
26D2:  MOVWF  FEA
26D4:  MOVFF  FEC,112
26D8:  MOVF   FED,F
26DA:  MOVFF  FEF,111
26DE:  MOVLW  B2
26E0:  MOVWF  FF6
26E2:  MOVLW  0C
26E4:  MOVWF  FF7
26E6:  MOVLW  1F
26E8:  MOVWF  x14
26EA:  MOVLB  0
26EC:  CALL   11E4
26F0:  MOVLW  10
26F2:  MOVWF  FE9
26F4:  MOVFF  112,114
26F8:  MOVFF  111,113
26FC:  RCALL  1F90
26FE:  MOVLW  0D
2700:  BTFSS  F9E.4
2702:  BRA    2700
2704:  MOVWF  FAD
2706:  MOVLW  0A
2708:  BTFSS  F9E.4
270A:  BRA    2708
270C:  MOVWF  FAD
.................... 				fprintf(STREAM_FTDI,"#  hvd_reconnect_delay_seconds=%u\r\n",channel[i].hvd_reconnect_delay_seconds);
270E:  MOVLB  1
2710:  MOVF   x0E,W
2712:  MULLW  17
2714:  MOVF   FF3,W
2716:  CLRF   x12
2718:  MOVWF  x11
271A:  MOVLW  0E
271C:  ADDWF  x11,W
271E:  MOVWF  01
2720:  MOVLW  00
2722:  ADDWFC x12,W
2724:  MOVWF  03
2726:  MOVF   01,W
2728:  ADDLW  D4
272A:  MOVWF  FE9
272C:  MOVLW  00
272E:  ADDWFC 03,W
2730:  MOVWF  FEA
2732:  MOVFF  FEF,111
2736:  MOVLW  D8
2738:  MOVWF  FF6
273A:  MOVLW  0C
273C:  MOVWF  FF7
273E:  MOVLW  1F
2740:  MOVWF  x14
2742:  MOVLB  0
2744:  CALL   11E4
2748:  MOVFF  111,112
274C:  MOVLW  1B
274E:  MOVLB  1
2750:  MOVWF  x13
2752:  MOVLB  0
2754:  CALL   1F12
2758:  MOVLW  0D
275A:  BTFSS  F9E.4
275C:  BRA    275A
275E:  MOVWF  FAD
2760:  MOVLW  0A
2762:  BTFSS  F9E.4
2764:  BRA    2762
2766:  MOVWF  FAD
2768:  MOVLB  1
276A:  INCF   x0E,F
276C:  BRA    23F8
276E:  MOVLB  0
.................... 			}
.................... 
.................... 		}
.................... 
.................... 		if ( input(SW_OVERRIDE_A) != last_a ) {
2770:  BSF    F92.5
2772:  MOVLW  00
2774:  BTFSC  F80.5
2776:  MOVLW  01
2778:  MOVLB  1
277A:  SUBWF  x0F,W
277C:  BZ    279E
.................... 			last_a=input(SW_OVERRIDE_A);
277E:  BSF    F92.5
2780:  CLRF   x0F
2782:  BTFSC  F80.5
2784:  INCF   x0F,F
.................... 
.................... 			if ( last_a ) {
2786:  MOVF   x0F,F
2788:  BZ    2796
.................... 				timers.led_on_a=500;
278A:  MOVLW  F4
278C:  MOVLB  0
278E:  MOVWF  xD0
.................... 				contactor_on_a();
2790:  BRA    208A
.................... 			} else {
2792:  BRA    279C
2794:  MOVLB  1
.................... 				timers.led_on_a=0;
2796:  MOVLB  0
2798:  CLRF   xD0
.................... 				contactor_off_a();
279A:  BRA    20A2
279C:  MOVLB  1
.................... 			}
.................... 		}
.................... 
.................... 
.................... 		if ( input(SW_OVERRIDE_B) != last_b ) {
279E:  BSF    F92.4
27A0:  MOVLW  00
27A2:  BTFSC  F80.4
27A4:  MOVLW  01
27A6:  SUBWF  x10,W
27A8:  BZ    27CA
.................... 			last_B=input(SW_OVERRIDE_B);
27AA:  BSF    F92.4
27AC:  CLRF   x10
27AE:  BTFSC  F80.4
27B0:  INCF   x10,F
.................... 
.................... 			if ( last_b ) {
27B2:  MOVF   x10,F
27B4:  BZ    27C2
.................... 				timers.led_on_b=500;
27B6:  MOVLW  F4
27B8:  MOVLB  0
27BA:  MOVWF  xD1
.................... 				contactor_on_b();
27BC:  BRA    20BA
.................... 			} else {
27BE:  BRA    27C8
27C0:  MOVLB  1
.................... 				timers.led_on_b=0;
27C2:  MOVLB  0
27C4:  CLRF   xD1
.................... 				contactor_off_b();
27C6:  BRA    20D2
27C8:  MOVLB  1
.................... 			}
.................... 		}
.................... 
.................... 
.................... 
.................... 		if ( timers.now_adc_sample ) {
27CA:  MOVLB  0
27CC:  BTFSS  xCF.0
27CE:  BRA    27D6
.................... 			timers.now_adc_sample=0;
27D0:  BCF    xCF.0
.................... 			adc_update();
27D2:  CALL   1230
.................... 		}
.................... 
.................... 		if ( timers.now_write_config ) {
27D6:  BTFSS  xCF.3
27D8:  BRA    27E0
.................... 			timers.now_write_config=0;
27DA:  BCF    xCF.3
.................... 			write_param_file();
27DC:  CALL   102E
.................... 		}
.................... 		if ( timers.now_reset_config ) {
27E0:  BTFSS  xCF.4
27E2:  BRA    27EA
.................... 			timers.now_reset_config=0;
27E4:  BCF    xCF.4
.................... 			write_default_param_file();
27E6:  CALL   107A
.................... 		}
27EA:  MOVLB  1
27EC:  BRA    22B6
.................... 
.................... 
.................... 	}
.................... 
.................... 
.................... }
27EE:  BRA    27EE

Configuration Fuses:
   Word  1: 2800   INTRC_IO NOPLLEN PCLKEN NOFCMEN NOIESO
   Word  2: 0E19   NOPUT NOBROWNOUT BORV19 NOWDT WDT128
   Word  3: 0000   NOHFOFST NOMCLR
   Word  4: 0009   STVREN NOLVP BBSIZ2K NOXINST DEBUG
   Word  5: C003   NOPROTECT NOCPB NOCPD
   Word  6: E003   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 4003   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.

ROM data:
F00000: 00 00 40 00                                        ..@.
