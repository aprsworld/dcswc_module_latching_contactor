CCS PCH C Compiler, Version 5.090, 49113               06-Feb-22 18:36

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\dcswc_module_latching_contactor\dcswc_module_latching_contactor.lst

               ROM used:   12164 bytes (74%)
                           Largest free fragment is 4216
               RAM used:   283 (55%) at main() level
                           311 (61%) worst case
               Stack used: 4 locations (2 in main + 2 for interrupts)
               Stack size: 31

0000:  GOTO   2D92
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   00D4
0060:  BTFSS  F9D.3
0062:  GOTO   006C
0066:  BTFSC  F9E.3
0068:  GOTO   0E8A
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include "dcswc_module_latching_contactor.h"
.................... #include <18F14K22.h>
.................... //////////// Standard Header file for the PIC18F14K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F14K22
00BA:  CLRF   FF7
00BC:  ADDLW  CA
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  RETURN 0
00CA:  DATA 36,2D
00CC:  DATA 46,65
00CE:  DATA 62,2D
00D0:  DATA 32,32
00D2:  DATA 00,00
*
0F5C:  DATA 23,20
0F5E:  DATA 20,20
0F60:  DATA 20,20
0F62:  DATA 20,20
0F64:  DATA 76,69
0F66:  DATA 6E,20
0F68:  DATA 61,64
0F6A:  DATA 63,3D
0F6C:  DATA 25,6C
0F6E:  DATA 75,0D
0F70:  DATA 0A,00
0F72:  DATA 23,20
0F74:  DATA 20,20
0F76:  DATA 20,20
0F78:  DATA 20,74
0F7A:  DATA 65,6D
0F7C:  DATA 70,20
0F7E:  DATA 61,64
0F80:  DATA 63,3D
0F82:  DATA 25,6C
0F84:  DATA 75,0D
0F86:  DATA 0A,00
0F88:  DATA 23,20
0F8A:  DATA 20,20
0F8C:  DATA 63,68
0F8E:  DATA 5B,30
0F90:  DATA 5D,2E
0F92:  DATA 73,74
0F94:  DATA 61,74
0F96:  DATA 65,3D
0F98:  DATA 30,78
0F9A:  DATA 25,32
0F9C:  DATA 58,0D
0F9E:  DATA 0A,00
0FA0:  DATA 23,20
0FA2:  DATA 20,20
0FA4:  DATA 63,68
0FA6:  DATA 5B,31
0FA8:  DATA 5D,2E
0FAA:  DATA 73,74
0FAC:  DATA 61,74
0FAE:  DATA 65,3D
0FB0:  DATA 30,78
0FB2:  DATA 25,32
0FB4:  DATA 58,0D
0FB6:  DATA 0A,00
0FB8:  DATA 23,20
0FBA:  DATA 64,63
0FBC:  DATA 73,77
0FBE:  DATA 63,5F
0FC0:  DATA 6D,6F
0FC2:  DATA 64,75
0FC4:  DATA 6C,65
0FC6:  DATA 5F,6C
0FC8:  DATA 61,74
0FCA:  DATA 63,68
0FCC:  DATA 69,6E
0FCE:  DATA 67,5F
0FD0:  DATA 63,6F
0FD2:  DATA 6E,74
0FD4:  DATA 61,63
0FD6:  DATA 74,6F
0FD8:  DATA 72,20
0FDA:  DATA 25,73
0FDC:  DATA 0D,0A
0FDE:  DATA 23,20
0FE0:  DATA 00,00
0FE2:  DATA 36,2D
0FE4:  DATA 46,65
0FE6:  DATA 62,2D
0FE8:  DATA 32,32
0FEA:  DATA 00,00
0FEC:  DATA 57,44
0FEE:  DATA 54,20
0FF0:  DATA 54,49
0FF2:  DATA 4D,45
0FF4:  DATA 4F,55
0FF6:  DATA 54,00
0FF8:  DATA 4D,43
0FFA:  DATA 4C,52
0FFC:  DATA 20,46
0FFE:  DATA 52,4F
1000:  DATA 4D,20
1002:  DATA 53,4C
1004:  DATA 45,45
1006:  DATA 50,00
1008:  DATA 4D,43
100A:  DATA 4C,52
100C:  DATA 20,46
100E:  DATA 52,4F
1010:  DATA 4D,20
1012:  DATA 52,55
1014:  DATA 4E,00
1016:  DATA 4E,4F
1018:  DATA 52,4D
101A:  DATA 41,4C
101C:  DATA 20,50
101E:  DATA 4F,57
1020:  DATA 45,52
1022:  DATA 20,55
1024:  DATA 50,00
1026:  DATA 42,52
1028:  DATA 4F,57
102A:  DATA 4E,4F
102C:  DATA 55,54
102E:  DATA 20,52
1030:  DATA 45,53
1032:  DATA 54,41
1034:  DATA 52,54
1036:  DATA 00,00
1038:  DATA 57,44
103A:  DATA 54,20
103C:  DATA 46,52
103E:  DATA 4F,4D
1040:  DATA 20,53
1042:  DATA 4C,45
1044:  DATA 45,50
1046:  DATA 00,00
1048:  DATA 52,45
104A:  DATA 53,45
104C:  DATA 54,20
104E:  DATA 49,4E
1050:  DATA 53,54
1052:  DATA 52,55
1054:  DATA 43,54
1056:  DATA 49,4F
1058:  DATA 4E,00
105A:  DATA 55,4E
105C:  DATA 4B,4E
105E:  DATA 4F,57
1060:  DATA 4E,21
1062:  DATA 00,00
*
1840:  TBLRD*+
1842:  MOVFF  FF6,11E
1846:  MOVFF  FF7,11F
184A:  MOVF   FF5,W
184C:  BTFSS  F9E.4
184E:  BRA    184C
1850:  MOVWF  FAD
1852:  MOVFF  11E,FF6
1856:  MOVFF  11F,FF7
185A:  MOVLB  1
185C:  DECFSZ x1D,F
185E:  BRA    1862
1860:  BRA    1866
1862:  MOVLB  0
1864:  BRA    1840
1866:  MOVLB  0
1868:  RETURN 0
186A:  TBLRD*+
186C:  MOVF   FF5,F
186E:  BZ    188A
1870:  MOVFF  FF6,11B
1874:  MOVFF  FF7,11C
1878:  MOVF   FF5,W
187A:  BTFSS  F9E.4
187C:  BRA    187A
187E:  MOVWF  FAD
1880:  MOVFF  11B,FF6
1884:  MOVFF  11C,FF7
1888:  BRA    186A
188A:  RETURN 0
*
2B8E:  MOVFF  FEA,125
2B92:  MOVFF  FE9,124
2B96:  MOVLB  1
2B98:  SWAPF  x1E,W
2B9A:  IORLW  F0
2B9C:  MOVWF  x20
2B9E:  ADDWF  x20,F
2BA0:  ADDLW  E2
2BA2:  MOVWF  x21
2BA4:  ADDLW  32
2BA6:  MOVWF  x23
2BA8:  MOVF   x1E,W
2BAA:  ANDLW  0F
2BAC:  ADDWF  x21,F
2BAE:  ADDWF  x21,F
2BB0:  ADDWF  x23,F
2BB2:  ADDLW  E9
2BB4:  MOVWF  x22
2BB6:  ADDWF  x22,F
2BB8:  ADDWF  x22,F
2BBA:  SWAPF  x1D,W
2BBC:  ANDLW  0F
2BBE:  ADDWF  x22,F
2BC0:  ADDWF  x23,F
2BC2:  RLCF   x22,F
2BC4:  RLCF   x23,F
2BC6:  COMF   x23,F
2BC8:  RLCF   x23,F
2BCA:  MOVF   x1D,W
2BCC:  ANDLW  0F
2BCE:  ADDWF  x23,F
2BD0:  RLCF   x20,F
2BD2:  MOVLW  07
2BD4:  MOVWF  x1F
2BD6:  MOVLW  0A
2BD8:  DECF   x22,F
2BDA:  ADDWF  x23,F
2BDC:  BNC   2BD8
2BDE:  DECF   x21,F
2BE0:  ADDWF  x22,F
2BE2:  BNC   2BDE
2BE4:  DECF   x20,F
2BE6:  ADDWF  x21,F
2BE8:  BNC   2BE4
2BEA:  DECF   x1F,F
2BEC:  ADDWF  x20,F
2BEE:  BNC   2BEA
2BF0:  MOVLW  01
2BF2:  MOVWF  FEA
2BF4:  MOVLW  1F
2BF6:  MOVWF  FE9
2BF8:  MOVLW  07
2BFA:  ANDWF  x24,W
2BFC:  BCF    x24.6
2BFE:  ADDWF  FE9,F
2C00:  MOVLW  00
2C02:  ADDWFC FEA,F
2C04:  MOVF   FE9,W
2C06:  SUBLW  23
2C08:  BNZ   2C10
2C0A:  DECFSZ FEA,W
2C0C:  BRA    2C10
2C0E:  BSF    x24.6
2C10:  MOVF   FEF,W
2C12:  MOVWF  00
2C14:  BNZ   2C26
2C16:  BTFSC  x24.6
2C18:  BRA    2C26
2C1A:  BTFSC  x24.4
2C1C:  BRA    2C36
2C1E:  BTFSC  x24.3
2C20:  BRA    2C26
2C22:  MOVLW  20
2C24:  BRA    2C2C
2C26:  BSF    x24.3
2C28:  BCF    x24.4
2C2A:  MOVLW  30
2C2C:  ADDWF  00,F
2C2E:  MOVF   00,W
2C30:  BTFSS  F9E.4
2C32:  BRA    2C30
2C34:  MOVWF  FAD
2C36:  MOVF   FEE,W
2C38:  BTFSS  x24.6
2C3A:  BRA    2C04
2C3C:  MOVLB  0
2C3E:  RETURN 0
2C40:  MOVLB  1
2C42:  BTFSC  x1C.7
2C44:  BRA    2C66
2C46:  MOVLW  0F
2C48:  MOVWF  00
2C4A:  SWAPF  x1B,W
2C4C:  ANDWF  00,F
2C4E:  MOVLW  0A
2C50:  SUBWF  00,W
2C52:  BC    2C5A
2C54:  MOVLW  30
2C56:  ADDWF  00,F
2C58:  BRA    2C5E
2C5A:  MOVF   x1C,W
2C5C:  ADDWF  00,F
2C5E:  MOVF   00,W
2C60:  BTFSS  F9E.4
2C62:  BRA    2C60
2C64:  MOVWF  FAD
2C66:  MOVLW  0F
2C68:  ANDWF  x1B,F
2C6A:  MOVLW  0A
2C6C:  SUBWF  x1B,W
2C6E:  BC    2C74
2C70:  MOVLW  30
2C72:  BRA    2C78
2C74:  BCF    x1C.7
2C76:  MOVF   x1C,W
2C78:  ADDWF  x1B,F
2C7A:  MOVF   x1B,W
2C7C:  BTFSS  F9E.4
2C7E:  BRA    2C7C
2C80:  MOVWF  FAD
2C82:  MOVLB  0
2C84:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #device *=16
.................... #use delay(clock=16MHz)
*
1064:  MOVLW  01
1066:  MOVWF  FEA
1068:  MOVLW  28
106A:  MOVWF  FE9
106C:  MOVF   FEF,W
106E:  BZ    108C
1070:  MOVLW  05
1072:  MOVWF  01
1074:  CLRF   00
1076:  DECFSZ 00,F
1078:  BRA    1076
107A:  DECFSZ 01,F
107C:  BRA    1074
107E:  MOVLW  2E
1080:  MOVWF  00
1082:  DECFSZ 00,F
1084:  BRA    1082
1086:  BRA    1088
1088:  DECFSZ FEF,F
108A:  BRA    1070
108C:  RETURN 0
.................... 
.................... /* hardware I2C port is slave and is connected to DCSWC bus */
.................... #use i2c(stream=STREAM_SLAVE,SLAVE, I2C1, FORCE_HW)
*
0E74:  MOVF   FC9,W
0E76:  MOVFF  12D,FC9
0E7A:  BSF    FC6.4
0E7C:  BCF    F9E.3
0E7E:  BTFSC  FC7.0
0E80:  BRA    0E7E
0E82:  CLRF   01
0E84:  BTFSS  FC5.6
0E86:  INCF   01,F
0E88:  RETURN 0
.................... /* slave address set based on dip switch in init() */
.................... 
.................... /* important FUSE notes! 
.................... MPLAB defaults to DEBUG mode and that will override fuses.
.................... make sure it is on "BUILD CONFIGURATION" of "RELEASE" under
.................... "PROJECT" menu.
.................... 
.................... CCS setup functions can override fuses. Check .LST file
.................... to see if anything has been overriden!
.................... */
.................... 
.................... #fuses NODEBUG 
.................... #fuses INTRC_IO
.................... #fuses NOPCLKEN
.................... #fuses NOPLLEN
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses BROWNOUT
.................... #fuses BORV30
.................... #fuses NOPUT
.................... #fuses WDT
.................... #fuses WDT128     /* this can be override by setup_wdt() */
.................... #fuses NOHFOFST
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses NOLVP
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... #fuses NOPROTECT
.................... #fuses NOWRT
.................... #fuses NOWRTC 
.................... #fuses NOWRTB
.................... #fuses NOWRTD
.................... #fuses NOEBTR
.................... #fuses NOEBTRB
.................... #fuses BBSIZ1K
.................... 
.................... 
.................... #use standard_io(ALL)
.................... 
.................... #use rs232(UART1,stream=STREAM_FTDI,baud=57600,errors)	
*
2B76:  BTFSS  F9E.5
2B78:  BRA    2B76
2B7A:  MOVFF  FAB,1A
2B7E:  MOVFF  FAE,01
2B82:  BTFSS  1A.1
2B84:  BRA    2B8A
2B86:  BCF    FAB.4
2B88:  BSF    FAB.4
2B8A:  GOTO   2F5A (RETURN)
.................... 
.................... /* program config CRC of 0 and a serial_prefix of 'A' ... that will trigger a write default on first boot */
.................... #ROM 0xF00000 = { 0x00, 0x00, 0x40, 0x00 }
.................... 
.................... 
.................... 
.................... 
.................... #define SW_OVERRIDE_A        PIN_A5
.................... #define SW_OVERRIDE_B        PIN_A4
.................... #define BRIDGE_B_A           PIN_C5
.................... #define BRIDGE_A_B           PIN_C4
.................... #define BRIDGE_A_A           PIN_C3
.................... #define BRIDGE_B_B           PIN_C6
.................... #define AN_DIP               PIN_C7
.................... #define SER_TO_PC            PIN_B7
.................... #define AN_VTEMP             PIN_A2
.................... #define AN_IN_VOLTS          PIN_C0
.................... #define LED_A                PIN_C1
.................... #define LED_B                PIN_C2
.................... #define I2C_SDA              PIN_B4
.................... #define SER_FROM_PC          PIN_B5
.................... #define I2C_SCL              PIN_B6
.................... 
.................... 
.................... /* 
.................... Parameters are stored in EEPROM
.................... */
.................... #define PARAM_CRC_ADDRESS  0x00
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2
.................... 
.................... 
.................... 
.................... /* bit positions for a channel state byte */
.................... #define CH_STATE_BIT_FUTURE   7  /* reserved for future use */
.................... #define CH_STATE_BIT_HTD      6  /* high temperature disconnect */
.................... #define CH_STATE_BIT_LTD      5  /* low temperature disconnect */
.................... #define CH_STATE_BIT_HVD      4  /* high voltage disconnect */
.................... #define CH_STATE_BIT_LVD      3  /* low voltage disconnect */
.................... #define CH_STATE_BIT_CMD_OFF  2  /* commanded off */
.................... #define CH_STATE_BIT_CMD_ON   1  /* commanded on (takes presedence over commanded off) */
.................... #define CH_STATE_BIT_OVERRIDE 0  /* override switch */
.................... 
.................... /* _OVERRIDE or _CMD_ON set means output on */
.................... #define CH_STATE_MASK_ON     0b00000011 
.................... /* _CMD_OFF, _LVD, _HVD, _LTD, _HTD means output off, unless override by on mask */
.................... #define CH_STATE_MASK_OFF    0b01111100 
.................... 
.................... #define ADC_SAMPLE_TICKS              20
.................... #define CONTACTOR_POWER_SAVE_MS       200 /* milliseconds for contactor be on. Must be >0 and <= 255 */
.................... #define CONTACTOR_REFRESH_CYCLES      10  /* re-appply contactor coil voltage every N cycles. 65525 disables */
.................... 
.................... #define BLINK_ON_TIME                 254
.................... #define BLINK_OFF_TIME                200
.................... 
.................... 
.................... typedef struct {
.................... 	/* command on hold time */
.................... 	int16 command_on_hold_time;
.................... 
.................... 	/* command off hold time */
.................... 	int16 command_off_hold_time;
.................... 
.................... 	/* low voltage disconnect */
.................... 	int16 lvd_disconnect_adc;
.................... 	int16 lvd_disconnect_delay;
.................... 	int16 lvd_reconnect_adc;
.................... 	int16 lvd_reconnect_delay;
.................... 
.................... 	/* high voltage disconnect */
.................... 	int16 hvd_disconnect_adc;
.................... 	int16 hvd_disconnect_delay;
.................... 	int16 hvd_reconnect_adc;
.................... 	int16 hvd_reconnect_delay;
.................... 
.................... 	/* low temperature disconnect */
.................... 	int16 ltd_disconnect_adc;
.................... 	int16 ltd_disconnect_delay;
.................... 	int16 ltd_reconnect_adc;
.................... 	int16 ltd_reconnect_delay;
.................... 
.................... 	/* high temperature disconnect */
.................... 	int16 htd_disconnect_adc;
.................... 	int16 htd_disconnect_delay;
.................... 	int16 htd_reconnect_adc;
.................... 	int16 htd_reconnect_delay;
.................... } struct_config_channel;
.................... 
.................... typedef struct {
.................... 	/* not much going on here */
.................... 	struct_config_channel ch[2];
.................... } struct_config;
.................... 
.................... 
.................... typedef struct {
.................... 	int8 state;
.................... 
.................... 	int16 command_on_seconds;			/* counts down. Off at zero. */
.................... 	int16 command_on_hold_seconds;      /* counts down. Off at zero. */
.................... 
.................... 	int16 command_off_seconds;			/* counts down. Off at zero. */
.................... 	int16 command_off_hold_seconds;     /* counts down. Off at zero. */
.................... 
.................... 	int16 lvd_disconnect_delay_seconds;	/* counts down */
.................... 	int16  lvd_reconnect_delay_seconds;	/* counts down */
.................... 
.................... 	int16 hvd_disconnect_delay_seconds;	/* counts down */
.................... 	int16  hvd_reconnect_delay_seconds;	/* counts down */
.................... 
.................... 	int16 ltd_disconnect_delay_seconds; /* counts down */
.................... 	int16 ltd_reconnect_delay_seconds;  /* counts down */
.................... 
.................... 	int16 htd_disconnect_delay_seconds; /* counts down */
.................... 	int16 htd_reconnect_delay_seconds;  /* counts down */
.................... } struct_channel;
.................... 
.................... typedef struct {
.................... 	/* circular buffer for ADC readings */
.................... 	int16 adc_buffer[3][16];
.................... 	int8  adc_buffer_index;
.................... 
.................... 	int16 sequence_number;
.................... 	int16 uptime_minutes;
.................... 	int16 interval_milliseconds;
.................... 
.................... 	int8 factory_unlocked;
.................... 
.................... 
.................... 	int8 compile_year;
.................... 	int8 compile_month;
.................... 	int8 compile_day;
.................... 
.................... 
.................... 	int8 default_params_written;
.................... } struct_current;
.................... 
.................... typedef struct {
.................... 	/* action flags */
.................... 	int1 now_adc_sample;
.................... 	int1 now_adc_reset_count;
.................... 
.................... 	int1 now_millisecond;
.................... 
.................... 	int1 now_write_config;
.................... 	int1 now_reset_config;
.................... 
.................... 	int1 now_debug_dump;
.................... 
.................... 
.................... 	/* timers */
.................... 	int8 led_blink[2];
.................... 	int8 led_on[2];
.................... 	int8 led_off[2];
.................... 
.................... 	/* contactors */
.................... 	int8 contactor[2]; 	         /* current state */
.................... 	int8 contactor_powersave[2]; /* countdown to shut off power to coil at 0 */
.................... } struct_time_keep;
.................... 
.................... /* global structures */
.................... struct_config config={0};
.................... struct_current current={0};
.................... struct_time_keep timers={0};
.................... struct_channel channel[2]={0};
.................... 
.................... #include "adc_dcswc_module_latching_contactor.c"
.................... int16 adc_get(int8 ch) {
.................... 	int16 sum;
.................... 	int8 i;
.................... 
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */
.................... 	int16 *p;
.................... 	p = current.adc_buffer[ch];
*
0594:  MOVLB  1
0596:  MOVF   x2F,W
0598:  MULLW  20
059A:  MOVF   FF3,W
059C:  CLRF   03
059E:  ADDLW  63
05A0:  MOVWF  01
05A2:  MOVLW  00
05A4:  ADDWFC 03,F
05A6:  MOVFF  01,133
05AA:  MOVFF  03,134
.................... 
.................... 	// Calculate the mean.  This is done by summing up the
.................... 	// values and dividing by the number of elements.
.................... 	sum = 0;
05AE:  CLRF   x31
05B0:  CLRF   x30
.................... 	for( i = 0; i < 16 ; i++ ) {
05B2:  CLRF   x32
05B4:  MOVF   x32,W
05B6:  SUBLW  0F
05B8:  BNC   05E4
.................... //		sum += current.adc_buffer[ch][i];
.................... 		sum += p[i];
05BA:  CLRF   03
05BC:  MOVFF  132,02
05C0:  BCF    FD8.0
05C2:  RLCF   02,F
05C4:  RLCF   03,F
05C6:  MOVF   02,W
05C8:  ADDWF  x33,W
05CA:  MOVWF  FE9
05CC:  MOVF   x34,W
05CE:  ADDWFC 03,W
05D0:  MOVWF  FEA
05D2:  MOVFF  FEC,03
05D6:  MOVF   FED,F
05D8:  MOVF   FEF,W
05DA:  ADDWF  x30,F
05DC:  MOVF   03,W
05DE:  ADDWFC x31,F
05E0:  INCF   x32,F
05E2:  BRA    05B4
.................... 	}
.................... 
.................... 	/* divide sum by our 16 samples and round by adding 8 */
.................... 	return ( (sum+8) >> 4 );
05E4:  MOVLW  08
05E6:  ADDWF  x30,W
05E8:  MOVWF  x35
05EA:  MOVLW  00
05EC:  ADDWFC x31,W
05EE:  MOVWF  x36
05F0:  RRCF   x36,W
05F2:  MOVWF  03
05F4:  RRCF   x35,W
05F6:  MOVWF  02
05F8:  RRCF   03,F
05FA:  RRCF   02,F
05FC:  RRCF   03,F
05FE:  RRCF   02,F
0600:  RRCF   03,F
0602:  RRCF   02,F
0604:  MOVLW  0F
0606:  ANDWF  03,F
0608:  MOVFF  02,01
060C:  MOVFF  03,02
0610:  MOVLB  0
0612:  RETURN 0
.................... }
.................... 
.................... 
.................... void adc_update(void) {
.................... 
.................... 	/* wrap buffer around */
.................... 	current.adc_buffer_index++;
*
188C:  INCF   xC3,F
.................... 	if ( current.adc_buffer_index >= 16 )
188E:  MOVF   xC3,W
1890:  SUBLW  0F
1892:  BC    1896
.................... 		current.adc_buffer_index=0;
1894:  CLRF   xC3
.................... 
.................... 	set_adc_channel(4);
1896:  MOVLW  10
1898:  MOVWF  01
189A:  MOVF   FC2,W
189C:  ANDLW  C3
189E:  IORWF  01,W
18A0:  MOVWF  FC2
.................... 	current.adc_buffer[0][current.adc_buffer_index] = read_adc();
18A2:  BCF    FD8.0
18A4:  RLCF   xC3,W
18A6:  CLRF   03
18A8:  ADDLW  63
18AA:  MOVWF  FE9
18AC:  MOVLW  00
18AE:  ADDWFC 03,W
18B0:  MOVWF  FEA
18B2:  BSF    FC2.1
18B4:  BTFSC  FC2.1
18B6:  BRA    18B4
18B8:  MOVFF  FC3,FEF
18BC:  MOVFF  FC4,FEC
.................... 
.................... 
.................... 	set_adc_channel(2);
18C0:  MOVLW  08
18C2:  MOVWF  01
18C4:  MOVF   FC2,W
18C6:  ANDLW  C3
18C8:  IORWF  01,W
18CA:  MOVWF  FC2
.................... 	delay_ms(1);
18CC:  MOVLW  01
18CE:  MOVLB  1
18D0:  MOVWF  x28
18D2:  MOVLB  0
18D4:  CALL   1064
.................... 	current.adc_buffer[1][current.adc_buffer_index] = read_adc();
18D8:  BCF    FD8.0
18DA:  RLCF   xC3,W
18DC:  CLRF   03
18DE:  ADDLW  83
18E0:  MOVWF  FE9
18E2:  MOVLW  00
18E4:  ADDWFC 03,W
18E6:  MOVWF  FEA
18E8:  BSF    FC2.1
18EA:  BTFSC  FC2.1
18EC:  BRA    18EA
18EE:  MOVFF  FC3,FEF
18F2:  MOVFF  FC4,FEC
.................... 
.................... 	set_adc_channel(9);
18F6:  MOVLW  24
18F8:  MOVWF  01
18FA:  MOVF   FC2,W
18FC:  ANDLW  C3
18FE:  IORWF  01,W
1900:  MOVWF  FC2
.................... 	delay_ms(1);
1902:  MOVLW  01
1904:  MOVLB  1
1906:  MOVWF  x28
1908:  MOVLB  0
190A:  CALL   1064
.................... 	current.adc_buffer[2][current.adc_buffer_index] = read_adc();
190E:  BCF    FD8.0
1910:  RLCF   xC3,W
1912:  CLRF   03
1914:  ADDLW  A3
1916:  MOVWF  FE9
1918:  MOVLW  00
191A:  ADDWFC 03,W
191C:  MOVWF  FEA
191E:  BSF    FC2.1
1920:  BTFSC  FC2.1
1922:  BRA    1920
1924:  MOVFF  FC3,FEF
1928:  MOVFF  FC4,FEC
192C:  RETURN 0
.................... }
.................... 
.................... int8 read_dip_switch(void) {
.................... 	int16 adc;
.................... 
.................... 	set_adc_channel(9);
*
108E:  MOVLW  24
1090:  MOVWF  01
1092:  MOVF   FC2,W
1094:  ANDLW  C3
1096:  IORWF  01,W
1098:  MOVWF  FC2
.................... 	delay_ms(1);
109A:  MOVLW  01
109C:  MOVLB  1
109E:  MOVWF  x28
10A0:  MOVLB  0
10A2:  RCALL  1064
.................... 	adc=read_adc();
10A4:  BSF    FC2.1
10A6:  BTFSC  FC2.1
10A8:  BRA    10A6
10AA:  MOVFF  FC4,127
10AE:  MOVFF  FC3,126
.................... 
.................... 	/* (note that table is sorted by vout reading 
.................... 	SW3.1 (LSB) SW3.2 (MSB) VALUE ADC
....................     OFF         OFF         0     1023
.................... 	OFF         ON          2     682
....................     ON          OFF         1     511
.................... 	ON          ON          3     409
.................... 	*/
.................... 
.................... 	if ( adc > (1023-64) )
10B2:  MOVLB  1
10B4:  MOVF   x27,W
10B6:  SUBLW  02
10B8:  BC    10CA
10BA:  XORLW  FF
10BC:  BNZ   10C4
10BE:  MOVF   x26,W
10C0:  SUBLW  BF
10C2:  BC    10CA
.................... 		return 0;
10C4:  MOVLW  00
10C6:  MOVWF  01
10C8:  BRA    10FA
.................... 	if ( adc > (682-64) )
10CA:  MOVF   x27,W
10CC:  SUBLW  01
10CE:  BC    10E0
10D0:  XORLW  FF
10D2:  BNZ   10DA
10D4:  MOVF   x26,W
10D6:  SUBLW  6A
10D8:  BC    10E0
.................... 		return 2;
10DA:  MOVLW  02
10DC:  MOVWF  01
10DE:  BRA    10FA
.................... 	if ( adc > (511-64) )
10E0:  MOVF   x27,W
10E2:  SUBLW  00
10E4:  BC    10F6
10E6:  XORLW  FF
10E8:  BNZ   10F0
10EA:  MOVF   x26,W
10EC:  SUBLW  BF
10EE:  BC    10F6
.................... 		return 1;
10F0:  MOVLW  01
10F2:  MOVWF  01
10F4:  BRA    10FA
.................... 
.................... 	return 3;
10F6:  MOVLW  03
10F8:  MOVWF  01
10FA:  MOVLB  0
10FC:  GOTO   13B2 (RETURN)
.................... }
.................... 
.................... #include "param_dcswc_module_latching_contactor.c"
.................... #inline
.................... char xor_crc(char oldcrc, char data) {
.................... 	return oldcrc ^ data;
*
142A:  MOVF   x28,W
142C:  XORWF  x29,W
142E:  MOVWF  01
*
1478:  MOVF   x28,W
147A:  XORWF  x29,W
147C:  MOVWF  01
.................... }
.................... 
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) {
*
13C2:  MOVLB  1
13C4:  CLRF   x24
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
13C6:  MOVFF  123,126
13CA:  MOVF   x22,W
13CC:  BTFSC  FD8.2
13CE:  DECF   x23,F
13D0:  DECF   x22,F
13D2:  MOVWF  x25
13D4:  MOVF   x25,F
13D6:  BNZ   13DC
13D8:  MOVF   x26,F
13DA:  BZ    143C
.................... 		*data = read_eeprom( address++ );
13DC:  MOVFF  121,03
13E0:  MOVF   x20,W
13E2:  MOVWF  FE9
13E4:  MOVFF  03,FEA
13E8:  MOVF   x1F,W
13EA:  MOVWF  03
13EC:  MOVF   x1E,W
13EE:  INCF   x1E,F
13F0:  BTFSC  FD8.2
13F2:  INCF   x1F,F
13F4:  MOVWF  x27
13F6:  MOVFF  03,128
13FA:  MOVFF  FF2,129
13FE:  BCF    FF2.7
1400:  MOVFF  127,FA9
1404:  BCF    FA6.6
1406:  BCF    FA6.7
1408:  BSF    FA6.0
140A:  MOVF   FA8,W
140C:  BTFSC  x29.7
140E:  BSF    FF2.7
1410:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data);
1412:  MOVFF  121,03
1416:  MOVF   x20,W
1418:  MOVWF  FE9
141A:  MOVFF  03,FEA
141E:  MOVFF  FEF,125
1422:  MOVFF  124,128
1426:  MOVFF  125,129
*
1430:  MOVFF  01,124
.................... 		data++;
1434:  INCF   x20,F
1436:  BTFSC  FD8.2
1438:  INCF   x21,F
143A:  BRA    13C6
.................... 	}
.................... 	return crc;
143C:  MOVFF  124,01
1440:  MOVLB  0
1442:  GOTO   1816 (RETURN)
.................... }
.................... 
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) {
1446:  MOVLB  1
1448:  CLRF   x26
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
144A:  MOVFF  125,128
144E:  MOVF   x24,W
1450:  BTFSC  FD8.2
1452:  DECF   x25,F
1454:  DECF   x24,F
1456:  MOVWF  x27
1458:  MOVF   x27,F
145A:  BNZ   1460
145C:  MOVF   x28,F
145E:  BZ    14D8
.................... 		/* restart_wdt() */
.................... 		crc = xor_crc(crc,*data);
1460:  MOVFF  123,03
1464:  MOVF   x22,W
1466:  MOVWF  FE9
1468:  MOVFF  03,FEA
146C:  MOVFF  FEF,127
1470:  MOVFF  126,128
1474:  MOVFF  127,129
*
147E:  MOVFF  01,126
.................... 		write_eeprom( address++, *data++ );
1482:  MOVF   x21,W
1484:  MOVWF  03
1486:  MOVF   x20,W
1488:  INCF   x20,F
148A:  BTFSC  FD8.2
148C:  INCF   x21,F
148E:  MOVWF  x27
1490:  MOVFF  03,128
1494:  MOVF   x23,W
1496:  MOVWF  03
1498:  MOVF   x22,W
149A:  INCF   x22,F
149C:  BTFSC  FD8.2
149E:  INCF   x23,F
14A0:  MOVWF  FE9
14A2:  MOVFF  03,FEA
14A6:  MOVFF  FEF,129
14AA:  MOVF   FF2,W
14AC:  MOVWF  00
14AE:  BCF    FF2.7
14B0:  MOVFF  127,FA9
14B4:  MOVFF  129,FA8
14B8:  BCF    FA6.6
14BA:  BCF    FA6.7
14BC:  BSF    FA6.2
14BE:  MOVLB  F
14C0:  MOVLW  55
14C2:  MOVWF  FA7
14C4:  MOVLW  AA
14C6:  MOVWF  FA7
14C8:  BSF    FA6.1
14CA:  BTFSC  FA6.1
14CC:  BRA    14CA
14CE:  BCF    FA6.2
14D0:  MOVF   00,W
14D2:  IORWF  FF2,F
14D4:  MOVLB  1
14D6:  BRA    144A
.................... 	}
.................... 
.................... 	return crc;
14D8:  MOVFF  126,01
14DC:  MOVLB  0
14DE:  GOTO   14FE (RETURN)
.................... }
.................... 
.................... void write_param_file() {
.................... 	int8 crc;
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config));
14E2:  MOVLB  1
14E4:  MOVLW  1B
14E6:  MOVWF  x1E
14E8:  CLRF   x21
14EA:  MOVLW  02
14EC:  MOVWF  x20
14EE:  CLRF   x23
14F0:  MOVFF  11E,122
14F4:  CLRF   x25
14F6:  MOVLW  48
14F8:  MOVWF  x24
14FA:  MOVLB  0
14FC:  BRA    1446
14FE:  MOVFF  01,11D
.................... 	/* write the CRC was calculated on the structure */
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc);
1502:  MOVF   FF2,W
1504:  MOVWF  00
1506:  BCF    FF2.7
1508:  CLRF   FA9
150A:  MOVFF  11D,FA8
150E:  BCF    FA6.6
1510:  BCF    FA6.7
1512:  BSF    FA6.2
1514:  MOVLB  F
1516:  MOVLW  55
1518:  MOVWF  FA7
151A:  MOVLW  AA
151C:  MOVWF  FA7
151E:  BSF    FA6.1
1520:  BTFSC  FA6.1
1522:  BRA    1520
1524:  BCF    FA6.2
1526:  MOVF   00,W
1528:  IORWF  FF2,F
152A:  MOVLB  0
152C:  RETURN 0
.................... }
.................... 
.................... void write_default_param_file() {
.................... 	int8 i;
.................... 
.................... 	current.default_params_written=1;
152E:  MOVLW  01
1530:  MOVWF  xCE
.................... 
.................... 	/* both LEDs on */
.................... 	timers.led_blink[0]=255;
1532:  SETF   xD0
.................... 	timers.led_blink[1]=255;
1534:  SETF   xD1
.................... 
.................... 
.................... 	for ( i=0 ; i<2 ; i++ ) {
1536:  MOVLB  1
1538:  CLRF   x1C
153A:  MOVF   x1C,W
153C:  SUBLW  01
153E:  BTFSS  FD8.0
1540:  BRA    17F4
.................... 		/* low voltage disconnect */
.................... 		config.ch[i].lvd_disconnect_adc=606;
1542:  MOVF   x1C,W
1544:  MULLW  24
1546:  MOVF   FF3,W
1548:  CLRF   x1E
154A:  MOVWF  x1D
154C:  MOVLW  04
154E:  ADDWF  x1D,W
1550:  MOVWF  01
1552:  MOVLW  00
1554:  ADDWFC x1E,W
1556:  MOVWF  03
1558:  MOVF   01,W
155A:  ADDLW  1B
155C:  MOVWF  FE9
155E:  MOVLW  00
1560:  ADDWFC 03,W
1562:  MOVWF  FEA
1564:  MOVLW  02
1566:  MOVWF  FEC
1568:  MOVF   FED,F
156A:  MOVLW  5E
156C:  MOVWF  FEF
.................... 		config.ch[i].lvd_disconnect_delay=20; /* 65535 disables LVD */
156E:  MOVF   x1C,W
1570:  MULLW  24
1572:  MOVF   FF3,W
1574:  CLRF   x1E
1576:  MOVWF  x1D
1578:  MOVLW  06
157A:  ADDWF  x1D,W
157C:  MOVWF  01
157E:  MOVLW  00
1580:  ADDWFC x1E,W
1582:  MOVWF  03
1584:  MOVF   01,W
1586:  ADDLW  1B
1588:  MOVWF  FE9
158A:  MOVLW  00
158C:  ADDWFC 03,W
158E:  MOVWF  FEA
1590:  CLRF   FEC
1592:  MOVF   FED,F
1594:  MOVLW  14
1596:  MOVWF  FEF
.................... 		config.ch[i].lvd_reconnect_adc=616;
1598:  MOVF   x1C,W
159A:  MULLW  24
159C:  MOVF   FF3,W
159E:  CLRF   x1E
15A0:  MOVWF  x1D
15A2:  MOVLW  08
15A4:  ADDWF  x1D,W
15A6:  MOVWF  01
15A8:  MOVLW  00
15AA:  ADDWFC x1E,W
15AC:  MOVWF  03
15AE:  MOVF   01,W
15B0:  ADDLW  1B
15B2:  MOVWF  FE9
15B4:  MOVLW  00
15B6:  ADDWFC 03,W
15B8:  MOVWF  FEA
15BA:  MOVLW  02
15BC:  MOVWF  FEC
15BE:  MOVF   FED,F
15C0:  MOVLW  68
15C2:  MOVWF  FEF
.................... 		config.ch[i].lvd_reconnect_delay=10;
15C4:  MOVF   x1C,W
15C6:  MULLW  24
15C8:  MOVF   FF3,W
15CA:  CLRF   x1E
15CC:  MOVWF  x1D
15CE:  MOVLW  0A
15D0:  ADDWF  x1D,W
15D2:  MOVWF  01
15D4:  MOVLW  00
15D6:  ADDWFC x1E,W
15D8:  MOVWF  03
15DA:  MOVF   01,W
15DC:  ADDLW  1B
15DE:  MOVWF  FE9
15E0:  MOVLW  00
15E2:  ADDWFC 03,W
15E4:  MOVWF  FEA
15E6:  CLRF   FEC
15E8:  MOVF   FED,F
15EA:  MOVLW  0A
15EC:  MOVWF  FEF
.................... 		
.................... 		/* high voltage disconnect */
.................... 		config.ch[i].hvd_disconnect_adc=700;
15EE:  MOVF   x1C,W
15F0:  MULLW  24
15F2:  MOVF   FF3,W
15F4:  CLRF   x1E
15F6:  MOVWF  x1D
15F8:  MOVLW  0C
15FA:  ADDWF  x1D,W
15FC:  MOVWF  01
15FE:  MOVLW  00
1600:  ADDWFC x1E,W
1602:  MOVWF  03
1604:  MOVF   01,W
1606:  ADDLW  1B
1608:  MOVWF  FE9
160A:  MOVLW  00
160C:  ADDWFC 03,W
160E:  MOVWF  FEA
1610:  MOVLW  02
1612:  MOVWF  FEC
1614:  MOVF   FED,F
1616:  MOVLW  BC
1618:  MOVWF  FEF
.................... 		config.ch[i].hvd_disconnect_delay=1; /* 65535 disables HVD */
161A:  MOVF   x1C,W
161C:  MULLW  24
161E:  MOVF   FF3,W
1620:  CLRF   x1E
1622:  MOVWF  x1D
1624:  MOVLW  0E
1626:  ADDWF  x1D,W
1628:  MOVWF  01
162A:  MOVLW  00
162C:  ADDWFC x1E,W
162E:  MOVWF  03
1630:  MOVF   01,W
1632:  ADDLW  1B
1634:  MOVWF  FE9
1636:  MOVLW  00
1638:  ADDWFC 03,W
163A:  MOVWF  FEA
163C:  CLRF   FEC
163E:  MOVF   FED,F
1640:  MOVLW  01
1642:  MOVWF  FEF
.................... 		config.ch[i].hvd_reconnect_adc=650;
1644:  MOVF   x1C,W
1646:  MULLW  24
1648:  MOVF   FF3,W
164A:  CLRF   x1E
164C:  MOVWF  x1D
164E:  MOVLW  10
1650:  ADDWF  x1D,W
1652:  MOVWF  01
1654:  MOVLW  00
1656:  ADDWFC x1E,W
1658:  MOVWF  03
165A:  MOVF   01,W
165C:  ADDLW  1B
165E:  MOVWF  FE9
1660:  MOVLW  00
1662:  ADDWFC 03,W
1664:  MOVWF  FEA
1666:  MOVLW  02
1668:  MOVWF  FEC
166A:  MOVF   FED,F
166C:  MOVLW  8A
166E:  MOVWF  FEF
.................... 		config.ch[i].hvd_reconnect_delay=60;
1670:  MOVF   x1C,W
1672:  MULLW  24
1674:  MOVF   FF3,W
1676:  CLRF   x1E
1678:  MOVWF  x1D
167A:  MOVLW  12
167C:  ADDWF  x1D,W
167E:  MOVWF  01
1680:  MOVLW  00
1682:  ADDWFC x1E,W
1684:  MOVWF  03
1686:  MOVF   01,W
1688:  ADDLW  1B
168A:  MOVWF  FE9
168C:  MOVLW  00
168E:  ADDWFC 03,W
1690:  MOVWF  FEA
1692:  CLRF   FEC
1694:  MOVF   FED,F
1696:  MOVLW  3C
1698:  MOVWF  FEF
.................... 
.................... 		/* low temperature disconnect */
.................... 		config.ch[i].ltd_disconnect_adc=786; // 0C / 32F
169A:  MOVF   x1C,W
169C:  MULLW  24
169E:  MOVF   FF3,W
16A0:  CLRF   x1E
16A2:  MOVWF  x1D
16A4:  MOVLW  14
16A6:  ADDWF  x1D,W
16A8:  MOVWF  01
16AA:  MOVLW  00
16AC:  ADDWFC x1E,W
16AE:  MOVWF  03
16B0:  MOVF   01,W
16B2:  ADDLW  1B
16B4:  MOVWF  FE9
16B6:  MOVLW  00
16B8:  ADDWFC 03,W
16BA:  MOVWF  FEA
16BC:  MOVLW  03
16BE:  MOVWF  FEC
16C0:  MOVF   FED,F
16C2:  MOVLW  12
16C4:  MOVWF  FEF
.................... 		config.ch[i].ltd_disconnect_delay=1; /* 65535 disables LTD */
16C6:  MOVF   x1C,W
16C8:  MULLW  24
16CA:  MOVF   FF3,W
16CC:  CLRF   x1E
16CE:  MOVWF  x1D
16D0:  MOVLW  16
16D2:  ADDWF  x1D,W
16D4:  MOVWF  01
16D6:  MOVLW  00
16D8:  ADDWFC x1E,W
16DA:  MOVWF  03
16DC:  MOVF   01,W
16DE:  ADDLW  1B
16E0:  MOVWF  FE9
16E2:  MOVLW  00
16E4:  ADDWFC 03,W
16E6:  MOVWF  FEA
16E8:  CLRF   FEC
16EA:  MOVF   FED,F
16EC:  MOVLW  01
16EE:  MOVWF  FEF
.................... 		config.ch[i].ltd_reconnect_adc=683;  // 10C / 50F
16F0:  MOVF   x1C,W
16F2:  MULLW  24
16F4:  MOVF   FF3,W
16F6:  CLRF   x1E
16F8:  MOVWF  x1D
16FA:  MOVLW  18
16FC:  ADDWF  x1D,W
16FE:  MOVWF  01
1700:  MOVLW  00
1702:  ADDWFC x1E,W
1704:  MOVWF  03
1706:  MOVF   01,W
1708:  ADDLW  1B
170A:  MOVWF  FE9
170C:  MOVLW  00
170E:  ADDWFC 03,W
1710:  MOVWF  FEA
1712:  MOVLW  02
1714:  MOVWF  FEC
1716:  MOVF   FED,F
1718:  MOVLW  AB
171A:  MOVWF  FEF
.................... 		config.ch[i].ltd_reconnect_delay=4;
171C:  MOVF   x1C,W
171E:  MULLW  24
1720:  MOVF   FF3,W
1722:  CLRF   x1E
1724:  MOVWF  x1D
1726:  MOVLW  1A
1728:  ADDWF  x1D,W
172A:  MOVWF  01
172C:  MOVLW  00
172E:  ADDWFC x1E,W
1730:  MOVWF  03
1732:  MOVF   01,W
1734:  ADDLW  1B
1736:  MOVWF  FE9
1738:  MOVLW  00
173A:  ADDWFC 03,W
173C:  MOVWF  FEA
173E:  CLRF   FEC
1740:  MOVF   FED,F
1742:  MOVLW  04
1744:  MOVWF  FEF
.................... 
.................... 		/* high temperature disconnect */
.................... 		config.ch[i].htd_disconnect_adc=405; // 35C / 95F
1746:  MOVF   x1C,W
1748:  MULLW  24
174A:  MOVF   FF3,W
174C:  CLRF   x1E
174E:  MOVWF  x1D
1750:  MOVLW  1C
1752:  ADDWF  x1D,W
1754:  MOVWF  01
1756:  MOVLW  00
1758:  ADDWFC x1E,W
175A:  MOVWF  03
175C:  MOVF   01,W
175E:  ADDLW  1B
1760:  MOVWF  FE9
1762:  MOVLW  00
1764:  ADDWFC 03,W
1766:  MOVWF  FEA
1768:  MOVLW  01
176A:  MOVWF  FEC
176C:  MOVF   FED,F
176E:  MOVLW  95
1770:  MOVWF  FEF
.................... 		config.ch[i].htd_disconnect_delay=1; /* 65535 disables LTD */
1772:  MOVF   x1C,W
1774:  MULLW  24
1776:  MOVF   FF3,W
1778:  CLRF   x1E
177A:  MOVWF  x1D
177C:  MOVLW  1E
177E:  ADDWF  x1D,W
1780:  MOVWF  01
1782:  MOVLW  00
1784:  ADDWFC x1E,W
1786:  MOVWF  03
1788:  MOVF   01,W
178A:  ADDLW  1B
178C:  MOVWF  FE9
178E:  MOVLW  00
1790:  ADDWFC 03,W
1792:  MOVWF  FEA
1794:  CLRF   FEC
1796:  MOVF   FED,F
1798:  MOVLW  01
179A:  MOVWF  FEF
.................... 		config.ch[i].htd_reconnect_adc=512;  // 25C / 77F
179C:  MOVF   x1C,W
179E:  MULLW  24
17A0:  MOVF   FF3,W
17A2:  CLRF   x1E
17A4:  MOVWF  x1D
17A6:  MOVLW  20
17A8:  ADDWF  x1D,W
17AA:  MOVWF  01
17AC:  MOVLW  00
17AE:  ADDWFC x1E,W
17B0:  MOVWF  03
17B2:  MOVF   01,W
17B4:  ADDLW  1B
17B6:  MOVWF  FE9
17B8:  MOVLW  00
17BA:  ADDWFC 03,W
17BC:  MOVWF  FEA
17BE:  MOVLW  02
17C0:  MOVWF  FEC
17C2:  MOVF   FED,F
17C4:  CLRF   FEF
.................... 		config.ch[i].htd_reconnect_delay=4;
17C6:  MOVF   x1C,W
17C8:  MULLW  24
17CA:  MOVF   FF3,W
17CC:  CLRF   x1E
17CE:  MOVWF  x1D
17D0:  MOVLW  22
17D2:  ADDWF  x1D,W
17D4:  MOVWF  01
17D6:  MOVLW  00
17D8:  ADDWFC x1E,W
17DA:  MOVWF  03
17DC:  MOVF   01,W
17DE:  ADDLW  1B
17E0:  MOVWF  FE9
17E2:  MOVLW  00
17E4:  ADDWFC 03,W
17E6:  MOVWF  FEA
17E8:  CLRF   FEC
17EA:  MOVF   FED,F
17EC:  MOVLW  04
17EE:  MOVWF  FEF
17F0:  INCF   x1C,F
17F2:  BRA    153A
.................... 	}
.................... 	
.................... 	/* write them so next time we use from EEPROM */
.................... 	write_param_file();
17F4:  MOVLB  0
17F6:  RCALL  14E2
17F8:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void read_param_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config)); 
17FA:  MOVLB  1
17FC:  MOVLW  1B
17FE:  MOVWF  x1C
1800:  CLRF   x1F
1802:  MOVLW  02
1804:  MOVWF  x1E
1806:  CLRF   x21
1808:  MOVFF  11C,120
180C:  CLRF   x23
180E:  MOVLW  48
1810:  MOVWF  x22
1812:  MOVLB  0
1814:  BRA    13C2
1816:  MOVFF  01,11B
.................... 		
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) {
181A:  MOVFF  FF2,11C
181E:  BCF    FF2.7
1820:  CLRF   FA9
1822:  BCF    FA6.6
1824:  BCF    FA6.7
1826:  BSF    FA6.0
1828:  MOVF   FA8,W
182A:  MOVLB  1
182C:  BTFSC  x1C.7
182E:  BSF    FF2.7
1830:  SUBWF  x1B,W
1832:  BZ    183A
.................... 		write_default_param_file();
1834:  MOVLB  0
1836:  RCALL  152E
1838:  MOVLB  1
.................... 	}
183A:  MOVLB  0
183C:  GOTO   2E24 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... #include "i2c_handler_dcswc_module_latching_contactor.c"
.................... #include "registers_dcswc_module_latching_contactor.h"
.................... 
.................... /* first two or three registers will give enough information for telemetry */
.................... /* 10 bit input voltage ADC averaged value */
.................... #define I2C_REG_VOLTAGE_INPUT_AVG             0  
.................... /* two 8 bit channel states (A is MSB / B is LSB) */
.................... #define I2C_REG_STATE_CONTACTORS              1 
.................... /* 10 bit NTC thermistor ADC averaged value */
.................... #define I2C_REG_TEMPERATURE_BOARD_AVG         2
.................... 
....................   
.................... /* channel 0 / A */
.................... /* command can only come from I2C interface */
.................... #define I2C_REG_CH0_COMMAND_ON                3 /* R/W seconds */
.................... #define I2C_REG_CH0_COMMAND_ON_HOLD           4
.................... 
.................... #define I2C_REG_CH0_COMMAND_OFF               5 /* R/W seconds */
.................... #define I2C_REG_CH0_COMMAND_OFF_HOLD          6
.................... 
.................... /* low voltage disconnect */
.................... #define I2C_REG_CH0_LVD_DISCONNECT            7  /* R seconds */
.................... #define I2C_REG_CH0_LVD_RECONNECT             8 
.................... 
.................... /* high voltage disconnect */
.................... #define I2C_REG_CH0_HVD_DISCONNECT            9 /* R seconds */
.................... #define I2C_REG_CH0_HVD_RECONNECT             10
.................... 
.................... /* low temperature disconnect */
.................... #define I2C_REG_CH0_LTD_DISCONNECT            11  /* R seconds */
.................... #define I2C_REG_CH0_LTD_RECONNECT             12
.................... 
.................... /* high temperature disconnect */
.................... #define I2C_REG_CH0_HTD_DISCONNECT            13 /* R seconds */
.................... #define I2C_REG_CH0_HTD_RECONNECT             14
.................... 
.................... /* reserved for future, unimplemented */
.................... #define I2C_REG_CH0_FUT_DISCONNECT            15 /* R seconds */
.................... #define I2C_REG_CH0_FUT_RECONNECT             16
.................... 
.................... /* channel 1 / B */
.................... /* command can only come from I2C interface */
.................... #define I2C_REG_CH1_COMMAND_ON                17 /* R/W seconds */
.................... #define I2C_REG_CH1_COMMAND_ON_HOLD           18
.................... 
.................... #define I2C_REG_CH1_COMMAND_OFF               19 /* R/W seconds */
.................... #define I2C_REG_CH1_COMMAND_OFF_HOLD          20
.................... 
.................... /* low voltage disconnect */
.................... #define I2C_REG_CH1_LVD_DISCONNECT            21 /* R seconds */
.................... #define I2C_REG_CH1_LVD_RECONNECT             22 
.................... 
.................... /* high voltage disconnect */
.................... #define I2C_REG_CH1_HVD_DISCONNECT            23 /* R seconds */
.................... #define I2C_REG_CH1_HVD_RECONNECT             24
.................... 
.................... /* low temperature disconnect */
.................... #define I2C_REG_CH1_LTD_DISCONNECT            25  /* R seconds */
.................... #define I2C_REG_CH1_LTD_RECONNECT             26
.................... 
.................... /* high temperature disconnect */
.................... #define I2C_REG_CH1_HTD_DISCONNECT            27 /* R seconds */
.................... #define I2C_REG_CH1_HTD_RECONNECT             28
.................... 
.................... /* reserved for future, unimplemented */
.................... #define I2C_REG_CH1_FUT_DISCONNECT            29 /* R seconds */
.................... #define I2C_REG_CH1_FUT_RECONNECT             30
.................... 
.................... /* meta */
.................... #define I2C_REG_SEQUENCE_NUMBER               31 /* R */
.................... #define I2C_REG_TIME_INTERVAL_MILLISECONDS    32
.................... #define I2C_REG_TIME_UPTIME_MINUTES           33
.................... #define I2C_REG_DEFAULT_PARAMS_WRITTEN        34
.................... 
.................... /* channel configuration */
.................... /* channel 0 / A */
.................... #define I2C_REG_CH0_COMMAND_ON_HOLD_INITIAL   64
.................... 
.................... #define I2C_REG_CH0_COMMAND_OFF_HOLD_INITIAL  65
.................... 
.................... #define I2C_REG_CH0_LVD_DISCONNECT_ADC        66
.................... #define I2C_REG_CH0_LVD_DISCONNECT_DELAY      67
.................... #define I2C_REG_CH0_LVD_RECONNECT_ADC         68
.................... #define I2C_REG_CH0_LVD_RECONNECT_DELAY       69
.................... 
.................... #define I2C_REG_CH0_HVD_DISCONNECT_ADC        70
.................... #define I2C_REG_CH0_HVD_DISCONNECT_DELAY      71
.................... #define I2C_REG_CH0_HVD_RECONNECT_ADC         72
.................... #define I2C_REG_CH0_HVD_RECONNECT_DELAY       73
.................... 
.................... #define I2C_REG_CH0_LTD_DISCONNECT_ADC        74
.................... #define I2C_REG_CH0_LTD_DISCONNECT_DELAY      75
.................... #define I2C_REG_CH0_LTD_RECONNECT_ADC         76
.................... #define I2C_REG_CH0_LTD_RECONNECT_DELAY       77
.................... 
.................... #define I2C_REG_CH0_HTD_DISCONNECT_ADC        78
.................... #define I2C_REG_CH0_HTD_DISCONNECT_DELAY      79
.................... #define I2C_REG_CH0_HTD_RECONNECT_ADC         80
.................... #define I2C_REG_CH0_HTD_RECONNECT_DELAY       81
.................... 
.................... #define I2C_REG_CH0_FUT_DISCONNECT_VALUE      82
.................... #define I2C_REG_CH0_FUT_DISCONNECT_DELAY      83
.................... #define I2C_REG_CH0_FUT_RECONNECT_VALUE       84
.................... #define I2C_REG_CH0_FUT_RECONNECT_DELAY       85
.................... 
.................... /* channel 1 / B */
.................... #define I2C_REG_CH1_COMMAND_ON_HOLD_INITIAL   86
.................... 
.................... #define I2C_REG_CH1_COMMAND_OFF_HOLD_INITIAL  87
.................... 
.................... #define I2C_REG_CH1_LVD_DISCONNECT_ADC        88
.................... #define I2C_REG_CH1_LVD_DISCONNECT_DELAY      89
.................... #define I2C_REG_CH1_LVD_RECONNECT_ADC         90
.................... #define I2C_REG_CH1_LVD_RECONNECT_DELAY       91
.................... 
.................... #define I2C_REG_CH1_HVD_DISCONNECT_ADC        92
.................... #define I2C_REG_CH1_HVD_DISCONNECT_DELAY      93
.................... #define I2C_REG_CH1_HVD_RECONNECT_ADC         94
.................... #define I2C_REG_CH1_HVD_RECONNECT_DELAY       95
.................... 
.................... #define I2C_REG_CH1_LTD_DISCONNECT_ADC        96
.................... #define I2C_REG_CH1_LTD_DISCONNECT_DELAY      97
.................... #define I2C_REG_CH1_LTD_RECONNECT_ADC         98
.................... #define I2C_REG_CH1_LTD_RECONNECT_DELAY       99
.................... 
.................... #define I2C_REG_CH1_HTD_DISCONNECT_ADC        100
.................... #define I2C_REG_CH1_HTD_DISCONNECT_DELAY      101
.................... #define I2C_REG_CH1_HTD_RECONNECT_ADC         102
.................... #define I2C_REG_CH1_HTD_RECONNECT_DELAY       103
.................... 
.................... #define I2C_REG_CH1_FUT_DISCONNECT_VALUE      104
.................... #define I2C_REG_CH1_FUT_DISCONNECT_DELAY      105
.................... #define I2C_REG_CH1_FUT_RECONNECT_VALUE       106
.................... #define I2C_REG_CH1_FUT_RECONNECT_DELAY       107
.................... 
.................... 
.................... /* configuration */
.................... #define I2C_REG_CONFIG_HARDWARE_MODEL              128 /* R */
.................... #define I2C_REG_CONFIG_HARDWARE_VERSION            129
.................... #define I2C_REG_CONFIG_SOFTWARE_MODEL              130
.................... #define I2C_REG_CONFIG_SOFTWARE_VERSION            131
.................... #define I2C_REG_CONFIG_SOFTWARE_YEAR               132
.................... #define I2C_REG_CONFIG_SOFTWARE_MONTH              133
.................... #define I2C_REG_CONFIG_SOFTWARE_DAY                134
.................... 
.................... #define I2C_REG_CONFIG_PARAM_WRITE                 135 /* R / W */
.................... 
.................... 
.................... 
.................... void write_i2c(int8 addr, int16 value) {
.................... 	int8 c;
.................... 
.................... 	/* c is the channel we are accessing based on register range */
.................... 	if ( addr >= I2C_REG_CH1_COMMAND_ON && addr <= I2C_REG_CH1_FUT_RECONNECT ) {
*
00DC:  MOVLB  1
00DE:  MOVF   x2F,W
00E0:  SUBLW  10
00E2:  BC    00F4
00E4:  MOVF   x2F,W
00E6:  SUBLW  1E
00E8:  BNC   00F4
.................... 		/* channel 1 status region */
.................... 		c=1;
00EA:  MOVLW  01
00EC:  MOVWF  x32
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON - I2C_REG_CH0_COMMAND_ON);
00EE:  MOVLW  0E
00F0:  SUBWF  x2F,F
.................... 	} else if ( addr >= I2C_REG_CH1_COMMAND_ON_HOLD && addr <= I2C_REG_CH1_FUT_RECONNECT_DELAY ) {
00F2:  BRA    010C
00F4:  MOVF   x2F,W
00F6:  SUBLW  11
00F8:  BC    010A
00FA:  MOVF   x2F,W
00FC:  SUBLW  6B
00FE:  BNC   010A
.................... 		/* channel 1 configuration region */
.................... 		c=1;
0100:  MOVLW  01
0102:  MOVWF  x32
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON_HOLD - I2C_REG_CH0_COMMAND_ON_HOLD );
0104:  MOVLW  0E
0106:  SUBWF  x2F,F
.................... 	} else {
0108:  BRA    010C
.................... 		c=0;
010A:  CLRF   x32
.................... 	}
.................... 
.................... 	switch ( addr ) {
010C:  MOVF   x2F,W
010E:  XORLW  03
0110:  MOVLB  0
0112:  BZ    018A
0114:  XORLW  07
0116:  BZ    01BA
0118:  XORLW  01
011A:  BZ    01EA
011C:  XORLW  03
011E:  BTFSC  FD8.2
0120:  BRA    021A
0122:  XORLW  44
0124:  BTFSC  FD8.2
0126:  BRA    024A
0128:  XORLW  01
012A:  BTFSC  FD8.2
012C:  BRA    027A
012E:  XORLW  07
0130:  BTFSC  FD8.2
0132:  BRA    02AA
0134:  XORLW  01
0136:  BTFSC  FD8.2
0138:  BRA    02DA
013A:  XORLW  03
013C:  BTFSC  FD8.2
013E:  BRA    030A
0140:  XORLW  01
0142:  BTFSC  FD8.2
0144:  BRA    033A
0146:  XORLW  0F
0148:  BTFSC  FD8.2
014A:  BRA    036A
014C:  XORLW  01
014E:  BTFSC  FD8.2
0150:  BRA    039A
0152:  XORLW  03
0154:  BTFSC  FD8.2
0156:  BRA    03CA
0158:  XORLW  01
015A:  BTFSC  FD8.2
015C:  BRA    03FA
015E:  XORLW  07
0160:  BTFSC  FD8.2
0162:  BRA    042A
0164:  XORLW  01
0166:  BTFSC  FD8.2
0168:  BRA    045A
016A:  XORLW  03
016C:  BTFSC  FD8.2
016E:  BRA    048A
0170:  XORLW  01
0172:  BTFSC  FD8.2
0174:  BRA    04BA
0176:  XORLW  1F
0178:  BTFSC  FD8.2
017A:  BRA    04EA
017C:  XORLW  01
017E:  BTFSC  FD8.2
0180:  BRA    051A
0182:  XORLW  D6
0184:  BTFSC  FD8.2
0186:  BRA    054A
0188:  BRA    0590
.................... 		case I2C_REG_CH0_COMMAND_ON:
.................... 			channel[c].command_on_seconds=value;
018A:  MOVLB  1
018C:  MOVF   x32,W
018E:  MULLW  19
0190:  MOVF   FF3,W
0192:  CLRF   x34
0194:  MOVWF  x33
0196:  MOVLW  01
0198:  ADDWF  x33,W
019A:  MOVWF  01
019C:  MOVLW  00
019E:  ADDWFC x34,W
01A0:  MOVWF  03
01A2:  MOVF   01,W
01A4:  ADDLW  DA
01A6:  MOVWF  FE9
01A8:  MOVLW  00
01AA:  ADDWFC 03,W
01AC:  MOVWF  FEA
01AE:  MOVFF  131,FEC
01B2:  MOVF   FED,F
01B4:  MOVFF  130,FEF
01B8:  MOVLB  0
.................... 		case I2C_REG_CH0_COMMAND_ON_HOLD:
.................... 			channel[c].command_on_hold_seconds=value;
01BA:  MOVLB  1
01BC:  MOVF   x32,W
01BE:  MULLW  19
01C0:  MOVF   FF3,W
01C2:  CLRF   x34
01C4:  MOVWF  x33
01C6:  MOVLW  03
01C8:  ADDWF  x33,W
01CA:  MOVWF  01
01CC:  MOVLW  00
01CE:  ADDWFC x34,W
01D0:  MOVWF  03
01D2:  MOVF   01,W
01D4:  ADDLW  DA
01D6:  MOVWF  FE9
01D8:  MOVLW  00
01DA:  ADDWFC 03,W
01DC:  MOVWF  FEA
01DE:  MOVFF  131,FEC
01E2:  MOVF   FED,F
01E4:  MOVFF  130,FEF
01E8:  MOVLB  0
.................... 	
.................... 		case I2C_REG_CH0_COMMAND_OFF:
.................... 			channel[c].command_off_seconds=value;
01EA:  MOVLB  1
01EC:  MOVF   x32,W
01EE:  MULLW  19
01F0:  MOVF   FF3,W
01F2:  CLRF   x34
01F4:  MOVWF  x33
01F6:  MOVLW  05
01F8:  ADDWF  x33,W
01FA:  MOVWF  01
01FC:  MOVLW  00
01FE:  ADDWFC x34,W
0200:  MOVWF  03
0202:  MOVF   01,W
0204:  ADDLW  DA
0206:  MOVWF  FE9
0208:  MOVLW  00
020A:  ADDWFC 03,W
020C:  MOVWF  FEA
020E:  MOVFF  131,FEC
0212:  MOVF   FED,F
0214:  MOVFF  130,FEF
0218:  MOVLB  0
.................... 		case I2C_REG_CH0_COMMAND_OFF_HOLD:
.................... 			channel[c].command_off_hold_seconds=value;
021A:  MOVLB  1
021C:  MOVF   x32,W
021E:  MULLW  19
0220:  MOVF   FF3,W
0222:  CLRF   x34
0224:  MOVWF  x33
0226:  MOVLW  07
0228:  ADDWF  x33,W
022A:  MOVWF  01
022C:  MOVLW  00
022E:  ADDWFC x34,W
0230:  MOVWF  03
0232:  MOVF   01,W
0234:  ADDLW  DA
0236:  MOVWF  FE9
0238:  MOVLW  00
023A:  ADDWFC 03,W
023C:  MOVWF  FEA
023E:  MOVFF  131,FEC
0242:  MOVF   FED,F
0244:  MOVFF  130,FEF
0248:  MOVLB  0
.................... 
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_ADC:
.................... 			config.ch[c].lvd_disconnect_adc=value;
024A:  MOVLB  1
024C:  MOVF   x32,W
024E:  MULLW  24
0250:  MOVF   FF3,W
0252:  CLRF   x34
0254:  MOVWF  x33
0256:  MOVLW  04
0258:  ADDWF  x33,W
025A:  MOVWF  01
025C:  MOVLW  00
025E:  ADDWFC x34,W
0260:  MOVWF  03
0262:  MOVF   01,W
0264:  ADDLW  1B
0266:  MOVWF  FE9
0268:  MOVLW  00
026A:  ADDWFC 03,W
026C:  MOVWF  FEA
026E:  MOVFF  131,FEC
0272:  MOVF   FED,F
0274:  MOVFF  130,FEF
0278:  MOVLB  0
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_DELAY:
.................... 			config.ch[c].lvd_disconnect_delay=value;
027A:  MOVLB  1
027C:  MOVF   x32,W
027E:  MULLW  24
0280:  MOVF   FF3,W
0282:  CLRF   x34
0284:  MOVWF  x33
0286:  MOVLW  06
0288:  ADDWF  x33,W
028A:  MOVWF  01
028C:  MOVLW  00
028E:  ADDWFC x34,W
0290:  MOVWF  03
0292:  MOVF   01,W
0294:  ADDLW  1B
0296:  MOVWF  FE9
0298:  MOVLW  00
029A:  ADDWFC 03,W
029C:  MOVWF  FEA
029E:  MOVFF  131,FEC
02A2:  MOVF   FED,F
02A4:  MOVFF  130,FEF
02A8:  MOVLB  0
.................... 		case I2C_REG_CH0_LVD_RECONNECT_ADC:
.................... 			config.ch[c].lvd_reconnect_adc=value;
02AA:  MOVLB  1
02AC:  MOVF   x32,W
02AE:  MULLW  24
02B0:  MOVF   FF3,W
02B2:  CLRF   x34
02B4:  MOVWF  x33
02B6:  MOVLW  08
02B8:  ADDWF  x33,W
02BA:  MOVWF  01
02BC:  MOVLW  00
02BE:  ADDWFC x34,W
02C0:  MOVWF  03
02C2:  MOVF   01,W
02C4:  ADDLW  1B
02C6:  MOVWF  FE9
02C8:  MOVLW  00
02CA:  ADDWFC 03,W
02CC:  MOVWF  FEA
02CE:  MOVFF  131,FEC
02D2:  MOVF   FED,F
02D4:  MOVFF  130,FEF
02D8:  MOVLB  0
.................... 		case I2C_REG_CH0_LVD_RECONNECT_DELAY:
.................... 			config.ch[c].lvd_reconnect_delay=value;
02DA:  MOVLB  1
02DC:  MOVF   x32,W
02DE:  MULLW  24
02E0:  MOVF   FF3,W
02E2:  CLRF   x34
02E4:  MOVWF  x33
02E6:  MOVLW  0A
02E8:  ADDWF  x33,W
02EA:  MOVWF  01
02EC:  MOVLW  00
02EE:  ADDWFC x34,W
02F0:  MOVWF  03
02F2:  MOVF   01,W
02F4:  ADDLW  1B
02F6:  MOVWF  FE9
02F8:  MOVLW  00
02FA:  ADDWFC 03,W
02FC:  MOVWF  FEA
02FE:  MOVFF  131,FEC
0302:  MOVF   FED,F
0304:  MOVFF  130,FEF
0308:  MOVLB  0
.................... 
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_ADC:
.................... 			config.ch[c].hvd_disconnect_adc=value;
030A:  MOVLB  1
030C:  MOVF   x32,W
030E:  MULLW  24
0310:  MOVF   FF3,W
0312:  CLRF   x34
0314:  MOVWF  x33
0316:  MOVLW  0C
0318:  ADDWF  x33,W
031A:  MOVWF  01
031C:  MOVLW  00
031E:  ADDWFC x34,W
0320:  MOVWF  03
0322:  MOVF   01,W
0324:  ADDLW  1B
0326:  MOVWF  FE9
0328:  MOVLW  00
032A:  ADDWFC 03,W
032C:  MOVWF  FEA
032E:  MOVFF  131,FEC
0332:  MOVF   FED,F
0334:  MOVFF  130,FEF
0338:  MOVLB  0
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_DELAY:
.................... 			config.ch[c].hvd_disconnect_delay=value;
033A:  MOVLB  1
033C:  MOVF   x32,W
033E:  MULLW  24
0340:  MOVF   FF3,W
0342:  CLRF   x34
0344:  MOVWF  x33
0346:  MOVLW  0E
0348:  ADDWF  x33,W
034A:  MOVWF  01
034C:  MOVLW  00
034E:  ADDWFC x34,W
0350:  MOVWF  03
0352:  MOVF   01,W
0354:  ADDLW  1B
0356:  MOVWF  FE9
0358:  MOVLW  00
035A:  ADDWFC 03,W
035C:  MOVWF  FEA
035E:  MOVFF  131,FEC
0362:  MOVF   FED,F
0364:  MOVFF  130,FEF
0368:  MOVLB  0
.................... 		case I2C_REG_CH0_HVD_RECONNECT_ADC:
.................... 			config.ch[c].hvd_reconnect_adc=value;
036A:  MOVLB  1
036C:  MOVF   x32,W
036E:  MULLW  24
0370:  MOVF   FF3,W
0372:  CLRF   x34
0374:  MOVWF  x33
0376:  MOVLW  10
0378:  ADDWF  x33,W
037A:  MOVWF  01
037C:  MOVLW  00
037E:  ADDWFC x34,W
0380:  MOVWF  03
0382:  MOVF   01,W
0384:  ADDLW  1B
0386:  MOVWF  FE9
0388:  MOVLW  00
038A:  ADDWFC 03,W
038C:  MOVWF  FEA
038E:  MOVFF  131,FEC
0392:  MOVF   FED,F
0394:  MOVFF  130,FEF
0398:  MOVLB  0
.................... 		case I2C_REG_CH0_HVD_RECONNECT_DELAY:
.................... 			config.ch[c].hvd_reconnect_delay=value;
039A:  MOVLB  1
039C:  MOVF   x32,W
039E:  MULLW  24
03A0:  MOVF   FF3,W
03A2:  CLRF   x34
03A4:  MOVWF  x33
03A6:  MOVLW  12
03A8:  ADDWF  x33,W
03AA:  MOVWF  01
03AC:  MOVLW  00
03AE:  ADDWFC x34,W
03B0:  MOVWF  03
03B2:  MOVF   01,W
03B4:  ADDLW  1B
03B6:  MOVWF  FE9
03B8:  MOVLW  00
03BA:  ADDWFC 03,W
03BC:  MOVWF  FEA
03BE:  MOVFF  131,FEC
03C2:  MOVF   FED,F
03C4:  MOVFF  130,FEF
03C8:  MOVLB  0
.................... 
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_ADC:
.................... 			config.ch[c].ltd_disconnect_adc=value;
03CA:  MOVLB  1
03CC:  MOVF   x32,W
03CE:  MULLW  24
03D0:  MOVF   FF3,W
03D2:  CLRF   x34
03D4:  MOVWF  x33
03D6:  MOVLW  14
03D8:  ADDWF  x33,W
03DA:  MOVWF  01
03DC:  MOVLW  00
03DE:  ADDWFC x34,W
03E0:  MOVWF  03
03E2:  MOVF   01,W
03E4:  ADDLW  1B
03E6:  MOVWF  FE9
03E8:  MOVLW  00
03EA:  ADDWFC 03,W
03EC:  MOVWF  FEA
03EE:  MOVFF  131,FEC
03F2:  MOVF   FED,F
03F4:  MOVFF  130,FEF
03F8:  MOVLB  0
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_DELAY:
.................... 			config.ch[c].ltd_disconnect_delay=value;
03FA:  MOVLB  1
03FC:  MOVF   x32,W
03FE:  MULLW  24
0400:  MOVF   FF3,W
0402:  CLRF   x34
0404:  MOVWF  x33
0406:  MOVLW  16
0408:  ADDWF  x33,W
040A:  MOVWF  01
040C:  MOVLW  00
040E:  ADDWFC x34,W
0410:  MOVWF  03
0412:  MOVF   01,W
0414:  ADDLW  1B
0416:  MOVWF  FE9
0418:  MOVLW  00
041A:  ADDWFC 03,W
041C:  MOVWF  FEA
041E:  MOVFF  131,FEC
0422:  MOVF   FED,F
0424:  MOVFF  130,FEF
0428:  MOVLB  0
.................... 		case I2C_REG_CH0_LTD_RECONNECT_ADC:
.................... 			config.ch[c].ltd_reconnect_adc=value;
042A:  MOVLB  1
042C:  MOVF   x32,W
042E:  MULLW  24
0430:  MOVF   FF3,W
0432:  CLRF   x34
0434:  MOVWF  x33
0436:  MOVLW  18
0438:  ADDWF  x33,W
043A:  MOVWF  01
043C:  MOVLW  00
043E:  ADDWFC x34,W
0440:  MOVWF  03
0442:  MOVF   01,W
0444:  ADDLW  1B
0446:  MOVWF  FE9
0448:  MOVLW  00
044A:  ADDWFC 03,W
044C:  MOVWF  FEA
044E:  MOVFF  131,FEC
0452:  MOVF   FED,F
0454:  MOVFF  130,FEF
0458:  MOVLB  0
.................... 		case I2C_REG_CH0_LTD_RECONNECT_DELAY:
.................... 			config.ch[c].ltd_reconnect_delay=value;
045A:  MOVLB  1
045C:  MOVF   x32,W
045E:  MULLW  24
0460:  MOVF   FF3,W
0462:  CLRF   x34
0464:  MOVWF  x33
0466:  MOVLW  1A
0468:  ADDWF  x33,W
046A:  MOVWF  01
046C:  MOVLW  00
046E:  ADDWFC x34,W
0470:  MOVWF  03
0472:  MOVF   01,W
0474:  ADDLW  1B
0476:  MOVWF  FE9
0478:  MOVLW  00
047A:  ADDWFC 03,W
047C:  MOVWF  FEA
047E:  MOVFF  131,FEC
0482:  MOVF   FED,F
0484:  MOVFF  130,FEF
0488:  MOVLB  0
.................... 
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_ADC:
.................... 			config.ch[c].htd_disconnect_adc=value;
048A:  MOVLB  1
048C:  MOVF   x32,W
048E:  MULLW  24
0490:  MOVF   FF3,W
0492:  CLRF   x34
0494:  MOVWF  x33
0496:  MOVLW  1C
0498:  ADDWF  x33,W
049A:  MOVWF  01
049C:  MOVLW  00
049E:  ADDWFC x34,W
04A0:  MOVWF  03
04A2:  MOVF   01,W
04A4:  ADDLW  1B
04A6:  MOVWF  FE9
04A8:  MOVLW  00
04AA:  ADDWFC 03,W
04AC:  MOVWF  FEA
04AE:  MOVFF  131,FEC
04B2:  MOVF   FED,F
04B4:  MOVFF  130,FEF
04B8:  MOVLB  0
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_DELAY:
.................... 			config.ch[c].htd_disconnect_delay=value;
04BA:  MOVLB  1
04BC:  MOVF   x32,W
04BE:  MULLW  24
04C0:  MOVF   FF3,W
04C2:  CLRF   x34
04C4:  MOVWF  x33
04C6:  MOVLW  1E
04C8:  ADDWF  x33,W
04CA:  MOVWF  01
04CC:  MOVLW  00
04CE:  ADDWFC x34,W
04D0:  MOVWF  03
04D2:  MOVF   01,W
04D4:  ADDLW  1B
04D6:  MOVWF  FE9
04D8:  MOVLW  00
04DA:  ADDWFC 03,W
04DC:  MOVWF  FEA
04DE:  MOVFF  131,FEC
04E2:  MOVF   FED,F
04E4:  MOVFF  130,FEF
04E8:  MOVLB  0
.................... 		case I2C_REG_CH0_HTD_RECONNECT_ADC:
.................... 			config.ch[c].htd_reconnect_adc=value;
04EA:  MOVLB  1
04EC:  MOVF   x32,W
04EE:  MULLW  24
04F0:  MOVF   FF3,W
04F2:  CLRF   x34
04F4:  MOVWF  x33
04F6:  MOVLW  20
04F8:  ADDWF  x33,W
04FA:  MOVWF  01
04FC:  MOVLW  00
04FE:  ADDWFC x34,W
0500:  MOVWF  03
0502:  MOVF   01,W
0504:  ADDLW  1B
0506:  MOVWF  FE9
0508:  MOVLW  00
050A:  ADDWFC 03,W
050C:  MOVWF  FEA
050E:  MOVFF  131,FEC
0512:  MOVF   FED,F
0514:  MOVFF  130,FEF
0518:  MOVLB  0
.................... 		case I2C_REG_CH0_HTD_RECONNECT_DELAY:
.................... 			config.ch[c].htd_reconnect_delay=value;
051A:  MOVLB  1
051C:  MOVF   x32,W
051E:  MULLW  24
0520:  MOVF   FF3,W
0522:  CLRF   x34
0524:  MOVWF  x33
0526:  MOVLW  22
0528:  ADDWF  x33,W
052A:  MOVWF  01
052C:  MOVLW  00
052E:  ADDWFC x34,W
0530:  MOVWF  03
0532:  MOVF   01,W
0534:  ADDLW  1B
0536:  MOVWF  FE9
0538:  MOVLW  00
053A:  ADDWFC 03,W
053C:  MOVWF  FEA
053E:  MOVFF  131,FEC
0542:  MOVF   FED,F
0544:  MOVFF  130,FEF
0548:  MOVLB  0
.................... 
.................... 		/* don't need to implement FUT ... there is nowhere for it to go anyhow */
.................... 
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			if ( 1 == value ) {
054A:  MOVLB  1
054C:  DECFSZ x30,W
054E:  BRA    055C
0550:  MOVF   x31,F
0552:  BNZ   055C
.................... 				timers.now_write_config=1;
0554:  MOVLB  0
0556:  BSF    xCF.3
.................... 			} else if ( 2 == value ) {
0558:  BRA    0590
055A:  MOVLB  1
055C:  MOVF   x30,W
055E:  SUBLW  02
0560:  BNZ   056E
0562:  MOVF   x31,F
0564:  BNZ   056E
.................... 				timers.now_reset_config=1;
0566:  MOVLB  0
0568:  BSF    xCF.4
.................... 			} else if ( 1802 == value ) {
056A:  BRA    0590
056C:  MOVLB  1
056E:  MOVF   x30,W
0570:  SUBLW  0A
0572:  BNZ   0584
0574:  MOVF   x31,W
0576:  SUBLW  07
0578:  BNZ   0584
.................... 				current.factory_unlocked =1;
057A:  MOVLW  01
057C:  MOVLB  0
057E:  MOVWF  xCA
.................... 			} else if ( 65535 == value ) {
0580:  BRA    0590
0582:  MOVLB  1
0584:  INCFSZ x30,W
0586:  BRA    058E
0588:  INCFSZ x31,W
058A:  BRA    058E
.................... 				reset_cpu();
058C:  RESET
058E:  MOVLB  0
.................... 			}
.................... 			break;
.................... 		default:
.................... 			/* do nothing */
.................... 	}
0590:  GOTO   0F14 (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... int16 map_i2c(int8 addr) {
.................... 	int8 c;
.................... 
.................... 	/* c is the channel we are accessing based on register range */
.................... 	if ( addr >= I2C_REG_CH1_COMMAND_ON && addr <= I2C_REG_CH1_FUT_RECONNECT ) {
*
0614:  MOVLB  1
0616:  MOVF   x2D,W
0618:  SUBLW  10
061A:  BC    062C
061C:  MOVF   x2D,W
061E:  SUBLW  1E
0620:  BNC   062C
.................... 		/* channel 1 status region */
.................... 		c=1;
0622:  MOVLW  01
0624:  MOVWF  x2E
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON - I2C_REG_CH0_COMMAND_ON);
0626:  MOVLW  0E
0628:  SUBWF  x2D,F
.................... 	} else if ( addr >= I2C_REG_CH1_COMMAND_ON_HOLD && addr <= I2C_REG_CH1_FUT_RECONNECT_DELAY ) {
062A:  BRA    0644
062C:  MOVF   x2D,W
062E:  SUBLW  11
0630:  BC    0642
0632:  MOVF   x2D,W
0634:  SUBLW  6B
0636:  BNC   0642
.................... 		/* channel 1 configuration region */
.................... 		c=1;
0638:  MOVLW  01
063A:  MOVWF  x2E
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON_HOLD - I2C_REG_CH0_COMMAND_ON_HOLD );
063C:  MOVLW  0E
063E:  SUBWF  x2D,F
.................... 	} else {
0640:  BRA    0644
.................... 		c=0;
0642:  CLRF   x2E
.................... 	}
.................... 
.................... 	switch ( addr ) {
0644:  MOVF   x2D,W
0646:  XORLW  00
0648:  MOVLB  0
064A:  BTFSC  FD8.2
064C:  BRA    077C
064E:  XORLW  01
0650:  BTFSC  FD8.2
0652:  BRA    0788
0654:  XORLW  03
0656:  BTFSC  FD8.2
0658:  BRA    0796
065A:  XORLW  01
065C:  BTFSC  FD8.2
065E:  BRA    07A4
0660:  XORLW  07
0662:  BTFSC  FD8.2
0664:  BRA    07DA
0666:  XORLW  01
0668:  BTFSC  FD8.2
066A:  BRA    0810
066C:  XORLW  03
066E:  BTFSC  FD8.2
0670:  BRA    0846
0672:  XORLW  01
0674:  BTFSC  FD8.2
0676:  BRA    087C
0678:  XORLW  0F
067A:  BTFSC  FD8.2
067C:  BRA    08B2
067E:  XORLW  01
0680:  BTFSC  FD8.2
0682:  BRA    08E8
0684:  XORLW  03
0686:  BTFSC  FD8.2
0688:  BRA    091E
068A:  XORLW  01
068C:  BTFSC  FD8.2
068E:  BRA    0954
0690:  XORLW  07
0692:  BTFSC  FD8.2
0694:  BRA    098A
0696:  XORLW  01
0698:  BTFSC  FD8.2
069A:  BRA    09C0
069C:  XORLW  03
069E:  BTFSC  FD8.2
06A0:  BRA    09F6
06A2:  XORLW  01
06A4:  BTFSC  FD8.2
06A6:  BRA    0A2C
06A8:  XORLW  1F
06AA:  BTFSC  FD8.2
06AC:  BRA    0A2C
06AE:  XORLW  0F
06B0:  BTFSC  FD8.2
06B2:  BRA    0A34
06B4:  XORLW  3F
06B6:  BTFSC  FD8.2
06B8:  BRA    0A3E
06BA:  XORLW  01
06BC:  BTFSC  FD8.2
06BE:  BRA    0A48
06C0:  XORLW  03
06C2:  BTFSC  FD8.2
06C4:  BRA    0A52
06C6:  XORLW  62
06C8:  BTFSC  FD8.2
06CA:  BRA    0A5A
06CC:  XORLW  01
06CE:  BTFSC  FD8.2
06D0:  BRA    0A84
06D2:  XORLW  03
06D4:  BTFSC  FD8.2
06D6:  BRA    0ABA
06D8:  XORLW  01
06DA:  BTFSC  FD8.2
06DC:  BRA    0AF0
06DE:  XORLW  07
06E0:  BTFSC  FD8.2
06E2:  BRA    0B26
06E4:  XORLW  01
06E6:  BTFSC  FD8.2
06E8:  BRA    0B5C
06EA:  XORLW  03
06EC:  BTFSC  FD8.2
06EE:  BRA    0B92
06F0:  XORLW  01
06F2:  BTFSC  FD8.2
06F4:  BRA    0BC8
06F6:  XORLW  0F
06F8:  BTFSC  FD8.2
06FA:  BRA    0BFE
06FC:  XORLW  01
06FE:  BTFSC  FD8.2
0700:  BRA    0C34
0702:  XORLW  03
0704:  BTFSC  FD8.2
0706:  BRA    0C6A
0708:  XORLW  01
070A:  BTFSC  FD8.2
070C:  BRA    0CA0
070E:  XORLW  07
0710:  BTFSC  FD8.2
0712:  BRA    0CD6
0714:  XORLW  01
0716:  BTFSC  FD8.2
0718:  BRA    0D0C
071A:  XORLW  03
071C:  BTFSC  FD8.2
071E:  BRA    0D42
0720:  XORLW  01
0722:  BTFSC  FD8.2
0724:  BRA    0D78
0726:  XORLW  1F
0728:  BTFSC  FD8.2
072A:  BRA    0DAE
072C:  XORLW  01
072E:  BTFSC  FD8.2
0730:  BRA    0DE4
0732:  XORLW  03
0734:  BTFSC  FD8.2
0736:  BRA    0E1A
0738:  XORLW  01
073A:  BTFSC  FD8.2
073C:  BRA    0E1A
073E:  XORLW  07
0740:  BTFSC  FD8.2
0742:  BRA    0E1A
0744:  XORLW  01
0746:  BTFSC  FD8.2
0748:  BRA    0E1A
074A:  XORLW  D5
074C:  BTFSC  FD8.2
074E:  BRA    0E22
0750:  XORLW  01
0752:  BTFSC  FD8.2
0754:  BRA    0E2C
0756:  XORLW  03
0758:  BTFSC  FD8.2
075A:  BRA    0E36
075C:  XORLW  01
075E:  BTFSC  FD8.2
0760:  BRA    0E40
0762:  XORLW  07
0764:  BTFSC  FD8.2
0766:  BRA    0E4A
0768:  XORLW  01
076A:  BTFSC  FD8.2
076C:  BRA    0E52
076E:  XORLW  03
0770:  BTFSC  FD8.2
0772:  BRA    0E5A
0774:  XORLW  01
0776:  BTFSC  FD8.2
0778:  BRA    0E62
077A:  BRA    0E6A
.................... 		/* not channel based */
.................... 		case I2C_REG_VOLTAGE_INPUT_AVG: 
.................... 			return (int16) adc_get(0);
077C:  MOVLB  1
077E:  CLRF   x2F
0780:  MOVLB  0
0782:  RCALL  0594
0784:  MOVF   02,W
0786:  BRA    0E70
.................... 		case I2C_REG_STATE_CONTACTORS:
.................... 			return (int16) make16(channel[0].state,channel[1].state);
0788:  MOVFF  DA,03
078C:  MOVFF  F3,01
0790:  MOVFF  DA,02
0794:  BRA    0E70
.................... 		case I2C_REG_TEMPERATURE_BOARD_AVG: 
.................... 			return (int16) adc_get(1);
0796:  MOVLW  01
0798:  MOVLB  1
079A:  MOVWF  x2F
079C:  MOVLB  0
079E:  RCALL  0594
07A0:  MOVF   02,W
07A2:  BRA    0E70
.................... 
.................... 		/* status based on channel value c */
.................... 		case I2C_REG_CH0_COMMAND_ON :
.................... 			return (int16) channel[c].command_on_seconds;
07A4:  MOVLB  1
07A6:  MOVF   x2E,W
07A8:  MULLW  19
07AA:  MOVF   FF3,W
07AC:  CLRF   x30
07AE:  MOVWF  x2F
07B0:  MOVLW  01
07B2:  ADDWF  x2F,W
07B4:  MOVWF  01
07B6:  MOVLW  00
07B8:  ADDWFC x30,W
07BA:  MOVWF  03
07BC:  MOVF   01,W
07BE:  ADDLW  DA
07C0:  MOVWF  FE9
07C2:  MOVLW  00
07C4:  ADDWFC 03,W
07C6:  MOVWF  FEA
07C8:  MOVFF  FEC,03
07CC:  MOVF   FED,F
07CE:  MOVFF  FEF,01
07D2:  MOVFF  03,02
07D6:  MOVLB  0
07D8:  BRA    0E70
.................... 		case I2C_REG_CH0_COMMAND_ON_HOLD:
.................... 			return (int16) channel[c].command_on_hold_seconds;
07DA:  MOVLB  1
07DC:  MOVF   x2E,W
07DE:  MULLW  19
07E0:  MOVF   FF3,W
07E2:  CLRF   x30
07E4:  MOVWF  x2F
07E6:  MOVLW  03
07E8:  ADDWF  x2F,W
07EA:  MOVWF  01
07EC:  MOVLW  00
07EE:  ADDWFC x30,W
07F0:  MOVWF  03
07F2:  MOVF   01,W
07F4:  ADDLW  DA
07F6:  MOVWF  FE9
07F8:  MOVLW  00
07FA:  ADDWFC 03,W
07FC:  MOVWF  FEA
07FE:  MOVFF  FEC,03
0802:  MOVF   FED,F
0804:  MOVFF  FEF,01
0808:  MOVFF  03,02
080C:  MOVLB  0
080E:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_COMMAND_OFF:
.................... 			return (int16) channel[c].command_off_seconds;
0810:  MOVLB  1
0812:  MOVF   x2E,W
0814:  MULLW  19
0816:  MOVF   FF3,W
0818:  CLRF   x30
081A:  MOVWF  x2F
081C:  MOVLW  05
081E:  ADDWF  x2F,W
0820:  MOVWF  01
0822:  MOVLW  00
0824:  ADDWFC x30,W
0826:  MOVWF  03
0828:  MOVF   01,W
082A:  ADDLW  DA
082C:  MOVWF  FE9
082E:  MOVLW  00
0830:  ADDWFC 03,W
0832:  MOVWF  FEA
0834:  MOVFF  FEC,03
0838:  MOVF   FED,F
083A:  MOVFF  FEF,01
083E:  MOVFF  03,02
0842:  MOVLB  0
0844:  BRA    0E70
.................... 		case I2C_REG_CH0_COMMAND_OFF_HOLD:
.................... 			return (int16) channel[c].command_off_hold_seconds;
0846:  MOVLB  1
0848:  MOVF   x2E,W
084A:  MULLW  19
084C:  MOVF   FF3,W
084E:  CLRF   x30
0850:  MOVWF  x2F
0852:  MOVLW  07
0854:  ADDWF  x2F,W
0856:  MOVWF  01
0858:  MOVLW  00
085A:  ADDWFC x30,W
085C:  MOVWF  03
085E:  MOVF   01,W
0860:  ADDLW  DA
0862:  MOVWF  FE9
0864:  MOVLW  00
0866:  ADDWFC 03,W
0868:  MOVWF  FEA
086A:  MOVFF  FEC,03
086E:  MOVF   FED,F
0870:  MOVFF  FEF,01
0874:  MOVFF  03,02
0878:  MOVLB  0
087A:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_LVD_DISCONNECT:
.................... 			return (int16) channel[c].lvd_disconnect_delay_seconds;
087C:  MOVLB  1
087E:  MOVF   x2E,W
0880:  MULLW  19
0882:  MOVF   FF3,W
0884:  CLRF   x30
0886:  MOVWF  x2F
0888:  MOVLW  09
088A:  ADDWF  x2F,W
088C:  MOVWF  01
088E:  MOVLW  00
0890:  ADDWFC x30,W
0892:  MOVWF  03
0894:  MOVF   01,W
0896:  ADDLW  DA
0898:  MOVWF  FE9
089A:  MOVLW  00
089C:  ADDWFC 03,W
089E:  MOVWF  FEA
08A0:  MOVFF  FEC,03
08A4:  MOVF   FED,F
08A6:  MOVFF  FEF,01
08AA:  MOVFF  03,02
08AE:  MOVLB  0
08B0:  BRA    0E70
.................... 		case I2C_REG_CH0_LVD_RECONNECT:
.................... 			return (int16) channel[c].lvd_reconnect_delay_seconds;
08B2:  MOVLB  1
08B4:  MOVF   x2E,W
08B6:  MULLW  19
08B8:  MOVF   FF3,W
08BA:  CLRF   x30
08BC:  MOVWF  x2F
08BE:  MOVLW  0B
08C0:  ADDWF  x2F,W
08C2:  MOVWF  01
08C4:  MOVLW  00
08C6:  ADDWFC x30,W
08C8:  MOVWF  03
08CA:  MOVF   01,W
08CC:  ADDLW  DA
08CE:  MOVWF  FE9
08D0:  MOVLW  00
08D2:  ADDWFC 03,W
08D4:  MOVWF  FEA
08D6:  MOVFF  FEC,03
08DA:  MOVF   FED,F
08DC:  MOVFF  FEF,01
08E0:  MOVFF  03,02
08E4:  MOVLB  0
08E6:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_HVD_DISCONNECT:
.................... 			return (int16) channel[c].hvd_disconnect_delay_seconds;
08E8:  MOVLB  1
08EA:  MOVF   x2E,W
08EC:  MULLW  19
08EE:  MOVF   FF3,W
08F0:  CLRF   x30
08F2:  MOVWF  x2F
08F4:  MOVLW  0D
08F6:  ADDWF  x2F,W
08F8:  MOVWF  01
08FA:  MOVLW  00
08FC:  ADDWFC x30,W
08FE:  MOVWF  03
0900:  MOVF   01,W
0902:  ADDLW  DA
0904:  MOVWF  FE9
0906:  MOVLW  00
0908:  ADDWFC 03,W
090A:  MOVWF  FEA
090C:  MOVFF  FEC,03
0910:  MOVF   FED,F
0912:  MOVFF  FEF,01
0916:  MOVFF  03,02
091A:  MOVLB  0
091C:  BRA    0E70
.................... 		case I2C_REG_CH0_HVD_RECONNECT:
.................... 			return (int16) channel[c].hvd_reconnect_delay_seconds;
091E:  MOVLB  1
0920:  MOVF   x2E,W
0922:  MULLW  19
0924:  MOVF   FF3,W
0926:  CLRF   x30
0928:  MOVWF  x2F
092A:  MOVLW  0F
092C:  ADDWF  x2F,W
092E:  MOVWF  01
0930:  MOVLW  00
0932:  ADDWFC x30,W
0934:  MOVWF  03
0936:  MOVF   01,W
0938:  ADDLW  DA
093A:  MOVWF  FE9
093C:  MOVLW  00
093E:  ADDWFC 03,W
0940:  MOVWF  FEA
0942:  MOVFF  FEC,03
0946:  MOVF   FED,F
0948:  MOVFF  FEF,01
094C:  MOVFF  03,02
0950:  MOVLB  0
0952:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_LTD_DISCONNECT:
.................... 			return (int16) channel[c].ltd_disconnect_delay_seconds;
0954:  MOVLB  1
0956:  MOVF   x2E,W
0958:  MULLW  19
095A:  MOVF   FF3,W
095C:  CLRF   x30
095E:  MOVWF  x2F
0960:  MOVLW  11
0962:  ADDWF  x2F,W
0964:  MOVWF  01
0966:  MOVLW  00
0968:  ADDWFC x30,W
096A:  MOVWF  03
096C:  MOVF   01,W
096E:  ADDLW  DA
0970:  MOVWF  FE9
0972:  MOVLW  00
0974:  ADDWFC 03,W
0976:  MOVWF  FEA
0978:  MOVFF  FEC,03
097C:  MOVF   FED,F
097E:  MOVFF  FEF,01
0982:  MOVFF  03,02
0986:  MOVLB  0
0988:  BRA    0E70
.................... 		case I2C_REG_CH0_LTD_RECONNECT:
.................... 			return (int16) channel[c].ltd_reconnect_delay_seconds;
098A:  MOVLB  1
098C:  MOVF   x2E,W
098E:  MULLW  19
0990:  MOVF   FF3,W
0992:  CLRF   x30
0994:  MOVWF  x2F
0996:  MOVLW  13
0998:  ADDWF  x2F,W
099A:  MOVWF  01
099C:  MOVLW  00
099E:  ADDWFC x30,W
09A0:  MOVWF  03
09A2:  MOVF   01,W
09A4:  ADDLW  DA
09A6:  MOVWF  FE9
09A8:  MOVLW  00
09AA:  ADDWFC 03,W
09AC:  MOVWF  FEA
09AE:  MOVFF  FEC,03
09B2:  MOVF   FED,F
09B4:  MOVFF  FEF,01
09B8:  MOVFF  03,02
09BC:  MOVLB  0
09BE:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_HTD_DISCONNECT:
.................... 			return (int16) channel[c].htd_disconnect_delay_seconds;
09C0:  MOVLB  1
09C2:  MOVF   x2E,W
09C4:  MULLW  19
09C6:  MOVF   FF3,W
09C8:  CLRF   x30
09CA:  MOVWF  x2F
09CC:  MOVLW  15
09CE:  ADDWF  x2F,W
09D0:  MOVWF  01
09D2:  MOVLW  00
09D4:  ADDWFC x30,W
09D6:  MOVWF  03
09D8:  MOVF   01,W
09DA:  ADDLW  DA
09DC:  MOVWF  FE9
09DE:  MOVLW  00
09E0:  ADDWFC 03,W
09E2:  MOVWF  FEA
09E4:  MOVFF  FEC,03
09E8:  MOVF   FED,F
09EA:  MOVFF  FEF,01
09EE:  MOVFF  03,02
09F2:  MOVLB  0
09F4:  BRA    0E70
.................... 		case I2C_REG_CH0_HTD_RECONNECT:
.................... 			return (int16) channel[c].htd_reconnect_delay_seconds;
09F6:  MOVLB  1
09F8:  MOVF   x2E,W
09FA:  MULLW  19
09FC:  MOVF   FF3,W
09FE:  CLRF   x30
0A00:  MOVWF  x2F
0A02:  MOVLW  17
0A04:  ADDWF  x2F,W
0A06:  MOVWF  01
0A08:  MOVLW  00
0A0A:  ADDWFC x30,W
0A0C:  MOVWF  03
0A0E:  MOVF   01,W
0A10:  ADDLW  DA
0A12:  MOVWF  FE9
0A14:  MOVLW  00
0A16:  ADDWFC 03,W
0A18:  MOVWF  FEA
0A1A:  MOVFF  FEC,03
0A1E:  MOVF   FED,F
0A20:  MOVFF  FEF,01
0A24:  MOVFF  03,02
0A28:  MOVLB  0
0A2A:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_FUT_DISCONNECT:
.................... 		case I2C_REG_CH0_FUT_RECONNECT:
.................... 			return (int16) 0xffff; /* not yet implemented */
0A2C:  MOVLW  FF
0A2E:  MOVWF  01
0A30:  MOVWF  02
0A32:  BRA    0E70
.................... 
.................... 
.................... 		/* non-channel based meta */
.................... 		case I2C_REG_SEQUENCE_NUMBER:
.................... 			return (int16) current.sequence_number;
0A34:  MOVFF  C4,01
0A38:  MOVFF  C5,02
0A3C:  BRA    0E70
.................... 		case I2C_REG_TIME_INTERVAL_MILLISECONDS:
.................... 			return (int16) current.interval_milliseconds;
0A3E:  MOVFF  C8,01
0A42:  MOVFF  C9,02
0A46:  BRA    0E70
.................... 		case I2C_REG_TIME_UPTIME_MINUTES:
.................... 			return (int16) current.uptime_minutes;
0A48:  MOVFF  C6,01
0A4C:  MOVFF  C7,02
0A50:  BRA    0E70
.................... 		case I2C_REG_DEFAULT_PARAMS_WRITTEN:
.................... 			return (int16) current.default_params_written;
0A52:  MOVFF  CE,01
0A56:  CLRF   02
0A58:  BRA    0E70
.................... 
.................... 		/* channel based configuration */
.................... 		case I2C_REG_CH0_COMMAND_ON_HOLD_INITIAL:
.................... 			return (int16) config.ch[c].command_on_hold_time;
0A5A:  MOVLB  1
0A5C:  MOVF   x2E,W
0A5E:  MULLW  24
0A60:  MOVF   FF3,W
0A62:  CLRF   x30
0A64:  MOVWF  x2F
0A66:  MOVLW  1B
0A68:  ADDWF  x2F,W
0A6A:  MOVWF  FE9
0A6C:  MOVLW  00
0A6E:  ADDWFC x30,W
0A70:  MOVWF  FEA
0A72:  MOVFF  FEC,03
0A76:  MOVF   FED,F
0A78:  MOVFF  FEF,01
0A7C:  MOVFF  03,02
0A80:  MOVLB  0
0A82:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_COMMAND_OFF_HOLD_INITIAL:
.................... 			return (int16) config.ch[c].command_off_hold_time;
0A84:  MOVLB  1
0A86:  MOVF   x2E,W
0A88:  MULLW  24
0A8A:  MOVF   FF3,W
0A8C:  CLRF   x30
0A8E:  MOVWF  x2F
0A90:  MOVLW  02
0A92:  ADDWF  x2F,W
0A94:  MOVWF  01
0A96:  MOVLW  00
0A98:  ADDWFC x30,W
0A9A:  MOVWF  03
0A9C:  MOVF   01,W
0A9E:  ADDLW  1B
0AA0:  MOVWF  FE9
0AA2:  MOVLW  00
0AA4:  ADDWFC 03,W
0AA6:  MOVWF  FEA
0AA8:  MOVFF  FEC,03
0AAC:  MOVF   FED,F
0AAE:  MOVFF  FEF,01
0AB2:  MOVFF  03,02
0AB6:  MOVLB  0
0AB8:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].lvd_disconnect_adc;
0ABA:  MOVLB  1
0ABC:  MOVF   x2E,W
0ABE:  MULLW  24
0AC0:  MOVF   FF3,W
0AC2:  CLRF   x30
0AC4:  MOVWF  x2F
0AC6:  MOVLW  04
0AC8:  ADDWF  x2F,W
0ACA:  MOVWF  01
0ACC:  MOVLW  00
0ACE:  ADDWFC x30,W
0AD0:  MOVWF  03
0AD2:  MOVF   01,W
0AD4:  ADDLW  1B
0AD6:  MOVWF  FE9
0AD8:  MOVLW  00
0ADA:  ADDWFC 03,W
0ADC:  MOVWF  FEA
0ADE:  MOVFF  FEC,03
0AE2:  MOVF   FED,F
0AE4:  MOVFF  FEF,01
0AE8:  MOVFF  03,02
0AEC:  MOVLB  0
0AEE:  BRA    0E70
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].lvd_disconnect_delay;
0AF0:  MOVLB  1
0AF2:  MOVF   x2E,W
0AF4:  MULLW  24
0AF6:  MOVF   FF3,W
0AF8:  CLRF   x30
0AFA:  MOVWF  x2F
0AFC:  MOVLW  06
0AFE:  ADDWF  x2F,W
0B00:  MOVWF  01
0B02:  MOVLW  00
0B04:  ADDWFC x30,W
0B06:  MOVWF  03
0B08:  MOVF   01,W
0B0A:  ADDLW  1B
0B0C:  MOVWF  FE9
0B0E:  MOVLW  00
0B10:  ADDWFC 03,W
0B12:  MOVWF  FEA
0B14:  MOVFF  FEC,03
0B18:  MOVF   FED,F
0B1A:  MOVFF  FEF,01
0B1E:  MOVFF  03,02
0B22:  MOVLB  0
0B24:  BRA    0E70
.................... 		case I2C_REG_CH0_LVD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].lvd_reconnect_adc;
0B26:  MOVLB  1
0B28:  MOVF   x2E,W
0B2A:  MULLW  24
0B2C:  MOVF   FF3,W
0B2E:  CLRF   x30
0B30:  MOVWF  x2F
0B32:  MOVLW  08
0B34:  ADDWF  x2F,W
0B36:  MOVWF  01
0B38:  MOVLW  00
0B3A:  ADDWFC x30,W
0B3C:  MOVWF  03
0B3E:  MOVF   01,W
0B40:  ADDLW  1B
0B42:  MOVWF  FE9
0B44:  MOVLW  00
0B46:  ADDWFC 03,W
0B48:  MOVWF  FEA
0B4A:  MOVFF  FEC,03
0B4E:  MOVF   FED,F
0B50:  MOVFF  FEF,01
0B54:  MOVFF  03,02
0B58:  MOVLB  0
0B5A:  BRA    0E70
.................... 		case I2C_REG_CH0_LVD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].lvd_reconnect_delay;
0B5C:  MOVLB  1
0B5E:  MOVF   x2E,W
0B60:  MULLW  24
0B62:  MOVF   FF3,W
0B64:  CLRF   x30
0B66:  MOVWF  x2F
0B68:  MOVLW  0A
0B6A:  ADDWF  x2F,W
0B6C:  MOVWF  01
0B6E:  MOVLW  00
0B70:  ADDWFC x30,W
0B72:  MOVWF  03
0B74:  MOVF   01,W
0B76:  ADDLW  1B
0B78:  MOVWF  FE9
0B7A:  MOVLW  00
0B7C:  ADDWFC 03,W
0B7E:  MOVWF  FEA
0B80:  MOVFF  FEC,03
0B84:  MOVF   FED,F
0B86:  MOVFF  FEF,01
0B8A:  MOVFF  03,02
0B8E:  MOVLB  0
0B90:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].hvd_disconnect_adc;
0B92:  MOVLB  1
0B94:  MOVF   x2E,W
0B96:  MULLW  24
0B98:  MOVF   FF3,W
0B9A:  CLRF   x30
0B9C:  MOVWF  x2F
0B9E:  MOVLW  0C
0BA0:  ADDWF  x2F,W
0BA2:  MOVWF  01
0BA4:  MOVLW  00
0BA6:  ADDWFC x30,W
0BA8:  MOVWF  03
0BAA:  MOVF   01,W
0BAC:  ADDLW  1B
0BAE:  MOVWF  FE9
0BB0:  MOVLW  00
0BB2:  ADDWFC 03,W
0BB4:  MOVWF  FEA
0BB6:  MOVFF  FEC,03
0BBA:  MOVF   FED,F
0BBC:  MOVFF  FEF,01
0BC0:  MOVFF  03,02
0BC4:  MOVLB  0
0BC6:  BRA    0E70
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].hvd_disconnect_delay;
0BC8:  MOVLB  1
0BCA:  MOVF   x2E,W
0BCC:  MULLW  24
0BCE:  MOVF   FF3,W
0BD0:  CLRF   x30
0BD2:  MOVWF  x2F
0BD4:  MOVLW  0E
0BD6:  ADDWF  x2F,W
0BD8:  MOVWF  01
0BDA:  MOVLW  00
0BDC:  ADDWFC x30,W
0BDE:  MOVWF  03
0BE0:  MOVF   01,W
0BE2:  ADDLW  1B
0BE4:  MOVWF  FE9
0BE6:  MOVLW  00
0BE8:  ADDWFC 03,W
0BEA:  MOVWF  FEA
0BEC:  MOVFF  FEC,03
0BF0:  MOVF   FED,F
0BF2:  MOVFF  FEF,01
0BF6:  MOVFF  03,02
0BFA:  MOVLB  0
0BFC:  BRA    0E70
.................... 		case I2C_REG_CH0_HVD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].hvd_reconnect_adc;
0BFE:  MOVLB  1
0C00:  MOVF   x2E,W
0C02:  MULLW  24
0C04:  MOVF   FF3,W
0C06:  CLRF   x30
0C08:  MOVWF  x2F
0C0A:  MOVLW  10
0C0C:  ADDWF  x2F,W
0C0E:  MOVWF  01
0C10:  MOVLW  00
0C12:  ADDWFC x30,W
0C14:  MOVWF  03
0C16:  MOVF   01,W
0C18:  ADDLW  1B
0C1A:  MOVWF  FE9
0C1C:  MOVLW  00
0C1E:  ADDWFC 03,W
0C20:  MOVWF  FEA
0C22:  MOVFF  FEC,03
0C26:  MOVF   FED,F
0C28:  MOVFF  FEF,01
0C2C:  MOVFF  03,02
0C30:  MOVLB  0
0C32:  BRA    0E70
.................... 		case I2C_REG_CH0_HVD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].hvd_reconnect_delay;
0C34:  MOVLB  1
0C36:  MOVF   x2E,W
0C38:  MULLW  24
0C3A:  MOVF   FF3,W
0C3C:  CLRF   x30
0C3E:  MOVWF  x2F
0C40:  MOVLW  12
0C42:  ADDWF  x2F,W
0C44:  MOVWF  01
0C46:  MOVLW  00
0C48:  ADDWFC x30,W
0C4A:  MOVWF  03
0C4C:  MOVF   01,W
0C4E:  ADDLW  1B
0C50:  MOVWF  FE9
0C52:  MOVLW  00
0C54:  ADDWFC 03,W
0C56:  MOVWF  FEA
0C58:  MOVFF  FEC,03
0C5C:  MOVF   FED,F
0C5E:  MOVFF  FEF,01
0C62:  MOVFF  03,02
0C66:  MOVLB  0
0C68:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_disconnect_adc;
0C6A:  MOVLB  1
0C6C:  MOVF   x2E,W
0C6E:  MULLW  24
0C70:  MOVF   FF3,W
0C72:  CLRF   x30
0C74:  MOVWF  x2F
0C76:  MOVLW  14
0C78:  ADDWF  x2F,W
0C7A:  MOVWF  01
0C7C:  MOVLW  00
0C7E:  ADDWFC x30,W
0C80:  MOVWF  03
0C82:  MOVF   01,W
0C84:  ADDLW  1B
0C86:  MOVWF  FE9
0C88:  MOVLW  00
0C8A:  ADDWFC 03,W
0C8C:  MOVWF  FEA
0C8E:  MOVFF  FEC,03
0C92:  MOVF   FED,F
0C94:  MOVFF  FEF,01
0C98:  MOVFF  03,02
0C9C:  MOVLB  0
0C9E:  BRA    0E70
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_disconnect_delay;
0CA0:  MOVLB  1
0CA2:  MOVF   x2E,W
0CA4:  MULLW  24
0CA6:  MOVF   FF3,W
0CA8:  CLRF   x30
0CAA:  MOVWF  x2F
0CAC:  MOVLW  16
0CAE:  ADDWF  x2F,W
0CB0:  MOVWF  01
0CB2:  MOVLW  00
0CB4:  ADDWFC x30,W
0CB6:  MOVWF  03
0CB8:  MOVF   01,W
0CBA:  ADDLW  1B
0CBC:  MOVWF  FE9
0CBE:  MOVLW  00
0CC0:  ADDWFC 03,W
0CC2:  MOVWF  FEA
0CC4:  MOVFF  FEC,03
0CC8:  MOVF   FED,F
0CCA:  MOVFF  FEF,01
0CCE:  MOVFF  03,02
0CD2:  MOVLB  0
0CD4:  BRA    0E70
.................... 		case I2C_REG_CH0_LTD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_reconnect_adc;
0CD6:  MOVLB  1
0CD8:  MOVF   x2E,W
0CDA:  MULLW  24
0CDC:  MOVF   FF3,W
0CDE:  CLRF   x30
0CE0:  MOVWF  x2F
0CE2:  MOVLW  18
0CE4:  ADDWF  x2F,W
0CE6:  MOVWF  01
0CE8:  MOVLW  00
0CEA:  ADDWFC x30,W
0CEC:  MOVWF  03
0CEE:  MOVF   01,W
0CF0:  ADDLW  1B
0CF2:  MOVWF  FE9
0CF4:  MOVLW  00
0CF6:  ADDWFC 03,W
0CF8:  MOVWF  FEA
0CFA:  MOVFF  FEC,03
0CFE:  MOVF   FED,F
0D00:  MOVFF  FEF,01
0D04:  MOVFF  03,02
0D08:  MOVLB  0
0D0A:  BRA    0E70
.................... 		case I2C_REG_CH0_LTD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_reconnect_delay;
0D0C:  MOVLB  1
0D0E:  MOVF   x2E,W
0D10:  MULLW  24
0D12:  MOVF   FF3,W
0D14:  CLRF   x30
0D16:  MOVWF  x2F
0D18:  MOVLW  1A
0D1A:  ADDWF  x2F,W
0D1C:  MOVWF  01
0D1E:  MOVLW  00
0D20:  ADDWFC x30,W
0D22:  MOVWF  03
0D24:  MOVF   01,W
0D26:  ADDLW  1B
0D28:  MOVWF  FE9
0D2A:  MOVLW  00
0D2C:  ADDWFC 03,W
0D2E:  MOVWF  FEA
0D30:  MOVFF  FEC,03
0D34:  MOVF   FED,F
0D36:  MOVFF  FEF,01
0D3A:  MOVFF  03,02
0D3E:  MOVLB  0
0D40:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_disconnect_adc;
0D42:  MOVLB  1
0D44:  MOVF   x2E,W
0D46:  MULLW  24
0D48:  MOVF   FF3,W
0D4A:  CLRF   x30
0D4C:  MOVWF  x2F
0D4E:  MOVLW  14
0D50:  ADDWF  x2F,W
0D52:  MOVWF  01
0D54:  MOVLW  00
0D56:  ADDWFC x30,W
0D58:  MOVWF  03
0D5A:  MOVF   01,W
0D5C:  ADDLW  1B
0D5E:  MOVWF  FE9
0D60:  MOVLW  00
0D62:  ADDWFC 03,W
0D64:  MOVWF  FEA
0D66:  MOVFF  FEC,03
0D6A:  MOVF   FED,F
0D6C:  MOVFF  FEF,01
0D70:  MOVFF  03,02
0D74:  MOVLB  0
0D76:  BRA    0E70
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_disconnect_delay;
0D78:  MOVLB  1
0D7A:  MOVF   x2E,W
0D7C:  MULLW  24
0D7E:  MOVF   FF3,W
0D80:  CLRF   x30
0D82:  MOVWF  x2F
0D84:  MOVLW  16
0D86:  ADDWF  x2F,W
0D88:  MOVWF  01
0D8A:  MOVLW  00
0D8C:  ADDWFC x30,W
0D8E:  MOVWF  03
0D90:  MOVF   01,W
0D92:  ADDLW  1B
0D94:  MOVWF  FE9
0D96:  MOVLW  00
0D98:  ADDWFC 03,W
0D9A:  MOVWF  FEA
0D9C:  MOVFF  FEC,03
0DA0:  MOVF   FED,F
0DA2:  MOVFF  FEF,01
0DA6:  MOVFF  03,02
0DAA:  MOVLB  0
0DAC:  BRA    0E70
.................... 		case I2C_REG_CH0_HTD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_reconnect_adc;
0DAE:  MOVLB  1
0DB0:  MOVF   x2E,W
0DB2:  MULLW  24
0DB4:  MOVF   FF3,W
0DB6:  CLRF   x30
0DB8:  MOVWF  x2F
0DBA:  MOVLW  18
0DBC:  ADDWF  x2F,W
0DBE:  MOVWF  01
0DC0:  MOVLW  00
0DC2:  ADDWFC x30,W
0DC4:  MOVWF  03
0DC6:  MOVF   01,W
0DC8:  ADDLW  1B
0DCA:  MOVWF  FE9
0DCC:  MOVLW  00
0DCE:  ADDWFC 03,W
0DD0:  MOVWF  FEA
0DD2:  MOVFF  FEC,03
0DD6:  MOVF   FED,F
0DD8:  MOVFF  FEF,01
0DDC:  MOVFF  03,02
0DE0:  MOVLB  0
0DE2:  BRA    0E70
.................... 		case I2C_REG_CH0_HTD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_reconnect_delay;	
0DE4:  MOVLB  1
0DE6:  MOVF   x2E,W
0DE8:  MULLW  24
0DEA:  MOVF   FF3,W
0DEC:  CLRF   x30
0DEE:  MOVWF  x2F
0DF0:  MOVLW  1A
0DF2:  ADDWF  x2F,W
0DF4:  MOVWF  01
0DF6:  MOVLW  00
0DF8:  ADDWFC x30,W
0DFA:  MOVWF  03
0DFC:  MOVF   01,W
0DFE:  ADDLW  1B
0E00:  MOVWF  FE9
0E02:  MOVLW  00
0E04:  ADDWFC 03,W
0E06:  MOVWF  FEA
0E08:  MOVFF  FEC,03
0E0C:  MOVF   FED,F
0E0E:  MOVFF  FEF,01
0E12:  MOVFF  03,02
0E16:  MOVLB  0
0E18:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_FUT_DISCONNECT_VALUE:
.................... 		case I2C_REG_CH0_FUT_DISCONNECT_DELAY:
.................... 		case I2C_REG_CH0_FUT_RECONNECT_VALUE:
.................... 		case I2C_REG_CH0_FUT_RECONNECT_DELAY:
.................... 			return (int16) 0xffff; /* not yet implemented */
0E1A:  MOVLW  FF
0E1C:  MOVWF  01
0E1E:  MOVWF  02
0E20:  BRA    0E70
.................... 		
.................... 		/* configuration */
.................... 		case I2C_REG_CONFIG_HARDWARE_MODEL: 
.................... 			return (int16) 'D';
0E22:  MOVLW  44
0E24:  MOVWF  01
0E26:  MOVLW  00
0E28:  MOVWF  02
0E2A:  BRA    0E70
.................... 		case I2C_REG_CONFIG_HARDWARE_VERSION: 
.................... 			return (int16) '2';
0E2C:  MOVLW  32
0E2E:  MOVWF  01
0E30:  MOVLW  00
0E32:  MOVWF  02
0E34:  BRA    0E70
.................... 		case I2C_REG_CONFIG_SOFTWARE_MODEL: 
.................... 			return (int16) 'L';
0E36:  MOVLW  4C
0E38:  MOVWF  01
0E3A:  MOVLW  00
0E3C:  MOVWF  02
0E3E:  BRA    0E70
.................... 		case I2C_REG_CONFIG_SOFTWARE_VERSION: 
.................... 			return (int16) '0';
0E40:  MOVLW  30
0E42:  MOVWF  01
0E44:  MOVLW  00
0E46:  MOVWF  02
0E48:  BRA    0E70
.................... 		case I2C_REG_CONFIG_SOFTWARE_YEAR:
.................... 			return (int16) current.compile_year;
0E4A:  MOVFF  CB,01
0E4E:  CLRF   02
0E50:  BRA    0E70
.................... 		case I2C_REG_CONFIG_SOFTWARE_MONTH:
.................... 			return (int16) current.compile_month;
0E52:  MOVFF  CC,01
0E56:  CLRF   02
0E58:  BRA    0E70
.................... 		case I2C_REG_CONFIG_SOFTWARE_DAY:
.................... 			return (int16) current.compile_day;
0E5A:  MOVFF  CD,01
0E5E:  CLRF   02
0E60:  BRA    0E70
.................... 
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			/* 1 if factory unlocked */ 
.................... 			return (int16) current.factory_unlocked; 	
0E62:  MOVFF  CA,01
0E66:  CLRF   02
0E68:  BRA    0E70
.................... 
.................... 		/* we should have range checked, and never gotten here ... or read unimplemented (future) register */
.................... 		default: return (int16) 0xffff;
0E6A:  MOVLW  FF
0E6C:  MOVWF  01
0E6E:  MOVWF  02
.................... 	}
0E70:  GOTO   0F2E (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... 
.................... 
.................... #include "interrupt_dcswc_module_latching_contactor.c"
.................... #int_timer2
.................... void isr_timer2() {
.................... 	timers.now_millisecond=1;
*
00D4:  BSF    xCF.2
.................... }
.................... 
.................... 
.................... 
.................... /* I2C slave interrupt */
00D6:  BCF    F9E.1
00D8:  GOTO   006C
.................... #byte SSPSTAT=GETENV("SFR:SSPSTAT")
.................... #INT_SSP
.................... void ssp_interrupt () {
.................... 	static int8 sstate;
.................... 	int8 state;
.................... 	int8 incoming;
.................... 	static int16 lastValue;
.................... 	static int8 lastMSB;
.................... 
.................... 	static int8 address; 
.................... 
.................... 	/* 
.................... 	our implementation of i2c_isr_state() that won't overflow and switch states
.................... 	but it will quit counting at 127 bytes. 
.................... 	If more bytes are needed, external counting variables can be used or the size of state can be made larger
.................... 	*/
.................... 
.................... 
.................... 	if ( ! bit_test(SSPSTAT,5) ) {
*
0E8A:  BTFSC  FC7.5
0E8C:  BRA    0E9A
.................... 		/* address */
.................... 		sstate=0;
0E8E:  MOVLB  1
0E90:  CLRF   x0C
.................... 
.................... 		if ( bit_test(SSPSTAT,2) ) {
0E92:  BTFSS  FC7.2
0E94:  BRA    0E98
.................... 			/* set high bit if read */
.................... 			bit_set(sstate,7);
0E96:  BSF    x0C.7
.................... 		}
.................... 	} else {
0E98:  MOVLB  0
.................... 		/* data */
.................... 	}
.................... 
.................... 	/* state variable used below is not incremented */
.................... 	state=sstate;
0E9A:  MOVFF  10C,12A
.................... 
.................... 	/* increment the state counter for next pass through unless it will overflow us into another state */
.................... 	if ( sstate != 0x7f && sstate != 0xff) {
0E9E:  MOVLB  1
0EA0:  MOVF   x0C,W
0EA2:  SUBLW  7F
0EA4:  BZ    0EAE
0EA6:  INCFSZ x0C,W
0EA8:  BRA    0EAC
0EAA:  BRA    0EAE
.................... 		sstate++;
0EAC:  INCF   x0C,F
.................... 	}
.................... 
.................... 	
.................... 	/* i2c_isr_state() return an 8 bit int
.................... 		0 - Address match received with R/W bit clear, perform i2c_read( ) to read the I2C address.
.................... 		1-0x7F - Master has written data; i2c_read() will immediately return the data
.................... 		0x80 - Address match received with R/W bit set; perform i2c_read( ) to read the I2C address,
.................... 		and use i2c_write( ) to pre-load the transmit buffer for the next transaction (next I2C read
.................... 		performed by master will read this byte).
.................... 		0x81-0xFF - Transmission completed and acknowledged; respond with i2c_write() to pre-load
.................... 		the transmit buffer for the next transition (the next I2C read performed by master will read this
.................... 		byte).
.................... 		Function:
.................... 		Returns the state of I2C communications in I2C slave mode after an SSP interrupt. The return
.................... 		value increments with each byte received or sent.
.................... 		If 0x00 or 0x80 is returned, an i2C_read( ) needs to be performed to read the I2C address that
.................... 		was sent (it will match the address configured by #USE I2C so this value can be ignored)
.................... 	*/
.................... 
.................... 	if ( state <= 0x80 ) {                      
0EAE:  MOVF   x2A,W
0EB0:  SUBLW  80
0EB2:  BNC   0F16
.................... 		/* I2C master is sending us data */
.................... 		if ( 0x80 == state ) {
0EB4:  MOVF   x2A,W
0EB6:  SUBLW  80
0EB8:  BNZ   0EC0
.................... 			/* i2c_read(2) casues the function to read the SSPBUF without releasing the clock */
.................... 			incoming = i2c_read(STREAM_SLAVE,2);
0EBA:  MOVFF  FC9,12B
.................... 		} else {
0EBE:  BRA    0ECC
.................... 			incoming = i2c_read(STREAM_SLAVE);
0EC0:  BCF    FC6.6
0EC2:  BTFSS  FC7.0
0EC4:  BRA    0EC2
0EC6:  MOVF   FC9,W
0EC8:  BSF    FC6.4
0ECA:  MOVWF  x2B
.................... 		}
.................... 
.................... 		if ( 1 == state ) {             
0ECC:  DECFSZ x2A,W
0ECE:  BRA    0ED8
.................... 			address = incoming<<1;
0ED0:  BCF    FD8.0
0ED2:  RLCF   x2B,W
0ED4:  MOVWF  x10
.................... 		} else if ( state >= 2 && 0x80 != state ) {
0ED6:  BRA    0F16
0ED8:  MOVF   x2A,W
0EDA:  SUBLW  01
0EDC:  BC    0F16
0EDE:  MOVF   x2A,W
0EE0:  SUBLW  80
0EE2:  BZ    0F16
.................... 			/* received byte is data */
.................... 		
.................... 			/* save MSB and we'll process it on next */
.................... 			if ( 2 == state ) {
0EE4:  MOVF   x2A,W
0EE6:  SUBLW  02
0EE8:  BNZ   0EF0
.................... 				lastMSB=incoming;
0EEA:  MOVFF  12B,10F
.................... 			} else if ( 3 == state ) {
0EEE:  BRA    0F16
0EF0:  MOVF   x2A,W
0EF2:  SUBLW  03
0EF4:  BNZ   0F16
.................... 				/* 16 bit value made of previous byte and this byte */
.................... 				write_i2c(address>>1,make16(lastMSB,incoming));
0EF6:  BCF    FD8.0
0EF8:  RRCF   x10,W
0EFA:  MOVWF  x2C
0EFC:  MOVFF  10F,12E
0F00:  MOVFF  12B,12D
0F04:  MOVWF  x2F
0F06:  MOVFF  10F,131
0F0A:  MOVFF  12B,130
0F0E:  MOVLB  0
0F10:  GOTO   00DC
0F14:  MOVLB  1
.................... 
.................... 				/* this write only works for a single register per I2C transaction */
.................... 				/* this is not a BUG, but it would need to be implemented if this functionality is needed */
.................... 			}
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	if ( state >= 0x80 ) {
0F16:  MOVF   x2A,W
0F18:  SUBLW  7F
0F1A:  BC    0F54
.................... 		/* I2C master is requesting data from us */
.................... 
.................... 		if ( ! bit_test(address,0) ) {
0F1C:  BTFSC  x10.0
0F1E:  BRA    0F44
.................... 			/* read 16 bit register (register address half of I2C address) on even address */
.................... 			lastValue=map_i2c(address>>1);
0F20:  BCF    FD8.0
0F22:  RRCF   x10,W
0F24:  MOVWF  x2C
0F26:  MOVWF  x2D
0F28:  MOVLB  0
0F2A:  GOTO   0614
0F2E:  MOVFF  02,10E
0F32:  MOVFF  01,10D
.................... 
.................... 			/* send the MSB */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,1));
0F36:  MOVFF  10E,12C
0F3A:  MOVFF  10E,12D
0F3E:  RCALL  0E74
.................... 		} else {
0F40:  BRA    0F50
0F42:  MOVLB  1
.................... 			/* send LSB of 16 bit register on odd address */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,0));
0F44:  MOVFF  10D,12C
0F48:  MOVFF  10D,12D
0F4C:  MOVLB  0
0F4E:  RCALL  0E74
.................... 		}
.................... 		address++;
0F50:  MOVLB  1
0F52:  INCF   x10,F
.................... 	}
.................... }
.................... 
.................... 
.................... 
.................... 
0F54:  BCF    F9E.3
0F56:  MOVLB  0
0F58:  GOTO   006C
.................... #include "debug_dcswc_module_latching_contactor.c"
.................... void debug_dump(void) {
.................... 
.................... //	int8 i;
.................... 
.................... 	
.................... 	restart_wdt();
*
2C86:  CLRWDT
2C88:  CLRF   19
2C8A:  BTFSC  FF2.7
2C8C:  BSF    19.7
2C8E:  BCF    FF2.7
.................... #if 0
.................... 	fprintf(STREAM_FTDI,"# '%s'\r\n",__DATE__);
.................... 	fprintf(STREAM_FTDI,"#  compile_year=%u\r\n",current.compile_year);
.................... 	fprintf(STREAM_FTDI,"# compile_month=%u\r\n",current.compile_month);
.................... 	fprintf(STREAM_FTDI,"#   compile_day=%u\r\n",current.compile_day);
.................... #endif
.................... 	fprintf(STREAM_FTDI,"#       vin adc=%lu\r\n",adc_get(0));
2C90:  MOVLB  1
2C92:  CLRF   x2F
2C94:  MOVLB  0
2C96:  CALL   0594
2C9A:  BTFSC  19.7
2C9C:  BSF    FF2.7
2C9E:  MOVFF  02,11C
2CA2:  MOVFF  01,11B
2CA6:  MOVLW  5C
2CA8:  MOVWF  FF6
2CAA:  MOVLW  0F
2CAC:  MOVWF  FF7
2CAE:  MOVLW  10
2CB0:  MOVLB  1
2CB2:  MOVWF  x1D
2CB4:  MOVLB  0
2CB6:  CALL   1840
2CBA:  MOVLW  10
2CBC:  MOVWF  FE9
2CBE:  MOVFF  11C,11E
2CC2:  MOVFF  11B,11D
2CC6:  RCALL  2B8E
2CC8:  MOVLW  0D
2CCA:  BTFSS  F9E.4
2CCC:  BRA    2CCA
2CCE:  MOVWF  FAD
2CD0:  MOVLW  0A
2CD2:  BTFSS  F9E.4
2CD4:  BRA    2CD2
2CD6:  MOVWF  FAD
2CD8:  CLRF   19
2CDA:  BTFSC  FF2.7
2CDC:  BSF    19.7
2CDE:  BCF    FF2.7
.................... 	fprintf(STREAM_FTDI,"#      temp adc=%lu\r\n",adc_get(1));
2CE0:  MOVLW  01
2CE2:  MOVLB  1
2CE4:  MOVWF  x2F
2CE6:  MOVLB  0
2CE8:  CALL   0594
2CEC:  BTFSC  19.7
2CEE:  BSF    FF2.7
2CF0:  MOVFF  02,11C
2CF4:  MOVFF  01,11B
2CF8:  MOVLW  72
2CFA:  MOVWF  FF6
2CFC:  MOVLW  0F
2CFE:  MOVWF  FF7
2D00:  MOVLW  10
2D02:  MOVLB  1
2D04:  MOVWF  x1D
2D06:  MOVLB  0
2D08:  CALL   1840
2D0C:  MOVLW  10
2D0E:  MOVWF  FE9
2D10:  MOVFF  11C,11E
2D14:  MOVFF  11B,11D
2D18:  RCALL  2B8E
2D1A:  MOVLW  0D
2D1C:  BTFSS  F9E.4
2D1E:  BRA    2D1C
2D20:  MOVWF  FAD
2D22:  MOVLW  0A
2D24:  BTFSS  F9E.4
2D26:  BRA    2D24
2D28:  MOVWF  FAD
.................... 	fprintf(STREAM_FTDI,"#   ch[0].state=0x%2X\r\n",channel[0].state);
2D2A:  MOVLW  88
2D2C:  MOVWF  FF6
2D2E:  MOVLW  0F
2D30:  MOVWF  FF7
2D32:  MOVLW  12
2D34:  MOVLB  1
2D36:  MOVWF  x1D
2D38:  MOVLB  0
2D3A:  CALL   1840
2D3E:  MOVFF  DA,11B
2D42:  MOVLW  37
2D44:  MOVLB  1
2D46:  MOVWF  x1C
2D48:  MOVLB  0
2D4A:  RCALL  2C40
2D4C:  MOVLW  0D
2D4E:  BTFSS  F9E.4
2D50:  BRA    2D4E
2D52:  MOVWF  FAD
2D54:  MOVLW  0A
2D56:  BTFSS  F9E.4
2D58:  BRA    2D56
2D5A:  MOVWF  FAD
.................... 	fprintf(STREAM_FTDI,"#   ch[1].state=0x%2X\r\n",channel[1].state);
2D5C:  MOVLW  A0
2D5E:  MOVWF  FF6
2D60:  MOVLW  0F
2D62:  MOVWF  FF7
2D64:  MOVLW  12
2D66:  MOVLB  1
2D68:  MOVWF  x1D
2D6A:  MOVLB  0
2D6C:  CALL   1840
2D70:  MOVFF  F3,11B
2D74:  MOVLW  37
2D76:  MOVLB  1
2D78:  MOVWF  x1C
2D7A:  MOVLB  0
2D7C:  RCALL  2C40
2D7E:  MOVLW  0D
2D80:  BTFSS  F9E.4
2D82:  BRA    2D80
2D84:  MOVWF  FAD
2D86:  MOVLW  0A
2D88:  BTFSS  F9E.4
2D8A:  BRA    2D88
2D8C:  MOVWF  FAD
.................... //	fprintf(STREAM_FTDI,"# read_dip_sw()=%u\r\n",read_dip_switch());
.................... //	fprintf(STREAM_FTDI,"#    dip sw adc=%lu\r\n",adc_get(2));
.................... 
.................... #if 0
2D8E:  GOTO   2F64 (RETURN)
.................... 	for ( i=0 ; i<2 ; i++ ) {
.................... 		restart_wdt();
.................... 		fprintf(STREAM_FTDI,"#-------\r\n");
.................... 		fprintf(STREAM_FTDI,"# config.ch[%u]\r\n",i);
.................... 		fprintf(STREAM_FTDI,"# command_off_hold_time=%lu\r\n",config.ch[i].command_off_hold_time);
.................... 
.................... 		fprintf(STREAM_FTDI,"#    lvd_disconnect_adc=%lu\r\n",config.ch[i].lvd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  lvd_disconnect_delay=%lu\r\n",config.ch[i].lvd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     lvd_reconnect_adc=%lu\r\n",config.ch[i].lvd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   lvd_reconnect_delay=%lu\r\n",config.ch[i].lvd_reconnect_delay);
.................... 
.................... 		fprintf(STREAM_FTDI,"#    hvd_disconnect_adc=%lu\r\n",config.ch[i].hvd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  hvd_disconnect_delay=%lu\r\n",config.ch[i].hvd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     hvd_reconnect_adc=%lu\r\n",config.ch[i].hvd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   hvd_reconnect_delay=%lu\r\n",config.ch[i].hvd_reconnect_delay);
.................... 
.................... 		restart_wdt();
.................... 		fprintf(STREAM_FTDI,"#    ltd_disconnect_adc=%lu\r\n",config.ch[i].ltd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  ltd_disconnect_delay=%lu\r\n",config.ch[i].ltd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     ltd_reconnect_adc=%lu\r\n",config.ch[i].ltd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   ltd_reconnect_delay=%lu\r\n",config.ch[i].ltd_reconnect_delay);
.................... 
.................... 		fprintf(STREAM_FTDI,"#    htd_disconnect_adc=%lu\r\n",config.ch[i].htd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  htd_disconnect_delay=%lu\r\n",config.ch[i].htd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     htd_reconnect_adc=%lu\r\n",config.ch[i].htd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   htd_reconnect_delay=%lu\r\n",config.ch[i].htd_reconnect_delay);
.................... 
.................... 
.................... 		restart_wdt();
.................... 		fprintf(STREAM_FTDI,"#\r\n");
.................... 		fprintf(STREAM_FTDI,"# channel[%u]\r\n",i);
.................... 		fprintf(STREAM_FTDI,"#                        state=0x%02x\r\n",channel[i].state);
.................... 		fprintf(STREAM_FTDI,"#           command_on_seconds=%lu\r\n",channel[i].command_on_seconds);
.................... 		fprintf(STREAM_FTDI,"#      command_on_hold_seconds=%lu\r\n",channel[i].command_on_hold_seconds);
.................... 
.................... 		fprintf(STREAM_FTDI,"#          command_off_seconds=%lu\r\n",channel[i].command_off_seconds);
.................... 		fprintf(STREAM_FTDI,"#     command_off_hold_seconds=%lu\r\n",channel[i].command_off_hold_seconds);
.................... 
.................... 		fprintf(STREAM_FTDI,"# lvd_disconnect_delay_seconds=%lu\r\n",channel[i].lvd_disconnect_delay_seconds);
.................... 		fprintf(STREAM_FTDI,"#  lvd_reconnect_delay_seconds=%lu\r\n",channel[i].lvd_reconnect_delay_seconds);
.................... 
.................... 		fprintf(STREAM_FTDI,"# hvd_disconnect_delay_seconds=%lu\r\n",channel[i].hvd_disconnect_delay_seconds);
.................... 		fprintf(STREAM_FTDI,"#  hvd_reconnect_delay_seconds=%lu\r\n",channel[i].hvd_reconnect_delay_seconds);
.................... 
.................... 		restart_wdt();
.................... 		fprintf(STREAM_FTDI,"# ltd_disconnect_delay_seconds=%lu\r\n",channel[i].ltd_disconnect_delay_seconds);
.................... 		fprintf(STREAM_FTDI,"#  ltd_reconnect_delay_seconds=%lu\r\n",channel[i].ltd_reconnect_delay_seconds);
.................... 
.................... 		fprintf(STREAM_FTDI,"# htd_disconnect_delay_seconds=%lu\r\n",channel[i].htd_disconnect_delay_seconds);
.................... 		fprintf(STREAM_FTDI,"#  htd_reconnect_delay_seconds=%lu\r\n",channel[i].htd_reconnect_delay_seconds);
.................... 	}
.................... 	#endif
.................... }
.................... 
.................... 
.................... 
.................... void contactor_on(int8 c) {
.................... 	/* only turn on contactor if it isn't on or needs a refresh */
.................... 	if ( 1 == timers.contactor[c] ) {
*
27EE:  CLRF   03
27F0:  MOVLB  1
27F2:  MOVF   x1E,W
27F4:  ADDLW  D6
27F6:  MOVWF  FE9
27F8:  MOVLW  00
27FA:  ADDWFC 03,W
27FC:  MOVWF  FEA
27FE:  MOVF   FEF,W
2800:  SUBLW  01
2802:  BNZ   2806
.................... 		return;
2804:  BRA    2840
.................... 	}
.................... 
.................... 	/* we start the powersave count down */
.................... 	timers.contactor_powersave[c]=CONTACTOR_POWER_SAVE_MS;
2806:  CLRF   03
2808:  MOVF   x1E,W
280A:  ADDLW  D8
280C:  MOVWF  FE9
280E:  MOVLW  00
2810:  ADDWFC 03,W
2812:  MOVWF  FEA
2814:  MOVLW  C8
2816:  MOVWF  FEF
.................... 
.................... 	/* control the actual coil depending on what channel we are on */
.................... 	if ( 0==c ) {
2818:  MOVF   x1E,F
281A:  BNZ   2826
.................... 		/* contactor A pins */
.................... 		output_low(BRIDGE_A_A);
281C:  BCF    F94.3
281E:  BCF    F8B.3
.................... 		output_high(BRIDGE_A_B);
2820:  BCF    F94.4
2822:  BSF    F8B.4
.................... 	} else {
2824:  BRA    282E
.................... 		/* contactor B pins */
.................... 		output_low(BRIDGE_B_A);
2826:  BCF    F94.5
2828:  BCF    F8B.5
.................... 		output_high(BRIDGE_B_B);
282A:  BCF    F94.6
282C:  BSF    F8B.6
.................... 	}
.................... 
.................... 	/* save state for next time */
.................... 	timers.contactor[c]=1;
282E:  CLRF   03
2830:  MOVF   x1E,W
2832:  ADDLW  D6
2834:  MOVWF  FE9
2836:  MOVLW  00
2838:  ADDWFC 03,W
283A:  MOVWF  FEA
283C:  MOVLW  01
283E:  MOVWF  FEF
2840:  MOVLB  0
2842:  GOTO   28A6 (RETURN)
.................... }
.................... 
.................... void contactor_off(int8 c) {
.................... 	/* only turn off contactor if it isn't on or needs a refresh */
.................... 	if ( 0 == timers.contactor[c] ) {
*
279A:  CLRF   03
279C:  MOVLB  1
279E:  MOVF   x1E,W
27A0:  ADDLW  D6
27A2:  MOVWF  FE9
27A4:  MOVLW  00
27A6:  ADDWFC 03,W
27A8:  MOVWF  FEA
27AA:  MOVF   FEF,W
27AC:  BNZ   27B0
.................... 		return;
27AE:  BRA    27E8
.................... 	}
.................... 
.................... 	/* we start the powersave count down */
.................... 	timers.contactor_powersave[c]=CONTACTOR_POWER_SAVE_MS;
27B0:  CLRF   03
27B2:  MOVF   x1E,W
27B4:  ADDLW  D8
27B6:  MOVWF  FE9
27B8:  MOVLW  00
27BA:  ADDWFC 03,W
27BC:  MOVWF  FEA
27BE:  MOVLW  C8
27C0:  MOVWF  FEF
.................... 
.................... 	/* control the actual coil depending on what channel we are on */
.................... 	if ( 0==c ) {
27C2:  MOVF   x1E,F
27C4:  BNZ   27D0
.................... 		output_high(BRIDGE_A_A);
27C6:  BCF    F94.3
27C8:  BSF    F8B.3
.................... 		output_low(BRIDGE_A_B);
27CA:  BCF    F94.4
27CC:  BCF    F8B.4
.................... 	} else {
27CE:  BRA    27D8
.................... 		output_high(BRIDGE_B_A);
27D0:  BCF    F94.5
27D2:  BSF    F8B.5
.................... 		output_low(BRIDGE_B_B);
27D4:  BCF    F94.6
27D6:  BCF    F8B.6
.................... 	}
.................... 
.................... 	/* save state for next time */
.................... 	timers.contactor[c]=0;
27D8:  CLRF   03
27DA:  MOVF   x1E,W
27DC:  ADDLW  D6
27DE:  MOVWF  FE9
27E0:  MOVLW  00
27E2:  ADDWFC 03,W
27E4:  MOVWF  FEA
27E6:  CLRF   FEF
27E8:  MOVLB  0
27EA:  GOTO   289A (RETURN)
.................... }
.................... 
.................... void contactor_set(int8 c) {
*
2846:  MOVLW  01
2848:  MOVLB  1
284A:  MOVWF  x1D
.................... 	int8 state=1;
.................... 
.................... 	/* if nothing is set in channel[c].state, contactor is on */
.................... 	state=1; 
284C:  MOVWF  x1D
.................... 
.................... 	if ( channel[c].state & CH_STATE_MASK_ON ) {
284E:  MOVF   x1C,W
2850:  MULLW  19
2852:  MOVF   FF3,W
2854:  CLRF   x1F
2856:  MOVWF  x1E
2858:  MOVLW  DA
285A:  ADDWF  x1E,W
285C:  MOVWF  FE9
285E:  MOVLW  00
2860:  ADDWFC x1F,W
2862:  MOVWF  FEA
2864:  MOVF   FEF,W
2866:  ANDLW  03
2868:  BZ    2870
.................... 		/* if override button (switch) is set or we are commanded on, then we will be on */
.................... 		state=1;
286A:  MOVLW  01
286C:  MOVWF  x1D
.................... 	} else if ( channel[c].state & CH_STATE_MASK_OFF ) {
286E:  BRA    288E
2870:  MOVF   x1C,W
2872:  MULLW  19
2874:  MOVF   FF3,W
2876:  CLRF   x1F
2878:  MOVWF  x1E
287A:  MOVLW  DA
287C:  ADDWF  x1E,W
287E:  MOVWF  FE9
2880:  MOVLW  00
2882:  ADDWFC x1F,W
2884:  MOVWF  FEA
2886:  MOVF   FEF,W
2888:  ANDLW  7C
288A:  BZ    288E
.................... 		/* if one of the disconnect bits is set, we will be off */
.................... 		state=0;
288C:  CLRF   x1D
.................... 	}
.................... 
.................... 	if ( 0==state ) {
288E:  MOVF   x1D,F
2890:  BNZ   289E
.................... 		contactor_off(c);
2892:  MOVFF  11C,11E
2896:  MOVLB  0
2898:  BRA    279A
.................... 	} else {
289A:  BRA    28A6
289C:  MOVLB  1
.................... 		contactor_on(c);
289E:  MOVFF  11C,11E
28A2:  MOVLB  0
28A4:  BRA    27EE
.................... 	}
28A6:  RETURN 0
.................... 
.................... }
.................... 
.................... void contactor_logic(int8 c) {
.................... 	int16 adc;
.................... 
.................... 	/* override button / switch */
.................... 	if ( (0==c && 0==input(SW_OVERRIDE_A)) || (1==c && 0==input(SW_OVERRIDE_B)) ) {
*
1956:  MOVLB  1
1958:  MOVF   x1C,F
195A:  BNZ   1962
195C:  BSF    F92.5
195E:  BTFSS  F80.5
1960:  BRA    196C
1962:  DECFSZ x1C,W
1964:  BRA    198A
1966:  BSF    F92.4
1968:  BTFSC  F80.4
196A:  BRA    198A
.................... 		bit_set(channel[c].state,CH_STATE_BIT_OVERRIDE);
196C:  MOVF   x1C,W
196E:  MULLW  19
1970:  MOVF   FF3,W
1972:  CLRF   x20
1974:  MOVWF  x1F
1976:  MOVLW  DA
1978:  ADDWF  x1F,W
197A:  MOVWF  01
197C:  MOVLW  00
197E:  ADDWFC x20,W
1980:  MOVFF  01,FE9
1984:  MOVWF  FEA
1986:  BSF    FEF.0
.................... 	} else {
1988:  BRA    19A6
.................... 		bit_clear(channel[c].state,CH_STATE_BIT_OVERRIDE);
198A:  MOVF   x1C,W
198C:  MULLW  19
198E:  MOVF   FF3,W
1990:  CLRF   x20
1992:  MOVWF  x1F
1994:  MOVLW  DA
1996:  ADDWF  x1F,W
1998:  MOVWF  01
199A:  MOVLW  00
199C:  ADDWFC x20,W
199E:  MOVFF  01,FE9
19A2:  MOVWF  FEA
19A4:  BCF    FEF.0
.................... 	}
.................... 
.................... 	/* command on. 65535 disables */
.................... 	if ( 65535 != channel[c].command_on_seconds ) {
19A6:  MOVF   x1C,W
19A8:  MULLW  19
19AA:  MOVF   FF3,W
19AC:  CLRF   x20
19AE:  MOVWF  x1F
19B0:  MOVLW  01
19B2:  ADDWF  x1F,W
19B4:  MOVWF  01
19B6:  MOVLW  00
19B8:  ADDWFC x20,W
19BA:  MOVWF  03
19BC:  MOVF   01,W
19BE:  ADDLW  DA
19C0:  MOVWF  FE9
19C2:  MOVLW  00
19C4:  ADDWFC 03,W
19C6:  MOVWF  FEA
19C8:  MOVFF  FEC,03
19CC:  MOVF   FED,F
19CE:  MOVF   FEF,W
19D0:  SUBLW  FF
19D2:  BNZ   19DA
19D4:  INCFSZ 03,W
19D6:  BRA    19DA
19D8:  BRA    1B70
.................... 		if ( channel[c].command_on_seconds > 0 ) {
19DA:  MOVF   x1C,W
19DC:  MULLW  19
19DE:  MOVF   FF3,W
19E0:  CLRF   x20
19E2:  MOVWF  x1F
19E4:  MOVLW  01
19E6:  ADDWF  x1F,W
19E8:  MOVWF  01
19EA:  MOVLW  00
19EC:  ADDWFC x20,W
19EE:  MOVWF  03
19F0:  MOVF   01,W
19F2:  ADDLW  DA
19F4:  MOVWF  FE9
19F6:  MOVLW  00
19F8:  ADDWFC 03,W
19FA:  MOVWF  FEA
19FC:  MOVFF  FEC,120
1A00:  MOVF   FED,F
1A02:  MOVFF  FEF,11F
1A06:  MOVF   x1F,F
1A08:  BNZ   1A0E
1A0A:  MOVF   x20,F
1A0C:  BZ    1A3C
.................... 			/* waiting to power on */
.................... 			channel[c].command_on_seconds--;
1A0E:  MOVF   x1C,W
1A10:  MULLW  19
1A12:  MOVF   FF3,W
1A14:  CLRF   x20
1A16:  MOVWF  x1F
1A18:  MOVLW  01
1A1A:  ADDWF  x1F,W
1A1C:  MOVWF  01
1A1E:  MOVLW  00
1A20:  ADDWFC x20,W
1A22:  MOVWF  03
1A24:  MOVF   01,W
1A26:  ADDLW  DA
1A28:  MOVWF  FE9
1A2A:  MOVLW  00
1A2C:  ADDWFC 03,W
1A2E:  MOVWF  FEA
1A30:  MOVLW  FF
1A32:  ADDWF  FEF,F
1A34:  BC    1A3A
1A36:  MOVF   FEE,F
1A38:  DECF   FED,F
.................... 		} else {
1A3A:  BRA    1B70
.................... 			/* timer at zero, ready to power on or already powered on */
.................... 			if ( ! bit_test(channel[c].state,CH_STATE_BIT_CMD_ON) ) {
1A3C:  MOVF   x1C,W
1A3E:  MULLW  19
1A40:  MOVF   FF3,W
1A42:  CLRF   x20
1A44:  MOVWF  x1F
1A46:  MOVLW  DA
1A48:  ADDWF  x1F,W
1A4A:  MOVWF  FE9
1A4C:  MOVLW  00
1A4E:  ADDWFC x20,W
1A50:  MOVWF  FEA
1A52:  MOVFF  FEF,121
1A56:  BTFSC  x21.1
1A58:  BRA    1ACE
.................... 				/* not currently set, so we set it and start the countdown */
.................... 				bit_set(channel[c].state,CH_STATE_BIT_CMD_ON);
1A5A:  MOVF   x1C,W
1A5C:  MULLW  19
1A5E:  MOVF   FF3,W
1A60:  CLRF   x20
1A62:  MOVWF  x1F
1A64:  MOVLW  DA
1A66:  ADDWF  x1F,W
1A68:  MOVWF  01
1A6A:  MOVLW  00
1A6C:  ADDWFC x20,W
1A6E:  MOVFF  01,FE9
1A72:  MOVWF  FEA
1A74:  BSF    FEF.1
.................... 				channel[c].command_on_hold_seconds=config.ch[c].command_on_hold_time;
1A76:  MOVF   x1C,W
1A78:  MULLW  19
1A7A:  MOVF   FF3,W
1A7C:  CLRF   x20
1A7E:  MOVWF  x1F
1A80:  MOVLW  03
1A82:  ADDWF  x1F,W
1A84:  MOVWF  01
1A86:  MOVLW  00
1A88:  ADDWFC x20,W
1A8A:  MOVWF  03
1A8C:  MOVF   01,W
1A8E:  ADDLW  DA
1A90:  MOVWF  01
1A92:  MOVLW  00
1A94:  ADDWFC 03,F
1A96:  MOVFF  03,120
1A9A:  MOVF   x1C,W
1A9C:  MULLW  24
1A9E:  MOVF   FF3,W
1AA0:  CLRF   x22
1AA2:  MOVWF  x21
1AA4:  MOVLW  1B
1AA6:  ADDWF  x21,W
1AA8:  MOVWF  FE9
1AAA:  MOVLW  00
1AAC:  ADDWFC x22,W
1AAE:  MOVWF  FEA
1AB0:  MOVFF  FEC,03
1AB4:  MOVF   FED,F
1AB6:  MOVFF  FEF,123
1ABA:  MOVFF  120,FEA
1ABE:  MOVFF  01,FE9
1AC2:  MOVFF  03,FEC
1AC6:  MOVF   FED,F
1AC8:  MOVFF  123,FEF
.................... 			} else {
1ACC:  BRA    1B70
.................... 				/* set, so we clear it once countdown has elapsed */
.................... 				if ( 0==channel[c].command_on_hold_seconds ) {
1ACE:  MOVF   x1C,W
1AD0:  MULLW  19
1AD2:  MOVF   FF3,W
1AD4:  CLRF   x20
1AD6:  MOVWF  x1F
1AD8:  MOVLW  03
1ADA:  ADDWF  x1F,W
1ADC:  MOVWF  01
1ADE:  MOVLW  00
1AE0:  ADDWFC x20,W
1AE2:  MOVWF  03
1AE4:  MOVF   01,W
1AE6:  ADDLW  DA
1AE8:  MOVWF  FE9
1AEA:  MOVLW  00
1AEC:  ADDWFC 03,W
1AEE:  MOVWF  FEA
1AF0:  MOVFF  FEC,03
1AF4:  MOVF   FED,F
1AF6:  MOVF   FEF,W
1AF8:  BNZ   1B44
1AFA:  MOVF   03,F
1AFC:  BNZ   1B44
.................... 					/* countdown elapsed, clear the flag and reset the timer */
.................... 					bit_clear(channel[c].state,CH_STATE_BIT_CMD_ON);
1AFE:  MOVF   x1C,W
1B00:  MULLW  19
1B02:  MOVF   FF3,W
1B04:  CLRF   x20
1B06:  MOVWF  x1F
1B08:  MOVLW  DA
1B0A:  ADDWF  x1F,W
1B0C:  MOVWF  01
1B0E:  MOVLW  00
1B10:  ADDWFC x20,W
1B12:  MOVFF  01,FE9
1B16:  MOVWF  FEA
1B18:  BCF    FEF.1
.................... 					channel[c].command_on_seconds=65535;
1B1A:  MOVF   x1C,W
1B1C:  MULLW  19
1B1E:  MOVF   FF3,W
1B20:  CLRF   x20
1B22:  MOVWF  x1F
1B24:  MOVLW  01
1B26:  ADDWF  x1F,W
1B28:  MOVWF  01
1B2A:  MOVLW  00
1B2C:  ADDWFC x20,W
1B2E:  MOVWF  03
1B30:  MOVF   01,W
1B32:  ADDLW  DA
1B34:  MOVWF  FE9
1B36:  MOVLW  00
1B38:  ADDWFC 03,W
1B3A:  MOVWF  FEA
1B3C:  SETF   FEC
1B3E:  MOVF   FED,F
1B40:  SETF   FEF
.................... 				} else {
1B42:  BRA    1B70
.................... 					channel[c].command_on_hold_seconds--;
1B44:  MOVF   x1C,W
1B46:  MULLW  19
1B48:  MOVF   FF3,W
1B4A:  CLRF   x20
1B4C:  MOVWF  x1F
1B4E:  MOVLW  03
1B50:  ADDWF  x1F,W
1B52:  MOVWF  01
1B54:  MOVLW  00
1B56:  ADDWFC x20,W
1B58:  MOVWF  03
1B5A:  MOVF   01,W
1B5C:  ADDLW  DA
1B5E:  MOVWF  FE9
1B60:  MOVLW  00
1B62:  ADDWFC 03,W
1B64:  MOVWF  FEA
1B66:  MOVLW  FF
1B68:  ADDWF  FEF,F
1B6A:  BC    1B70
1B6C:  MOVF   FEE,F
1B6E:  DECF   FED,F
.................... 				}
.................... 			}		
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	/* command off. 65535 disables */
.................... 	if ( 65535 != channel[c].command_off_seconds ) {
1B70:  MOVF   x1C,W
1B72:  MULLW  19
1B74:  MOVF   FF3,W
1B76:  CLRF   x20
1B78:  MOVWF  x1F
1B7A:  MOVLW  05
1B7C:  ADDWF  x1F,W
1B7E:  MOVWF  01
1B80:  MOVLW  00
1B82:  ADDWFC x20,W
1B84:  MOVWF  03
1B86:  MOVF   01,W
1B88:  ADDLW  DA
1B8A:  MOVWF  FE9
1B8C:  MOVLW  00
1B8E:  ADDWFC 03,W
1B90:  MOVWF  FEA
1B92:  MOVFF  FEC,03
1B96:  MOVF   FED,F
1B98:  MOVF   FEF,W
1B9A:  SUBLW  FF
1B9C:  BNZ   1BA4
1B9E:  INCFSZ 03,W
1BA0:  BRA    1BA4
1BA2:  BRA    1D4A
.................... 		if ( channel[c].command_off_seconds > 0 ) {
1BA4:  MOVF   x1C,W
1BA6:  MULLW  19
1BA8:  MOVF   FF3,W
1BAA:  CLRF   x20
1BAC:  MOVWF  x1F
1BAE:  MOVLW  05
1BB0:  ADDWF  x1F,W
1BB2:  MOVWF  01
1BB4:  MOVLW  00
1BB6:  ADDWFC x20,W
1BB8:  MOVWF  03
1BBA:  MOVF   01,W
1BBC:  ADDLW  DA
1BBE:  MOVWF  FE9
1BC0:  MOVLW  00
1BC2:  ADDWFC 03,W
1BC4:  MOVWF  FEA
1BC6:  MOVFF  FEC,120
1BCA:  MOVF   FED,F
1BCC:  MOVFF  FEF,11F
1BD0:  MOVF   x1F,F
1BD2:  BNZ   1BD8
1BD4:  MOVF   x20,F
1BD6:  BZ    1C06
.................... 			/* waiting to power off */
.................... 			channel[c].command_off_seconds--;
1BD8:  MOVF   x1C,W
1BDA:  MULLW  19
1BDC:  MOVF   FF3,W
1BDE:  CLRF   x20
1BE0:  MOVWF  x1F
1BE2:  MOVLW  05
1BE4:  ADDWF  x1F,W
1BE6:  MOVWF  01
1BE8:  MOVLW  00
1BEA:  ADDWFC x20,W
1BEC:  MOVWF  03
1BEE:  MOVF   01,W
1BF0:  ADDLW  DA
1BF2:  MOVWF  FE9
1BF4:  MOVLW  00
1BF6:  ADDWFC 03,W
1BF8:  MOVWF  FEA
1BFA:  MOVLW  FF
1BFC:  ADDWF  FEF,F
1BFE:  BC    1C04
1C00:  MOVF   FEE,F
1C02:  DECF   FED,F
.................... 		} else {
1C04:  BRA    1D4A
.................... 			/* timer at zero, ready to power off or already powered off */
.................... 			if ( ! bit_test(channel[c].state,CH_STATE_BIT_CMD_OFF) ) {
1C06:  MOVF   x1C,W
1C08:  MULLW  19
1C0A:  MOVF   FF3,W
1C0C:  CLRF   x20
1C0E:  MOVWF  x1F
1C10:  MOVLW  DA
1C12:  ADDWF  x1F,W
1C14:  MOVWF  FE9
1C16:  MOVLW  00
1C18:  ADDWFC x20,W
1C1A:  MOVWF  FEA
1C1C:  MOVFF  FEF,121
1C20:  BTFSC  x21.2
1C22:  BRA    1CA8
.................... 				/* not currently set, so we set it and start the countdown */
.................... 				bit_set(channel[c].state,CH_STATE_BIT_CMD_OFF);
1C24:  MOVF   x1C,W
1C26:  MULLW  19
1C28:  MOVF   FF3,W
1C2A:  CLRF   x20
1C2C:  MOVWF  x1F
1C2E:  MOVLW  DA
1C30:  ADDWF  x1F,W
1C32:  MOVWF  01
1C34:  MOVLW  00
1C36:  ADDWFC x20,W
1C38:  MOVFF  01,FE9
1C3C:  MOVWF  FEA
1C3E:  BSF    FEF.2
.................... 				channel[c].command_off_hold_seconds=config.ch[c].command_off_hold_time;
1C40:  MOVF   x1C,W
1C42:  MULLW  19
1C44:  MOVF   FF3,W
1C46:  CLRF   x20
1C48:  MOVWF  x1F
1C4A:  MOVLW  07
1C4C:  ADDWF  x1F,W
1C4E:  MOVWF  01
1C50:  MOVLW  00
1C52:  ADDWFC x20,W
1C54:  MOVWF  03
1C56:  MOVF   01,W
1C58:  ADDLW  DA
1C5A:  MOVWF  01
1C5C:  MOVLW  00
1C5E:  ADDWFC 03,F
1C60:  MOVFF  01,11F
1C64:  MOVFF  03,120
1C68:  MOVF   x1C,W
1C6A:  MULLW  24
1C6C:  MOVF   FF3,W
1C6E:  CLRF   x22
1C70:  MOVWF  x21
1C72:  MOVLW  02
1C74:  ADDWF  x21,W
1C76:  MOVWF  01
1C78:  MOVLW  00
1C7A:  ADDWFC x22,W
1C7C:  MOVWF  03
1C7E:  MOVF   01,W
1C80:  ADDLW  1B
1C82:  MOVWF  FE9
1C84:  MOVLW  00
1C86:  ADDWFC 03,W
1C88:  MOVWF  FEA
1C8A:  MOVFF  FEC,03
1C8E:  MOVF   FED,F
1C90:  MOVFF  FEF,121
1C94:  MOVFF  120,FEA
1C98:  MOVFF  11F,FE9
1C9C:  MOVFF  03,FEC
1CA0:  MOVF   FED,F
1CA2:  MOVFF  121,FEF
.................... 			} else {
1CA6:  BRA    1D4A
.................... 				/* set, so we clear it once countdown has elapsed */
.................... 				if ( 0==channel[c].command_off_hold_seconds ) {
1CA8:  MOVF   x1C,W
1CAA:  MULLW  19
1CAC:  MOVF   FF3,W
1CAE:  CLRF   x20
1CB0:  MOVWF  x1F
1CB2:  MOVLW  07
1CB4:  ADDWF  x1F,W
1CB6:  MOVWF  01
1CB8:  MOVLW  00
1CBA:  ADDWFC x20,W
1CBC:  MOVWF  03
1CBE:  MOVF   01,W
1CC0:  ADDLW  DA
1CC2:  MOVWF  FE9
1CC4:  MOVLW  00
1CC6:  ADDWFC 03,W
1CC8:  MOVWF  FEA
1CCA:  MOVFF  FEC,03
1CCE:  MOVF   FED,F
1CD0:  MOVF   FEF,W
1CD2:  BNZ   1D1E
1CD4:  MOVF   03,F
1CD6:  BNZ   1D1E
.................... 					/* countdown elapsed, clear the flag and reset the timer */
.................... 					bit_clear(channel[c].state,CH_STATE_BIT_CMD_OFF);
1CD8:  MOVF   x1C,W
1CDA:  MULLW  19
1CDC:  MOVF   FF3,W
1CDE:  CLRF   x20
1CE0:  MOVWF  x1F
1CE2:  MOVLW  DA
1CE4:  ADDWF  x1F,W
1CE6:  MOVWF  01
1CE8:  MOVLW  00
1CEA:  ADDWFC x20,W
1CEC:  MOVFF  01,FE9
1CF0:  MOVWF  FEA
1CF2:  BCF    FEF.2
.................... 					channel[c].command_off_seconds=65535;
1CF4:  MOVF   x1C,W
1CF6:  MULLW  19
1CF8:  MOVF   FF3,W
1CFA:  CLRF   x20
1CFC:  MOVWF  x1F
1CFE:  MOVLW  05
1D00:  ADDWF  x1F,W
1D02:  MOVWF  01
1D04:  MOVLW  00
1D06:  ADDWFC x20,W
1D08:  MOVWF  03
1D0A:  MOVF   01,W
1D0C:  ADDLW  DA
1D0E:  MOVWF  FE9
1D10:  MOVLW  00
1D12:  ADDWFC 03,W
1D14:  MOVWF  FEA
1D16:  SETF   FEC
1D18:  MOVF   FED,F
1D1A:  SETF   FEF
.................... 				} else {
1D1C:  BRA    1D4A
.................... 					channel[c].command_off_hold_seconds--;
1D1E:  MOVF   x1C,W
1D20:  MULLW  19
1D22:  MOVF   FF3,W
1D24:  CLRF   x20
1D26:  MOVWF  x1F
1D28:  MOVLW  07
1D2A:  ADDWF  x1F,W
1D2C:  MOVWF  01
1D2E:  MOVLW  00
1D30:  ADDWFC x20,W
1D32:  MOVWF  03
1D34:  MOVF   01,W
1D36:  ADDLW  DA
1D38:  MOVWF  FE9
1D3A:  MOVLW  00
1D3C:  ADDWFC 03,W
1D3E:  MOVWF  FEA
1D40:  MOVLW  FF
1D42:  ADDWF  FEF,F
1D44:  BC    1D4A
1D46:  MOVF   FEE,F
1D48:  DECF   FED,F
.................... 				}
.................... 			}		
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	/* Low Voltage Disconnect. 65535 disables */
.................... 	if ( 65535 != config.ch[c].lvd_disconnect_delay ) {
1D4A:  MOVF   x1C,W
1D4C:  MULLW  24
1D4E:  MOVF   FF3,W
1D50:  CLRF   x20
1D52:  MOVWF  x1F
1D54:  MOVLW  06
1D56:  ADDWF  x1F,W
1D58:  MOVWF  01
1D5A:  MOVLW  00
1D5C:  ADDWFC x20,W
1D5E:  MOVWF  03
1D60:  MOVF   01,W
1D62:  ADDLW  1B
1D64:  MOVWF  FE9
1D66:  MOVLW  00
1D68:  ADDWFC 03,W
1D6A:  MOVWF  FEA
1D6C:  MOVFF  FEC,03
1D70:  MOVF   FED,F
1D72:  MOVF   FEF,W
1D74:  SUBLW  FF
1D76:  BNZ   1D7E
1D78:  INCFSZ 03,W
1D7A:  BRA    1D7E
1D7C:  BRA    1FDC
1D7E:  CLRF   19
1D80:  BTFSC  FF2.7
1D82:  BSF    19.7
1D84:  BCF    FF2.7
.................... 		adc=adc_get(0);
1D86:  CLRF   x2F
1D88:  MOVLB  0
1D8A:  CALL   0594
1D8E:  BTFSC  19.7
1D90:  BSF    FF2.7
1D92:  MOVFF  02,11E
1D96:  MOVFF  01,11D
.................... 
.................... 		if ( adc > config.ch[c].lvd_reconnect_adc ) {
1D9A:  MOVLB  1
1D9C:  MOVF   x1C,W
1D9E:  MULLW  24
1DA0:  MOVF   FF3,W
1DA2:  CLRF   x20
1DA4:  MOVWF  x1F
1DA6:  MOVLW  08
1DA8:  ADDWF  x1F,W
1DAA:  MOVWF  01
1DAC:  MOVLW  00
1DAE:  ADDWFC x20,W
1DB0:  MOVWF  03
1DB2:  MOVF   01,W
1DB4:  ADDLW  1B
1DB6:  MOVWF  FE9
1DB8:  MOVLW  00
1DBA:  ADDWFC 03,W
1DBC:  MOVWF  FEA
1DBE:  MOVFF  FEC,03
1DC2:  MOVF   FED,F
1DC4:  MOVFF  FEF,01
1DC8:  MOVF   03,W
1DCA:  SUBWF  x1E,W
1DCC:  BNC   1E56
1DCE:  BNZ   1DD6
1DD0:  MOVF   x1D,W
1DD2:  SUBWF  01,W
1DD4:  BC    1E56
.................... 			if ( channel[c].lvd_reconnect_delay_seconds > 0 ) {
1DD6:  MOVF   x1C,W
1DD8:  MULLW  19
1DDA:  MOVF   FF3,W
1DDC:  CLRF   x20
1DDE:  MOVWF  x1F
1DE0:  MOVLW  0B
1DE2:  ADDWF  x1F,W
1DE4:  MOVWF  01
1DE6:  MOVLW  00
1DE8:  ADDWFC x20,W
1DEA:  MOVWF  03
1DEC:  MOVF   01,W
1DEE:  ADDLW  DA
1DF0:  MOVWF  FE9
1DF2:  MOVLW  00
1DF4:  ADDWFC 03,W
1DF6:  MOVWF  FEA
1DF8:  MOVFF  FEC,120
1DFC:  MOVF   FED,F
1DFE:  MOVFF  FEF,11F
1E02:  MOVF   x1F,F
1E04:  BNZ   1E0A
1E06:  MOVF   x20,F
1E08:  BZ    1E38
.................... 				channel[c].lvd_reconnect_delay_seconds--;
1E0A:  MOVF   x1C,W
1E0C:  MULLW  19
1E0E:  MOVF   FF3,W
1E10:  CLRF   x20
1E12:  MOVWF  x1F
1E14:  MOVLW  0B
1E16:  ADDWF  x1F,W
1E18:  MOVWF  01
1E1A:  MOVLW  00
1E1C:  ADDWFC x20,W
1E1E:  MOVWF  03
1E20:  MOVF   01,W
1E22:  ADDLW  DA
1E24:  MOVWF  FE9
1E26:  MOVLW  00
1E28:  ADDWFC 03,W
1E2A:  MOVWF  FEA
1E2C:  MOVLW  FF
1E2E:  ADDWF  FEF,F
1E30:  BC    1E36
1E32:  MOVF   FEE,F
1E34:  DECF   FED,F
.................... 			} else {
1E36:  BRA    1E54
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_LVD);
1E38:  MOVF   x1C,W
1E3A:  MULLW  19
1E3C:  MOVF   FF3,W
1E3E:  CLRF   x20
1E40:  MOVWF  x1F
1E42:  MOVLW  DA
1E44:  ADDWF  x1F,W
1E46:  MOVWF  01
1E48:  MOVLW  00
1E4A:  ADDWFC x20,W
1E4C:  MOVFF  01,FE9
1E50:  MOVWF  FEA
1E52:  BCF    FEF.3
.................... 			}
.................... 		} else {
1E54:  BRA    1EBC
.................... 			channel[c].lvd_reconnect_delay_seconds=config.ch[c].lvd_reconnect_delay;
1E56:  MOVF   x1C,W
1E58:  MULLW  19
1E5A:  MOVF   FF3,W
1E5C:  CLRF   x20
1E5E:  MOVWF  x1F
1E60:  MOVLW  0B
1E62:  ADDWF  x1F,W
1E64:  MOVWF  01
1E66:  MOVLW  00
1E68:  ADDWFC x20,W
1E6A:  MOVWF  03
1E6C:  MOVF   01,W
1E6E:  ADDLW  DA
1E70:  MOVWF  01
1E72:  MOVLW  00
1E74:  ADDWFC 03,F
1E76:  MOVFF  01,11F
1E7A:  MOVFF  03,120
1E7E:  MOVF   x1C,W
1E80:  MULLW  24
1E82:  MOVF   FF3,W
1E84:  CLRF   x22
1E86:  MOVWF  x21
1E88:  MOVLW  0A
1E8A:  ADDWF  x21,W
1E8C:  MOVWF  01
1E8E:  MOVLW  00
1E90:  ADDWFC x22,W
1E92:  MOVWF  03
1E94:  MOVF   01,W
1E96:  ADDLW  1B
1E98:  MOVWF  FE9
1E9A:  MOVLW  00
1E9C:  ADDWFC 03,W
1E9E:  MOVWF  FEA
1EA0:  MOVFF  FEC,03
1EA4:  MOVF   FED,F
1EA6:  MOVFF  FEF,121
1EAA:  MOVFF  120,FEA
1EAE:  MOVFF  11F,FE9
1EB2:  MOVFF  03,FEC
1EB6:  MOVF   FED,F
1EB8:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc < config.ch[c].lvd_disconnect_adc ) {
1EBC:  MOVF   x1C,W
1EBE:  MULLW  24
1EC0:  MOVF   FF3,W
1EC2:  CLRF   x20
1EC4:  MOVWF  x1F
1EC6:  MOVLW  04
1EC8:  ADDWF  x1F,W
1ECA:  MOVWF  01
1ECC:  MOVLW  00
1ECE:  ADDWFC x20,W
1ED0:  MOVWF  03
1ED2:  MOVF   01,W
1ED4:  ADDLW  1B
1ED6:  MOVWF  FE9
1ED8:  MOVLW  00
1EDA:  ADDWFC 03,W
1EDC:  MOVWF  FEA
1EDE:  MOVFF  FEC,03
1EE2:  MOVF   FED,F
1EE4:  MOVFF  FEF,01
1EE8:  MOVF   x1E,W
1EEA:  SUBWF  03,W
1EEC:  BNC   1F76
1EEE:  BNZ   1EF6
1EF0:  MOVF   01,W
1EF2:  SUBWF  x1D,W
1EF4:  BC    1F76
.................... 			if ( channel[c].lvd_disconnect_delay_seconds > 0 ) {
1EF6:  MOVF   x1C,W
1EF8:  MULLW  19
1EFA:  MOVF   FF3,W
1EFC:  CLRF   x20
1EFE:  MOVWF  x1F
1F00:  MOVLW  09
1F02:  ADDWF  x1F,W
1F04:  MOVWF  01
1F06:  MOVLW  00
1F08:  ADDWFC x20,W
1F0A:  MOVWF  03
1F0C:  MOVF   01,W
1F0E:  ADDLW  DA
1F10:  MOVWF  FE9
1F12:  MOVLW  00
1F14:  ADDWFC 03,W
1F16:  MOVWF  FEA
1F18:  MOVFF  FEC,120
1F1C:  MOVF   FED,F
1F1E:  MOVFF  FEF,11F
1F22:  MOVF   x1F,F
1F24:  BNZ   1F2A
1F26:  MOVF   x20,F
1F28:  BZ    1F58
.................... 				channel[c].lvd_disconnect_delay_seconds--;
1F2A:  MOVF   x1C,W
1F2C:  MULLW  19
1F2E:  MOVF   FF3,W
1F30:  CLRF   x20
1F32:  MOVWF  x1F
1F34:  MOVLW  09
1F36:  ADDWF  x1F,W
1F38:  MOVWF  01
1F3A:  MOVLW  00
1F3C:  ADDWFC x20,W
1F3E:  MOVWF  03
1F40:  MOVF   01,W
1F42:  ADDLW  DA
1F44:  MOVWF  FE9
1F46:  MOVLW  00
1F48:  ADDWFC 03,W
1F4A:  MOVWF  FEA
1F4C:  MOVLW  FF
1F4E:  ADDWF  FEF,F
1F50:  BC    1F56
1F52:  MOVF   FEE,F
1F54:  DECF   FED,F
.................... 			} else {
1F56:  BRA    1F74
.................... 				bit_set(channel[c].state,CH_STATE_BIT_LVD);
1F58:  MOVF   x1C,W
1F5A:  MULLW  19
1F5C:  MOVF   FF3,W
1F5E:  CLRF   x20
1F60:  MOVWF  x1F
1F62:  MOVLW  DA
1F64:  ADDWF  x1F,W
1F66:  MOVWF  01
1F68:  MOVLW  00
1F6A:  ADDWFC x20,W
1F6C:  MOVFF  01,FE9
1F70:  MOVWF  FEA
1F72:  BSF    FEF.3
.................... 			}
.................... 		} else {
1F74:  BRA    1FDC
.................... 			channel[c].lvd_disconnect_delay_seconds=config.ch[c].lvd_disconnect_delay;
1F76:  MOVF   x1C,W
1F78:  MULLW  19
1F7A:  MOVF   FF3,W
1F7C:  CLRF   x20
1F7E:  MOVWF  x1F
1F80:  MOVLW  09
1F82:  ADDWF  x1F,W
1F84:  MOVWF  01
1F86:  MOVLW  00
1F88:  ADDWFC x20,W
1F8A:  MOVWF  03
1F8C:  MOVF   01,W
1F8E:  ADDLW  DA
1F90:  MOVWF  01
1F92:  MOVLW  00
1F94:  ADDWFC 03,F
1F96:  MOVFF  01,11F
1F9A:  MOVFF  03,120
1F9E:  MOVF   x1C,W
1FA0:  MULLW  24
1FA2:  MOVF   FF3,W
1FA4:  CLRF   x22
1FA6:  MOVWF  x21
1FA8:  MOVLW  06
1FAA:  ADDWF  x21,W
1FAC:  MOVWF  01
1FAE:  MOVLW  00
1FB0:  ADDWFC x22,W
1FB2:  MOVWF  03
1FB4:  MOVF   01,W
1FB6:  ADDLW  1B
1FB8:  MOVWF  FE9
1FBA:  MOVLW  00
1FBC:  ADDWFC 03,W
1FBE:  MOVWF  FEA
1FC0:  MOVFF  FEC,03
1FC4:  MOVF   FED,F
1FC6:  MOVFF  FEF,121
1FCA:  MOVFF  120,FEA
1FCE:  MOVFF  11F,FE9
1FD2:  MOVFF  03,FEC
1FD6:  MOVF   FED,F
1FD8:  MOVFF  121,FEF
.................... 		}
.................... 	}
.................... 
.................... 	/* High Voltage Disconnect. 65535 disables */
.................... 	if ( 65535 != config.ch[c].hvd_disconnect_delay ) {
1FDC:  MOVF   x1C,W
1FDE:  MULLW  24
1FE0:  MOVF   FF3,W
1FE2:  CLRF   x20
1FE4:  MOVWF  x1F
1FE6:  MOVLW  0E
1FE8:  ADDWF  x1F,W
1FEA:  MOVWF  01
1FEC:  MOVLW  00
1FEE:  ADDWFC x20,W
1FF0:  MOVWF  03
1FF2:  MOVF   01,W
1FF4:  ADDLW  1B
1FF6:  MOVWF  FE9
1FF8:  MOVLW  00
1FFA:  ADDWFC 03,W
1FFC:  MOVWF  FEA
1FFE:  MOVFF  FEC,03
2002:  MOVF   FED,F
2004:  MOVF   FEF,W
2006:  SUBLW  FF
2008:  BNZ   2010
200A:  INCFSZ 03,W
200C:  BRA    2010
200E:  BRA    226E
2010:  CLRF   19
2012:  BTFSC  FF2.7
2014:  BSF    19.7
2016:  BCF    FF2.7
.................... 		adc=adc_get(0);
2018:  CLRF   x2F
201A:  MOVLB  0
201C:  CALL   0594
2020:  BTFSC  19.7
2022:  BSF    FF2.7
2024:  MOVFF  02,11E
2028:  MOVFF  01,11D
.................... 
.................... 		if ( adc < config.ch[c].hvd_reconnect_adc ) {
202C:  MOVLB  1
202E:  MOVF   x1C,W
2030:  MULLW  24
2032:  MOVF   FF3,W
2034:  CLRF   x20
2036:  MOVWF  x1F
2038:  MOVLW  10
203A:  ADDWF  x1F,W
203C:  MOVWF  01
203E:  MOVLW  00
2040:  ADDWFC x20,W
2042:  MOVWF  03
2044:  MOVF   01,W
2046:  ADDLW  1B
2048:  MOVWF  FE9
204A:  MOVLW  00
204C:  ADDWFC 03,W
204E:  MOVWF  FEA
2050:  MOVFF  FEC,03
2054:  MOVF   FED,F
2056:  MOVFF  FEF,01
205A:  MOVF   x1E,W
205C:  SUBWF  03,W
205E:  BNC   20E8
2060:  BNZ   2068
2062:  MOVF   01,W
2064:  SUBWF  x1D,W
2066:  BC    20E8
.................... 			if ( channel[c].hvd_reconnect_delay_seconds > 0 ) {
2068:  MOVF   x1C,W
206A:  MULLW  19
206C:  MOVF   FF3,W
206E:  CLRF   x20
2070:  MOVWF  x1F
2072:  MOVLW  0F
2074:  ADDWF  x1F,W
2076:  MOVWF  01
2078:  MOVLW  00
207A:  ADDWFC x20,W
207C:  MOVWF  03
207E:  MOVF   01,W
2080:  ADDLW  DA
2082:  MOVWF  FE9
2084:  MOVLW  00
2086:  ADDWFC 03,W
2088:  MOVWF  FEA
208A:  MOVFF  FEC,120
208E:  MOVF   FED,F
2090:  MOVFF  FEF,11F
2094:  MOVF   x1F,F
2096:  BNZ   209C
2098:  MOVF   x20,F
209A:  BZ    20CA
.................... 				channel[c].hvd_reconnect_delay_seconds--;
209C:  MOVF   x1C,W
209E:  MULLW  19
20A0:  MOVF   FF3,W
20A2:  CLRF   x20
20A4:  MOVWF  x1F
20A6:  MOVLW  0F
20A8:  ADDWF  x1F,W
20AA:  MOVWF  01
20AC:  MOVLW  00
20AE:  ADDWFC x20,W
20B0:  MOVWF  03
20B2:  MOVF   01,W
20B4:  ADDLW  DA
20B6:  MOVWF  FE9
20B8:  MOVLW  00
20BA:  ADDWFC 03,W
20BC:  MOVWF  FEA
20BE:  MOVLW  FF
20C0:  ADDWF  FEF,F
20C2:  BC    20C8
20C4:  MOVF   FEE,F
20C6:  DECF   FED,F
.................... 			} else {
20C8:  BRA    20E6
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_HVD);
20CA:  MOVF   x1C,W
20CC:  MULLW  19
20CE:  MOVF   FF3,W
20D0:  CLRF   x20
20D2:  MOVWF  x1F
20D4:  MOVLW  DA
20D6:  ADDWF  x1F,W
20D8:  MOVWF  01
20DA:  MOVLW  00
20DC:  ADDWFC x20,W
20DE:  MOVFF  01,FE9
20E2:  MOVWF  FEA
20E4:  BCF    FEF.4
.................... 			}
.................... 		} else {
20E6:  BRA    214E
.................... 			channel[c].hvd_reconnect_delay_seconds=config.ch[c].hvd_reconnect_delay;
20E8:  MOVF   x1C,W
20EA:  MULLW  19
20EC:  MOVF   FF3,W
20EE:  CLRF   x20
20F0:  MOVWF  x1F
20F2:  MOVLW  0F
20F4:  ADDWF  x1F,W
20F6:  MOVWF  01
20F8:  MOVLW  00
20FA:  ADDWFC x20,W
20FC:  MOVWF  03
20FE:  MOVF   01,W
2100:  ADDLW  DA
2102:  MOVWF  01
2104:  MOVLW  00
2106:  ADDWFC 03,F
2108:  MOVFF  01,11F
210C:  MOVFF  03,120
2110:  MOVF   x1C,W
2112:  MULLW  24
2114:  MOVF   FF3,W
2116:  CLRF   x22
2118:  MOVWF  x21
211A:  MOVLW  12
211C:  ADDWF  x21,W
211E:  MOVWF  01
2120:  MOVLW  00
2122:  ADDWFC x22,W
2124:  MOVWF  03
2126:  MOVF   01,W
2128:  ADDLW  1B
212A:  MOVWF  FE9
212C:  MOVLW  00
212E:  ADDWFC 03,W
2130:  MOVWF  FEA
2132:  MOVFF  FEC,03
2136:  MOVF   FED,F
2138:  MOVFF  FEF,121
213C:  MOVFF  120,FEA
2140:  MOVFF  11F,FE9
2144:  MOVFF  03,FEC
2148:  MOVF   FED,F
214A:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc > config.ch[c].hvd_disconnect_adc ) {
214E:  MOVF   x1C,W
2150:  MULLW  24
2152:  MOVF   FF3,W
2154:  CLRF   x20
2156:  MOVWF  x1F
2158:  MOVLW  0C
215A:  ADDWF  x1F,W
215C:  MOVWF  01
215E:  MOVLW  00
2160:  ADDWFC x20,W
2162:  MOVWF  03
2164:  MOVF   01,W
2166:  ADDLW  1B
2168:  MOVWF  FE9
216A:  MOVLW  00
216C:  ADDWFC 03,W
216E:  MOVWF  FEA
2170:  MOVFF  FEC,03
2174:  MOVF   FED,F
2176:  MOVFF  FEF,01
217A:  MOVF   03,W
217C:  SUBWF  x1E,W
217E:  BNC   2208
2180:  BNZ   2188
2182:  MOVF   x1D,W
2184:  SUBWF  01,W
2186:  BC    2208
.................... 			if ( channel[c].hvd_disconnect_delay_seconds > 0 ) {
2188:  MOVF   x1C,W
218A:  MULLW  19
218C:  MOVF   FF3,W
218E:  CLRF   x20
2190:  MOVWF  x1F
2192:  MOVLW  0D
2194:  ADDWF  x1F,W
2196:  MOVWF  01
2198:  MOVLW  00
219A:  ADDWFC x20,W
219C:  MOVWF  03
219E:  MOVF   01,W
21A0:  ADDLW  DA
21A2:  MOVWF  FE9
21A4:  MOVLW  00
21A6:  ADDWFC 03,W
21A8:  MOVWF  FEA
21AA:  MOVFF  FEC,120
21AE:  MOVF   FED,F
21B0:  MOVFF  FEF,11F
21B4:  MOVF   x1F,F
21B6:  BNZ   21BC
21B8:  MOVF   x20,F
21BA:  BZ    21EA
.................... 				channel[c].hvd_disconnect_delay_seconds--;
21BC:  MOVF   x1C,W
21BE:  MULLW  19
21C0:  MOVF   FF3,W
21C2:  CLRF   x20
21C4:  MOVWF  x1F
21C6:  MOVLW  0D
21C8:  ADDWF  x1F,W
21CA:  MOVWF  01
21CC:  MOVLW  00
21CE:  ADDWFC x20,W
21D0:  MOVWF  03
21D2:  MOVF   01,W
21D4:  ADDLW  DA
21D6:  MOVWF  FE9
21D8:  MOVLW  00
21DA:  ADDWFC 03,W
21DC:  MOVWF  FEA
21DE:  MOVLW  FF
21E0:  ADDWF  FEF,F
21E2:  BC    21E8
21E4:  MOVF   FEE,F
21E6:  DECF   FED,F
.................... 			} else {
21E8:  BRA    2206
.................... 				bit_set(channel[c].state,CH_STATE_BIT_HVD);
21EA:  MOVF   x1C,W
21EC:  MULLW  19
21EE:  MOVF   FF3,W
21F0:  CLRF   x20
21F2:  MOVWF  x1F
21F4:  MOVLW  DA
21F6:  ADDWF  x1F,W
21F8:  MOVWF  01
21FA:  MOVLW  00
21FC:  ADDWFC x20,W
21FE:  MOVFF  01,FE9
2202:  MOVWF  FEA
2204:  BSF    FEF.4
.................... 			}
.................... 		} else {
2206:  BRA    226E
.................... 			channel[c].hvd_disconnect_delay_seconds=config.ch[c].hvd_disconnect_delay;
2208:  MOVF   x1C,W
220A:  MULLW  19
220C:  MOVF   FF3,W
220E:  CLRF   x20
2210:  MOVWF  x1F
2212:  MOVLW  0D
2214:  ADDWF  x1F,W
2216:  MOVWF  01
2218:  MOVLW  00
221A:  ADDWFC x20,W
221C:  MOVWF  03
221E:  MOVF   01,W
2220:  ADDLW  DA
2222:  MOVWF  01
2224:  MOVLW  00
2226:  ADDWFC 03,F
2228:  MOVFF  01,11F
222C:  MOVFF  03,120
2230:  MOVF   x1C,W
2232:  MULLW  24
2234:  MOVF   FF3,W
2236:  CLRF   x22
2238:  MOVWF  x21
223A:  MOVLW  0E
223C:  ADDWF  x21,W
223E:  MOVWF  01
2240:  MOVLW  00
2242:  ADDWFC x22,W
2244:  MOVWF  03
2246:  MOVF   01,W
2248:  ADDLW  1B
224A:  MOVWF  FE9
224C:  MOVLW  00
224E:  ADDWFC 03,W
2250:  MOVWF  FEA
2252:  MOVFF  FEC,03
2256:  MOVF   FED,F
2258:  MOVFF  FEF,121
225C:  MOVFF  120,FEA
2260:  MOVFF  11F,FE9
2264:  MOVFF  03,FEC
2268:  MOVF   FED,F
226A:  MOVFF  121,FEF
.................... 		}
.................... 	}
.................... 
.................... 	/* Low Temperature Disconnect. 65535 disables */
.................... 	if ( 65535 != config.ch[c].ltd_disconnect_delay ) {
226E:  MOVF   x1C,W
2270:  MULLW  24
2272:  MOVF   FF3,W
2274:  CLRF   x20
2276:  MOVWF  x1F
2278:  MOVLW  16
227A:  ADDWF  x1F,W
227C:  MOVWF  01
227E:  MOVLW  00
2280:  ADDWFC x20,W
2282:  MOVWF  03
2284:  MOVF   01,W
2286:  ADDLW  1B
2288:  MOVWF  FE9
228A:  MOVLW  00
228C:  ADDWFC 03,W
228E:  MOVWF  FEA
2290:  MOVFF  FEC,03
2294:  MOVF   FED,F
2296:  MOVF   FEF,W
2298:  SUBLW  FF
229A:  BNZ   22A2
229C:  INCFSZ 03,W
229E:  BRA    22A2
22A0:  BRA    2502
22A2:  CLRF   19
22A4:  BTFSC  FF2.7
22A6:  BSF    19.7
22A8:  BCF    FF2.7
.................... 		adc=adc_get(1);
22AA:  MOVLW  01
22AC:  MOVWF  x2F
22AE:  MOVLB  0
22B0:  CALL   0594
22B4:  BTFSC  19.7
22B6:  BSF    FF2.7
22B8:  MOVFF  02,11E
22BC:  MOVFF  01,11D
.................... 
.................... 		if ( adc < config.ch[c].ltd_reconnect_adc ) {
22C0:  MOVLB  1
22C2:  MOVF   x1C,W
22C4:  MULLW  24
22C6:  MOVF   FF3,W
22C8:  CLRF   x20
22CA:  MOVWF  x1F
22CC:  MOVLW  18
22CE:  ADDWF  x1F,W
22D0:  MOVWF  01
22D2:  MOVLW  00
22D4:  ADDWFC x20,W
22D6:  MOVWF  03
22D8:  MOVF   01,W
22DA:  ADDLW  1B
22DC:  MOVWF  FE9
22DE:  MOVLW  00
22E0:  ADDWFC 03,W
22E2:  MOVWF  FEA
22E4:  MOVFF  FEC,03
22E8:  MOVF   FED,F
22EA:  MOVFF  FEF,01
22EE:  MOVF   x1E,W
22F0:  SUBWF  03,W
22F2:  BNC   237C
22F4:  BNZ   22FC
22F6:  MOVF   01,W
22F8:  SUBWF  x1D,W
22FA:  BC    237C
.................... 			/* above reconnect temperature */
.................... 			if ( channel[c].ltd_reconnect_delay_seconds > 0 ) {
22FC:  MOVF   x1C,W
22FE:  MULLW  19
2300:  MOVF   FF3,W
2302:  CLRF   x20
2304:  MOVWF  x1F
2306:  MOVLW  13
2308:  ADDWF  x1F,W
230A:  MOVWF  01
230C:  MOVLW  00
230E:  ADDWFC x20,W
2310:  MOVWF  03
2312:  MOVF   01,W
2314:  ADDLW  DA
2316:  MOVWF  FE9
2318:  MOVLW  00
231A:  ADDWFC 03,W
231C:  MOVWF  FEA
231E:  MOVFF  FEC,120
2322:  MOVF   FED,F
2324:  MOVFF  FEF,11F
2328:  MOVF   x1F,F
232A:  BNZ   2330
232C:  MOVF   x20,F
232E:  BZ    235E
.................... 				channel[c].ltd_reconnect_delay_seconds--;
2330:  MOVF   x1C,W
2332:  MULLW  19
2334:  MOVF   FF3,W
2336:  CLRF   x20
2338:  MOVWF  x1F
233A:  MOVLW  13
233C:  ADDWF  x1F,W
233E:  MOVWF  01
2340:  MOVLW  00
2342:  ADDWFC x20,W
2344:  MOVWF  03
2346:  MOVF   01,W
2348:  ADDLW  DA
234A:  MOVWF  FE9
234C:  MOVLW  00
234E:  ADDWFC 03,W
2350:  MOVWF  FEA
2352:  MOVLW  FF
2354:  ADDWF  FEF,F
2356:  BC    235C
2358:  MOVF   FEE,F
235A:  DECF   FED,F
.................... 			} else {
235C:  BRA    237A
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_LTD);
235E:  MOVF   x1C,W
2360:  MULLW  19
2362:  MOVF   FF3,W
2364:  CLRF   x20
2366:  MOVWF  x1F
2368:  MOVLW  DA
236A:  ADDWF  x1F,W
236C:  MOVWF  01
236E:  MOVLW  00
2370:  ADDWFC x20,W
2372:  MOVFF  01,FE9
2376:  MOVWF  FEA
2378:  BCF    FEF.5
.................... 			}
.................... 		} else {
237A:  BRA    23E2
.................... 			channel[c].ltd_reconnect_delay_seconds=config.ch[c].ltd_reconnect_delay;
237C:  MOVF   x1C,W
237E:  MULLW  19
2380:  MOVF   FF3,W
2382:  CLRF   x20
2384:  MOVWF  x1F
2386:  MOVLW  13
2388:  ADDWF  x1F,W
238A:  MOVWF  01
238C:  MOVLW  00
238E:  ADDWFC x20,W
2390:  MOVWF  03
2392:  MOVF   01,W
2394:  ADDLW  DA
2396:  MOVWF  01
2398:  MOVLW  00
239A:  ADDWFC 03,F
239C:  MOVFF  01,11F
23A0:  MOVFF  03,120
23A4:  MOVF   x1C,W
23A6:  MULLW  24
23A8:  MOVF   FF3,W
23AA:  CLRF   x22
23AC:  MOVWF  x21
23AE:  MOVLW  1A
23B0:  ADDWF  x21,W
23B2:  MOVWF  01
23B4:  MOVLW  00
23B6:  ADDWFC x22,W
23B8:  MOVWF  03
23BA:  MOVF   01,W
23BC:  ADDLW  1B
23BE:  MOVWF  FE9
23C0:  MOVLW  00
23C2:  ADDWFC 03,W
23C4:  MOVWF  FEA
23C6:  MOVFF  FEC,03
23CA:  MOVF   FED,F
23CC:  MOVFF  FEF,121
23D0:  MOVFF  120,FEA
23D4:  MOVFF  11F,FE9
23D8:  MOVFF  03,FEC
23DC:  MOVF   FED,F
23DE:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc > config.ch[c].ltd_disconnect_adc ) {
23E2:  MOVF   x1C,W
23E4:  MULLW  24
23E6:  MOVF   FF3,W
23E8:  CLRF   x20
23EA:  MOVWF  x1F
23EC:  MOVLW  14
23EE:  ADDWF  x1F,W
23F0:  MOVWF  01
23F2:  MOVLW  00
23F4:  ADDWFC x20,W
23F6:  MOVWF  03
23F8:  MOVF   01,W
23FA:  ADDLW  1B
23FC:  MOVWF  FE9
23FE:  MOVLW  00
2400:  ADDWFC 03,W
2402:  MOVWF  FEA
2404:  MOVFF  FEC,03
2408:  MOVF   FED,F
240A:  MOVFF  FEF,01
240E:  MOVF   03,W
2410:  SUBWF  x1E,W
2412:  BNC   249C
2414:  BNZ   241C
2416:  MOVF   x1D,W
2418:  SUBWF  01,W
241A:  BC    249C
.................... 			/* below disconnect temperature */
.................... 			if ( channel[c].ltd_disconnect_delay_seconds > 0 ) {
241C:  MOVF   x1C,W
241E:  MULLW  19
2420:  MOVF   FF3,W
2422:  CLRF   x20
2424:  MOVWF  x1F
2426:  MOVLW  11
2428:  ADDWF  x1F,W
242A:  MOVWF  01
242C:  MOVLW  00
242E:  ADDWFC x20,W
2430:  MOVWF  03
2432:  MOVF   01,W
2434:  ADDLW  DA
2436:  MOVWF  FE9
2438:  MOVLW  00
243A:  ADDWFC 03,W
243C:  MOVWF  FEA
243E:  MOVFF  FEC,120
2442:  MOVF   FED,F
2444:  MOVFF  FEF,11F
2448:  MOVF   x1F,F
244A:  BNZ   2450
244C:  MOVF   x20,F
244E:  BZ    247E
.................... 				channel[c].ltd_disconnect_delay_seconds--;
2450:  MOVF   x1C,W
2452:  MULLW  19
2454:  MOVF   FF3,W
2456:  CLRF   x20
2458:  MOVWF  x1F
245A:  MOVLW  11
245C:  ADDWF  x1F,W
245E:  MOVWF  01
2460:  MOVLW  00
2462:  ADDWFC x20,W
2464:  MOVWF  03
2466:  MOVF   01,W
2468:  ADDLW  DA
246A:  MOVWF  FE9
246C:  MOVLW  00
246E:  ADDWFC 03,W
2470:  MOVWF  FEA
2472:  MOVLW  FF
2474:  ADDWF  FEF,F
2476:  BC    247C
2478:  MOVF   FEE,F
247A:  DECF   FED,F
.................... 			} else {
247C:  BRA    249A
.................... 				bit_set(channel[c].state,CH_STATE_BIT_LTD);
247E:  MOVF   x1C,W
2480:  MULLW  19
2482:  MOVF   FF3,W
2484:  CLRF   x20
2486:  MOVWF  x1F
2488:  MOVLW  DA
248A:  ADDWF  x1F,W
248C:  MOVWF  01
248E:  MOVLW  00
2490:  ADDWFC x20,W
2492:  MOVFF  01,FE9
2496:  MOVWF  FEA
2498:  BSF    FEF.5
.................... 			}
.................... 		} else {
249A:  BRA    2502
.................... 			channel[c].ltd_disconnect_delay_seconds=config.ch[c].ltd_disconnect_delay;
249C:  MOVF   x1C,W
249E:  MULLW  19
24A0:  MOVF   FF3,W
24A2:  CLRF   x20
24A4:  MOVWF  x1F
24A6:  MOVLW  11
24A8:  ADDWF  x1F,W
24AA:  MOVWF  01
24AC:  MOVLW  00
24AE:  ADDWFC x20,W
24B0:  MOVWF  03
24B2:  MOVF   01,W
24B4:  ADDLW  DA
24B6:  MOVWF  01
24B8:  MOVLW  00
24BA:  ADDWFC 03,F
24BC:  MOVFF  01,11F
24C0:  MOVFF  03,120
24C4:  MOVF   x1C,W
24C6:  MULLW  24
24C8:  MOVF   FF3,W
24CA:  CLRF   x22
24CC:  MOVWF  x21
24CE:  MOVLW  16
24D0:  ADDWF  x21,W
24D2:  MOVWF  01
24D4:  MOVLW  00
24D6:  ADDWFC x22,W
24D8:  MOVWF  03
24DA:  MOVF   01,W
24DC:  ADDLW  1B
24DE:  MOVWF  FE9
24E0:  MOVLW  00
24E2:  ADDWFC 03,W
24E4:  MOVWF  FEA
24E6:  MOVFF  FEC,03
24EA:  MOVF   FED,F
24EC:  MOVFF  FEF,121
24F0:  MOVFF  120,FEA
24F4:  MOVFF  11F,FE9
24F8:  MOVFF  03,FEC
24FC:  MOVF   FED,F
24FE:  MOVFF  121,FEF
.................... 		}
.................... 	}
.................... 
.................... 	/* High Temperature Disconnect. 65535 disables */
.................... 	if ( 65535 != config.ch[c].htd_disconnect_delay ) {
2502:  MOVF   x1C,W
2504:  MULLW  24
2506:  MOVF   FF3,W
2508:  CLRF   x20
250A:  MOVWF  x1F
250C:  MOVLW  1E
250E:  ADDWF  x1F,W
2510:  MOVWF  01
2512:  MOVLW  00
2514:  ADDWFC x20,W
2516:  MOVWF  03
2518:  MOVF   01,W
251A:  ADDLW  1B
251C:  MOVWF  FE9
251E:  MOVLW  00
2520:  ADDWFC 03,W
2522:  MOVWF  FEA
2524:  MOVFF  FEC,03
2528:  MOVF   FED,F
252A:  MOVF   FEF,W
252C:  SUBLW  FF
252E:  BNZ   2536
2530:  INCFSZ 03,W
2532:  BRA    2536
2534:  BRA    2796
2536:  CLRF   19
2538:  BTFSC  FF2.7
253A:  BSF    19.7
253C:  BCF    FF2.7
.................... 		adc=adc_get(1);
253E:  MOVLW  01
2540:  MOVWF  x2F
2542:  MOVLB  0
2544:  CALL   0594
2548:  BTFSC  19.7
254A:  BSF    FF2.7
254C:  MOVFF  02,11E
2550:  MOVFF  01,11D
.................... 
.................... 		if ( adc > config.ch[c].htd_reconnect_adc ) {
2554:  MOVLB  1
2556:  MOVF   x1C,W
2558:  MULLW  24
255A:  MOVF   FF3,W
255C:  CLRF   x20
255E:  MOVWF  x1F
2560:  MOVLW  20
2562:  ADDWF  x1F,W
2564:  MOVWF  01
2566:  MOVLW  00
2568:  ADDWFC x20,W
256A:  MOVWF  03
256C:  MOVF   01,W
256E:  ADDLW  1B
2570:  MOVWF  FE9
2572:  MOVLW  00
2574:  ADDWFC 03,W
2576:  MOVWF  FEA
2578:  MOVFF  FEC,03
257C:  MOVF   FED,F
257E:  MOVFF  FEF,01
2582:  MOVF   03,W
2584:  SUBWF  x1E,W
2586:  BNC   2610
2588:  BNZ   2590
258A:  MOVF   x1D,W
258C:  SUBWF  01,W
258E:  BC    2610
.................... 			if ( channel[c].htd_reconnect_delay_seconds > 0 ) {
2590:  MOVF   x1C,W
2592:  MULLW  19
2594:  MOVF   FF3,W
2596:  CLRF   x20
2598:  MOVWF  x1F
259A:  MOVLW  17
259C:  ADDWF  x1F,W
259E:  MOVWF  01
25A0:  MOVLW  00
25A2:  ADDWFC x20,W
25A4:  MOVWF  03
25A6:  MOVF   01,W
25A8:  ADDLW  DA
25AA:  MOVWF  FE9
25AC:  MOVLW  00
25AE:  ADDWFC 03,W
25B0:  MOVWF  FEA
25B2:  MOVFF  FEC,120
25B6:  MOVF   FED,F
25B8:  MOVFF  FEF,11F
25BC:  MOVF   x1F,F
25BE:  BNZ   25C4
25C0:  MOVF   x20,F
25C2:  BZ    25F2
.................... 				channel[c].htd_reconnect_delay_seconds--;
25C4:  MOVF   x1C,W
25C6:  MULLW  19
25C8:  MOVF   FF3,W
25CA:  CLRF   x20
25CC:  MOVWF  x1F
25CE:  MOVLW  17
25D0:  ADDWF  x1F,W
25D2:  MOVWF  01
25D4:  MOVLW  00
25D6:  ADDWFC x20,W
25D8:  MOVWF  03
25DA:  MOVF   01,W
25DC:  ADDLW  DA
25DE:  MOVWF  FE9
25E0:  MOVLW  00
25E2:  ADDWFC 03,W
25E4:  MOVWF  FEA
25E6:  MOVLW  FF
25E8:  ADDWF  FEF,F
25EA:  BC    25F0
25EC:  MOVF   FEE,F
25EE:  DECF   FED,F
.................... 			} else {
25F0:  BRA    260E
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_HTD);
25F2:  MOVF   x1C,W
25F4:  MULLW  19
25F6:  MOVF   FF3,W
25F8:  CLRF   x20
25FA:  MOVWF  x1F
25FC:  MOVLW  DA
25FE:  ADDWF  x1F,W
2600:  MOVWF  01
2602:  MOVLW  00
2604:  ADDWFC x20,W
2606:  MOVFF  01,FE9
260A:  MOVWF  FEA
260C:  BCF    FEF.6
.................... 			}
.................... 		} else {
260E:  BRA    2676
.................... 			channel[c].htd_reconnect_delay_seconds=config.ch[c].htd_reconnect_delay;
2610:  MOVF   x1C,W
2612:  MULLW  19
2614:  MOVF   FF3,W
2616:  CLRF   x20
2618:  MOVWF  x1F
261A:  MOVLW  17
261C:  ADDWF  x1F,W
261E:  MOVWF  01
2620:  MOVLW  00
2622:  ADDWFC x20,W
2624:  MOVWF  03
2626:  MOVF   01,W
2628:  ADDLW  DA
262A:  MOVWF  01
262C:  MOVLW  00
262E:  ADDWFC 03,F
2630:  MOVFF  01,11F
2634:  MOVFF  03,120
2638:  MOVF   x1C,W
263A:  MULLW  24
263C:  MOVF   FF3,W
263E:  CLRF   x22
2640:  MOVWF  x21
2642:  MOVLW  22
2644:  ADDWF  x21,W
2646:  MOVWF  01
2648:  MOVLW  00
264A:  ADDWFC x22,W
264C:  MOVWF  03
264E:  MOVF   01,W
2650:  ADDLW  1B
2652:  MOVWF  FE9
2654:  MOVLW  00
2656:  ADDWFC 03,W
2658:  MOVWF  FEA
265A:  MOVFF  FEC,03
265E:  MOVF   FED,F
2660:  MOVFF  FEF,121
2664:  MOVFF  120,FEA
2668:  MOVFF  11F,FE9
266C:  MOVFF  03,FEC
2670:  MOVF   FED,F
2672:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc < config.ch[c].htd_disconnect_adc ) {
2676:  MOVF   x1C,W
2678:  MULLW  24
267A:  MOVF   FF3,W
267C:  CLRF   x20
267E:  MOVWF  x1F
2680:  MOVLW  1C
2682:  ADDWF  x1F,W
2684:  MOVWF  01
2686:  MOVLW  00
2688:  ADDWFC x20,W
268A:  MOVWF  03
268C:  MOVF   01,W
268E:  ADDLW  1B
2690:  MOVWF  FE9
2692:  MOVLW  00
2694:  ADDWFC 03,W
2696:  MOVWF  FEA
2698:  MOVFF  FEC,03
269C:  MOVF   FED,F
269E:  MOVFF  FEF,01
26A2:  MOVF   x1E,W
26A4:  SUBWF  03,W
26A6:  BNC   2730
26A8:  BNZ   26B0
26AA:  MOVF   01,W
26AC:  SUBWF  x1D,W
26AE:  BC    2730
.................... 			if ( channel[c].htd_disconnect_delay_seconds > 0 ) {
26B0:  MOVF   x1C,W
26B2:  MULLW  19
26B4:  MOVF   FF3,W
26B6:  CLRF   x20
26B8:  MOVWF  x1F
26BA:  MOVLW  15
26BC:  ADDWF  x1F,W
26BE:  MOVWF  01
26C0:  MOVLW  00
26C2:  ADDWFC x20,W
26C4:  MOVWF  03
26C6:  MOVF   01,W
26C8:  ADDLW  DA
26CA:  MOVWF  FE9
26CC:  MOVLW  00
26CE:  ADDWFC 03,W
26D0:  MOVWF  FEA
26D2:  MOVFF  FEC,120
26D6:  MOVF   FED,F
26D8:  MOVFF  FEF,11F
26DC:  MOVF   x1F,F
26DE:  BNZ   26E4
26E0:  MOVF   x20,F
26E2:  BZ    2712
.................... 				channel[c].htd_disconnect_delay_seconds--;
26E4:  MOVF   x1C,W
26E6:  MULLW  19
26E8:  MOVF   FF3,W
26EA:  CLRF   x20
26EC:  MOVWF  x1F
26EE:  MOVLW  15
26F0:  ADDWF  x1F,W
26F2:  MOVWF  01
26F4:  MOVLW  00
26F6:  ADDWFC x20,W
26F8:  MOVWF  03
26FA:  MOVF   01,W
26FC:  ADDLW  DA
26FE:  MOVWF  FE9
2700:  MOVLW  00
2702:  ADDWFC 03,W
2704:  MOVWF  FEA
2706:  MOVLW  FF
2708:  ADDWF  FEF,F
270A:  BC    2710
270C:  MOVF   FEE,F
270E:  DECF   FED,F
.................... 			} else {
2710:  BRA    272E
.................... 				bit_set(channel[c].state,CH_STATE_BIT_HTD);
2712:  MOVF   x1C,W
2714:  MULLW  19
2716:  MOVF   FF3,W
2718:  CLRF   x20
271A:  MOVWF  x1F
271C:  MOVLW  DA
271E:  ADDWF  x1F,W
2720:  MOVWF  01
2722:  MOVLW  00
2724:  ADDWFC x20,W
2726:  MOVFF  01,FE9
272A:  MOVWF  FEA
272C:  BSF    FEF.6
.................... 			}
.................... 		} else {
272E:  BRA    2796
.................... 			channel[c].htd_disconnect_delay_seconds=config.ch[c].htd_disconnect_delay;
2730:  MOVF   x1C,W
2732:  MULLW  19
2734:  MOVF   FF3,W
2736:  CLRF   x20
2738:  MOVWF  x1F
273A:  MOVLW  15
273C:  ADDWF  x1F,W
273E:  MOVWF  01
2740:  MOVLW  00
2742:  ADDWFC x20,W
2744:  MOVWF  03
2746:  MOVF   01,W
2748:  ADDLW  DA
274A:  MOVWF  01
274C:  MOVLW  00
274E:  ADDWFC 03,F
2750:  MOVFF  01,11F
2754:  MOVFF  03,120
2758:  MOVF   x1C,W
275A:  MULLW  24
275C:  MOVF   FF3,W
275E:  CLRF   x22
2760:  MOVWF  x21
2762:  MOVLW  1E
2764:  ADDWF  x21,W
2766:  MOVWF  01
2768:  MOVLW  00
276A:  ADDWFC x22,W
276C:  MOVWF  03
276E:  MOVF   01,W
2770:  ADDLW  1B
2772:  MOVWF  FE9
2774:  MOVLW  00
2776:  ADDWFC 03,W
2778:  MOVWF  FEA
277A:  MOVFF  FEC,03
277E:  MOVF   FED,F
2780:  MOVFF  FEF,121
2784:  MOVFF  120,FEA
2788:  MOVFF  11F,FE9
278C:  MOVFF  03,FEC
2790:  MOVF   FED,F
2792:  MOVFF  121,FEF
.................... 		}
.................... 	}
2796:  MOVLB  0
2798:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void led_status_update(void) {
.................... 	static int8 cycle=0;
.................... 	int8 led;
.................... 
.................... 	for ( led=0 ; led<2 ; led++ ) {
*
28A8:  MOVLB  1
28AA:  CLRF   x1C
28AC:  MOVF   x1C,W
28AE:  SUBLW  01
28B0:  BNC   2986
.................... 		if ( cycle < 8 ) {
28B2:  MOVF   x11,W
28B4:  SUBLW  07
28B6:  BNC   291E
.................... 			/* first 8 cycles are 8 bits of state bit field */
.................... 
.................... 			/* if bit is set, then we blink the number of times+1 of the bit we are in. So bit 1 set means we blink 2 times */
.................... 			if ( bit_test(channel[led].state,cycle) ) {
28B8:  MOVF   x1C,W
28BA:  MULLW  19
28BC:  MOVF   FF3,W
28BE:  CLRF   x1E
28C0:  MOVWF  x1D
28C2:  MOVLW  DA
28C4:  ADDWF  x1D,W
28C6:  MOVWF  FE9
28C8:  MOVLW  00
28CA:  ADDWFC x1E,W
28CC:  MOVWF  FEA
28CE:  MOVFF  FEF,00
28D2:  MOVF   x11,W
28D4:  MOVWF  01
28D6:  BZ    28E0
28D8:  BCF    FD8.0
28DA:  RRCF   00,F
28DC:  DECFSZ 01,F
28DE:  BRA    28D8
28E0:  BTFSS  00.0
28E2:  BRA    290C
.................... 				timers.led_blink[led]=cycle+1;      /* number of blinks */
28E4:  CLRF   03
28E6:  MOVF   x1C,W
28E8:  ADDLW  D0
28EA:  MOVWF  FE9
28EC:  MOVLW  00
28EE:  ADDWFC 03,W
28F0:  MOVWF  FEA
28F2:  MOVLW  01
28F4:  ADDWF  x11,W
28F6:  MOVWF  FEF
.................... 				timers.led_on[led]=BLINK_ON_TIME;   /* how long to be on */
28F8:  CLRF   03
28FA:  MOVF   x1C,W
28FC:  ADDLW  D2
28FE:  MOVWF  FE9
2900:  MOVLW  00
2902:  ADDWFC 03,W
2904:  MOVWF  FEA
2906:  MOVLW  FE
2908:  MOVWF  FEF
.................... 			} else {
290A:  BRA    291C
.................... 				timers.led_blink[led]=0;
290C:  CLRF   03
290E:  MOVF   x1C,W
2910:  ADDLW  D0
2912:  MOVWF  FE9
2914:  MOVLW  00
2916:  ADDWFC 03,W
2918:  MOVWF  FEA
291A:  CLRF   FEF
.................... 			}
.................... 		} else if ( 8 == cycle ) {
291C:  BRA    2982
291E:  MOVF   x11,W
2920:  SUBLW  08
2922:  BNZ   2936
.................... 			/* solid light to mark start of next cycle */
.................... 			timers.led_blink[led]=255;
2924:  CLRF   03
2926:  MOVF   x1C,W
2928:  ADDLW  D0
292A:  MOVWF  FE9
292C:  MOVLW  00
292E:  ADDWFC 03,W
2930:  MOVWF  FEA
2932:  SETF   FEF
.................... 		} else if ( 9 == cycle ) {
2934:  BRA    2982
2936:  MOVF   x11,W
2938:  SUBLW  09
293A:  BNZ   2972
.................... 			/* solid on if contactor state is on, otherwise off */
.................... 			if ( timers.contactor[led] ) {
293C:  CLRF   03
293E:  MOVF   x1C,W
2940:  ADDLW  D6
2942:  MOVWF  FE9
2944:  MOVLW  00
2946:  ADDWFC 03,W
2948:  MOVWF  FEA
294A:  MOVF   FEF,F
294C:  BZ    2960
.................... 				timers.led_blink[led]=255;
294E:  CLRF   03
2950:  MOVF   x1C,W
2952:  ADDLW  D0
2954:  MOVWF  FE9
2956:  MOVLW  00
2958:  ADDWFC 03,W
295A:  MOVWF  FEA
295C:  SETF   FEF
.................... 			} else {
295E:  BRA    2970
.................... 				timers.led_blink[led]=0;
2960:  CLRF   03
2962:  MOVF   x1C,W
2964:  ADDLW  D0
2966:  MOVWF  FE9
2968:  MOVLW  00
296A:  ADDWFC 03,W
296C:  MOVWF  FEA
296E:  CLRF   FEF
.................... 			}
.................... 		} else {
2970:  BRA    2982
.................... 			/* blank period before starting the bit field */
.................... 			timers.led_blink[led]=0;
2972:  CLRF   03
2974:  MOVF   x1C,W
2976:  ADDLW  D0
2978:  MOVWF  FE9
297A:  MOVLW  00
297C:  ADDWFC 03,W
297E:  MOVWF  FEA
2980:  CLRF   FEF
.................... 		}
2982:  INCF   x1C,F
2984:  BRA    28AC
.................... 	}
.................... 
.................... //	fprintf(STREAM_FTDI,"# LED %u A=%03u (0x%02X) B=%03u (0x%02X)\r\n",cycle,timers.led_blink[0],channel[0].state,timers.led_blink[1],channel[1].state);
.................... 
.................... 	if ( 10 == cycle ) {
2986:  MOVF   x11,W
2988:  SUBLW  0A
298A:  BNZ   2990
.................... 		cycle=0; 
298C:  CLRF   x11
.................... 	} else {
298E:  BRA    2992
.................... 		cycle++;
2990:  INCF   x11,F
.................... 	}
2992:  MOVLB  0
2994:  GOTO   2B42 (RETURN)
.................... }
.................... 
.................... void led_on(int8 c) {
.................... 	if ( 0==c ) 
*
192E:  MOVLB  1
1930:  MOVF   x1C,F
1932:  BNZ   193A
.................... 		output_high(LED_A);
1934:  BCF    F94.1
1936:  BSF    F8B.1
1938:  BRA    193E
.................... 	else
.................... 		output_high(LED_B);
193A:  BCF    F94.2
193C:  BSF    F8B.2
193E:  MOVLB  0
1940:  RETURN 0
.................... }
.................... 
.................... void led_off(int8 c) {
.................... 	if ( 0==c ) 
1942:  MOVLB  1
1944:  MOVF   x1C,F
1946:  BNZ   194E
.................... 		output_low(LED_A);
1948:  BCF    F94.1
194A:  BCF    F8B.1
194C:  BRA    1952
.................... 	else
.................... 		output_low(LED_B);
194E:  BCF    F94.2
1950:  BCF    F8B.2
1952:  MOVLB  0
1954:  RETURN 0
.................... }
.................... 
.................... void periodic_millisecond(void) {
.................... 	static int8  uptimeTicks=0;
.................... 	static int8  statusTicks=0;
.................... 	static int16 adcTicks=0;
.................... 	static int16 ticks=0;
.................... 
.................... 	int8 i;
.................... 
.................... 
.................... 	timers.now_millisecond=0;
*
2998:  BCF    xCF.2
.................... 
.................... 	/* set LED output */
.................... 	for ( i=0 ; i<2 ; i++ ) {
299A:  MOVLB  1
299C:  CLRF   x1B
299E:  MOVF   x1B,W
29A0:  SUBLW  01
29A2:  BTFSS  FD8.0
29A4:  BRA    2AA4
.................... 		if ( 255 == timers.led_blink[i] ) {
29A6:  CLRF   03
29A8:  MOVF   x1B,W
29AA:  ADDLW  D0
29AC:  MOVWF  FE9
29AE:  MOVLW  00
29B0:  ADDWFC 03,W
29B2:  MOVWF  FEA
29B4:  MOVF   FEF,W
29B6:  SUBLW  FF
29B8:  BNZ   29C8
.................... 			led_on(i);
29BA:  MOVFF  11B,11C
29BE:  MOVLB  0
29C0:  CALL   192E
.................... 		} else if ( 0 == timers.led_blink[i] ) {
29C4:  BRA    2A9E
29C6:  MOVLB  1
29C8:  CLRF   03
29CA:  MOVF   x1B,W
29CC:  ADDLW  D0
29CE:  MOVWF  FE9
29D0:  MOVLW  00
29D2:  ADDWFC 03,W
29D4:  MOVWF  FEA
29D6:  MOVF   FEF,W
29D8:  BNZ   29E8
.................... 			led_off(i);
29DA:  MOVFF  11B,11C
29DE:  MOVLB  0
29E0:  CALL   1942
.................... 		} else {
29E4:  BRA    2A9E
29E6:  MOVLB  1
.................... 			/* led_blink[i] is somewhere between 1 and 254 */
.................... 			if ( timers.led_on[i] > 0 ) {
29E8:  CLRF   03
29EA:  MOVF   x1B,W
29EC:  ADDLW  D2
29EE:  MOVWF  FE9
29F0:  MOVLW  00
29F2:  ADDWFC 03,W
29F4:  MOVWF  FEA
29F6:  MOVF   FEF,F
29F8:  BZ    2A3A
.................... 				led_on(i);
29FA:  MOVFF  11B,11C
29FE:  MOVLB  0
2A00:  CALL   192E
.................... 				timers.led_on[i]--;
2A04:  CLRF   03
2A06:  MOVLB  1
2A08:  MOVF   x1B,W
2A0A:  ADDLW  D2
2A0C:  MOVWF  FE9
2A0E:  MOVLW  00
2A10:  ADDWFC 03,W
2A12:  MOVWF  FEA
2A14:  DECF   FEF,F
.................... 
.................... 				if ( 0==timers.led_on[i] ) {
2A16:  CLRF   03
2A18:  MOVF   x1B,W
2A1A:  ADDLW  D2
2A1C:  MOVWF  FE9
2A1E:  MOVLW  00
2A20:  ADDWFC 03,W
2A22:  MOVWF  FEA
2A24:  MOVF   FEF,W
2A26:  BNZ   2A3A
.................... 					/* hit zero, switch to our off timer */
.................... 					timers.led_off[i]=BLINK_OFF_TIME;
2A28:  CLRF   03
2A2A:  MOVF   x1B,W
2A2C:  ADDLW  D4
2A2E:  MOVWF  FE9
2A30:  MOVLW  00
2A32:  ADDWFC 03,W
2A34:  MOVWF  FEA
2A36:  MOVLW  C8
2A38:  MOVWF  FEF
.................... 				}
.................... 			}
.................... 
.................... 			if ( timers.led_off[i] > 0 ) {
2A3A:  CLRF   03
2A3C:  MOVF   x1B,W
2A3E:  ADDLW  D4
2A40:  MOVWF  FE9
2A42:  MOVLW  00
2A44:  ADDWFC 03,W
2A46:  MOVWF  FEA
2A48:  MOVF   FEF,F
2A4A:  BZ    2A9C
.................... 				led_off(i);
2A4C:  MOVFF  11B,11C
2A50:  MOVLB  0
2A52:  CALL   1942
.................... 				timers.led_off[i]--;
2A56:  CLRF   03
2A58:  MOVLB  1
2A5A:  MOVF   x1B,W
2A5C:  ADDLW  D4
2A5E:  MOVWF  FE9
2A60:  MOVLW  00
2A62:  ADDWFC 03,W
2A64:  MOVWF  FEA
2A66:  DECF   FEF,F
.................... 
.................... 				if ( 0==timers.led_off[i] ) {
2A68:  CLRF   03
2A6A:  MOVF   x1B,W
2A6C:  ADDLW  D4
2A6E:  MOVWF  FE9
2A70:  MOVLW  00
2A72:  ADDWFC 03,W
2A74:  MOVWF  FEA
2A76:  MOVF   FEF,W
2A78:  BNZ   2A9C
.................... 					/* hit zero, preload for next */
.................... 					timers.led_on[i]=BLINK_ON_TIME;
2A7A:  CLRF   03
2A7C:  MOVF   x1B,W
2A7E:  ADDLW  D2
2A80:  MOVWF  FE9
2A82:  MOVLW  00
2A84:  ADDWFC 03,W
2A86:  MOVWF  FEA
2A88:  MOVLW  FE
2A8A:  MOVWF  FEF
.................... 					/* done with this blink cycle */	
.................... 					timers.led_blink[i]--;
2A8C:  CLRF   03
2A8E:  MOVF   x1B,W
2A90:  ADDLW  D0
2A92:  MOVWF  FE9
2A94:  MOVLW  00
2A96:  ADDWFC 03,W
2A98:  MOVWF  FEA
2A9A:  DECF   FEF,F
2A9C:  MOVLB  0
.................... 				}
.................... 			}
.................... 		}
2A9E:  MOVLB  1
2AA0:  INCF   x1B,F
2AA2:  BRA    299E
.................... 	}
.................... 
.................... 
.................... 	/* some other random stuff that we don't need to do every cycle in main */
.................... 	if ( current.interval_milliseconds < 65535 ) {
2AA4:  MOVLB  0
2AA6:  INCFSZ xC8,W
2AA8:  BRA    2AB0
2AAA:  INCFSZ xC9,W
2AAC:  BRA    2AB0
2AAE:  BRA    2AB6
.................... 		current.interval_milliseconds++;
2AB0:  INCF   xC8,F
2AB2:  BTFSC  FD8.2
2AB4:  INCF   xC9,F
.................... 	}
.................... 
.................... 
.................... 	/* contactor timeout */
.................... 	if ( 0 == timers.contactor_powersave[0] ) {
2AB6:  MOVF   xD8,F
2AB8:  BNZ   2AC4
.................... 		output_low(BRIDGE_A_A);
2ABA:  BCF    F94.3
2ABC:  BCF    F8B.3
.................... 		output_low(BRIDGE_A_B);
2ABE:  BCF    F94.4
2AC0:  BCF    F8B.4
.................... 	} else {
2AC2:  BRA    2AC6
.................... 		timers.contactor_powersave[0]--;
2AC4:  DECF   xD8,F
.................... 	}
.................... 	if ( 0 == timers.contactor_powersave[1] ) {
2AC6:  MOVF   xD9,F
2AC8:  BNZ   2AD4
.................... 		output_low(BRIDGE_B_A);
2ACA:  BCF    F94.5
2ACC:  BCF    F8B.5
.................... 		output_low(BRIDGE_B_B);
2ACE:  BCF    F94.6
2AD0:  BCF    F8B.6
.................... 	} else {
2AD2:  BRA    2AD6
.................... 		timers.contactor_powersave[1]--;
2AD4:  DECF   xD9,F
.................... 	}
.................... 
.................... 
.................... 
.................... 
.................... 	/* seconds */
.................... 	ticks++;
2AD6:  MOVLB  1
2AD8:  INCF   x16,F
2ADA:  BTFSC  FD8.2
2ADC:  INCF   x17,F
.................... 	if ( 1000 == ticks ) {
2ADE:  MOVF   x16,W
2AE0:  SUBLW  E8
2AE2:  BNZ   2B44
2AE4:  MOVF   x17,W
2AE6:  SUBLW  03
2AE8:  BNZ   2B44
.................... 		ticks=0;
2AEA:  CLRF   x17
2AEC:  CLRF   x16
.................... 
.................... 		/* set channe[n].state based on logic */
.................... 		contactor_logic(0);
2AEE:  CLRF   x1C
2AF0:  MOVLB  0
2AF2:  CALL   1956
.................... 		contactor_logic(1);
2AF6:  MOVLW  01
2AF8:  MOVLB  1
2AFA:  MOVWF  x1C
2AFC:  MOVLB  0
2AFE:  CALL   1956
.................... 
.................... 		/* set contactor outputs based on their state bit field */
.................... 		contactor_set(0);
2B02:  MOVLB  1
2B04:  CLRF   x1C
2B06:  MOVLB  0
2B08:  RCALL  2846
.................... 		contactor_set(1);		
2B0A:  MOVLW  01
2B0C:  MOVLB  1
2B0E:  MOVWF  x1C
2B10:  MOVLB  0
2B12:  RCALL  2846
.................... 
.................... 		/* uptime counter */
.................... 		uptimeTicks++;
2B14:  MOVLB  1
2B16:  INCF   x12,F
.................... 		if ( 60 == uptimeTicks ) {
2B18:  MOVF   x12,W
2B1A:  SUBLW  3C
2B1C:  BNZ   2B34
.................... 			uptimeTicks=0;
2B1E:  CLRF   x12
.................... 			if ( current.uptime_minutes < 65535 ) 
2B20:  MOVLB  0
2B22:  INCFSZ xC6,W
2B24:  BRA    2B2C
2B26:  INCFSZ xC7,W
2B28:  BRA    2B2C
2B2A:  BRA    2B32
.................... 				current.uptime_minutes++;
2B2C:  INCF   xC6,F
2B2E:  BTFSC  FD8.2
2B30:  INCF   xC7,F
2B32:  MOVLB  1
.................... 		}
.................... 
.................... 		/* LED status update every 4 seconds */
.................... 		statusTicks++;
2B34:  INCF   x13,F
.................... 		if ( 4 == statusTicks ) {
2B36:  MOVF   x13,W
2B38:  SUBLW  04
2B3A:  BNZ   2B44
.................... 			/* LED state display update */
.................... 			statusTicks=0;
2B3C:  CLRF   x13
.................... 			led_status_update();
2B3E:  MOVLB  0
2B40:  BRA    28A8
2B42:  MOVLB  1
.................... 		}
.................... 
.................... 
.................... 	}
.................... 
.................... 	/* ADC sample counter */
.................... 	if ( timers.now_adc_reset_count ) {
2B44:  MOVLB  0
2B46:  BTFSS  xCF.1
2B48:  BRA    2B54
.................... 		timers.now_adc_reset_count=0;
2B4A:  BCF    xCF.1
.................... 		adcTicks=0;
2B4C:  MOVLB  1
2B4E:  CLRF   x15
2B50:  CLRF   x14
2B52:  MOVLB  0
.................... 	}
.................... 
.................... 	/* ADC sampling trigger */
.................... 	adcTicks++;
2B54:  MOVLB  1
2B56:  INCF   x14,F
2B58:  BTFSC  FD8.2
2B5A:  INCF   x15,F
.................... 	if ( ADC_SAMPLE_TICKS == adcTicks ) {
2B5C:  MOVF   x14,W
2B5E:  SUBLW  14
2B60:  BNZ   2B70
2B62:  MOVF   x15,F
2B64:  BNZ   2B70
.................... 		adcTicks=0;
2B66:  CLRF   x15
2B68:  CLRF   x14
.................... 		timers.now_adc_sample=1;
2B6A:  MOVLB  0
2B6C:  BSF    xCF.0
2B6E:  MOVLB  1
.................... 	}
2B70:  MOVLB  0
2B72:  GOTO   2F54 (RETURN)
.................... 
.................... }
.................... 
.................... void init(void) {
.................... 	int8 i;
.................... 	int8 buff[10];
.................... 	setup_oscillator(OSC_16MHZ);
*
1100:  MOVLW  70
1102:  MOVWF  FD3
1104:  BCF    F9B.6
1106:  BCF    F9B.7
.................... 
.................... 	setup_adc(ADC_CLOCK_DIV_16);
1108:  MOVF   FC0,W
110A:  ANDLW  C0
110C:  IORLW  05
110E:  MOVWF  FC0
1110:  BSF    FC0.7
1112:  BSF    FC2.0
.................... 	/* NTC thermistor on sAN2, input voltage divider on sAN4, DIP switch analog on sAN9
.................... 	voltage spans between 0 and Vdd */
.................... 	setup_adc_ports(sAN2 | sAN4 | sAN9,VSS_VDD);
1114:  MOVLW  14
1116:  MOVWF  F7E
1118:  BCF    FC1.0
111A:  BCF    FC1.1
111C:  BCF    FC1.2
111E:  BCF    FC1.3
1120:  MOVLW  02
1122:  MOVWF  F7F
.................... 
.................... 	setup_wdt(WDT_512MS); /* forces the fuse to WDT128 */
1124:  BSF    FD1.0
.................... 
.................... 	set_tris_a(0b00111111);
1126:  MOVLW  3F
1128:  MOVWF  F92
.................... 	set_tris_b(0b01110000);
112A:  MOVLW  70
112C:  MOVWF  F93
.................... 	set_tris_c(0b10000001);
112E:  MOVLW  81
1130:  MOVWF  F94
.................... //               76543210
.................... 
.................... 	port_a_pullups(0b00110000);
1132:  MOVLW  30
1134:  MOVWF  F77
1136:  BCF    FF1.7
.................... 	port_b_pullups(0b00000000);
1138:  CLRF   F78
.................... //                   76543210
.................... 
.................... 	/* data structure initialization */
.................... 	/* all initialized to 0 on declaration. Just do this if need non-zero */
.................... 	for ( i=0 ; i<=1 ; i++ ) {
113A:  MOVLB  1
113C:  CLRF   x1B
113E:  MOVF   x1B,W
1140:  SUBLW  01
1142:  BNC   1198
.................... 		channel[i].command_off_seconds=65535;
1144:  MOVF   x1B,W
1146:  MULLW  19
1148:  MOVF   FF3,W
114A:  CLRF   x27
114C:  MOVWF  x26
114E:  MOVLW  05
1150:  ADDWF  x26,W
1152:  MOVWF  01
1154:  MOVLW  00
1156:  ADDWFC x27,W
1158:  MOVWF  03
115A:  MOVF   01,W
115C:  ADDLW  DA
115E:  MOVWF  FE9
1160:  MOVLW  00
1162:  ADDWFC 03,W
1164:  MOVWF  FEA
1166:  SETF   FEC
1168:  MOVF   FED,F
116A:  SETF   FEF
.................... 		channel[i].command_on_seconds =65535;
116C:  MOVF   x1B,W
116E:  MULLW  19
1170:  MOVF   FF3,W
1172:  CLRF   x27
1174:  MOVWF  x26
1176:  MOVLW  01
1178:  ADDWF  x26,W
117A:  MOVWF  01
117C:  MOVLW  00
117E:  ADDWFC x27,W
1180:  MOVWF  03
1182:  MOVF   01,W
1184:  ADDLW  DA
1186:  MOVWF  FE9
1188:  MOVLW  00
118A:  ADDWFC 03,W
118C:  MOVWF  FEA
118E:  SETF   FEC
1190:  MOVF   FED,F
1192:  SETF   FEF
1194:  INCF   x1B,F
1196:  BRA    113E
.................... 	}
.................... 
.................... 	/* get our compiled date from constant  
.................... 	'5-Feb-22'
.................... 	 01234567
.................... 
.................... 	'25-Feb-22'
.................... 	 012345678
.................... 	*/
.................... 	strcpy(buff,__DATE__);
1198:  MOVLW  01
119A:  MOVWF  FEA
119C:  MOVLW  1C
119E:  MOVWF  FE9
11A0:  MOVLW  00
11A2:  MOVLB  0
11A4:  CALL   00BA
11A8:  TBLRD*-
11AA:  TBLRD*+
11AC:  MOVF   FF5,W
11AE:  MOVWF  FEE
11B0:  IORLW  00
11B2:  BNZ   11AA
.................... 	i=0;
11B4:  MOVLB  1
11B6:  CLRF   x1B
.................... 	if ( '-' != buff[1] ) {
11B8:  MOVF   x1D,W
11BA:  SUBLW  2D
11BC:  BZ    11DC
.................... 		/* day can be one or two digits */
.................... 		current.compile_day =(buff[i]-'0')*10;
11BE:  CLRF   03
11C0:  MOVF   x1B,W
11C2:  ADDLW  1C
11C4:  MOVWF  FE9
11C6:  MOVLW  01
11C8:  ADDWFC 03,W
11CA:  MOVWF  FEA
11CC:  MOVLW  30
11CE:  SUBWF  FEF,W
11D0:  MULLW  0A
11D2:  MOVFF  FF3,CD
11D6:  MOVLB  0
.................... 		i++;
11D8:  MOVLB  1
11DA:  INCF   x1B,F
.................... 	}
.................... 	current.compile_day+=(buff[i]-'0');
11DC:  CLRF   03
11DE:  MOVF   x1B,W
11E0:  ADDLW  1C
11E2:  MOVWF  FE9
11E4:  MOVLW  01
11E6:  ADDWFC 03,W
11E8:  MOVWF  FEA
11EA:  MOVLW  30
11EC:  SUBWF  FEF,W
11EE:  MOVLB  0
11F0:  ADDWF  xCD,F
.................... 	i+=2; /* now points to month */
11F2:  MOVLW  02
11F4:  MOVLB  1
11F6:  ADDWF  x1B,F
.................... 
.................... 	/* determine month ... how annoying */
.................... 	if ( 'J'==buff[i+0] ) {
11F8:  CLRF   03
11FA:  MOVF   x1B,W
11FC:  ADDLW  1C
11FE:  MOVWF  FE9
1200:  MOVLW  01
1202:  ADDWFC 03,W
1204:  MOVWF  FEA
1206:  MOVF   FEF,W
1208:  SUBLW  4A
120A:  BNZ   1256
.................... 		if ( 'A'==buff[i+1] )
120C:  MOVLW  01
120E:  ADDWF  x1B,W
1210:  CLRF   03
1212:  ADDLW  1C
1214:  MOVWF  FE9
1216:  MOVLW  01
1218:  ADDWFC 03,W
121A:  MOVWF  FEA
121C:  MOVF   FEF,W
121E:  SUBLW  41
1220:  BNZ   122C
.................... 			current.compile_month=1;
1222:  MOVLW  01
1224:  MOVLB  0
1226:  MOVWF  xCC
1228:  BRA    1252
122A:  MOVLB  1
.................... 		else if ( 'N'==buff[i+2] )
122C:  MOVLW  02
122E:  ADDWF  x1B,W
1230:  CLRF   03
1232:  ADDLW  1C
1234:  MOVWF  FE9
1236:  MOVLW  01
1238:  ADDWFC 03,W
123A:  MOVWF  FEA
123C:  MOVF   FEF,W
123E:  SUBLW  4E
1240:  BNZ   124C
.................... 			current.compile_month=6;
1242:  MOVLW  06
1244:  MOVLB  0
1246:  MOVWF  xCC
1248:  BRA    1252
124A:  MOVLB  1
.................... 		else
.................... 			current.compile_month=7;
124C:  MOVLW  07
124E:  MOVLB  0
1250:  MOVWF  xCC
.................... 	} else if ( 'A'==buff[i+0] ) {
1252:  BRA    136C
1254:  MOVLB  1
1256:  CLRF   03
1258:  MOVF   x1B,W
125A:  ADDLW  1C
125C:  MOVWF  FE9
125E:  MOVLW  01
1260:  ADDWFC 03,W
1262:  MOVWF  FEA
1264:  MOVF   FEF,W
1266:  SUBLW  41
1268:  BNZ   1294
.................... 		if ( 'P'==buff[i+1] )
126A:  MOVLW  01
126C:  ADDWF  x1B,W
126E:  CLRF   03
1270:  ADDLW  1C
1272:  MOVWF  FE9
1274:  MOVLW  01
1276:  ADDWFC 03,W
1278:  MOVWF  FEA
127A:  MOVF   FEF,W
127C:  SUBLW  50
127E:  BNZ   128A
.................... 			current.compile_month=4;
1280:  MOVLW  04
1282:  MOVLB  0
1284:  MOVWF  xCC
1286:  BRA    1290
1288:  MOVLB  1
.................... 		else
.................... 			current.compile_month=8;
128A:  MOVLW  08
128C:  MOVLB  0
128E:  MOVWF  xCC
.................... 	} else if ( 'M'==buff[i+0] ) {
1290:  BRA    136C
1292:  MOVLB  1
1294:  CLRF   03
1296:  MOVF   x1B,W
1298:  ADDLW  1C
129A:  MOVWF  FE9
129C:  MOVLW  01
129E:  ADDWFC 03,W
12A0:  MOVWF  FEA
12A2:  MOVF   FEF,W
12A4:  SUBLW  4D
12A6:  BNZ   12D2
.................... 		if ( 'R'==buff[i+2] )
12A8:  MOVLW  02
12AA:  ADDWF  x1B,W
12AC:  CLRF   03
12AE:  ADDLW  1C
12B0:  MOVWF  FE9
12B2:  MOVLW  01
12B4:  ADDWFC 03,W
12B6:  MOVWF  FEA
12B8:  MOVF   FEF,W
12BA:  SUBLW  52
12BC:  BNZ   12C8
.................... 			current.compile_month=3;
12BE:  MOVLW  03
12C0:  MOVLB  0
12C2:  MOVWF  xCC
12C4:  BRA    12CE
12C6:  MOVLB  1
.................... 		else
.................... 			current.compile_month=5;
12C8:  MOVLW  05
12CA:  MOVLB  0
12CC:  MOVWF  xCC
.................... 	} else if ( 'F'==buff[i+0] ) {
12CE:  BRA    136C
12D0:  MOVLB  1
12D2:  CLRF   03
12D4:  MOVF   x1B,W
12D6:  ADDLW  1C
12D8:  MOVWF  FE9
12DA:  MOVLW  01
12DC:  ADDWFC 03,W
12DE:  MOVWF  FEA
12E0:  MOVF   FEF,W
12E2:  SUBLW  46
12E4:  BNZ   12F0
.................... 		current.compile_month=2;
12E6:  MOVLW  02
12E8:  MOVLB  0
12EA:  MOVWF  xCC
.................... 	} else if ( 'S'==buff[i+0] ) {
12EC:  BRA    136C
12EE:  MOVLB  1
12F0:  CLRF   03
12F2:  MOVF   x1B,W
12F4:  ADDLW  1C
12F6:  MOVWF  FE9
12F8:  MOVLW  01
12FA:  ADDWFC 03,W
12FC:  MOVWF  FEA
12FE:  MOVF   FEF,W
1300:  SUBLW  53
1302:  BNZ   130E
.................... 		current.compile_month=9;
1304:  MOVLW  09
1306:  MOVLB  0
1308:  MOVWF  xCC
.................... 	} else if ( 'O'==buff[i+0] ) {
130A:  BRA    136C
130C:  MOVLB  1
130E:  CLRF   03
1310:  MOVF   x1B,W
1312:  ADDLW  1C
1314:  MOVWF  FE9
1316:  MOVLW  01
1318:  ADDWFC 03,W
131A:  MOVWF  FEA
131C:  MOVF   FEF,W
131E:  SUBLW  4F
1320:  BNZ   132C
.................... 		current.compile_month=10;
1322:  MOVLW  0A
1324:  MOVLB  0
1326:  MOVWF  xCC
.................... 	} else if ( 'N'==buff[i+0] ) {
1328:  BRA    136C
132A:  MOVLB  1
132C:  CLRF   03
132E:  MOVF   x1B,W
1330:  ADDLW  1C
1332:  MOVWF  FE9
1334:  MOVLW  01
1336:  ADDWFC 03,W
1338:  MOVWF  FEA
133A:  MOVF   FEF,W
133C:  SUBLW  4E
133E:  BNZ   134A
.................... 		current.compile_month=11;
1340:  MOVLW  0B
1342:  MOVLB  0
1344:  MOVWF  xCC
.................... 	} else if ( 'D'==buff[i+0] ) {
1346:  BRA    136C
1348:  MOVLB  1
134A:  CLRF   03
134C:  MOVF   x1B,W
134E:  ADDLW  1C
1350:  MOVWF  FE9
1352:  MOVLW  01
1354:  ADDWFC 03,W
1356:  MOVWF  FEA
1358:  MOVF   FEF,W
135A:  SUBLW  44
135C:  BNZ   1368
.................... 		current.compile_month=12;
135E:  MOVLW  0C
1360:  MOVLB  0
1362:  MOVWF  xCC
.................... 	} else {
1364:  BRA    136C
1366:  MOVLB  1
.................... 		/* error parsing, shouldn't happen */
.................... 		current.compile_month=255;
1368:  MOVLB  0
136A:  SETF   xCC
.................... 	}
.................... 	current.compile_year =(buff[i+4]-'0')*10;
136C:  MOVLW  04
136E:  MOVLB  1
1370:  ADDWF  x1B,W
1372:  CLRF   03
1374:  ADDLW  1C
1376:  MOVWF  FE9
1378:  MOVLW  01
137A:  ADDWFC 03,W
137C:  MOVWF  FEA
137E:  MOVLW  30
1380:  SUBWF  FEF,W
1382:  MULLW  0A
1384:  MOVFF  FF3,CB
1388:  MOVLB  0
.................... 	current.compile_year+=(buff[i+5]-'0');
138A:  MOVLW  05
138C:  MOVLB  1
138E:  ADDWF  x1B,W
1390:  CLRF   03
1392:  ADDLW  1C
1394:  MOVWF  FE9
1396:  MOVLW  01
1398:  ADDWFC 03,W
139A:  MOVWF  FEA
139C:  MOVLW  30
139E:  SUBWF  FEF,W
13A0:  MOVLB  0
13A2:  ADDWF  xCB,F
.................... 
.................... 
.................... 	/* one periodic interrupt @ 1mS. Generated from system 16 MHz clock */
.................... 	/* prescale=16, match=249, postscale=1. Match is 249 because when match occurs, one cycle is lost */
.................... 	setup_timer_2(T2_DIV_BY_16,249,1);
13A4:  MOVLW  00
13A6:  IORLW  06
13A8:  MOVWF  FCA
13AA:  MOVLW  F9
13AC:  MOVWF  FCB
.................... 
.................... 	enable_interrupts(INT_TIMER2);
13AE:  BSF    F9D.1
.................... 
.................... 	/* set I2C slave address, which is always an even number */
.................... 	i2c_slaveaddr(STREAM_SLAVE,0x3e + (read_dip_switch()<<1) );
13B0:  BRA    108E
13B2:  BCF    FD8.0
13B4:  RLCF   01,W
13B6:  ADDLW  3E
13B8:  MOVLB  1
13BA:  MOVWF  FC8
13BC:  MOVLB  0
13BE:  GOTO   2E20 (RETURN)
.................... }
.................... 
.................... 
.................... void main(void) {
*
2D92:  CLRF   FF8
2D94:  BCF    FD0.7
2D96:  BSF    07.7
2D98:  BSF    F93.6
2D9A:  BSF    F93.4
2D9C:  CLRF   FC8
2D9E:  MOVLW  36
2DA0:  MOVWF  FC6
2DA2:  BSF    FC5.0
2DA4:  BSF    FC5.7
2DA6:  CLRF   1A
2DA8:  BSF    FB8.3
2DAA:  MOVLW  44
2DAC:  MOVWF  FAF
2DAE:  MOVLW  00
2DB0:  MOVWF  FB0
2DB2:  MOVLW  A6
2DB4:  MOVWF  FAC
2DB6:  MOVLW  90
2DB8:  MOVWF  FAB
2DBA:  MOVLB  1
2DBC:  CLRF   x19
2DBE:  CLRF   x18
2DC0:  MOVLW  00
2DC2:  MOVWF  F7E
2DC4:  BCF    FC1.0
2DC6:  BCF    FC1.1
2DC8:  BCF    FC1.2
2DCA:  BCF    FC1.3
2DCC:  MOVWF  F7F
2DCE:  CLRF   F6C
2DD0:  CLRF   F6B
2DD2:  CLRF   F6D
2DD4:  BRA    2DDC
2DD6:  DATA FD,40
2DD8:  DATA 1B,00
2DDA:  DATA 00,00
2DDC:  MOVLW  00
2DDE:  MOVWF  FF8
2DE0:  MOVLW  2D
2DE2:  MOVWF  FF7
2DE4:  MOVLW  D6
2DE6:  MOVWF  FF6
2DE8:  TBLRD*+
2DEA:  MOVF   FF5,W
2DEC:  MOVWF  00
2DEE:  XORLW  00
2DF0:  BZ    2E18
2DF2:  TBLRD*+
2DF4:  MOVF   FF5,W
2DF6:  MOVWF  01
2DF8:  BTFSC  FE8.7
2DFA:  BRA    2E06
2DFC:  ANDLW  3F
2DFE:  MOVWF  FEA
2E00:  TBLRD*+
2E02:  MOVFF  FF5,FE9
2E06:  BTFSC  01.6
2E08:  TBLRD*+
2E0A:  BTFSS  01.6
2E0C:  TBLRD*+
2E0E:  MOVFF  FF5,FEE
2E12:  DCFSNZ 00,F
2E14:  BRA    2DE8
2E16:  BRA    2E0A
2E18:  CLRF   FF8
.................... 	int8 i;
.................... 
.................... 	init();
2E1A:  MOVLB  0
2E1C:  GOTO   1100
.................... 
.................... 
.................... 	/* read parameters from EEPROM and write defaults if CRC doesn't match */
.................... 	read_param_file();
2E20:  GOTO   17FA
.................... 
.................... 
.................... 	/* flash on startup */
.................... 	for ( i=0 ; i<5 ; i++ ) {
2E24:  MOVLB  1
2E26:  CLRF   x1A
2E28:  MOVF   x1A,W
2E2A:  SUBLW  04
2E2C:  BNC   2E54
.................... 		restart_wdt();
2E2E:  CLRWDT
.................... 		output_high(LED_A);
2E30:  BCF    F94.1
2E32:  BSF    F8B.1
.................... 		delay_ms(200);
2E34:  MOVLW  C8
2E36:  MOVWF  x28
2E38:  MOVLB  0
2E3A:  CALL   1064
.................... 		output_low(LED_A);
2E3E:  BCF    F94.1
2E40:  BCF    F8B.1
.................... 		delay_ms(200);
2E42:  MOVLW  C8
2E44:  MOVLB  1
2E46:  MOVWF  x28
2E48:  MOVLB  0
2E4A:  CALL   1064
2E4E:  MOVLB  1
2E50:  INCF   x1A,F
2E52:  BRA    2E28
.................... 	}
.................... 
.................... 	fprintf(STREAM_FTDI,"# dcswc_module_latching_contactor %s\r\n# ",__DATE__);
2E54:  MOVLW  B8
2E56:  MOVWF  FF6
2E58:  MOVLW  0F
2E5A:  MOVWF  FF7
2E5C:  MOVLW  22
2E5E:  MOVWF  x1D
2E60:  MOVLB  0
2E62:  CALL   1840
2E66:  MOVLW  E2
2E68:  MOVWF  FF6
2E6A:  MOVLW  0F
2E6C:  MOVWF  FF7
2E6E:  CALL   186A
2E72:  MOVLW  DC
2E74:  MOVWF  FF6
2E76:  MOVLW  0F
2E78:  MOVWF  FF7
2E7A:  MOVLW  04
2E7C:  MOVLB  1
2E7E:  MOVWF  x1D
2E80:  MOVLB  0
2E82:  CALL   1840
.................... 	switch ( restart_cause ) {
2E86:  MOVLW  07
2E88:  SUBWF  00,W
2E8A:  BZ    2EB0
2E8C:  MOVLW  0B
2E8E:  SUBWF  00,W
2E90:  BZ    2EBE
2E92:  MOVLW  0F
2E94:  SUBWF  00,W
2E96:  BZ    2ECC
2E98:  MOVLW  0C
2E9A:  SUBWF  00,W
2E9C:  BZ    2EDA
2E9E:  MOVLW  0E
2EA0:  SUBWF  00,W
2EA2:  BZ    2EE8
2EA4:  MOVLW  03
2EA6:  SUBWF  00,W
2EA8:  BZ    2EF6
2EAA:  MOVF   00,F
2EAC:  BZ    2F04
2EAE:  BRA    2F12
.................... 		case WDT_TIMEOUT:       fprintf(STREAM_FTDI,"WDT TIMEOUT"); break;
2EB0:  MOVLW  EC
2EB2:  MOVWF  FF6
2EB4:  MOVLW  0F
2EB6:  MOVWF  FF7
2EB8:  CALL   186A
2EBC:  BRA    2F1E
.................... 		case MCLR_FROM_SLEEP:   fprintf(STREAM_FTDI,"MCLR FROM SLEEP"); break;
2EBE:  MOVLW  F8
2EC0:  MOVWF  FF6
2EC2:  MOVLW  0F
2EC4:  MOVWF  FF7
2EC6:  CALL   186A
2ECA:  BRA    2F1E
.................... 		case MCLR_FROM_RUN:     fprintf(STREAM_FTDI,"MCLR FROM RUN"); break;
2ECC:  MOVLW  08
2ECE:  MOVWF  FF6
2ED0:  MOVLW  10
2ED2:  MOVWF  FF7
2ED4:  CALL   186A
2ED8:  BRA    2F1E
.................... 		case NORMAL_POWER_UP:   fprintf(STREAM_FTDI,"NORMAL POWER UP"); break;
2EDA:  MOVLW  16
2EDC:  MOVWF  FF6
2EDE:  MOVLW  10
2EE0:  MOVWF  FF7
2EE2:  CALL   186A
2EE6:  BRA    2F1E
.................... 		case BROWNOUT_RESTART:  fprintf(STREAM_FTDI,"BROWNOUT RESTART"); break;
2EE8:  MOVLW  26
2EEA:  MOVWF  FF6
2EEC:  MOVLW  10
2EEE:  MOVWF  FF7
2EF0:  CALL   186A
2EF4:  BRA    2F1E
.................... 		case WDT_FROM_SLEEP:    fprintf(STREAM_FTDI,"WDT FROM SLEEP"); break;
2EF6:  MOVLW  38
2EF8:  MOVWF  FF6
2EFA:  MOVLW  10
2EFC:  MOVWF  FF7
2EFE:  CALL   186A
2F02:  BRA    2F1E
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_FTDI,"RESET INSTRUCTION"); break;
2F04:  MOVLW  48
2F06:  MOVWF  FF6
2F08:  MOVLW  10
2F0A:  MOVWF  FF7
2F0C:  CALL   186A
2F10:  BRA    2F1E
.................... 		default:                fprintf(STREAM_FTDI,"UNKNOWN!");
2F12:  MOVLW  5A
2F14:  MOVWF  FF6
2F16:  MOVLW  10
2F18:  MOVWF  FF7
2F1A:  CALL   186A
.................... 	}
.................... 	fprintf(STREAM_FTDI,"\r\n");
2F1E:  MOVLW  0D
2F20:  BTFSS  F9E.4
2F22:  BRA    2F20
2F24:  MOVWF  FAD
2F26:  MOVLW  0A
2F28:  BTFSS  F9E.4
2F2A:  BRA    2F28
2F2C:  MOVWF  FAD
.................... 
.................... 	enable_interrupts(GLOBAL);
2F2E:  MOVLW  C0
2F30:  IORWF  FF2,F
.................... 
.................... 	/* Prime ADC filter */
.................... 	for ( i=0 ; i<30 ; i++ ) {
2F32:  MOVLB  1
2F34:  CLRF   x1A
2F36:  MOVF   x1A,W
2F38:  SUBLW  1D
2F3A:  BNC   2F48
.................... 		adc_update();
2F3C:  MOVLB  0
2F3E:  CALL   188C
2F42:  MOVLB  1
2F44:  INCF   x1A,F
2F46:  BRA    2F36
.................... 	}
.................... 
.................... 
.................... 	/* enable I2C slave interrupt */
.................... 	enable_interrupts(INT_SSP);
2F48:  BSF    F9D.3
.................... 
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
2F4A:  CLRWDT
.................... 
.................... 		if ( timers.now_millisecond ) {
2F4C:  MOVLB  0
2F4E:  BTFSS  xCF.2
2F50:  BRA    2F54
.................... 			periodic_millisecond();
2F52:  BRA    2998
.................... 		}
.................... 
.................... 		if ( kbhit() ) {
2F54:  BTFSS  F9E.5
2F56:  BRA    2F5C
.................... 			getc();
2F58:  BRA    2B76
.................... 			timers.now_debug_dump=1;
2F5A:  BSF    xCF.5
.................... 		}
.................... 
.................... 		if ( timers.now_debug_dump ) {
2F5C:  BTFSS  xCF.5
2F5E:  BRA    2F64
.................... 			timers.now_debug_dump=0;
2F60:  BCF    xCF.5
.................... 
.................... 			debug_dump();
2F62:  BRA    2C86
.................... 		}
.................... 
.................... 		if ( timers.now_adc_sample ) {
2F64:  BTFSS  xCF.0
2F66:  BRA    2F6E
.................... 			timers.now_adc_sample=0;
2F68:  BCF    xCF.0
.................... 			adc_update();
2F6A:  CALL   188C
.................... 		}
.................... 
.................... 		if ( timers.now_write_config ) {
2F6E:  BTFSS  xCF.3
2F70:  BRA    2F78
.................... 			timers.now_write_config=0;
2F72:  BCF    xCF.3
.................... 			write_param_file();
2F74:  CALL   14E2
.................... 		}
.................... 		if ( timers.now_reset_config ) {
2F78:  BTFSS  xCF.4
2F7A:  BRA    2F82
.................... 			timers.now_reset_config=0;
2F7C:  BCF    xCF.4
.................... 			write_default_param_file();
2F7E:  CALL   152E
.................... 		}
2F82:  MOVLB  1
2F84:  BRA    2F4A
.................... 
.................... 
.................... 	}
.................... 
.................... 
.................... }
2F86:  SLEEP 

Configuration Fuses:
   Word  1: 0800   INTRC_IO NOPLLEN NOPCLKEN NOFCMEN NOIESO
   Word  2: 0F07   NOPUT BROWNOUT BORV30 WDT WDT128
   Word  3: 0000   NOHFOFST NOMCLR
   Word  4: 0081   STVREN NOLVP BBSIZ1K NOXINST NODEBUG
   Word  5: C003   NOPROTECT NOCPB NOCPD
   Word  6: E003   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 4003   NOEBTR NOEBTRB

ROM data:
F00000: 00 00 40 00                                        ..@.
