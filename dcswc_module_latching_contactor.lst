CCS PCH C Compiler, Version 5.090, 49113               06-Feb-22 16:10

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\dcswc_module_latching_contactor\dcswc_module_latching_contactor.lst

               ROM used:   11374 bytes (73%)
                           Largest free fragment is 4174
               RAM used:   283 (55%) at main() level
                           311 (61%) worst case
               Stack used: 4 locations (2 in main + 2 for interrupts)
               Stack size: 30

0000:  GOTO   2A7C
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   00D4
0060:  BTFSS  F9D.3
0062:  GOTO   006C
0066:  BTFSC  F9E.3
0068:  GOTO   0E8A
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include "dcswc_module_latching_contactor.h"
.................... #include <18F14K22.h>
.................... //////////// Standard Header file for the PIC18F14K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F14K22
00BA:  CLRF   FF7
00BC:  ADDLW  CA
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  RETURN 0
00CA:  DATA 36,2D
00CC:  DATA 46,65
00CE:  DATA 62,2D
00D0:  DATA 32,32
00D2:  DATA 00,00
*
0F5C:  DATA 23,20
0F5E:  DATA 20,20
0F60:  DATA 20,20
0F62:  DATA 20,20
0F64:  DATA 76,69
0F66:  DATA 6E,20
0F68:  DATA 61,64
0F6A:  DATA 63,3D
0F6C:  DATA 25,6C
0F6E:  DATA 75,0D
0F70:  DATA 0A,00
0F72:  DATA 23,20
0F74:  DATA 20,20
0F76:  DATA 20,20
0F78:  DATA 20,74
0F7A:  DATA 65,6D
0F7C:  DATA 70,20
0F7E:  DATA 61,64
0F80:  DATA 63,3D
0F82:  DATA 25,6C
0F84:  DATA 75,0D
0F86:  DATA 0A,00
0F88:  DATA 23,20
0F8A:  DATA 20,20
0F8C:  DATA 63,68
0F8E:  DATA 5B,30
0F90:  DATA 5D,2E
0F92:  DATA 73,74
0F94:  DATA 61,74
0F96:  DATA 65,3D
0F98:  DATA 30,78
0F9A:  DATA 25,32
0F9C:  DATA 58,0D
0F9E:  DATA 0A,00
0FA0:  DATA 23,20
0FA2:  DATA 20,20
0FA4:  DATA 63,68
0FA6:  DATA 5B,31
0FA8:  DATA 5D,2E
0FAA:  DATA 73,74
0FAC:  DATA 61,74
0FAE:  DATA 65,3D
0FB0:  DATA 30,78
0FB2:  DATA 25,32
0FB4:  DATA 58,0D
0FB6:  DATA 0A,00
0FB8:  DATA 23,20
0FBA:  DATA 64,63
0FBC:  DATA 73,77
0FBE:  DATA 63,5F
0FC0:  DATA 6D,6F
0FC2:  DATA 64,75
0FC4:  DATA 6C,65
0FC6:  DATA 5F,6C
0FC8:  DATA 61,74
0FCA:  DATA 63,68
0FCC:  DATA 69,6E
0FCE:  DATA 67,5F
0FD0:  DATA 63,6F
0FD2:  DATA 6E,74
0FD4:  DATA 61,63
0FD6:  DATA 74,6F
0FD8:  DATA 72,20
0FDA:  DATA 25,73
0FDC:  DATA 0D,0A
0FDE:  DATA 23,20
0FE0:  DATA 00,00
0FE2:  DATA 36,2D
0FE4:  DATA 46,65
0FE6:  DATA 62,2D
0FE8:  DATA 32,32
0FEA:  DATA 00,00
0FEC:  DATA 57,44
0FEE:  DATA 54,20
0FF0:  DATA 54,49
0FF2:  DATA 4D,45
0FF4:  DATA 4F,55
0FF6:  DATA 54,00
0FF8:  DATA 4D,43
0FFA:  DATA 4C,52
0FFC:  DATA 20,46
0FFE:  DATA 52,4F
1000:  DATA 4D,20
1002:  DATA 53,4C
1004:  DATA 45,45
1006:  DATA 50,00
1008:  DATA 4D,43
100A:  DATA 4C,52
100C:  DATA 20,46
100E:  DATA 52,4F
1010:  DATA 4D,20
1012:  DATA 52,55
1014:  DATA 4E,00
1016:  DATA 4E,4F
1018:  DATA 52,4D
101A:  DATA 41,4C
101C:  DATA 20,50
101E:  DATA 4F,57
1020:  DATA 45,52
1022:  DATA 20,55
1024:  DATA 50,00
1026:  DATA 42,52
1028:  DATA 4F,57
102A:  DATA 4E,4F
102C:  DATA 55,54
102E:  DATA 20,52
1030:  DATA 45,53
1032:  DATA 54,41
1034:  DATA 52,54
1036:  DATA 00,00
1038:  DATA 57,44
103A:  DATA 54,20
103C:  DATA 46,52
103E:  DATA 4F,4D
1040:  DATA 20,53
1042:  DATA 4C,45
1044:  DATA 45,50
1046:  DATA 00,00
1048:  DATA 52,45
104A:  DATA 53,45
104C:  DATA 54,20
104E:  DATA 49,4E
1050:  DATA 53,54
1052:  DATA 52,55
1054:  DATA 43,54
1056:  DATA 49,4F
1058:  DATA 4E,00
105A:  DATA 55,4E
105C:  DATA 4B,4E
105E:  DATA 4F,57
1060:  DATA 4E,21
1062:  DATA 00,00
*
17BE:  TBLRD*+
17C0:  MOVFF  FF6,11F
17C4:  MOVFF  FF7,120
17C8:  MOVF   FF5,W
17CA:  BTFSS  F9E.4
17CC:  BRA    17CA
17CE:  MOVWF  FAD
17D0:  MOVFF  11F,FF6
17D4:  MOVFF  120,FF7
17D8:  MOVLB  1
17DA:  DECFSZ x1E,F
17DC:  BRA    17E0
17DE:  BRA    17E4
17E0:  MOVLB  0
17E2:  BRA    17BE
17E4:  MOVLB  0
17E6:  RETURN 0
17E8:  TBLRD*+
17EA:  MOVF   FF5,F
17EC:  BZ    1808
17EE:  MOVFF  FF6,11B
17F2:  MOVFF  FF7,11C
17F6:  MOVF   FF5,W
17F8:  BTFSS  F9E.4
17FA:  BRA    17F8
17FC:  MOVWF  FAD
17FE:  MOVFF  11B,FF6
1802:  MOVFF  11C,FF7
1806:  BRA    17E8
1808:  RETURN 0
*
2878:  MOVFF  FEA,126
287C:  MOVFF  FE9,125
2880:  MOVLB  1
2882:  SWAPF  x1F,W
2884:  IORLW  F0
2886:  MOVWF  x21
2888:  ADDWF  x21,F
288A:  ADDLW  E2
288C:  MOVWF  x22
288E:  ADDLW  32
2890:  MOVWF  x24
2892:  MOVF   x1F,W
2894:  ANDLW  0F
2896:  ADDWF  x22,F
2898:  ADDWF  x22,F
289A:  ADDWF  x24,F
289C:  ADDLW  E9
289E:  MOVWF  x23
28A0:  ADDWF  x23,F
28A2:  ADDWF  x23,F
28A4:  SWAPF  x1E,W
28A6:  ANDLW  0F
28A8:  ADDWF  x23,F
28AA:  ADDWF  x24,F
28AC:  RLCF   x23,F
28AE:  RLCF   x24,F
28B0:  COMF   x24,F
28B2:  RLCF   x24,F
28B4:  MOVF   x1E,W
28B6:  ANDLW  0F
28B8:  ADDWF  x24,F
28BA:  RLCF   x21,F
28BC:  MOVLW  07
28BE:  MOVWF  x20
28C0:  MOVLW  0A
28C2:  DECF   x23,F
28C4:  ADDWF  x24,F
28C6:  BNC   28C2
28C8:  DECF   x22,F
28CA:  ADDWF  x23,F
28CC:  BNC   28C8
28CE:  DECF   x21,F
28D0:  ADDWF  x22,F
28D2:  BNC   28CE
28D4:  DECF   x20,F
28D6:  ADDWF  x21,F
28D8:  BNC   28D4
28DA:  MOVLW  01
28DC:  MOVWF  FEA
28DE:  MOVLW  20
28E0:  MOVWF  FE9
28E2:  MOVLW  07
28E4:  ANDWF  x25,W
28E6:  BCF    x25.6
28E8:  ADDWF  FE9,F
28EA:  MOVLW  00
28EC:  ADDWFC FEA,F
28EE:  MOVF   FE9,W
28F0:  SUBLW  24
28F2:  BNZ   28FA
28F4:  DECFSZ FEA,W
28F6:  BRA    28FA
28F8:  BSF    x25.6
28FA:  MOVF   FEF,W
28FC:  MOVWF  00
28FE:  BNZ   2910
2900:  BTFSC  x25.6
2902:  BRA    2910
2904:  BTFSC  x25.4
2906:  BRA    2920
2908:  BTFSC  x25.3
290A:  BRA    2910
290C:  MOVLW  20
290E:  BRA    2916
2910:  BSF    x25.3
2912:  BCF    x25.4
2914:  MOVLW  30
2916:  ADDWF  00,F
2918:  MOVF   00,W
291A:  BTFSS  F9E.4
291C:  BRA    291A
291E:  MOVWF  FAD
2920:  MOVF   FEE,W
2922:  BTFSS  x25.6
2924:  BRA    28EE
2926:  MOVLB  0
2928:  RETURN 0
292A:  MOVLB  1
292C:  BTFSC  x1D.7
292E:  BRA    2950
2930:  MOVLW  0F
2932:  MOVWF  00
2934:  SWAPF  x1C,W
2936:  ANDWF  00,F
2938:  MOVLW  0A
293A:  SUBWF  00,W
293C:  BC    2944
293E:  MOVLW  30
2940:  ADDWF  00,F
2942:  BRA    2948
2944:  MOVF   x1D,W
2946:  ADDWF  00,F
2948:  MOVF   00,W
294A:  BTFSS  F9E.4
294C:  BRA    294A
294E:  MOVWF  FAD
2950:  MOVLW  0F
2952:  ANDWF  x1C,F
2954:  MOVLW  0A
2956:  SUBWF  x1C,W
2958:  BC    295E
295A:  MOVLW  30
295C:  BRA    2962
295E:  BCF    x1D.7
2960:  MOVF   x1D,W
2962:  ADDWF  x1C,F
2964:  MOVF   x1C,W
2966:  BTFSS  F9E.4
2968:  BRA    2966
296A:  MOVWF  FAD
296C:  MOVLB  0
296E:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #device *=16
.................... #use delay(clock=16MHz)
*
1064:  MOVLW  01
1066:  MOVWF  FEA
1068:  MOVLW  28
106A:  MOVWF  FE9
106C:  MOVF   FEF,W
106E:  BZ    108C
1070:  MOVLW  05
1072:  MOVWF  01
1074:  CLRF   00
1076:  DECFSZ 00,F
1078:  BRA    1076
107A:  DECFSZ 01,F
107C:  BRA    1074
107E:  MOVLW  2E
1080:  MOVWF  00
1082:  DECFSZ 00,F
1084:  BRA    1082
1086:  BRA    1088
1088:  DECFSZ FEF,F
108A:  BRA    1070
108C:  RETURN 0
.................... 
.................... /* hardware I2C port is slave and is connected to DCSWC bus */
.................... #use i2c(stream=STREAM_SLAVE,SLAVE, I2C1, FORCE_HW)
*
0E74:  MOVF   FC9,W
0E76:  MOVFF  12D,FC9
0E7A:  BSF    FC6.4
0E7C:  BCF    F9E.3
0E7E:  BTFSC  FC7.0
0E80:  BRA    0E7E
0E82:  CLRF   01
0E84:  BTFSS  FC5.6
0E86:  INCF   01,F
0E88:  RETURN 0
.................... /* slave address set based on dip switch in init() */
.................... 
.................... 
.................... #fuses INTRC_IO
.................... #fuses NOPLLEN
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses PUT
.................... #fuses BROWNOUT
.................... #fuses WDT512
.................... #fuses NOHFOFST
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses NOLVP
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... #fuses NOPROTECT
.................... #fuses NOWRT
.................... #fuses NOWRTC 
.................... #fuses NOWRTB
.................... #fuses NOWRTD
.................... #fuses NOEBTR
.................... #fuses NOEBTRB
.................... 
.................... #use standard_io(ALL)
.................... 
.................... #use rs232(UART1,stream=STREAM_FTDI,baud=57600,errors)	
*
2860:  BTFSS  F9E.5
2862:  BRA    2860
2864:  MOVFF  FAB,1A
2868:  MOVFF  FAE,01
286C:  BTFSS  1A.1
286E:  BRA    2874
2870:  BCF    FAB.4
2872:  BSF    FAB.4
2874:  GOTO   2C44 (RETURN)
.................... 
.................... /* program config CRC of 0 and a serial_prefix of 'A' ... that will trigger a write default on first boot */
.................... #ROM 0xF00000 = { 0x00, 0x00, 0x40, 0x00 }
.................... 
.................... 
.................... 
.................... 
.................... #define SW_OVERRIDE_A        PIN_A5
.................... #define SW_OVERRIDE_B        PIN_A4
.................... #define BRIDGE_B_A           PIN_C5
.................... #define BRIDGE_A_B           PIN_C4
.................... #define BRIDGE_A_A           PIN_C3
.................... #define BRIDGE_B_B           PIN_C6
.................... #define AN_DIP               PIN_C7
.................... #define SER_TO_PC            PIN_B7
.................... #define AN_VTEMP             PIN_A2
.................... #define AN_IN_VOLTS          PIN_C0
.................... #define LED_A                PIN_C1
.................... #define LED_B                PIN_C2
.................... #define I2C_SDA              PIN_B4
.................... #define SER_FROM_PC          PIN_B5
.................... #define I2C_SCL              PIN_B6
.................... 
.................... 
.................... /* 
.................... Parameters are stored in EEPROM
.................... */
.................... #define PARAM_CRC_ADDRESS  0x00
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2
.................... 
.................... 
.................... 
.................... /* bit positions for a channel state byte */
.................... #define CH_STATE_BIT_FUTURE   7  /* reserved for future use */
.................... #define CH_STATE_BIT_HTD      6  /* high temperature disconnect */
.................... #define CH_STATE_BIT_LTD      5  /* low temperature disconnect */
.................... #define CH_STATE_BIT_HVD      4  /* high voltage disconnect */
.................... #define CH_STATE_BIT_LVD      3  /* low voltage disconnect */
.................... #define CH_STATE_BIT_CMD_OFF  2  /* commanded off */
.................... #define CH_STATE_BIT_CMD_ON   1  /* commanded on (takes presedence over commanded off) */
.................... #define CH_STATE_BIT_OVERRIDE 0  /* override switch */
.................... 
.................... /* _OVERRIDE or _CMD_ON set means output on */
.................... #define CH_STATE_MASK_ON     0b00000011 
.................... /* _CMD_OFF, _LVD, _HVD, _LTD, _HTD means output off, unless override by on mask */
.................... #define CH_STATE_MASK_OFF    0b01111100 
.................... 
.................... #define ADC_SAMPLE_TICKS              20
.................... #define CONTACTOR_POWER_SAVE_MS       200 /* milliseconds for contactor be on. Must be >0 and <= 255 */
.................... #define CONTACTOR_REFRESH_CYCLES      10  /* re-appply contactor coil voltage every N cycles. 65525 disables */
.................... 
.................... #define BLINK_ON_TIME                 254
.................... #define BLINK_OFF_TIME                200
.................... 
.................... 
.................... typedef struct {
.................... 	/* command on hold time */
.................... 	int16 command_on_hold_time;
.................... 
.................... 	/* command off hold time */
.................... 	int16 command_off_hold_time;
.................... 
.................... 	/* low voltage disconnect */
.................... 	int16 lvd_disconnect_adc;
.................... 	int16 lvd_disconnect_delay;
.................... 	int16 lvd_reconnect_adc;
.................... 	int16 lvd_reconnect_delay;
.................... 
.................... 	/* high voltage disconnect */
.................... 	int16 hvd_disconnect_adc;
.................... 	int16 hvd_disconnect_delay;
.................... 	int16 hvd_reconnect_adc;
.................... 	int16 hvd_reconnect_delay;
.................... 
.................... 	/* low temperature disconnect */
.................... 	int16 ltd_disconnect_adc;
.................... 	int16 ltd_disconnect_delay;
.................... 	int16 ltd_reconnect_adc;
.................... 	int16 ltd_reconnect_delay;
.................... 
.................... 	/* high temperature disconnect */
.................... 	int16 htd_disconnect_adc;
.................... 	int16 htd_disconnect_delay;
.................... 	int16 htd_reconnect_adc;
.................... 	int16 htd_reconnect_delay;
.................... } struct_config_channel;
.................... 
.................... typedef struct {
.................... 	/* not much going on here */
.................... 	struct_config_channel ch[2];
.................... } struct_config;
.................... 
.................... 
.................... typedef struct {
.................... 	int8 state;
.................... 
.................... 	int16 command_on_seconds;			/* counts down. Off at zero. */
.................... 	int16 command_on_hold_seconds;      /* counts down. Off at zero. */
.................... 
.................... 	int16 command_off_seconds;			/* counts down. Off at zero. */
.................... 	int16 command_off_hold_seconds;     /* counts down. Off at zero. */
.................... 
.................... 	int16 lvd_disconnect_delay_seconds;	/* counts down */
.................... 	int16  lvd_reconnect_delay_seconds;	/* counts down */
.................... 
.................... 	int16 hvd_disconnect_delay_seconds;	/* counts down */
.................... 	int16  hvd_reconnect_delay_seconds;	/* counts down */
.................... 
.................... 	int16 ltd_disconnect_delay_seconds; /* counts down */
.................... 	int16 ltd_reconnect_delay_seconds;  /* counts down */
.................... 
.................... 	int16 htd_disconnect_delay_seconds; /* counts down */
.................... 	int16 htd_reconnect_delay_seconds;  /* counts down */
.................... } struct_channel;
.................... 
.................... typedef struct {
.................... 	/* circular buffer for ADC readings */
.................... 	int16 adc_buffer[3][16];
.................... 	int8  adc_buffer_index;
.................... 
.................... 	int16 sequence_number;
.................... 	int16 uptime_minutes;
.................... 	int16 interval_milliseconds;
.................... 
.................... 	int8 factory_unlocked;
.................... 
.................... 
.................... 	int8 compile_year;
.................... 	int8 compile_month;
.................... 	int8 compile_day;
.................... 
.................... 
.................... 	int8 default_params_written;
.................... } struct_current;
.................... 
.................... typedef struct {
.................... 	/* action flags */
.................... 	int1 now_adc_sample;
.................... 	int1 now_adc_reset_count;
.................... 
.................... 	int1 now_millisecond;
.................... 
.................... 	int1 now_write_config;
.................... 	int1 now_reset_config;
.................... 
.................... 	int1 now_debug_dump;
.................... 
.................... 
.................... 	/* timers */
.................... 	int8 led_blink[2];
.................... 	int8 led_on[2];
.................... 	int8 led_off[2];
.................... 
.................... 	/* contactors */
.................... 	int8 contactor[2]; 	         /* current state */
.................... 	int8 contactor_powersave[2]; /* countdown to shut off power to coil at 0 */
.................... } struct_time_keep;
.................... 
.................... /* global structures */
.................... struct_config config={0};
.................... struct_current current={0};
.................... struct_time_keep timers={0};
.................... struct_channel channel[2]={0};
.................... 
.................... #include "adc_dcswc_module_latching_contactor.c"
.................... int16 adc_get(int8 ch) {
.................... 	int16 sum;
.................... 	int8 i;
.................... 
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */
.................... 	int16 *p;
.................... 	p = current.adc_buffer[ch];
*
0594:  MOVLB  1
0596:  MOVF   x2F,W
0598:  MULLW  20
059A:  MOVF   FF3,W
059C:  CLRF   03
059E:  ADDLW  63
05A0:  MOVWF  01
05A2:  MOVLW  00
05A4:  ADDWFC 03,F
05A6:  MOVFF  01,133
05AA:  MOVFF  03,134
.................... 
.................... 	// Calculate the mean.  This is done by summing up the
.................... 	// values and dividing by the number of elements.
.................... 	sum = 0;
05AE:  CLRF   x31
05B0:  CLRF   x30
.................... 	for( i = 0; i < 16 ; i++ ) {
05B2:  CLRF   x32
05B4:  MOVF   x32,W
05B6:  SUBLW  0F
05B8:  BNC   05E4
.................... //		sum += current.adc_buffer[ch][i];
.................... 		sum += p[i];
05BA:  CLRF   03
05BC:  MOVFF  132,02
05C0:  BCF    FD8.0
05C2:  RLCF   02,F
05C4:  RLCF   03,F
05C6:  MOVF   02,W
05C8:  ADDWF  x33,W
05CA:  MOVWF  FE9
05CC:  MOVF   x34,W
05CE:  ADDWFC 03,W
05D0:  MOVWF  FEA
05D2:  MOVFF  FEC,03
05D6:  MOVF   FED,F
05D8:  MOVF   FEF,W
05DA:  ADDWF  x30,F
05DC:  MOVF   03,W
05DE:  ADDWFC x31,F
05E0:  INCF   x32,F
05E2:  BRA    05B4
.................... 	}
.................... 
.................... 	/* divide sum by our 16 samples and round by adding 8 */
.................... 	return ( (sum+8) >> 4 );
05E4:  MOVLW  08
05E6:  ADDWF  x30,W
05E8:  MOVWF  x35
05EA:  MOVLW  00
05EC:  ADDWFC x31,W
05EE:  MOVWF  x36
05F0:  RRCF   x36,W
05F2:  MOVWF  03
05F4:  RRCF   x35,W
05F6:  MOVWF  02
05F8:  RRCF   03,F
05FA:  RRCF   02,F
05FC:  RRCF   03,F
05FE:  RRCF   02,F
0600:  RRCF   03,F
0602:  RRCF   02,F
0604:  MOVLW  0F
0606:  ANDWF  03,F
0608:  MOVFF  02,01
060C:  MOVFF  03,02
0610:  MOVLB  0
0612:  RETURN 0
.................... }
.................... 
.................... 
.................... void adc_update(void) {
.................... 
.................... 	/* wrap buffer around */
.................... 	current.adc_buffer_index++;
*
180A:  INCF   xC3,F
.................... 	if ( current.adc_buffer_index >= 16 )
180C:  MOVF   xC3,W
180E:  SUBLW  0F
1810:  BC    1814
.................... 		current.adc_buffer_index=0;
1812:  CLRF   xC3
.................... 
.................... 	set_adc_channel(4);
1814:  MOVLW  10
1816:  MOVWF  01
1818:  MOVF   FC2,W
181A:  ANDLW  C3
181C:  IORWF  01,W
181E:  MOVWF  FC2
.................... 	current.adc_buffer[0][current.adc_buffer_index] = read_adc();
1820:  BCF    FD8.0
1822:  RLCF   xC3,W
1824:  CLRF   03
1826:  ADDLW  63
1828:  MOVWF  FE9
182A:  MOVLW  00
182C:  ADDWFC 03,W
182E:  MOVWF  FEA
1830:  BSF    FC2.1
1832:  BTFSC  FC2.1
1834:  BRA    1832
1836:  MOVFF  FC3,FEF
183A:  MOVFF  FC4,FEC
.................... 
.................... 
.................... 	set_adc_channel(2);
183E:  MOVLW  08
1840:  MOVWF  01
1842:  MOVF   FC2,W
1844:  ANDLW  C3
1846:  IORWF  01,W
1848:  MOVWF  FC2
.................... 	delay_ms(1);
184A:  MOVLW  01
184C:  MOVLB  1
184E:  MOVWF  x28
1850:  MOVLB  0
1852:  RCALL  1064
.................... 	current.adc_buffer[1][current.adc_buffer_index] = read_adc();
1854:  BCF    FD8.0
1856:  RLCF   xC3,W
1858:  CLRF   03
185A:  ADDLW  83
185C:  MOVWF  FE9
185E:  MOVLW  00
1860:  ADDWFC 03,W
1862:  MOVWF  FEA
1864:  BSF    FC2.1
1866:  BTFSC  FC2.1
1868:  BRA    1866
186A:  MOVFF  FC3,FEF
186E:  MOVFF  FC4,FEC
.................... 
.................... 	set_adc_channel(9);
1872:  MOVLW  24
1874:  MOVWF  01
1876:  MOVF   FC2,W
1878:  ANDLW  C3
187A:  IORWF  01,W
187C:  MOVWF  FC2
.................... 	delay_ms(1);
187E:  MOVLW  01
1880:  MOVLB  1
1882:  MOVWF  x28
1884:  MOVLB  0
1886:  CALL   1064
.................... 	current.adc_buffer[2][current.adc_buffer_index] = read_adc();
188A:  BCF    FD8.0
188C:  RLCF   xC3,W
188E:  CLRF   03
1890:  ADDLW  A3
1892:  MOVWF  FE9
1894:  MOVLW  00
1896:  ADDWFC 03,W
1898:  MOVWF  FEA
189A:  BSF    FC2.1
189C:  BTFSC  FC2.1
189E:  BRA    189C
18A0:  MOVFF  FC3,FEF
18A4:  MOVFF  FC4,FEC
18A8:  RETURN 0
.................... }
.................... 
.................... int8 read_dip_switch(void) {
.................... 	int16 adc;
.................... 
.................... 	set_adc_channel(9);
*
108E:  MOVLW  24
1090:  MOVWF  01
1092:  MOVF   FC2,W
1094:  ANDLW  C3
1096:  IORWF  01,W
1098:  MOVWF  FC2
.................... 	delay_ms(1);
109A:  MOVLW  01
109C:  MOVLB  1
109E:  MOVWF  x28
10A0:  MOVLB  0
10A2:  RCALL  1064
.................... 	adc=read_adc();
10A4:  BSF    FC2.1
10A6:  BTFSC  FC2.1
10A8:  BRA    10A6
10AA:  MOVFF  FC4,127
10AE:  MOVFF  FC3,126
.................... 
.................... 	/* (note that table is sorted by vout reading 
.................... 	SW3.1 (LSB) SW3.2 (MSB) VALUE ADC
....................     OFF         OFF         0     1023
.................... 	OFF         ON          2     682
....................     ON          OFF         1     511
.................... 	ON          ON          3     409
.................... 	*/
.................... 
.................... 	if ( adc > (1023-64) )
10B2:  MOVLB  1
10B4:  MOVF   x27,W
10B6:  SUBLW  02
10B8:  BC    10CA
10BA:  XORLW  FF
10BC:  BNZ   10C4
10BE:  MOVF   x26,W
10C0:  SUBLW  BF
10C2:  BC    10CA
.................... 		return 0;
10C4:  MOVLW  00
10C6:  MOVWF  01
10C8:  BRA    10FA
.................... 	if ( adc > (682-64) )
10CA:  MOVF   x27,W
10CC:  SUBLW  01
10CE:  BC    10E0
10D0:  XORLW  FF
10D2:  BNZ   10DA
10D4:  MOVF   x26,W
10D6:  SUBLW  6A
10D8:  BC    10E0
.................... 		return 2;
10DA:  MOVLW  02
10DC:  MOVWF  01
10DE:  BRA    10FA
.................... 	if ( adc > (511-64) )
10E0:  MOVF   x27,W
10E2:  SUBLW  00
10E4:  BC    10F6
10E6:  XORLW  FF
10E8:  BNZ   10F0
10EA:  MOVF   x26,W
10EC:  SUBLW  BF
10EE:  BC    10F6
.................... 		return 1;
10F0:  MOVLW  01
10F2:  MOVWF  01
10F4:  BRA    10FA
.................... 
.................... 	return 3;
10F6:  MOVLW  03
10F8:  MOVWF  01
10FA:  MOVLB  0
10FC:  GOTO   13B2 (RETURN)
.................... }
.................... 
.................... #include "param_dcswc_module_latching_contactor.c"
.................... #inline
.................... char xor_crc(char oldcrc, char data) {
.................... 	return oldcrc ^ data;
*
142A:  MOVF   x28,W
142C:  XORWF  x29,W
142E:  MOVWF  01
*
1478:  MOVF   x28,W
147A:  XORWF  x29,W
147C:  MOVWF  01
.................... }
.................... 
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) {
*
13C2:  MOVLB  1
13C4:  CLRF   x24
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
13C6:  MOVFF  123,126
13CA:  MOVF   x22,W
13CC:  BTFSC  FD8.2
13CE:  DECF   x23,F
13D0:  DECF   x22,F
13D2:  MOVWF  x25
13D4:  MOVF   x25,F
13D6:  BNZ   13DC
13D8:  MOVF   x26,F
13DA:  BZ    143C
.................... 		*data = read_eeprom( address++ );
13DC:  MOVFF  121,03
13E0:  MOVF   x20,W
13E2:  MOVWF  FE9
13E4:  MOVFF  03,FEA
13E8:  MOVF   x1F,W
13EA:  MOVWF  03
13EC:  MOVF   x1E,W
13EE:  INCF   x1E,F
13F0:  BTFSC  FD8.2
13F2:  INCF   x1F,F
13F4:  MOVWF  x27
13F6:  MOVFF  03,128
13FA:  MOVFF  FF2,129
13FE:  BCF    FF2.7
1400:  MOVFF  127,FA9
1404:  BCF    FA6.6
1406:  BCF    FA6.7
1408:  BSF    FA6.0
140A:  MOVF   FA8,W
140C:  BTFSC  x29.7
140E:  BSF    FF2.7
1410:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data);
1412:  MOVFF  121,03
1416:  MOVF   x20,W
1418:  MOVWF  FE9
141A:  MOVFF  03,FEA
141E:  MOVFF  FEF,125
1422:  MOVFF  124,128
1426:  MOVFF  125,129
*
1430:  MOVFF  01,124
.................... 		data++;
1434:  INCF   x20,F
1436:  BTFSC  FD8.2
1438:  INCF   x21,F
143A:  BRA    13C6
.................... 	}
.................... 	return crc;
143C:  MOVFF  124,01
1440:  MOVLB  0
1442:  GOTO   1794 (RETURN)
.................... }
.................... 
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) {
1446:  MOVLB  1
1448:  CLRF   x26
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
144A:  MOVFF  125,128
144E:  MOVF   x24,W
1450:  BTFSC  FD8.2
1452:  DECF   x25,F
1454:  DECF   x24,F
1456:  MOVWF  x27
1458:  MOVF   x27,F
145A:  BNZ   1460
145C:  MOVF   x28,F
145E:  BZ    14D8
.................... 		/* restart_wdt() */
.................... 		crc = xor_crc(crc,*data);
1460:  MOVFF  123,03
1464:  MOVF   x22,W
1466:  MOVWF  FE9
1468:  MOVFF  03,FEA
146C:  MOVFF  FEF,127
1470:  MOVFF  126,128
1474:  MOVFF  127,129
*
147E:  MOVFF  01,126
.................... 		write_eeprom( address++, *data++ );
1482:  MOVF   x21,W
1484:  MOVWF  03
1486:  MOVF   x20,W
1488:  INCF   x20,F
148A:  BTFSC  FD8.2
148C:  INCF   x21,F
148E:  MOVWF  x27
1490:  MOVFF  03,128
1494:  MOVF   x23,W
1496:  MOVWF  03
1498:  MOVF   x22,W
149A:  INCF   x22,F
149C:  BTFSC  FD8.2
149E:  INCF   x23,F
14A0:  MOVWF  FE9
14A2:  MOVFF  03,FEA
14A6:  MOVFF  FEF,129
14AA:  MOVF   FF2,W
14AC:  MOVWF  00
14AE:  BCF    FF2.7
14B0:  MOVFF  127,FA9
14B4:  MOVFF  129,FA8
14B8:  BCF    FA6.6
14BA:  BCF    FA6.7
14BC:  BSF    FA6.2
14BE:  MOVLB  F
14C0:  MOVLW  55
14C2:  MOVWF  FA7
14C4:  MOVLW  AA
14C6:  MOVWF  FA7
14C8:  BSF    FA6.1
14CA:  BTFSC  FA6.1
14CC:  BRA    14CA
14CE:  BCF    FA6.2
14D0:  MOVF   00,W
14D2:  IORWF  FF2,F
14D4:  MOVLB  1
14D6:  BRA    144A
.................... 	}
.................... 
.................... 	return crc;
14D8:  MOVFF  126,01
14DC:  MOVLB  0
14DE:  GOTO   14FE (RETURN)
.................... }
.................... 
.................... void write_param_file() {
.................... 	int8 crc;
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config));
14E2:  MOVLB  1
14E4:  MOVLW  1B
14E6:  MOVWF  x1E
14E8:  CLRF   x21
14EA:  MOVLW  02
14EC:  MOVWF  x20
14EE:  CLRF   x23
14F0:  MOVFF  11E,122
14F4:  CLRF   x25
14F6:  MOVLW  48
14F8:  MOVWF  x24
14FA:  MOVLB  0
14FC:  BRA    1446
14FE:  MOVFF  01,11D
.................... 	/* write the CRC was calculated on the structure */
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc);
1502:  MOVF   FF2,W
1504:  MOVWF  00
1506:  BCF    FF2.7
1508:  CLRF   FA9
150A:  MOVFF  11D,FA8
150E:  BCF    FA6.6
1510:  BCF    FA6.7
1512:  BSF    FA6.2
1514:  MOVLB  F
1516:  MOVLW  55
1518:  MOVWF  FA7
151A:  MOVLW  AA
151C:  MOVWF  FA7
151E:  BSF    FA6.1
1520:  BTFSC  FA6.1
1522:  BRA    1520
1524:  BCF    FA6.2
1526:  MOVF   00,W
1528:  IORWF  FF2,F
152A:  MOVLB  0
152C:  RETURN 0
.................... }
.................... 
.................... void write_default_param_file() {
.................... 	int8 i;
.................... 
.................... 	current.default_params_written=1;
152E:  MOVLW  01
1530:  MOVWF  xCE
.................... 
.................... 	/* both LEDs on */
.................... 	timers.led_blink[0]=255;
1532:  SETF   xD0
.................... 	timers.led_blink[1]=255;
1534:  SETF   xD1
.................... 
.................... 
.................... 	for ( i=0 ; i<2 ; i++ ) {
1536:  MOVLB  1
1538:  CLRF   x1C
153A:  MOVF   x1C,W
153C:  SUBLW  01
153E:  BTFSS  FD8.0
1540:  BRA    1772
.................... 		/* low voltage disconnect */
.................... 		config.ch[i].lvd_disconnect_adc=606;
1542:  MOVF   x1C,W
1544:  MULLW  24
1546:  MOVF   FF3,W
1548:  CLRF   x1E
154A:  MOVWF  x1D
154C:  MOVLW  04
154E:  ADDWF  x1D,W
1550:  MOVWF  01
1552:  MOVLW  00
1554:  ADDWFC x1E,W
1556:  MOVWF  03
1558:  MOVF   01,W
155A:  ADDLW  1B
155C:  MOVWF  FE9
155E:  MOVLW  00
1560:  ADDWFC 03,W
1562:  MOVWF  FEA
1564:  MOVLW  02
1566:  MOVWF  FEC
1568:  MOVF   FED,F
156A:  MOVLW  5E
156C:  MOVWF  FEF
.................... 		config.ch[i].lvd_disconnect_delay=20; /* 65535 disables LVD */
156E:  MOVF   x1C,W
1570:  MULLW  24
1572:  MOVF   FF3,W
1574:  CLRF   x1E
1576:  MOVWF  x1D
1578:  MOVLW  06
157A:  ADDWF  x1D,W
157C:  MOVWF  01
157E:  MOVLW  00
1580:  ADDWFC x1E,W
1582:  MOVWF  03
1584:  MOVF   01,W
1586:  ADDLW  1B
1588:  MOVWF  FE9
158A:  MOVLW  00
158C:  ADDWFC 03,W
158E:  MOVWF  FEA
1590:  CLRF   FEC
1592:  MOVF   FED,F
1594:  MOVLW  14
1596:  MOVWF  FEF
.................... 		config.ch[i].lvd_reconnect_adc=616;
1598:  MOVF   x1C,W
159A:  MULLW  24
159C:  MOVF   FF3,W
159E:  CLRF   x1E
15A0:  MOVWF  x1D
15A2:  MOVLW  08
15A4:  ADDWF  x1D,W
15A6:  MOVWF  01
15A8:  MOVLW  00
15AA:  ADDWFC x1E,W
15AC:  MOVWF  03
15AE:  MOVF   01,W
15B0:  ADDLW  1B
15B2:  MOVWF  FE9
15B4:  MOVLW  00
15B6:  ADDWFC 03,W
15B8:  MOVWF  FEA
15BA:  MOVLW  02
15BC:  MOVWF  FEC
15BE:  MOVF   FED,F
15C0:  MOVLW  68
15C2:  MOVWF  FEF
.................... 		config.ch[i].lvd_reconnect_delay=10;
15C4:  MOVF   x1C,W
15C6:  MULLW  24
15C8:  MOVF   FF3,W
15CA:  CLRF   x1E
15CC:  MOVWF  x1D
15CE:  MOVLW  0A
15D0:  ADDWF  x1D,W
15D2:  MOVWF  01
15D4:  MOVLW  00
15D6:  ADDWFC x1E,W
15D8:  MOVWF  03
15DA:  MOVF   01,W
15DC:  ADDLW  1B
15DE:  MOVWF  FE9
15E0:  MOVLW  00
15E2:  ADDWFC 03,W
15E4:  MOVWF  FEA
15E6:  CLRF   FEC
15E8:  MOVF   FED,F
15EA:  MOVLW  0A
15EC:  MOVWF  FEF
.................... 		
.................... 		/* high voltage disconnect */
.................... 		config.ch[i].hvd_disconnect_adc=700;
15EE:  MOVF   x1C,W
15F0:  MULLW  24
15F2:  MOVF   FF3,W
15F4:  CLRF   x1E
15F6:  MOVWF  x1D
15F8:  MOVLW  0C
15FA:  ADDWF  x1D,W
15FC:  MOVWF  01
15FE:  MOVLW  00
1600:  ADDWFC x1E,W
1602:  MOVWF  03
1604:  MOVF   01,W
1606:  ADDLW  1B
1608:  MOVWF  FE9
160A:  MOVLW  00
160C:  ADDWFC 03,W
160E:  MOVWF  FEA
1610:  MOVLW  02
1612:  MOVWF  FEC
1614:  MOVF   FED,F
1616:  MOVLW  BC
1618:  MOVWF  FEF
.................... 		config.ch[i].hvd_disconnect_delay=1; /* 65535 disables HVD */
161A:  MOVF   x1C,W
161C:  MULLW  24
161E:  MOVF   FF3,W
1620:  CLRF   x1E
1622:  MOVWF  x1D
1624:  MOVLW  0E
1626:  ADDWF  x1D,W
1628:  MOVWF  01
162A:  MOVLW  00
162C:  ADDWFC x1E,W
162E:  MOVWF  03
1630:  MOVF   01,W
1632:  ADDLW  1B
1634:  MOVWF  FE9
1636:  MOVLW  00
1638:  ADDWFC 03,W
163A:  MOVWF  FEA
163C:  CLRF   FEC
163E:  MOVF   FED,F
1640:  MOVLW  01
1642:  MOVWF  FEF
.................... 		config.ch[i].hvd_reconnect_adc=650;
1644:  MOVF   x1C,W
1646:  MULLW  24
1648:  MOVF   FF3,W
164A:  CLRF   x1E
164C:  MOVWF  x1D
164E:  MOVLW  10
1650:  ADDWF  x1D,W
1652:  MOVWF  01
1654:  MOVLW  00
1656:  ADDWFC x1E,W
1658:  MOVWF  03
165A:  MOVF   01,W
165C:  ADDLW  1B
165E:  MOVWF  FE9
1660:  MOVLW  00
1662:  ADDWFC 03,W
1664:  MOVWF  FEA
1666:  MOVLW  02
1668:  MOVWF  FEC
166A:  MOVF   FED,F
166C:  MOVLW  8A
166E:  MOVWF  FEF
.................... 		config.ch[i].hvd_reconnect_delay=60;
1670:  MOVF   x1C,W
1672:  MULLW  24
1674:  MOVF   FF3,W
1676:  CLRF   x1E
1678:  MOVWF  x1D
167A:  MOVLW  12
167C:  ADDWF  x1D,W
167E:  MOVWF  01
1680:  MOVLW  00
1682:  ADDWFC x1E,W
1684:  MOVWF  03
1686:  MOVF   01,W
1688:  ADDLW  1B
168A:  MOVWF  FE9
168C:  MOVLW  00
168E:  ADDWFC 03,W
1690:  MOVWF  FEA
1692:  CLRF   FEC
1694:  MOVF   FED,F
1696:  MOVLW  3C
1698:  MOVWF  FEF
.................... 
.................... 		/* low temperature disconnect */
.................... 		config.ch[i].ltd_disconnect_adc=786; // 0C / 32F
169A:  MOVF   x1C,W
169C:  MULLW  24
169E:  MOVF   FF3,W
16A0:  CLRF   x1E
16A2:  MOVWF  x1D
16A4:  MOVLW  14
16A6:  ADDWF  x1D,W
16A8:  MOVWF  01
16AA:  MOVLW  00
16AC:  ADDWFC x1E,W
16AE:  MOVWF  03
16B0:  MOVF   01,W
16B2:  ADDLW  1B
16B4:  MOVWF  FE9
16B6:  MOVLW  00
16B8:  ADDWFC 03,W
16BA:  MOVWF  FEA
16BC:  MOVLW  03
16BE:  MOVWF  FEC
16C0:  MOVF   FED,F
16C2:  MOVLW  12
16C4:  MOVWF  FEF
.................... 		config.ch[i].ltd_disconnect_delay=1; /* 65535 disables LTD */
16C6:  MOVF   x1C,W
16C8:  MULLW  24
16CA:  MOVF   FF3,W
16CC:  CLRF   x1E
16CE:  MOVWF  x1D
16D0:  MOVLW  16
16D2:  ADDWF  x1D,W
16D4:  MOVWF  01
16D6:  MOVLW  00
16D8:  ADDWFC x1E,W
16DA:  MOVWF  03
16DC:  MOVF   01,W
16DE:  ADDLW  1B
16E0:  MOVWF  FE9
16E2:  MOVLW  00
16E4:  ADDWFC 03,W
16E6:  MOVWF  FEA
16E8:  CLRF   FEC
16EA:  MOVF   FED,F
16EC:  MOVLW  01
16EE:  MOVWF  FEF
.................... 		config.ch[i].ltd_reconnect_adc=683;  // 10C / 50F
16F0:  MOVF   x1C,W
16F2:  MULLW  24
16F4:  MOVF   FF3,W
16F6:  CLRF   x1E
16F8:  MOVWF  x1D
16FA:  MOVLW  18
16FC:  ADDWF  x1D,W
16FE:  MOVWF  01
1700:  MOVLW  00
1702:  ADDWFC x1E,W
1704:  MOVWF  03
1706:  MOVF   01,W
1708:  ADDLW  1B
170A:  MOVWF  FE9
170C:  MOVLW  00
170E:  ADDWFC 03,W
1710:  MOVWF  FEA
1712:  MOVLW  02
1714:  MOVWF  FEC
1716:  MOVF   FED,F
1718:  MOVLW  AB
171A:  MOVWF  FEF
.................... 		config.ch[i].ltd_reconnect_delay=4;
171C:  MOVF   x1C,W
171E:  MULLW  24
1720:  MOVF   FF3,W
1722:  CLRF   x1E
1724:  MOVWF  x1D
1726:  MOVLW  1A
1728:  ADDWF  x1D,W
172A:  MOVWF  01
172C:  MOVLW  00
172E:  ADDWFC x1E,W
1730:  MOVWF  03
1732:  MOVF   01,W
1734:  ADDLW  1B
1736:  MOVWF  FE9
1738:  MOVLW  00
173A:  ADDWFC 03,W
173C:  MOVWF  FEA
173E:  CLRF   FEC
1740:  MOVF   FED,F
1742:  MOVLW  04
1744:  MOVWF  FEF
.................... 
.................... 
.................... 		config.ch[i].htd_disconnect_delay=65535;
1746:  MOVF   x1C,W
1748:  MULLW  24
174A:  MOVF   FF3,W
174C:  CLRF   x1E
174E:  MOVWF  x1D
1750:  MOVLW  1E
1752:  ADDWF  x1D,W
1754:  MOVWF  01
1756:  MOVLW  00
1758:  ADDWFC x1E,W
175A:  MOVWF  03
175C:  MOVF   01,W
175E:  ADDLW  1B
1760:  MOVWF  FE9
1762:  MOVLW  00
1764:  ADDWFC 03,W
1766:  MOVWF  FEA
1768:  SETF   FEC
176A:  MOVF   FED,F
176C:  SETF   FEF
176E:  INCF   x1C,F
1770:  BRA    153A
.................... 	}
.................... 	
.................... 	/* write them so next time we use from EEPROM */
.................... 	write_param_file();
1772:  MOVLB  0
1774:  RCALL  14E2
1776:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void read_param_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config)); 
1778:  MOVLB  1
177A:  MOVLW  1B
177C:  MOVWF  x1C
177E:  CLRF   x1F
1780:  MOVLW  02
1782:  MOVWF  x1E
1784:  CLRF   x21
1786:  MOVFF  11C,120
178A:  CLRF   x23
178C:  MOVLW  48
178E:  MOVWF  x22
1790:  MOVLB  0
1792:  BRA    13C2
1794:  MOVFF  01,11B
.................... 		
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) {
1798:  MOVFF  FF2,11C
179C:  BCF    FF2.7
179E:  CLRF   FA9
17A0:  BCF    FA6.6
17A2:  BCF    FA6.7
17A4:  BSF    FA6.0
17A6:  MOVF   FA8,W
17A8:  MOVLB  1
17AA:  BTFSC  x1C.7
17AC:  BSF    FF2.7
17AE:  SUBWF  x1B,W
17B0:  BZ    17B8
.................... 		write_default_param_file();
17B2:  MOVLB  0
17B4:  RCALL  152E
17B6:  MOVLB  1
.................... 	}
17B8:  MOVLB  0
17BA:  GOTO   2B0E (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... #include "i2c_handler_dcswc_module_latching_contactor.c"
.................... #include "registers_dcswc_module_latching_contactor.h"
.................... 
.................... /* first two or three registers will give enough information for telemetry */
.................... /* 10 bit input voltage ADC averaged value */
.................... #define I2C_REG_VOLTAGE_INPUT_AVG             0  
.................... /* two 8 bit channel states (A is MSB / B is LSB) */
.................... #define I2C_REG_STATE_CONTACTORS              1 
.................... /* 10 bit NTC thermistor ADC averaged value */
.................... #define I2C_REG_TEMPERATURE_BOARD_AVG         2
.................... 
....................   
.................... /* channel 0 / A */
.................... /* command can only come from I2C interface */
.................... #define I2C_REG_CH0_COMMAND_ON                3 /* R/W seconds */
.................... #define I2C_REG_CH0_COMMAND_ON_HOLD           4
.................... 
.................... #define I2C_REG_CH0_COMMAND_OFF               5 /* R/W seconds */
.................... #define I2C_REG_CH0_COMMAND_OFF_HOLD          6
.................... 
.................... /* low voltage disconnect */
.................... #define I2C_REG_CH0_LVD_DISCONNECT            7  /* R seconds */
.................... #define I2C_REG_CH0_LVD_RECONNECT             8 
.................... 
.................... /* high voltage disconnect */
.................... #define I2C_REG_CH0_HVD_DISCONNECT            9 /* R seconds */
.................... #define I2C_REG_CH0_HVD_RECONNECT             10
.................... 
.................... /* low temperature disconnect */
.................... #define I2C_REG_CH0_LTD_DISCONNECT            11  /* R seconds */
.................... #define I2C_REG_CH0_LTD_RECONNECT             12
.................... 
.................... /* high temperature disconnect */
.................... #define I2C_REG_CH0_HTD_DISCONNECT            13 /* R seconds */
.................... #define I2C_REG_CH0_HTD_RECONNECT             14
.................... 
.................... /* reserved for future, unimplemented */
.................... #define I2C_REG_CH0_FUT_DISCONNECT            15 /* R seconds */
.................... #define I2C_REG_CH0_FUT_RECONNECT             16
.................... 
.................... /* channel 1 / B */
.................... /* command can only come from I2C interface */
.................... #define I2C_REG_CH1_COMMAND_ON                17 /* R/W seconds */
.................... #define I2C_REG_CH1_COMMAND_ON_HOLD           18
.................... 
.................... #define I2C_REG_CH1_COMMAND_OFF               19 /* R/W seconds */
.................... #define I2C_REG_CH1_COMMAND_OFF_HOLD          20
.................... 
.................... /* low voltage disconnect */
.................... #define I2C_REG_CH1_LVD_DISCONNECT            21 /* R seconds */
.................... #define I2C_REG_CH1_LVD_RECONNECT             22 
.................... 
.................... /* high voltage disconnect */
.................... #define I2C_REG_CH1_HVD_DISCONNECT            23 /* R seconds */
.................... #define I2C_REG_CH1_HVD_RECONNECT             24
.................... 
.................... /* low temperature disconnect */
.................... #define I2C_REG_CH1_LTD_DISCONNECT            25  /* R seconds */
.................... #define I2C_REG_CH1_LTD_RECONNECT             26
.................... 
.................... /* high temperature disconnect */
.................... #define I2C_REG_CH1_HTD_DISCONNECT            27 /* R seconds */
.................... #define I2C_REG_CH1_HTD_RECONNECT             28
.................... 
.................... /* reserved for future, unimplemented */
.................... #define I2C_REG_CH1_FUT_DISCONNECT            29 /* R seconds */
.................... #define I2C_REG_CH1_FUT_RECONNECT             30
.................... 
.................... /* meta */
.................... #define I2C_REG_SEQUENCE_NUMBER               31 /* R */
.................... #define I2C_REG_TIME_INTERVAL_MILLISECONDS    32
.................... #define I2C_REG_TIME_UPTIME_MINUTES           33
.................... #define I2C_REG_DEFAULT_PARAMS_WRITTEN        34
.................... 
.................... /* channel configuration */
.................... /* channel 0 / A */
.................... #define I2C_REG_CH0_COMMAND_ON_HOLD_INITIAL   64
.................... 
.................... #define I2C_REG_CH0_COMMAND_OFF_HOLD_INITIAL  65
.................... 
.................... #define I2C_REG_CH0_LVD_DISCONNECT_ADC        66
.................... #define I2C_REG_CH0_LVD_DISCONNECT_DELAY      67
.................... #define I2C_REG_CH0_LVD_RECONNECT_ADC         68
.................... #define I2C_REG_CH0_LVD_RECONNECT_DELAY       69
.................... 
.................... #define I2C_REG_CH0_HVD_DISCONNECT_ADC        70
.................... #define I2C_REG_CH0_HVD_DISCONNECT_DELAY      71
.................... #define I2C_REG_CH0_HVD_RECONNECT_ADC         72
.................... #define I2C_REG_CH0_HVD_RECONNECT_DELAY       73
.................... 
.................... #define I2C_REG_CH0_LTD_DISCONNECT_ADC        74
.................... #define I2C_REG_CH0_LTD_DISCONNECT_DELAY      75
.................... #define I2C_REG_CH0_LTD_RECONNECT_ADC         76
.................... #define I2C_REG_CH0_LTD_RECONNECT_DELAY       77
.................... 
.................... #define I2C_REG_CH0_HTD_DISCONNECT_ADC        78
.................... #define I2C_REG_CH0_HTD_DISCONNECT_DELAY      79
.................... #define I2C_REG_CH0_HTD_RECONNECT_ADC         80
.................... #define I2C_REG_CH0_HTD_RECONNECT_DELAY       81
.................... 
.................... #define I2C_REG_CH0_FUT_DISCONNECT_VALUE      82
.................... #define I2C_REG_CH0_FUT_DISCONNECT_DELAY      83
.................... #define I2C_REG_CH0_FUT_RECONNECT_VALUE       84
.................... #define I2C_REG_CH0_FUT_RECONNECT_DELAY       85
.................... 
.................... /* channel 1 / B */
.................... #define I2C_REG_CH1_COMMAND_ON_HOLD_INITIAL   86
.................... 
.................... #define I2C_REG_CH1_COMMAND_OFF_HOLD_INITIAL  87
.................... 
.................... #define I2C_REG_CH1_LVD_DISCONNECT_ADC        88
.................... #define I2C_REG_CH1_LVD_DISCONNECT_DELAY      89
.................... #define I2C_REG_CH1_LVD_RECONNECT_ADC         90
.................... #define I2C_REG_CH1_LVD_RECONNECT_DELAY       91
.................... 
.................... #define I2C_REG_CH1_HVD_DISCONNECT_ADC        92
.................... #define I2C_REG_CH1_HVD_DISCONNECT_DELAY      93
.................... #define I2C_REG_CH1_HVD_RECONNECT_ADC         94
.................... #define I2C_REG_CH1_HVD_RECONNECT_DELAY       95
.................... 
.................... #define I2C_REG_CH1_LTD_DISCONNECT_ADC        96
.................... #define I2C_REG_CH1_LTD_DISCONNECT_DELAY      97
.................... #define I2C_REG_CH1_LTD_RECONNECT_ADC         98
.................... #define I2C_REG_CH1_LTD_RECONNECT_DELAY       99
.................... 
.................... #define I2C_REG_CH1_HTD_DISCONNECT_ADC        100
.................... #define I2C_REG_CH1_HTD_DISCONNECT_DELAY      101
.................... #define I2C_REG_CH1_HTD_RECONNECT_ADC         102
.................... #define I2C_REG_CH1_HTD_RECONNECT_DELAY       103
.................... 
.................... #define I2C_REG_CH1_FUT_DISCONNECT_VALUE      104
.................... #define I2C_REG_CH1_FUT_DISCONNECT_DELAY      105
.................... #define I2C_REG_CH1_FUT_RECONNECT_VALUE       106
.................... #define I2C_REG_CH1_FUT_RECONNECT_DELAY       107
.................... 
.................... 
.................... /* configuration */
.................... #define I2C_REG_CONFIG_HARDWARE_MODEL              128 /* R */
.................... #define I2C_REG_CONFIG_HARDWARE_VERSION            129
.................... #define I2C_REG_CONFIG_SOFTWARE_MODEL              130
.................... #define I2C_REG_CONFIG_SOFTWARE_VERSION            131
.................... #define I2C_REG_CONFIG_SOFTWARE_YEAR               132
.................... #define I2C_REG_CONFIG_SOFTWARE_MONTH              133
.................... #define I2C_REG_CONFIG_SOFTWARE_DAY                134
.................... 
.................... #define I2C_REG_CONFIG_PARAM_WRITE                 135 /* R / W */
.................... 
.................... 
.................... 
.................... void write_i2c(int8 addr, int16 value) {
.................... 	int8 c;
.................... 
.................... 	/* c is the channel we are accessing based on register range */
.................... 	if ( addr >= I2C_REG_CH1_COMMAND_ON && addr <= I2C_REG_CH1_FUT_RECONNECT ) {
*
00DC:  MOVLB  1
00DE:  MOVF   x2F,W
00E0:  SUBLW  10
00E2:  BC    00F4
00E4:  MOVF   x2F,W
00E6:  SUBLW  1E
00E8:  BNC   00F4
.................... 		/* channel 1 status region */
.................... 		c=1;
00EA:  MOVLW  01
00EC:  MOVWF  x32
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON - I2C_REG_CH0_COMMAND_ON);
00EE:  MOVLW  0E
00F0:  SUBWF  x2F,F
.................... 	} else if ( addr >= I2C_REG_CH1_COMMAND_ON_HOLD && addr <= I2C_REG_CH1_FUT_RECONNECT_DELAY ) {
00F2:  BRA    010C
00F4:  MOVF   x2F,W
00F6:  SUBLW  11
00F8:  BC    010A
00FA:  MOVF   x2F,W
00FC:  SUBLW  6B
00FE:  BNC   010A
.................... 		/* channel 1 configuration region */
.................... 		c=1;
0100:  MOVLW  01
0102:  MOVWF  x32
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON_HOLD - I2C_REG_CH0_COMMAND_ON_HOLD );
0104:  MOVLW  0E
0106:  SUBWF  x2F,F
.................... 	} else {
0108:  BRA    010C
.................... 		c=0;
010A:  CLRF   x32
.................... 	}
.................... 
.................... 	switch ( addr ) {
010C:  MOVF   x2F,W
010E:  XORLW  03
0110:  MOVLB  0
0112:  BZ    018A
0114:  XORLW  07
0116:  BZ    01BA
0118:  XORLW  01
011A:  BZ    01EA
011C:  XORLW  03
011E:  BTFSC  FD8.2
0120:  BRA    021A
0122:  XORLW  44
0124:  BTFSC  FD8.2
0126:  BRA    024A
0128:  XORLW  01
012A:  BTFSC  FD8.2
012C:  BRA    027A
012E:  XORLW  07
0130:  BTFSC  FD8.2
0132:  BRA    02AA
0134:  XORLW  01
0136:  BTFSC  FD8.2
0138:  BRA    02DA
013A:  XORLW  03
013C:  BTFSC  FD8.2
013E:  BRA    030A
0140:  XORLW  01
0142:  BTFSC  FD8.2
0144:  BRA    033A
0146:  XORLW  0F
0148:  BTFSC  FD8.2
014A:  BRA    036A
014C:  XORLW  01
014E:  BTFSC  FD8.2
0150:  BRA    039A
0152:  XORLW  03
0154:  BTFSC  FD8.2
0156:  BRA    03CA
0158:  XORLW  01
015A:  BTFSC  FD8.2
015C:  BRA    03FA
015E:  XORLW  07
0160:  BTFSC  FD8.2
0162:  BRA    042A
0164:  XORLW  01
0166:  BTFSC  FD8.2
0168:  BRA    045A
016A:  XORLW  03
016C:  BTFSC  FD8.2
016E:  BRA    048A
0170:  XORLW  01
0172:  BTFSC  FD8.2
0174:  BRA    04BA
0176:  XORLW  1F
0178:  BTFSC  FD8.2
017A:  BRA    04EA
017C:  XORLW  01
017E:  BTFSC  FD8.2
0180:  BRA    051A
0182:  XORLW  D6
0184:  BTFSC  FD8.2
0186:  BRA    054A
0188:  BRA    0590
.................... 		case I2C_REG_CH0_COMMAND_ON:
.................... 			channel[c].command_on_seconds=value;
018A:  MOVLB  1
018C:  MOVF   x32,W
018E:  MULLW  19
0190:  MOVF   FF3,W
0192:  CLRF   x34
0194:  MOVWF  x33
0196:  MOVLW  01
0198:  ADDWF  x33,W
019A:  MOVWF  01
019C:  MOVLW  00
019E:  ADDWFC x34,W
01A0:  MOVWF  03
01A2:  MOVF   01,W
01A4:  ADDLW  DA
01A6:  MOVWF  FE9
01A8:  MOVLW  00
01AA:  ADDWFC 03,W
01AC:  MOVWF  FEA
01AE:  MOVFF  131,FEC
01B2:  MOVF   FED,F
01B4:  MOVFF  130,FEF
01B8:  MOVLB  0
.................... 		case I2C_REG_CH0_COMMAND_ON_HOLD:
.................... 			channel[c].command_on_hold_seconds=value;
01BA:  MOVLB  1
01BC:  MOVF   x32,W
01BE:  MULLW  19
01C0:  MOVF   FF3,W
01C2:  CLRF   x34
01C4:  MOVWF  x33
01C6:  MOVLW  03
01C8:  ADDWF  x33,W
01CA:  MOVWF  01
01CC:  MOVLW  00
01CE:  ADDWFC x34,W
01D0:  MOVWF  03
01D2:  MOVF   01,W
01D4:  ADDLW  DA
01D6:  MOVWF  FE9
01D8:  MOVLW  00
01DA:  ADDWFC 03,W
01DC:  MOVWF  FEA
01DE:  MOVFF  131,FEC
01E2:  MOVF   FED,F
01E4:  MOVFF  130,FEF
01E8:  MOVLB  0
.................... 	
.................... 		case I2C_REG_CH0_COMMAND_OFF:
.................... 			channel[c].command_off_seconds=value;
01EA:  MOVLB  1
01EC:  MOVF   x32,W
01EE:  MULLW  19
01F0:  MOVF   FF3,W
01F2:  CLRF   x34
01F4:  MOVWF  x33
01F6:  MOVLW  05
01F8:  ADDWF  x33,W
01FA:  MOVWF  01
01FC:  MOVLW  00
01FE:  ADDWFC x34,W
0200:  MOVWF  03
0202:  MOVF   01,W
0204:  ADDLW  DA
0206:  MOVWF  FE9
0208:  MOVLW  00
020A:  ADDWFC 03,W
020C:  MOVWF  FEA
020E:  MOVFF  131,FEC
0212:  MOVF   FED,F
0214:  MOVFF  130,FEF
0218:  MOVLB  0
.................... 		case I2C_REG_CH0_COMMAND_OFF_HOLD:
.................... 			channel[c].command_off_hold_seconds=value;
021A:  MOVLB  1
021C:  MOVF   x32,W
021E:  MULLW  19
0220:  MOVF   FF3,W
0222:  CLRF   x34
0224:  MOVWF  x33
0226:  MOVLW  07
0228:  ADDWF  x33,W
022A:  MOVWF  01
022C:  MOVLW  00
022E:  ADDWFC x34,W
0230:  MOVWF  03
0232:  MOVF   01,W
0234:  ADDLW  DA
0236:  MOVWF  FE9
0238:  MOVLW  00
023A:  ADDWFC 03,W
023C:  MOVWF  FEA
023E:  MOVFF  131,FEC
0242:  MOVF   FED,F
0244:  MOVFF  130,FEF
0248:  MOVLB  0
.................... 
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_ADC:
.................... 			config.ch[c].lvd_disconnect_adc=value;
024A:  MOVLB  1
024C:  MOVF   x32,W
024E:  MULLW  24
0250:  MOVF   FF3,W
0252:  CLRF   x34
0254:  MOVWF  x33
0256:  MOVLW  04
0258:  ADDWF  x33,W
025A:  MOVWF  01
025C:  MOVLW  00
025E:  ADDWFC x34,W
0260:  MOVWF  03
0262:  MOVF   01,W
0264:  ADDLW  1B
0266:  MOVWF  FE9
0268:  MOVLW  00
026A:  ADDWFC 03,W
026C:  MOVWF  FEA
026E:  MOVFF  131,FEC
0272:  MOVF   FED,F
0274:  MOVFF  130,FEF
0278:  MOVLB  0
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_DELAY:
.................... 			config.ch[c].lvd_disconnect_delay=value;
027A:  MOVLB  1
027C:  MOVF   x32,W
027E:  MULLW  24
0280:  MOVF   FF3,W
0282:  CLRF   x34
0284:  MOVWF  x33
0286:  MOVLW  06
0288:  ADDWF  x33,W
028A:  MOVWF  01
028C:  MOVLW  00
028E:  ADDWFC x34,W
0290:  MOVWF  03
0292:  MOVF   01,W
0294:  ADDLW  1B
0296:  MOVWF  FE9
0298:  MOVLW  00
029A:  ADDWFC 03,W
029C:  MOVWF  FEA
029E:  MOVFF  131,FEC
02A2:  MOVF   FED,F
02A4:  MOVFF  130,FEF
02A8:  MOVLB  0
.................... 		case I2C_REG_CH0_LVD_RECONNECT_ADC:
.................... 			config.ch[c].lvd_reconnect_adc=value;
02AA:  MOVLB  1
02AC:  MOVF   x32,W
02AE:  MULLW  24
02B0:  MOVF   FF3,W
02B2:  CLRF   x34
02B4:  MOVWF  x33
02B6:  MOVLW  08
02B8:  ADDWF  x33,W
02BA:  MOVWF  01
02BC:  MOVLW  00
02BE:  ADDWFC x34,W
02C0:  MOVWF  03
02C2:  MOVF   01,W
02C4:  ADDLW  1B
02C6:  MOVWF  FE9
02C8:  MOVLW  00
02CA:  ADDWFC 03,W
02CC:  MOVWF  FEA
02CE:  MOVFF  131,FEC
02D2:  MOVF   FED,F
02D4:  MOVFF  130,FEF
02D8:  MOVLB  0
.................... 		case I2C_REG_CH0_LVD_RECONNECT_DELAY:
.................... 			config.ch[c].lvd_reconnect_delay=value;
02DA:  MOVLB  1
02DC:  MOVF   x32,W
02DE:  MULLW  24
02E0:  MOVF   FF3,W
02E2:  CLRF   x34
02E4:  MOVWF  x33
02E6:  MOVLW  0A
02E8:  ADDWF  x33,W
02EA:  MOVWF  01
02EC:  MOVLW  00
02EE:  ADDWFC x34,W
02F0:  MOVWF  03
02F2:  MOVF   01,W
02F4:  ADDLW  1B
02F6:  MOVWF  FE9
02F8:  MOVLW  00
02FA:  ADDWFC 03,W
02FC:  MOVWF  FEA
02FE:  MOVFF  131,FEC
0302:  MOVF   FED,F
0304:  MOVFF  130,FEF
0308:  MOVLB  0
.................... 
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_ADC:
.................... 			config.ch[c].hvd_disconnect_adc=value;
030A:  MOVLB  1
030C:  MOVF   x32,W
030E:  MULLW  24
0310:  MOVF   FF3,W
0312:  CLRF   x34
0314:  MOVWF  x33
0316:  MOVLW  0C
0318:  ADDWF  x33,W
031A:  MOVWF  01
031C:  MOVLW  00
031E:  ADDWFC x34,W
0320:  MOVWF  03
0322:  MOVF   01,W
0324:  ADDLW  1B
0326:  MOVWF  FE9
0328:  MOVLW  00
032A:  ADDWFC 03,W
032C:  MOVWF  FEA
032E:  MOVFF  131,FEC
0332:  MOVF   FED,F
0334:  MOVFF  130,FEF
0338:  MOVLB  0
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_DELAY:
.................... 			config.ch[c].hvd_disconnect_delay=value;
033A:  MOVLB  1
033C:  MOVF   x32,W
033E:  MULLW  24
0340:  MOVF   FF3,W
0342:  CLRF   x34
0344:  MOVWF  x33
0346:  MOVLW  0E
0348:  ADDWF  x33,W
034A:  MOVWF  01
034C:  MOVLW  00
034E:  ADDWFC x34,W
0350:  MOVWF  03
0352:  MOVF   01,W
0354:  ADDLW  1B
0356:  MOVWF  FE9
0358:  MOVLW  00
035A:  ADDWFC 03,W
035C:  MOVWF  FEA
035E:  MOVFF  131,FEC
0362:  MOVF   FED,F
0364:  MOVFF  130,FEF
0368:  MOVLB  0
.................... 		case I2C_REG_CH0_HVD_RECONNECT_ADC:
.................... 			config.ch[c].hvd_reconnect_adc=value;
036A:  MOVLB  1
036C:  MOVF   x32,W
036E:  MULLW  24
0370:  MOVF   FF3,W
0372:  CLRF   x34
0374:  MOVWF  x33
0376:  MOVLW  10
0378:  ADDWF  x33,W
037A:  MOVWF  01
037C:  MOVLW  00
037E:  ADDWFC x34,W
0380:  MOVWF  03
0382:  MOVF   01,W
0384:  ADDLW  1B
0386:  MOVWF  FE9
0388:  MOVLW  00
038A:  ADDWFC 03,W
038C:  MOVWF  FEA
038E:  MOVFF  131,FEC
0392:  MOVF   FED,F
0394:  MOVFF  130,FEF
0398:  MOVLB  0
.................... 		case I2C_REG_CH0_HVD_RECONNECT_DELAY:
.................... 			config.ch[c].hvd_reconnect_delay=value;
039A:  MOVLB  1
039C:  MOVF   x32,W
039E:  MULLW  24
03A0:  MOVF   FF3,W
03A2:  CLRF   x34
03A4:  MOVWF  x33
03A6:  MOVLW  12
03A8:  ADDWF  x33,W
03AA:  MOVWF  01
03AC:  MOVLW  00
03AE:  ADDWFC x34,W
03B0:  MOVWF  03
03B2:  MOVF   01,W
03B4:  ADDLW  1B
03B6:  MOVWF  FE9
03B8:  MOVLW  00
03BA:  ADDWFC 03,W
03BC:  MOVWF  FEA
03BE:  MOVFF  131,FEC
03C2:  MOVF   FED,F
03C4:  MOVFF  130,FEF
03C8:  MOVLB  0
.................... 
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_ADC:
.................... 			config.ch[c].ltd_disconnect_adc=value;
03CA:  MOVLB  1
03CC:  MOVF   x32,W
03CE:  MULLW  24
03D0:  MOVF   FF3,W
03D2:  CLRF   x34
03D4:  MOVWF  x33
03D6:  MOVLW  14
03D8:  ADDWF  x33,W
03DA:  MOVWF  01
03DC:  MOVLW  00
03DE:  ADDWFC x34,W
03E0:  MOVWF  03
03E2:  MOVF   01,W
03E4:  ADDLW  1B
03E6:  MOVWF  FE9
03E8:  MOVLW  00
03EA:  ADDWFC 03,W
03EC:  MOVWF  FEA
03EE:  MOVFF  131,FEC
03F2:  MOVF   FED,F
03F4:  MOVFF  130,FEF
03F8:  MOVLB  0
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_DELAY:
.................... 			config.ch[c].ltd_disconnect_delay=value;
03FA:  MOVLB  1
03FC:  MOVF   x32,W
03FE:  MULLW  24
0400:  MOVF   FF3,W
0402:  CLRF   x34
0404:  MOVWF  x33
0406:  MOVLW  16
0408:  ADDWF  x33,W
040A:  MOVWF  01
040C:  MOVLW  00
040E:  ADDWFC x34,W
0410:  MOVWF  03
0412:  MOVF   01,W
0414:  ADDLW  1B
0416:  MOVWF  FE9
0418:  MOVLW  00
041A:  ADDWFC 03,W
041C:  MOVWF  FEA
041E:  MOVFF  131,FEC
0422:  MOVF   FED,F
0424:  MOVFF  130,FEF
0428:  MOVLB  0
.................... 		case I2C_REG_CH0_LTD_RECONNECT_ADC:
.................... 			config.ch[c].ltd_reconnect_adc=value;
042A:  MOVLB  1
042C:  MOVF   x32,W
042E:  MULLW  24
0430:  MOVF   FF3,W
0432:  CLRF   x34
0434:  MOVWF  x33
0436:  MOVLW  18
0438:  ADDWF  x33,W
043A:  MOVWF  01
043C:  MOVLW  00
043E:  ADDWFC x34,W
0440:  MOVWF  03
0442:  MOVF   01,W
0444:  ADDLW  1B
0446:  MOVWF  FE9
0448:  MOVLW  00
044A:  ADDWFC 03,W
044C:  MOVWF  FEA
044E:  MOVFF  131,FEC
0452:  MOVF   FED,F
0454:  MOVFF  130,FEF
0458:  MOVLB  0
.................... 		case I2C_REG_CH0_LTD_RECONNECT_DELAY:
.................... 			config.ch[c].ltd_reconnect_delay=value;
045A:  MOVLB  1
045C:  MOVF   x32,W
045E:  MULLW  24
0460:  MOVF   FF3,W
0462:  CLRF   x34
0464:  MOVWF  x33
0466:  MOVLW  1A
0468:  ADDWF  x33,W
046A:  MOVWF  01
046C:  MOVLW  00
046E:  ADDWFC x34,W
0470:  MOVWF  03
0472:  MOVF   01,W
0474:  ADDLW  1B
0476:  MOVWF  FE9
0478:  MOVLW  00
047A:  ADDWFC 03,W
047C:  MOVWF  FEA
047E:  MOVFF  131,FEC
0482:  MOVF   FED,F
0484:  MOVFF  130,FEF
0488:  MOVLB  0
.................... 
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_ADC:
.................... 			config.ch[c].htd_disconnect_adc=value;
048A:  MOVLB  1
048C:  MOVF   x32,W
048E:  MULLW  24
0490:  MOVF   FF3,W
0492:  CLRF   x34
0494:  MOVWF  x33
0496:  MOVLW  1C
0498:  ADDWF  x33,W
049A:  MOVWF  01
049C:  MOVLW  00
049E:  ADDWFC x34,W
04A0:  MOVWF  03
04A2:  MOVF   01,W
04A4:  ADDLW  1B
04A6:  MOVWF  FE9
04A8:  MOVLW  00
04AA:  ADDWFC 03,W
04AC:  MOVWF  FEA
04AE:  MOVFF  131,FEC
04B2:  MOVF   FED,F
04B4:  MOVFF  130,FEF
04B8:  MOVLB  0
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_DELAY:
.................... 			config.ch[c].htd_disconnect_delay=value;
04BA:  MOVLB  1
04BC:  MOVF   x32,W
04BE:  MULLW  24
04C0:  MOVF   FF3,W
04C2:  CLRF   x34
04C4:  MOVWF  x33
04C6:  MOVLW  1E
04C8:  ADDWF  x33,W
04CA:  MOVWF  01
04CC:  MOVLW  00
04CE:  ADDWFC x34,W
04D0:  MOVWF  03
04D2:  MOVF   01,W
04D4:  ADDLW  1B
04D6:  MOVWF  FE9
04D8:  MOVLW  00
04DA:  ADDWFC 03,W
04DC:  MOVWF  FEA
04DE:  MOVFF  131,FEC
04E2:  MOVF   FED,F
04E4:  MOVFF  130,FEF
04E8:  MOVLB  0
.................... 		case I2C_REG_CH0_HTD_RECONNECT_ADC:
.................... 			config.ch[c].htd_reconnect_adc=value;
04EA:  MOVLB  1
04EC:  MOVF   x32,W
04EE:  MULLW  24
04F0:  MOVF   FF3,W
04F2:  CLRF   x34
04F4:  MOVWF  x33
04F6:  MOVLW  20
04F8:  ADDWF  x33,W
04FA:  MOVWF  01
04FC:  MOVLW  00
04FE:  ADDWFC x34,W
0500:  MOVWF  03
0502:  MOVF   01,W
0504:  ADDLW  1B
0506:  MOVWF  FE9
0508:  MOVLW  00
050A:  ADDWFC 03,W
050C:  MOVWF  FEA
050E:  MOVFF  131,FEC
0512:  MOVF   FED,F
0514:  MOVFF  130,FEF
0518:  MOVLB  0
.................... 		case I2C_REG_CH0_HTD_RECONNECT_DELAY:
.................... 			config.ch[c].htd_reconnect_delay=value;
051A:  MOVLB  1
051C:  MOVF   x32,W
051E:  MULLW  24
0520:  MOVF   FF3,W
0522:  CLRF   x34
0524:  MOVWF  x33
0526:  MOVLW  22
0528:  ADDWF  x33,W
052A:  MOVWF  01
052C:  MOVLW  00
052E:  ADDWFC x34,W
0530:  MOVWF  03
0532:  MOVF   01,W
0534:  ADDLW  1B
0536:  MOVWF  FE9
0538:  MOVLW  00
053A:  ADDWFC 03,W
053C:  MOVWF  FEA
053E:  MOVFF  131,FEC
0542:  MOVF   FED,F
0544:  MOVFF  130,FEF
0548:  MOVLB  0
.................... 
.................... 		/* don't need to implement FUT ... there is nowhere for it to go anyhow */
.................... 
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			if ( 1 == value ) {
054A:  MOVLB  1
054C:  DECFSZ x30,W
054E:  BRA    055C
0550:  MOVF   x31,F
0552:  BNZ   055C
.................... 				timers.now_write_config=1;
0554:  MOVLB  0
0556:  BSF    xCF.3
.................... 			} else if ( 2 == value ) {
0558:  BRA    0590
055A:  MOVLB  1
055C:  MOVF   x30,W
055E:  SUBLW  02
0560:  BNZ   056E
0562:  MOVF   x31,F
0564:  BNZ   056E
.................... 				timers.now_reset_config=1;
0566:  MOVLB  0
0568:  BSF    xCF.4
.................... 			} else if ( 1802 == value ) {
056A:  BRA    0590
056C:  MOVLB  1
056E:  MOVF   x30,W
0570:  SUBLW  0A
0572:  BNZ   0584
0574:  MOVF   x31,W
0576:  SUBLW  07
0578:  BNZ   0584
.................... 				current.factory_unlocked =1;
057A:  MOVLW  01
057C:  MOVLB  0
057E:  MOVWF  xCA
.................... 			} else if ( 65535 == value ) {
0580:  BRA    0590
0582:  MOVLB  1
0584:  INCFSZ x30,W
0586:  BRA    058E
0588:  INCFSZ x31,W
058A:  BRA    058E
.................... 				reset_cpu();
058C:  RESET
058E:  MOVLB  0
.................... 			}
.................... 			break;
.................... 		default:
.................... 			/* do nothing */
.................... 	}
0590:  GOTO   0F14 (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... int16 map_i2c(int8 addr) {
.................... 	int8 c;
.................... 
.................... 	/* c is the channel we are accessing based on register range */
.................... 	if ( addr >= I2C_REG_CH1_COMMAND_ON && addr <= I2C_REG_CH1_FUT_RECONNECT ) {
*
0614:  MOVLB  1
0616:  MOVF   x2D,W
0618:  SUBLW  10
061A:  BC    062C
061C:  MOVF   x2D,W
061E:  SUBLW  1E
0620:  BNC   062C
.................... 		/* channel 1 status region */
.................... 		c=1;
0622:  MOVLW  01
0624:  MOVWF  x2E
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON - I2C_REG_CH0_COMMAND_ON);
0626:  MOVLW  0E
0628:  SUBWF  x2D,F
.................... 	} else if ( addr >= I2C_REG_CH1_COMMAND_ON_HOLD && addr <= I2C_REG_CH1_FUT_RECONNECT_DELAY ) {
062A:  BRA    0644
062C:  MOVF   x2D,W
062E:  SUBLW  11
0630:  BC    0642
0632:  MOVF   x2D,W
0634:  SUBLW  6B
0636:  BNC   0642
.................... 		/* channel 1 configuration region */
.................... 		c=1;
0638:  MOVLW  01
063A:  MOVWF  x2E
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON_HOLD - I2C_REG_CH0_COMMAND_ON_HOLD );
063C:  MOVLW  0E
063E:  SUBWF  x2D,F
.................... 	} else {
0640:  BRA    0644
.................... 		c=0;
0642:  CLRF   x2E
.................... 	}
.................... 
.................... 	switch ( addr ) {
0644:  MOVF   x2D,W
0646:  XORLW  00
0648:  MOVLB  0
064A:  BTFSC  FD8.2
064C:  BRA    077C
064E:  XORLW  01
0650:  BTFSC  FD8.2
0652:  BRA    0788
0654:  XORLW  03
0656:  BTFSC  FD8.2
0658:  BRA    0796
065A:  XORLW  01
065C:  BTFSC  FD8.2
065E:  BRA    07A4
0660:  XORLW  07
0662:  BTFSC  FD8.2
0664:  BRA    07DA
0666:  XORLW  01
0668:  BTFSC  FD8.2
066A:  BRA    0810
066C:  XORLW  03
066E:  BTFSC  FD8.2
0670:  BRA    0846
0672:  XORLW  01
0674:  BTFSC  FD8.2
0676:  BRA    087C
0678:  XORLW  0F
067A:  BTFSC  FD8.2
067C:  BRA    08B2
067E:  XORLW  01
0680:  BTFSC  FD8.2
0682:  BRA    08E8
0684:  XORLW  03
0686:  BTFSC  FD8.2
0688:  BRA    091E
068A:  XORLW  01
068C:  BTFSC  FD8.2
068E:  BRA    0954
0690:  XORLW  07
0692:  BTFSC  FD8.2
0694:  BRA    098A
0696:  XORLW  01
0698:  BTFSC  FD8.2
069A:  BRA    09C0
069C:  XORLW  03
069E:  BTFSC  FD8.2
06A0:  BRA    09F6
06A2:  XORLW  01
06A4:  BTFSC  FD8.2
06A6:  BRA    0A2C
06A8:  XORLW  1F
06AA:  BTFSC  FD8.2
06AC:  BRA    0A2C
06AE:  XORLW  0F
06B0:  BTFSC  FD8.2
06B2:  BRA    0A34
06B4:  XORLW  3F
06B6:  BTFSC  FD8.2
06B8:  BRA    0A3E
06BA:  XORLW  01
06BC:  BTFSC  FD8.2
06BE:  BRA    0A48
06C0:  XORLW  03
06C2:  BTFSC  FD8.2
06C4:  BRA    0A52
06C6:  XORLW  62
06C8:  BTFSC  FD8.2
06CA:  BRA    0A5A
06CC:  XORLW  01
06CE:  BTFSC  FD8.2
06D0:  BRA    0A84
06D2:  XORLW  03
06D4:  BTFSC  FD8.2
06D6:  BRA    0ABA
06D8:  XORLW  01
06DA:  BTFSC  FD8.2
06DC:  BRA    0AF0
06DE:  XORLW  07
06E0:  BTFSC  FD8.2
06E2:  BRA    0B26
06E4:  XORLW  01
06E6:  BTFSC  FD8.2
06E8:  BRA    0B5C
06EA:  XORLW  03
06EC:  BTFSC  FD8.2
06EE:  BRA    0B92
06F0:  XORLW  01
06F2:  BTFSC  FD8.2
06F4:  BRA    0BC8
06F6:  XORLW  0F
06F8:  BTFSC  FD8.2
06FA:  BRA    0BFE
06FC:  XORLW  01
06FE:  BTFSC  FD8.2
0700:  BRA    0C34
0702:  XORLW  03
0704:  BTFSC  FD8.2
0706:  BRA    0C6A
0708:  XORLW  01
070A:  BTFSC  FD8.2
070C:  BRA    0CA0
070E:  XORLW  07
0710:  BTFSC  FD8.2
0712:  BRA    0CD6
0714:  XORLW  01
0716:  BTFSC  FD8.2
0718:  BRA    0D0C
071A:  XORLW  03
071C:  BTFSC  FD8.2
071E:  BRA    0D42
0720:  XORLW  01
0722:  BTFSC  FD8.2
0724:  BRA    0D78
0726:  XORLW  1F
0728:  BTFSC  FD8.2
072A:  BRA    0DAE
072C:  XORLW  01
072E:  BTFSC  FD8.2
0730:  BRA    0DE4
0732:  XORLW  03
0734:  BTFSC  FD8.2
0736:  BRA    0E1A
0738:  XORLW  01
073A:  BTFSC  FD8.2
073C:  BRA    0E1A
073E:  XORLW  07
0740:  BTFSC  FD8.2
0742:  BRA    0E1A
0744:  XORLW  01
0746:  BTFSC  FD8.2
0748:  BRA    0E1A
074A:  XORLW  D5
074C:  BTFSC  FD8.2
074E:  BRA    0E22
0750:  XORLW  01
0752:  BTFSC  FD8.2
0754:  BRA    0E2C
0756:  XORLW  03
0758:  BTFSC  FD8.2
075A:  BRA    0E36
075C:  XORLW  01
075E:  BTFSC  FD8.2
0760:  BRA    0E40
0762:  XORLW  07
0764:  BTFSC  FD8.2
0766:  BRA    0E4A
0768:  XORLW  01
076A:  BTFSC  FD8.2
076C:  BRA    0E52
076E:  XORLW  03
0770:  BTFSC  FD8.2
0772:  BRA    0E5A
0774:  XORLW  01
0776:  BTFSC  FD8.2
0778:  BRA    0E62
077A:  BRA    0E6A
.................... 		/* not channel based */
.................... 		case I2C_REG_VOLTAGE_INPUT_AVG: 
.................... 			return (int16) adc_get(0);
077C:  MOVLB  1
077E:  CLRF   x2F
0780:  MOVLB  0
0782:  RCALL  0594
0784:  MOVF   02,W
0786:  BRA    0E70
.................... 		case I2C_REG_STATE_CONTACTORS:
.................... 			return (int16) make16(channel[0].state,channel[1].state);
0788:  MOVFF  DA,03
078C:  MOVFF  F3,01
0790:  MOVFF  DA,02
0794:  BRA    0E70
.................... 		case I2C_REG_TEMPERATURE_BOARD_AVG: 
.................... 			return (int16) adc_get(1);
0796:  MOVLW  01
0798:  MOVLB  1
079A:  MOVWF  x2F
079C:  MOVLB  0
079E:  RCALL  0594
07A0:  MOVF   02,W
07A2:  BRA    0E70
.................... 
.................... 		/* status based on channel value c */
.................... 		case I2C_REG_CH0_COMMAND_ON :
.................... 			return (int16) channel[c].command_on_seconds;
07A4:  MOVLB  1
07A6:  MOVF   x2E,W
07A8:  MULLW  19
07AA:  MOVF   FF3,W
07AC:  CLRF   x30
07AE:  MOVWF  x2F
07B0:  MOVLW  01
07B2:  ADDWF  x2F,W
07B4:  MOVWF  01
07B6:  MOVLW  00
07B8:  ADDWFC x30,W
07BA:  MOVWF  03
07BC:  MOVF   01,W
07BE:  ADDLW  DA
07C0:  MOVWF  FE9
07C2:  MOVLW  00
07C4:  ADDWFC 03,W
07C6:  MOVWF  FEA
07C8:  MOVFF  FEC,03
07CC:  MOVF   FED,F
07CE:  MOVFF  FEF,01
07D2:  MOVFF  03,02
07D6:  MOVLB  0
07D8:  BRA    0E70
.................... 		case I2C_REG_CH0_COMMAND_ON_HOLD:
.................... 			return (int16) channel[c].command_on_hold_seconds;
07DA:  MOVLB  1
07DC:  MOVF   x2E,W
07DE:  MULLW  19
07E0:  MOVF   FF3,W
07E2:  CLRF   x30
07E4:  MOVWF  x2F
07E6:  MOVLW  03
07E8:  ADDWF  x2F,W
07EA:  MOVWF  01
07EC:  MOVLW  00
07EE:  ADDWFC x30,W
07F0:  MOVWF  03
07F2:  MOVF   01,W
07F4:  ADDLW  DA
07F6:  MOVWF  FE9
07F8:  MOVLW  00
07FA:  ADDWFC 03,W
07FC:  MOVWF  FEA
07FE:  MOVFF  FEC,03
0802:  MOVF   FED,F
0804:  MOVFF  FEF,01
0808:  MOVFF  03,02
080C:  MOVLB  0
080E:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_COMMAND_OFF:
.................... 			return (int16) channel[c].command_off_seconds;
0810:  MOVLB  1
0812:  MOVF   x2E,W
0814:  MULLW  19
0816:  MOVF   FF3,W
0818:  CLRF   x30
081A:  MOVWF  x2F
081C:  MOVLW  05
081E:  ADDWF  x2F,W
0820:  MOVWF  01
0822:  MOVLW  00
0824:  ADDWFC x30,W
0826:  MOVWF  03
0828:  MOVF   01,W
082A:  ADDLW  DA
082C:  MOVWF  FE9
082E:  MOVLW  00
0830:  ADDWFC 03,W
0832:  MOVWF  FEA
0834:  MOVFF  FEC,03
0838:  MOVF   FED,F
083A:  MOVFF  FEF,01
083E:  MOVFF  03,02
0842:  MOVLB  0
0844:  BRA    0E70
.................... 		case I2C_REG_CH0_COMMAND_OFF_HOLD:
.................... 			return (int16) channel[c].command_off_hold_seconds;
0846:  MOVLB  1
0848:  MOVF   x2E,W
084A:  MULLW  19
084C:  MOVF   FF3,W
084E:  CLRF   x30
0850:  MOVWF  x2F
0852:  MOVLW  07
0854:  ADDWF  x2F,W
0856:  MOVWF  01
0858:  MOVLW  00
085A:  ADDWFC x30,W
085C:  MOVWF  03
085E:  MOVF   01,W
0860:  ADDLW  DA
0862:  MOVWF  FE9
0864:  MOVLW  00
0866:  ADDWFC 03,W
0868:  MOVWF  FEA
086A:  MOVFF  FEC,03
086E:  MOVF   FED,F
0870:  MOVFF  FEF,01
0874:  MOVFF  03,02
0878:  MOVLB  0
087A:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_LVD_DISCONNECT:
.................... 			return (int16) channel[c].lvd_disconnect_delay_seconds;
087C:  MOVLB  1
087E:  MOVF   x2E,W
0880:  MULLW  19
0882:  MOVF   FF3,W
0884:  CLRF   x30
0886:  MOVWF  x2F
0888:  MOVLW  09
088A:  ADDWF  x2F,W
088C:  MOVWF  01
088E:  MOVLW  00
0890:  ADDWFC x30,W
0892:  MOVWF  03
0894:  MOVF   01,W
0896:  ADDLW  DA
0898:  MOVWF  FE9
089A:  MOVLW  00
089C:  ADDWFC 03,W
089E:  MOVWF  FEA
08A0:  MOVFF  FEC,03
08A4:  MOVF   FED,F
08A6:  MOVFF  FEF,01
08AA:  MOVFF  03,02
08AE:  MOVLB  0
08B0:  BRA    0E70
.................... 		case I2C_REG_CH0_LVD_RECONNECT:
.................... 			return (int16) channel[c].lvd_reconnect_delay_seconds;
08B2:  MOVLB  1
08B4:  MOVF   x2E,W
08B6:  MULLW  19
08B8:  MOVF   FF3,W
08BA:  CLRF   x30
08BC:  MOVWF  x2F
08BE:  MOVLW  0B
08C0:  ADDWF  x2F,W
08C2:  MOVWF  01
08C4:  MOVLW  00
08C6:  ADDWFC x30,W
08C8:  MOVWF  03
08CA:  MOVF   01,W
08CC:  ADDLW  DA
08CE:  MOVWF  FE9
08D0:  MOVLW  00
08D2:  ADDWFC 03,W
08D4:  MOVWF  FEA
08D6:  MOVFF  FEC,03
08DA:  MOVF   FED,F
08DC:  MOVFF  FEF,01
08E0:  MOVFF  03,02
08E4:  MOVLB  0
08E6:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_HVD_DISCONNECT:
.................... 			return (int16) channel[c].hvd_disconnect_delay_seconds;
08E8:  MOVLB  1
08EA:  MOVF   x2E,W
08EC:  MULLW  19
08EE:  MOVF   FF3,W
08F0:  CLRF   x30
08F2:  MOVWF  x2F
08F4:  MOVLW  0D
08F6:  ADDWF  x2F,W
08F8:  MOVWF  01
08FA:  MOVLW  00
08FC:  ADDWFC x30,W
08FE:  MOVWF  03
0900:  MOVF   01,W
0902:  ADDLW  DA
0904:  MOVWF  FE9
0906:  MOVLW  00
0908:  ADDWFC 03,W
090A:  MOVWF  FEA
090C:  MOVFF  FEC,03
0910:  MOVF   FED,F
0912:  MOVFF  FEF,01
0916:  MOVFF  03,02
091A:  MOVLB  0
091C:  BRA    0E70
.................... 		case I2C_REG_CH0_HVD_RECONNECT:
.................... 			return (int16) channel[c].hvd_reconnect_delay_seconds;
091E:  MOVLB  1
0920:  MOVF   x2E,W
0922:  MULLW  19
0924:  MOVF   FF3,W
0926:  CLRF   x30
0928:  MOVWF  x2F
092A:  MOVLW  0F
092C:  ADDWF  x2F,W
092E:  MOVWF  01
0930:  MOVLW  00
0932:  ADDWFC x30,W
0934:  MOVWF  03
0936:  MOVF   01,W
0938:  ADDLW  DA
093A:  MOVWF  FE9
093C:  MOVLW  00
093E:  ADDWFC 03,W
0940:  MOVWF  FEA
0942:  MOVFF  FEC,03
0946:  MOVF   FED,F
0948:  MOVFF  FEF,01
094C:  MOVFF  03,02
0950:  MOVLB  0
0952:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_LTD_DISCONNECT:
.................... 			return (int16) channel[c].ltd_disconnect_delay_seconds;
0954:  MOVLB  1
0956:  MOVF   x2E,W
0958:  MULLW  19
095A:  MOVF   FF3,W
095C:  CLRF   x30
095E:  MOVWF  x2F
0960:  MOVLW  11
0962:  ADDWF  x2F,W
0964:  MOVWF  01
0966:  MOVLW  00
0968:  ADDWFC x30,W
096A:  MOVWF  03
096C:  MOVF   01,W
096E:  ADDLW  DA
0970:  MOVWF  FE9
0972:  MOVLW  00
0974:  ADDWFC 03,W
0976:  MOVWF  FEA
0978:  MOVFF  FEC,03
097C:  MOVF   FED,F
097E:  MOVFF  FEF,01
0982:  MOVFF  03,02
0986:  MOVLB  0
0988:  BRA    0E70
.................... 		case I2C_REG_CH0_LTD_RECONNECT:
.................... 			return (int16) channel[c].ltd_reconnect_delay_seconds;
098A:  MOVLB  1
098C:  MOVF   x2E,W
098E:  MULLW  19
0990:  MOVF   FF3,W
0992:  CLRF   x30
0994:  MOVWF  x2F
0996:  MOVLW  13
0998:  ADDWF  x2F,W
099A:  MOVWF  01
099C:  MOVLW  00
099E:  ADDWFC x30,W
09A0:  MOVWF  03
09A2:  MOVF   01,W
09A4:  ADDLW  DA
09A6:  MOVWF  FE9
09A8:  MOVLW  00
09AA:  ADDWFC 03,W
09AC:  MOVWF  FEA
09AE:  MOVFF  FEC,03
09B2:  MOVF   FED,F
09B4:  MOVFF  FEF,01
09B8:  MOVFF  03,02
09BC:  MOVLB  0
09BE:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_HTD_DISCONNECT:
.................... 			return (int16) channel[c].htd_disconnect_delay_seconds;
09C0:  MOVLB  1
09C2:  MOVF   x2E,W
09C4:  MULLW  19
09C6:  MOVF   FF3,W
09C8:  CLRF   x30
09CA:  MOVWF  x2F
09CC:  MOVLW  15
09CE:  ADDWF  x2F,W
09D0:  MOVWF  01
09D2:  MOVLW  00
09D4:  ADDWFC x30,W
09D6:  MOVWF  03
09D8:  MOVF   01,W
09DA:  ADDLW  DA
09DC:  MOVWF  FE9
09DE:  MOVLW  00
09E0:  ADDWFC 03,W
09E2:  MOVWF  FEA
09E4:  MOVFF  FEC,03
09E8:  MOVF   FED,F
09EA:  MOVFF  FEF,01
09EE:  MOVFF  03,02
09F2:  MOVLB  0
09F4:  BRA    0E70
.................... 		case I2C_REG_CH0_HTD_RECONNECT:
.................... 			return (int16) channel[c].htd_reconnect_delay_seconds;
09F6:  MOVLB  1
09F8:  MOVF   x2E,W
09FA:  MULLW  19
09FC:  MOVF   FF3,W
09FE:  CLRF   x30
0A00:  MOVWF  x2F
0A02:  MOVLW  17
0A04:  ADDWF  x2F,W
0A06:  MOVWF  01
0A08:  MOVLW  00
0A0A:  ADDWFC x30,W
0A0C:  MOVWF  03
0A0E:  MOVF   01,W
0A10:  ADDLW  DA
0A12:  MOVWF  FE9
0A14:  MOVLW  00
0A16:  ADDWFC 03,W
0A18:  MOVWF  FEA
0A1A:  MOVFF  FEC,03
0A1E:  MOVF   FED,F
0A20:  MOVFF  FEF,01
0A24:  MOVFF  03,02
0A28:  MOVLB  0
0A2A:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_FUT_DISCONNECT:
.................... 		case I2C_REG_CH0_FUT_RECONNECT:
.................... 			return (int16) 0xffff; /* not yet implemented */
0A2C:  MOVLW  FF
0A2E:  MOVWF  01
0A30:  MOVWF  02
0A32:  BRA    0E70
.................... 
.................... 
.................... 		/* non-channel based meta */
.................... 		case I2C_REG_SEQUENCE_NUMBER:
.................... 			return (int16) current.sequence_number;
0A34:  MOVFF  C4,01
0A38:  MOVFF  C5,02
0A3C:  BRA    0E70
.................... 		case I2C_REG_TIME_INTERVAL_MILLISECONDS:
.................... 			return (int16) current.interval_milliseconds;
0A3E:  MOVFF  C8,01
0A42:  MOVFF  C9,02
0A46:  BRA    0E70
.................... 		case I2C_REG_TIME_UPTIME_MINUTES:
.................... 			return (int16) current.uptime_minutes;
0A48:  MOVFF  C6,01
0A4C:  MOVFF  C7,02
0A50:  BRA    0E70
.................... 		case I2C_REG_DEFAULT_PARAMS_WRITTEN:
.................... 			return (int16) current.default_params_written;
0A52:  MOVFF  CE,01
0A56:  CLRF   02
0A58:  BRA    0E70
.................... 
.................... 		/* channel based configuration */
.................... 		case I2C_REG_CH0_COMMAND_ON_HOLD_INITIAL:
.................... 			return (int16) config.ch[c].command_on_hold_time;
0A5A:  MOVLB  1
0A5C:  MOVF   x2E,W
0A5E:  MULLW  24
0A60:  MOVF   FF3,W
0A62:  CLRF   x30
0A64:  MOVWF  x2F
0A66:  MOVLW  1B
0A68:  ADDWF  x2F,W
0A6A:  MOVWF  FE9
0A6C:  MOVLW  00
0A6E:  ADDWFC x30,W
0A70:  MOVWF  FEA
0A72:  MOVFF  FEC,03
0A76:  MOVF   FED,F
0A78:  MOVFF  FEF,01
0A7C:  MOVFF  03,02
0A80:  MOVLB  0
0A82:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_COMMAND_OFF_HOLD_INITIAL:
.................... 			return (int16) config.ch[c].command_off_hold_time;
0A84:  MOVLB  1
0A86:  MOVF   x2E,W
0A88:  MULLW  24
0A8A:  MOVF   FF3,W
0A8C:  CLRF   x30
0A8E:  MOVWF  x2F
0A90:  MOVLW  02
0A92:  ADDWF  x2F,W
0A94:  MOVWF  01
0A96:  MOVLW  00
0A98:  ADDWFC x30,W
0A9A:  MOVWF  03
0A9C:  MOVF   01,W
0A9E:  ADDLW  1B
0AA0:  MOVWF  FE9
0AA2:  MOVLW  00
0AA4:  ADDWFC 03,W
0AA6:  MOVWF  FEA
0AA8:  MOVFF  FEC,03
0AAC:  MOVF   FED,F
0AAE:  MOVFF  FEF,01
0AB2:  MOVFF  03,02
0AB6:  MOVLB  0
0AB8:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].lvd_disconnect_adc;
0ABA:  MOVLB  1
0ABC:  MOVF   x2E,W
0ABE:  MULLW  24
0AC0:  MOVF   FF3,W
0AC2:  CLRF   x30
0AC4:  MOVWF  x2F
0AC6:  MOVLW  04
0AC8:  ADDWF  x2F,W
0ACA:  MOVWF  01
0ACC:  MOVLW  00
0ACE:  ADDWFC x30,W
0AD0:  MOVWF  03
0AD2:  MOVF   01,W
0AD4:  ADDLW  1B
0AD6:  MOVWF  FE9
0AD8:  MOVLW  00
0ADA:  ADDWFC 03,W
0ADC:  MOVWF  FEA
0ADE:  MOVFF  FEC,03
0AE2:  MOVF   FED,F
0AE4:  MOVFF  FEF,01
0AE8:  MOVFF  03,02
0AEC:  MOVLB  0
0AEE:  BRA    0E70
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].lvd_disconnect_delay;
0AF0:  MOVLB  1
0AF2:  MOVF   x2E,W
0AF4:  MULLW  24
0AF6:  MOVF   FF3,W
0AF8:  CLRF   x30
0AFA:  MOVWF  x2F
0AFC:  MOVLW  06
0AFE:  ADDWF  x2F,W
0B00:  MOVWF  01
0B02:  MOVLW  00
0B04:  ADDWFC x30,W
0B06:  MOVWF  03
0B08:  MOVF   01,W
0B0A:  ADDLW  1B
0B0C:  MOVWF  FE9
0B0E:  MOVLW  00
0B10:  ADDWFC 03,W
0B12:  MOVWF  FEA
0B14:  MOVFF  FEC,03
0B18:  MOVF   FED,F
0B1A:  MOVFF  FEF,01
0B1E:  MOVFF  03,02
0B22:  MOVLB  0
0B24:  BRA    0E70
.................... 		case I2C_REG_CH0_LVD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].lvd_reconnect_adc;
0B26:  MOVLB  1
0B28:  MOVF   x2E,W
0B2A:  MULLW  24
0B2C:  MOVF   FF3,W
0B2E:  CLRF   x30
0B30:  MOVWF  x2F
0B32:  MOVLW  08
0B34:  ADDWF  x2F,W
0B36:  MOVWF  01
0B38:  MOVLW  00
0B3A:  ADDWFC x30,W
0B3C:  MOVWF  03
0B3E:  MOVF   01,W
0B40:  ADDLW  1B
0B42:  MOVWF  FE9
0B44:  MOVLW  00
0B46:  ADDWFC 03,W
0B48:  MOVWF  FEA
0B4A:  MOVFF  FEC,03
0B4E:  MOVF   FED,F
0B50:  MOVFF  FEF,01
0B54:  MOVFF  03,02
0B58:  MOVLB  0
0B5A:  BRA    0E70
.................... 		case I2C_REG_CH0_LVD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].lvd_reconnect_delay;
0B5C:  MOVLB  1
0B5E:  MOVF   x2E,W
0B60:  MULLW  24
0B62:  MOVF   FF3,W
0B64:  CLRF   x30
0B66:  MOVWF  x2F
0B68:  MOVLW  0A
0B6A:  ADDWF  x2F,W
0B6C:  MOVWF  01
0B6E:  MOVLW  00
0B70:  ADDWFC x30,W
0B72:  MOVWF  03
0B74:  MOVF   01,W
0B76:  ADDLW  1B
0B78:  MOVWF  FE9
0B7A:  MOVLW  00
0B7C:  ADDWFC 03,W
0B7E:  MOVWF  FEA
0B80:  MOVFF  FEC,03
0B84:  MOVF   FED,F
0B86:  MOVFF  FEF,01
0B8A:  MOVFF  03,02
0B8E:  MOVLB  0
0B90:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].hvd_disconnect_adc;
0B92:  MOVLB  1
0B94:  MOVF   x2E,W
0B96:  MULLW  24
0B98:  MOVF   FF3,W
0B9A:  CLRF   x30
0B9C:  MOVWF  x2F
0B9E:  MOVLW  0C
0BA0:  ADDWF  x2F,W
0BA2:  MOVWF  01
0BA4:  MOVLW  00
0BA6:  ADDWFC x30,W
0BA8:  MOVWF  03
0BAA:  MOVF   01,W
0BAC:  ADDLW  1B
0BAE:  MOVWF  FE9
0BB0:  MOVLW  00
0BB2:  ADDWFC 03,W
0BB4:  MOVWF  FEA
0BB6:  MOVFF  FEC,03
0BBA:  MOVF   FED,F
0BBC:  MOVFF  FEF,01
0BC0:  MOVFF  03,02
0BC4:  MOVLB  0
0BC6:  BRA    0E70
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].hvd_disconnect_delay;
0BC8:  MOVLB  1
0BCA:  MOVF   x2E,W
0BCC:  MULLW  24
0BCE:  MOVF   FF3,W
0BD0:  CLRF   x30
0BD2:  MOVWF  x2F
0BD4:  MOVLW  0E
0BD6:  ADDWF  x2F,W
0BD8:  MOVWF  01
0BDA:  MOVLW  00
0BDC:  ADDWFC x30,W
0BDE:  MOVWF  03
0BE0:  MOVF   01,W
0BE2:  ADDLW  1B
0BE4:  MOVWF  FE9
0BE6:  MOVLW  00
0BE8:  ADDWFC 03,W
0BEA:  MOVWF  FEA
0BEC:  MOVFF  FEC,03
0BF0:  MOVF   FED,F
0BF2:  MOVFF  FEF,01
0BF6:  MOVFF  03,02
0BFA:  MOVLB  0
0BFC:  BRA    0E70
.................... 		case I2C_REG_CH0_HVD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].hvd_reconnect_adc;
0BFE:  MOVLB  1
0C00:  MOVF   x2E,W
0C02:  MULLW  24
0C04:  MOVF   FF3,W
0C06:  CLRF   x30
0C08:  MOVWF  x2F
0C0A:  MOVLW  10
0C0C:  ADDWF  x2F,W
0C0E:  MOVWF  01
0C10:  MOVLW  00
0C12:  ADDWFC x30,W
0C14:  MOVWF  03
0C16:  MOVF   01,W
0C18:  ADDLW  1B
0C1A:  MOVWF  FE9
0C1C:  MOVLW  00
0C1E:  ADDWFC 03,W
0C20:  MOVWF  FEA
0C22:  MOVFF  FEC,03
0C26:  MOVF   FED,F
0C28:  MOVFF  FEF,01
0C2C:  MOVFF  03,02
0C30:  MOVLB  0
0C32:  BRA    0E70
.................... 		case I2C_REG_CH0_HVD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].hvd_reconnect_delay;
0C34:  MOVLB  1
0C36:  MOVF   x2E,W
0C38:  MULLW  24
0C3A:  MOVF   FF3,W
0C3C:  CLRF   x30
0C3E:  MOVWF  x2F
0C40:  MOVLW  12
0C42:  ADDWF  x2F,W
0C44:  MOVWF  01
0C46:  MOVLW  00
0C48:  ADDWFC x30,W
0C4A:  MOVWF  03
0C4C:  MOVF   01,W
0C4E:  ADDLW  1B
0C50:  MOVWF  FE9
0C52:  MOVLW  00
0C54:  ADDWFC 03,W
0C56:  MOVWF  FEA
0C58:  MOVFF  FEC,03
0C5C:  MOVF   FED,F
0C5E:  MOVFF  FEF,01
0C62:  MOVFF  03,02
0C66:  MOVLB  0
0C68:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_disconnect_adc;
0C6A:  MOVLB  1
0C6C:  MOVF   x2E,W
0C6E:  MULLW  24
0C70:  MOVF   FF3,W
0C72:  CLRF   x30
0C74:  MOVWF  x2F
0C76:  MOVLW  14
0C78:  ADDWF  x2F,W
0C7A:  MOVWF  01
0C7C:  MOVLW  00
0C7E:  ADDWFC x30,W
0C80:  MOVWF  03
0C82:  MOVF   01,W
0C84:  ADDLW  1B
0C86:  MOVWF  FE9
0C88:  MOVLW  00
0C8A:  ADDWFC 03,W
0C8C:  MOVWF  FEA
0C8E:  MOVFF  FEC,03
0C92:  MOVF   FED,F
0C94:  MOVFF  FEF,01
0C98:  MOVFF  03,02
0C9C:  MOVLB  0
0C9E:  BRA    0E70
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_disconnect_delay;
0CA0:  MOVLB  1
0CA2:  MOVF   x2E,W
0CA4:  MULLW  24
0CA6:  MOVF   FF3,W
0CA8:  CLRF   x30
0CAA:  MOVWF  x2F
0CAC:  MOVLW  16
0CAE:  ADDWF  x2F,W
0CB0:  MOVWF  01
0CB2:  MOVLW  00
0CB4:  ADDWFC x30,W
0CB6:  MOVWF  03
0CB8:  MOVF   01,W
0CBA:  ADDLW  1B
0CBC:  MOVWF  FE9
0CBE:  MOVLW  00
0CC0:  ADDWFC 03,W
0CC2:  MOVWF  FEA
0CC4:  MOVFF  FEC,03
0CC8:  MOVF   FED,F
0CCA:  MOVFF  FEF,01
0CCE:  MOVFF  03,02
0CD2:  MOVLB  0
0CD4:  BRA    0E70
.................... 		case I2C_REG_CH0_LTD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_reconnect_adc;
0CD6:  MOVLB  1
0CD8:  MOVF   x2E,W
0CDA:  MULLW  24
0CDC:  MOVF   FF3,W
0CDE:  CLRF   x30
0CE0:  MOVWF  x2F
0CE2:  MOVLW  18
0CE4:  ADDWF  x2F,W
0CE6:  MOVWF  01
0CE8:  MOVLW  00
0CEA:  ADDWFC x30,W
0CEC:  MOVWF  03
0CEE:  MOVF   01,W
0CF0:  ADDLW  1B
0CF2:  MOVWF  FE9
0CF4:  MOVLW  00
0CF6:  ADDWFC 03,W
0CF8:  MOVWF  FEA
0CFA:  MOVFF  FEC,03
0CFE:  MOVF   FED,F
0D00:  MOVFF  FEF,01
0D04:  MOVFF  03,02
0D08:  MOVLB  0
0D0A:  BRA    0E70
.................... 		case I2C_REG_CH0_LTD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_reconnect_delay;
0D0C:  MOVLB  1
0D0E:  MOVF   x2E,W
0D10:  MULLW  24
0D12:  MOVF   FF3,W
0D14:  CLRF   x30
0D16:  MOVWF  x2F
0D18:  MOVLW  1A
0D1A:  ADDWF  x2F,W
0D1C:  MOVWF  01
0D1E:  MOVLW  00
0D20:  ADDWFC x30,W
0D22:  MOVWF  03
0D24:  MOVF   01,W
0D26:  ADDLW  1B
0D28:  MOVWF  FE9
0D2A:  MOVLW  00
0D2C:  ADDWFC 03,W
0D2E:  MOVWF  FEA
0D30:  MOVFF  FEC,03
0D34:  MOVF   FED,F
0D36:  MOVFF  FEF,01
0D3A:  MOVFF  03,02
0D3E:  MOVLB  0
0D40:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_disconnect_adc;
0D42:  MOVLB  1
0D44:  MOVF   x2E,W
0D46:  MULLW  24
0D48:  MOVF   FF3,W
0D4A:  CLRF   x30
0D4C:  MOVWF  x2F
0D4E:  MOVLW  14
0D50:  ADDWF  x2F,W
0D52:  MOVWF  01
0D54:  MOVLW  00
0D56:  ADDWFC x30,W
0D58:  MOVWF  03
0D5A:  MOVF   01,W
0D5C:  ADDLW  1B
0D5E:  MOVWF  FE9
0D60:  MOVLW  00
0D62:  ADDWFC 03,W
0D64:  MOVWF  FEA
0D66:  MOVFF  FEC,03
0D6A:  MOVF   FED,F
0D6C:  MOVFF  FEF,01
0D70:  MOVFF  03,02
0D74:  MOVLB  0
0D76:  BRA    0E70
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_disconnect_delay;
0D78:  MOVLB  1
0D7A:  MOVF   x2E,W
0D7C:  MULLW  24
0D7E:  MOVF   FF3,W
0D80:  CLRF   x30
0D82:  MOVWF  x2F
0D84:  MOVLW  16
0D86:  ADDWF  x2F,W
0D88:  MOVWF  01
0D8A:  MOVLW  00
0D8C:  ADDWFC x30,W
0D8E:  MOVWF  03
0D90:  MOVF   01,W
0D92:  ADDLW  1B
0D94:  MOVWF  FE9
0D96:  MOVLW  00
0D98:  ADDWFC 03,W
0D9A:  MOVWF  FEA
0D9C:  MOVFF  FEC,03
0DA0:  MOVF   FED,F
0DA2:  MOVFF  FEF,01
0DA6:  MOVFF  03,02
0DAA:  MOVLB  0
0DAC:  BRA    0E70
.................... 		case I2C_REG_CH0_HTD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_reconnect_adc;
0DAE:  MOVLB  1
0DB0:  MOVF   x2E,W
0DB2:  MULLW  24
0DB4:  MOVF   FF3,W
0DB6:  CLRF   x30
0DB8:  MOVWF  x2F
0DBA:  MOVLW  18
0DBC:  ADDWF  x2F,W
0DBE:  MOVWF  01
0DC0:  MOVLW  00
0DC2:  ADDWFC x30,W
0DC4:  MOVWF  03
0DC6:  MOVF   01,W
0DC8:  ADDLW  1B
0DCA:  MOVWF  FE9
0DCC:  MOVLW  00
0DCE:  ADDWFC 03,W
0DD0:  MOVWF  FEA
0DD2:  MOVFF  FEC,03
0DD6:  MOVF   FED,F
0DD8:  MOVFF  FEF,01
0DDC:  MOVFF  03,02
0DE0:  MOVLB  0
0DE2:  BRA    0E70
.................... 		case I2C_REG_CH0_HTD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_reconnect_delay;	
0DE4:  MOVLB  1
0DE6:  MOVF   x2E,W
0DE8:  MULLW  24
0DEA:  MOVF   FF3,W
0DEC:  CLRF   x30
0DEE:  MOVWF  x2F
0DF0:  MOVLW  1A
0DF2:  ADDWF  x2F,W
0DF4:  MOVWF  01
0DF6:  MOVLW  00
0DF8:  ADDWFC x30,W
0DFA:  MOVWF  03
0DFC:  MOVF   01,W
0DFE:  ADDLW  1B
0E00:  MOVWF  FE9
0E02:  MOVLW  00
0E04:  ADDWFC 03,W
0E06:  MOVWF  FEA
0E08:  MOVFF  FEC,03
0E0C:  MOVF   FED,F
0E0E:  MOVFF  FEF,01
0E12:  MOVFF  03,02
0E16:  MOVLB  0
0E18:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_FUT_DISCONNECT_VALUE:
.................... 		case I2C_REG_CH0_FUT_DISCONNECT_DELAY:
.................... 		case I2C_REG_CH0_FUT_RECONNECT_VALUE:
.................... 		case I2C_REG_CH0_FUT_RECONNECT_DELAY:
.................... 			return (int16) 0xffff; /* not yet implemented */
0E1A:  MOVLW  FF
0E1C:  MOVWF  01
0E1E:  MOVWF  02
0E20:  BRA    0E70
.................... 		
.................... 		/* configuration */
.................... 		case I2C_REG_CONFIG_HARDWARE_MODEL: 
.................... 			return (int16) 'D';
0E22:  MOVLW  44
0E24:  MOVWF  01
0E26:  MOVLW  00
0E28:  MOVWF  02
0E2A:  BRA    0E70
.................... 		case I2C_REG_CONFIG_HARDWARE_VERSION: 
.................... 			return (int16) '2';
0E2C:  MOVLW  32
0E2E:  MOVWF  01
0E30:  MOVLW  00
0E32:  MOVWF  02
0E34:  BRA    0E70
.................... 		case I2C_REG_CONFIG_SOFTWARE_MODEL: 
.................... 			return (int16) 'L';
0E36:  MOVLW  4C
0E38:  MOVWF  01
0E3A:  MOVLW  00
0E3C:  MOVWF  02
0E3E:  BRA    0E70
.................... 		case I2C_REG_CONFIG_SOFTWARE_VERSION: 
.................... 			return (int16) '0';
0E40:  MOVLW  30
0E42:  MOVWF  01
0E44:  MOVLW  00
0E46:  MOVWF  02
0E48:  BRA    0E70
.................... 		case I2C_REG_CONFIG_SOFTWARE_YEAR:
.................... 			return (int16) current.compile_year;
0E4A:  MOVFF  CB,01
0E4E:  CLRF   02
0E50:  BRA    0E70
.................... 		case I2C_REG_CONFIG_SOFTWARE_MONTH:
.................... 			return (int16) current.compile_month;
0E52:  MOVFF  CC,01
0E56:  CLRF   02
0E58:  BRA    0E70
.................... 		case I2C_REG_CONFIG_SOFTWARE_DAY:
.................... 			return (int16) current.compile_day;
0E5A:  MOVFF  CD,01
0E5E:  CLRF   02
0E60:  BRA    0E70
.................... 
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			/* 1 if factory unlocked */ 
.................... 			return (int16) current.factory_unlocked; 	
0E62:  MOVFF  CA,01
0E66:  CLRF   02
0E68:  BRA    0E70
.................... 
.................... 		/* we should have range checked, and never gotten here ... or read unimplemented (future) register */
.................... 		default: return (int16) 0xffff;
0E6A:  MOVLW  FF
0E6C:  MOVWF  01
0E6E:  MOVWF  02
.................... 	}
0E70:  GOTO   0F2E (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... 
.................... 
.................... #include "interrupt_dcswc_module_latching_contactor.c"
.................... #int_timer2
.................... void isr_timer2() {
.................... 	timers.now_millisecond=1;
*
00D4:  BSF    xCF.2
.................... }
.................... 
.................... 
.................... 
.................... /* I2C slave interrupt */
00D6:  BCF    F9E.1
00D8:  GOTO   006C
.................... #byte SSPSTAT=GETENV("SFR:SSPSTAT")
.................... #INT_SSP
.................... void ssp_interrupt () {
.................... 	static int8 sstate;
.................... 	int8 state;
.................... 	int8 incoming;
.................... 	static int16 lastValue;
.................... 	static int8 lastMSB;
.................... 
.................... 	static int8 address; 
.................... 
.................... 	/* 
.................... 	our implementation of i2c_isr_state() that won't overflow and switch states
.................... 	but it will quit counting at 127 bytes. 
.................... 	If more bytes are needed, external counting variables can be used or the size of state can be made larger
.................... 	*/
.................... 
.................... 
.................... 	if ( ! bit_test(SSPSTAT,5) ) {
*
0E8A:  BTFSC  FC7.5
0E8C:  BRA    0E9A
.................... 		/* address */
.................... 		sstate=0;
0E8E:  MOVLB  1
0E90:  CLRF   x0C
.................... 
.................... 		if ( bit_test(SSPSTAT,2) ) {
0E92:  BTFSS  FC7.2
0E94:  BRA    0E98
.................... 			/* set high bit if read */
.................... 			bit_set(sstate,7);
0E96:  BSF    x0C.7
.................... 		}
.................... 	} else {
0E98:  MOVLB  0
.................... 		/* data */
.................... 	}
.................... 
.................... 	/* state variable used below is not incremented */
.................... 	state=sstate;
0E9A:  MOVFF  10C,12A
.................... 
.................... 	/* increment the state counter for next pass through unless it will overflow us into another state */
.................... 	if ( sstate != 0x7f && sstate != 0xff) {
0E9E:  MOVLB  1
0EA0:  MOVF   x0C,W
0EA2:  SUBLW  7F
0EA4:  BZ    0EAE
0EA6:  INCFSZ x0C,W
0EA8:  BRA    0EAC
0EAA:  BRA    0EAE
.................... 		sstate++;
0EAC:  INCF   x0C,F
.................... 	}
.................... 
.................... 	
.................... 	/* i2c_isr_state() return an 8 bit int
.................... 		0 - Address match received with R/W bit clear, perform i2c_read( ) to read the I2C address.
.................... 		1-0x7F - Master has written data; i2c_read() will immediately return the data
.................... 		0x80 - Address match received with R/W bit set; perform i2c_read( ) to read the I2C address,
.................... 		and use i2c_write( ) to pre-load the transmit buffer for the next transaction (next I2C read
.................... 		performed by master will read this byte).
.................... 		0x81-0xFF - Transmission completed and acknowledged; respond with i2c_write() to pre-load
.................... 		the transmit buffer for the next transition (the next I2C read performed by master will read this
.................... 		byte).
.................... 		Function:
.................... 		Returns the state of I2C communications in I2C slave mode after an SSP interrupt. The return
.................... 		value increments with each byte received or sent.
.................... 		If 0x00 or 0x80 is returned, an i2C_read( ) needs to be performed to read the I2C address that
.................... 		was sent (it will match the address configured by #USE I2C so this value can be ignored)
.................... 	*/
.................... 
.................... 	if ( state <= 0x80 ) {                      
0EAE:  MOVF   x2A,W
0EB0:  SUBLW  80
0EB2:  BNC   0F16
.................... 		/* I2C master is sending us data */
.................... 		if ( 0x80 == state ) {
0EB4:  MOVF   x2A,W
0EB6:  SUBLW  80
0EB8:  BNZ   0EC0
.................... 			/* i2c_read(2) casues the function to read the SSPBUF without releasing the clock */
.................... 			incoming = i2c_read(STREAM_SLAVE,2);
0EBA:  MOVFF  FC9,12B
.................... 		} else {
0EBE:  BRA    0ECC
.................... 			incoming = i2c_read(STREAM_SLAVE);
0EC0:  BCF    FC6.6
0EC2:  BTFSS  FC7.0
0EC4:  BRA    0EC2
0EC6:  MOVF   FC9,W
0EC8:  BSF    FC6.4
0ECA:  MOVWF  x2B
.................... 		}
.................... 
.................... 		if ( 1 == state ) {             
0ECC:  DECFSZ x2A,W
0ECE:  BRA    0ED8
.................... 			address = incoming<<1;
0ED0:  BCF    FD8.0
0ED2:  RLCF   x2B,W
0ED4:  MOVWF  x10
.................... 		} else if ( state >= 2 && 0x80 != state ) {
0ED6:  BRA    0F16
0ED8:  MOVF   x2A,W
0EDA:  SUBLW  01
0EDC:  BC    0F16
0EDE:  MOVF   x2A,W
0EE0:  SUBLW  80
0EE2:  BZ    0F16
.................... 			/* received byte is data */
.................... 		
.................... 			/* save MSB and we'll process it on next */
.................... 			if ( 2 == state ) {
0EE4:  MOVF   x2A,W
0EE6:  SUBLW  02
0EE8:  BNZ   0EF0
.................... 				lastMSB=incoming;
0EEA:  MOVFF  12B,10F
.................... 			} else if ( 3 == state ) {
0EEE:  BRA    0F16
0EF0:  MOVF   x2A,W
0EF2:  SUBLW  03
0EF4:  BNZ   0F16
.................... 				/* 16 bit value made of previous byte and this byte */
.................... 				write_i2c(address>>1,make16(lastMSB,incoming));
0EF6:  BCF    FD8.0
0EF8:  RRCF   x10,W
0EFA:  MOVWF  x2C
0EFC:  MOVFF  10F,12E
0F00:  MOVFF  12B,12D
0F04:  MOVWF  x2F
0F06:  MOVFF  10F,131
0F0A:  MOVFF  12B,130
0F0E:  MOVLB  0
0F10:  GOTO   00DC
0F14:  MOVLB  1
.................... 
.................... 				/* this write only works for a single register per I2C transaction */
.................... 				/* this is not a BUG, but it would need to be implemented if this functionality is needed */
.................... 			}
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	if ( state >= 0x80 ) {
0F16:  MOVF   x2A,W
0F18:  SUBLW  7F
0F1A:  BC    0F54
.................... 		/* I2C master is requesting data from us */
.................... 
.................... 		if ( ! bit_test(address,0) ) {
0F1C:  BTFSC  x10.0
0F1E:  BRA    0F44
.................... 			/* read 16 bit register (register address half of I2C address) on even address */
.................... 			lastValue=map_i2c(address>>1);
0F20:  BCF    FD8.0
0F22:  RRCF   x10,W
0F24:  MOVWF  x2C
0F26:  MOVWF  x2D
0F28:  MOVLB  0
0F2A:  GOTO   0614
0F2E:  MOVFF  02,10E
0F32:  MOVFF  01,10D
.................... 
.................... 			/* send the MSB */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,1));
0F36:  MOVFF  10E,12C
0F3A:  MOVFF  10E,12D
0F3E:  RCALL  0E74
.................... 		} else {
0F40:  BRA    0F50
0F42:  MOVLB  1
.................... 			/* send LSB of 16 bit register on odd address */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,0));
0F44:  MOVFF  10D,12C
0F48:  MOVFF  10D,12D
0F4C:  MOVLB  0
0F4E:  RCALL  0E74
.................... 		}
.................... 		address++;
0F50:  MOVLB  1
0F52:  INCF   x10,F
.................... 	}
.................... }
.................... 
.................... 
.................... 
.................... 
0F54:  BCF    F9E.3
0F56:  MOVLB  0
0F58:  GOTO   006C
.................... #include "debug_dcswc_module_latching_contactor.c"
.................... void debug_dump(void) {
.................... 
.................... 	int8 i;
.................... 
.................... 	
.................... 	restart_wdt();
*
2970:  CLRWDT
2972:  CLRF   19
2974:  BTFSC  FF2.7
2976:  BSF    19.7
2978:  BCF    FF2.7
.................... #if 0
.................... 	fprintf(STREAM_FTDI,"# '%s'\r\n",__DATE__);
.................... 	fprintf(STREAM_FTDI,"#  compile_year=%u\r\n",current.compile_year);
.................... 	fprintf(STREAM_FTDI,"# compile_month=%u\r\n",current.compile_month);
.................... 	fprintf(STREAM_FTDI,"#   compile_day=%u\r\n",current.compile_day);
.................... #endif
.................... 	fprintf(STREAM_FTDI,"#       vin adc=%lu\r\n",adc_get(0));
297A:  MOVLB  1
297C:  CLRF   x2F
297E:  MOVLB  0
2980:  CALL   0594
2984:  BTFSC  19.7
2986:  BSF    FF2.7
2988:  MOVFF  02,11D
298C:  MOVFF  01,11C
2990:  MOVLW  5C
2992:  MOVWF  FF6
2994:  MOVLW  0F
2996:  MOVWF  FF7
2998:  MOVLW  10
299A:  MOVLB  1
299C:  MOVWF  x1E
299E:  MOVLB  0
29A0:  CALL   17BE
29A4:  MOVLW  10
29A6:  MOVWF  FE9
29A8:  MOVFF  11D,11F
29AC:  MOVFF  11C,11E
29B0:  RCALL  2878
29B2:  MOVLW  0D
29B4:  BTFSS  F9E.4
29B6:  BRA    29B4
29B8:  MOVWF  FAD
29BA:  MOVLW  0A
29BC:  BTFSS  F9E.4
29BE:  BRA    29BC
29C0:  MOVWF  FAD
29C2:  CLRF   19
29C4:  BTFSC  FF2.7
29C6:  BSF    19.7
29C8:  BCF    FF2.7
.................... 	fprintf(STREAM_FTDI,"#      temp adc=%lu\r\n",adc_get(1));
29CA:  MOVLW  01
29CC:  MOVLB  1
29CE:  MOVWF  x2F
29D0:  MOVLB  0
29D2:  CALL   0594
29D6:  BTFSC  19.7
29D8:  BSF    FF2.7
29DA:  MOVFF  02,11D
29DE:  MOVFF  01,11C
29E2:  MOVLW  72
29E4:  MOVWF  FF6
29E6:  MOVLW  0F
29E8:  MOVWF  FF7
29EA:  MOVLW  10
29EC:  MOVLB  1
29EE:  MOVWF  x1E
29F0:  MOVLB  0
29F2:  CALL   17BE
29F6:  MOVLW  10
29F8:  MOVWF  FE9
29FA:  MOVFF  11D,11F
29FE:  MOVFF  11C,11E
2A02:  RCALL  2878
2A04:  MOVLW  0D
2A06:  BTFSS  F9E.4
2A08:  BRA    2A06
2A0A:  MOVWF  FAD
2A0C:  MOVLW  0A
2A0E:  BTFSS  F9E.4
2A10:  BRA    2A0E
2A12:  MOVWF  FAD
.................... 	fprintf(STREAM_FTDI,"#   ch[0].state=0x%2X\r\n",channel[0].state);
2A14:  MOVLW  88
2A16:  MOVWF  FF6
2A18:  MOVLW  0F
2A1A:  MOVWF  FF7
2A1C:  MOVLW  12
2A1E:  MOVLB  1
2A20:  MOVWF  x1E
2A22:  MOVLB  0
2A24:  CALL   17BE
2A28:  MOVFF  DA,11C
2A2C:  MOVLW  37
2A2E:  MOVLB  1
2A30:  MOVWF  x1D
2A32:  MOVLB  0
2A34:  RCALL  292A
2A36:  MOVLW  0D
2A38:  BTFSS  F9E.4
2A3A:  BRA    2A38
2A3C:  MOVWF  FAD
2A3E:  MOVLW  0A
2A40:  BTFSS  F9E.4
2A42:  BRA    2A40
2A44:  MOVWF  FAD
.................... 	fprintf(STREAM_FTDI,"#   ch[1].state=0x%2X\r\n",channel[1].state);
2A46:  MOVLW  A0
2A48:  MOVWF  FF6
2A4A:  MOVLW  0F
2A4C:  MOVWF  FF7
2A4E:  MOVLW  12
2A50:  MOVLB  1
2A52:  MOVWF  x1E
2A54:  MOVLB  0
2A56:  CALL   17BE
2A5A:  MOVFF  F3,11C
2A5E:  MOVLW  37
2A60:  MOVLB  1
2A62:  MOVWF  x1D
2A64:  MOVLB  0
2A66:  RCALL  292A
2A68:  MOVLW  0D
2A6A:  BTFSS  F9E.4
2A6C:  BRA    2A6A
2A6E:  MOVWF  FAD
2A70:  MOVLW  0A
2A72:  BTFSS  F9E.4
2A74:  BRA    2A72
2A76:  MOVWF  FAD
.................... //	fprintf(STREAM_FTDI,"# read_dip_sw()=%u\r\n",read_dip_switch());
.................... //	fprintf(STREAM_FTDI,"#    dip sw adc=%lu\r\n",adc_get(2));
.................... 
.................... #if 0
2A78:  GOTO   2C4E (RETURN)
.................... 	for ( i=0 ; i<2 ; i++ ) {
.................... 		restart_wdt();
.................... 		fprintf(STREAM_FTDI,"#-------\r\n");
.................... 		fprintf(STREAM_FTDI,"# config.ch[%u]\r\n",i);
.................... 		fprintf(STREAM_FTDI,"# command_off_hold_time=%lu\r\n",config.ch[i].command_off_hold_time);
.................... 
.................... 		fprintf(STREAM_FTDI,"#    lvd_disconnect_adc=%lu\r\n",config.ch[i].lvd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  lvd_disconnect_delay=%lu\r\n",config.ch[i].lvd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     lvd_reconnect_adc=%lu\r\n",config.ch[i].lvd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   lvd_reconnect_delay=%lu\r\n",config.ch[i].lvd_reconnect_delay);
.................... 
.................... 		fprintf(STREAM_FTDI,"#    hvd_disconnect_adc=%lu\r\n",config.ch[i].hvd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  hvd_disconnect_delay=%lu\r\n",config.ch[i].hvd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     hvd_reconnect_adc=%lu\r\n",config.ch[i].hvd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   hvd_reconnect_delay=%lu\r\n",config.ch[i].hvd_reconnect_delay);
.................... 
.................... 		restart_wdt();
.................... 		fprintf(STREAM_FTDI,"#    ltd_disconnect_adc=%lu\r\n",config.ch[i].ltd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  ltd_disconnect_delay=%lu\r\n",config.ch[i].ltd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     ltd_reconnect_adc=%lu\r\n",config.ch[i].ltd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   ltd_reconnect_delay=%lu\r\n",config.ch[i].ltd_reconnect_delay);
.................... 
.................... 		fprintf(STREAM_FTDI,"#    htd_disconnect_adc=%lu\r\n",config.ch[i].htd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  htd_disconnect_delay=%lu\r\n",config.ch[i].htd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     htd_reconnect_adc=%lu\r\n",config.ch[i].htd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   htd_reconnect_delay=%lu\r\n",config.ch[i].htd_reconnect_delay);
.................... 
.................... 
.................... 		restart_wdt();
.................... 		fprintf(STREAM_FTDI,"#\r\n");
.................... 		fprintf(STREAM_FTDI,"# channel[%u]\r\n",i);
.................... 		fprintf(STREAM_FTDI,"#                        state=0x%02x\r\n",channel[i].state);
.................... 		fprintf(STREAM_FTDI,"#           command_on_seconds=%lu\r\n",channel[i].command_on_seconds);
.................... 		fprintf(STREAM_FTDI,"#      command_on_hold_seconds=%lu\r\n",channel[i].command_on_hold_seconds);
.................... 
.................... 		fprintf(STREAM_FTDI,"#          command_off_seconds=%lu\r\n",channel[i].command_off_seconds);
.................... 		fprintf(STREAM_FTDI,"#     command_off_hold_seconds=%lu\r\n",channel[i].command_off_hold_seconds);
.................... 
.................... 		fprintf(STREAM_FTDI,"# lvd_disconnect_delay_seconds=%lu\r\n",channel[i].lvd_disconnect_delay_seconds);
.................... 		fprintf(STREAM_FTDI,"#  lvd_reconnect_delay_seconds=%lu\r\n",channel[i].lvd_reconnect_delay_seconds);
.................... 
.................... 		fprintf(STREAM_FTDI,"# hvd_disconnect_delay_seconds=%lu\r\n",channel[i].hvd_disconnect_delay_seconds);
.................... 		fprintf(STREAM_FTDI,"#  hvd_reconnect_delay_seconds=%lu\r\n",channel[i].hvd_reconnect_delay_seconds);
.................... 
.................... 		restart_wdt();
.................... 		fprintf(STREAM_FTDI,"# ltd_disconnect_delay_seconds=%lu\r\n",channel[i].ltd_disconnect_delay_seconds);
.................... 		fprintf(STREAM_FTDI,"#  ltd_reconnect_delay_seconds=%lu\r\n",channel[i].ltd_reconnect_delay_seconds);
.................... 
.................... 		fprintf(STREAM_FTDI,"# htd_disconnect_delay_seconds=%lu\r\n",channel[i].htd_disconnect_delay_seconds);
.................... 		fprintf(STREAM_FTDI,"#  htd_reconnect_delay_seconds=%lu\r\n",channel[i].htd_reconnect_delay_seconds);
.................... 	}
.................... 	#endif
.................... }
.................... 
.................... 
.................... 
.................... void contactor_on(int8 c) {
.................... 	/* only turn on contactor if it isn't on or needs a refresh */
.................... 	if ( 1 == timers.contactor[c] ) {
*
24D6:  CLRF   03
24D8:  MOVLB  1
24DA:  MOVF   x1E,W
24DC:  ADDLW  D6
24DE:  MOVWF  FE9
24E0:  MOVLW  00
24E2:  ADDWFC 03,W
24E4:  MOVWF  FEA
24E6:  MOVF   FEF,W
24E8:  SUBLW  01
24EA:  BNZ   24EE
.................... 		return;
24EC:  BRA    2528
.................... 	}
.................... 
.................... 	/* we start the powersave count down */
.................... 	timers.contactor_powersave[c]=CONTACTOR_POWER_SAVE_MS;
24EE:  CLRF   03
24F0:  MOVF   x1E,W
24F2:  ADDLW  D8
24F4:  MOVWF  FE9
24F6:  MOVLW  00
24F8:  ADDWFC 03,W
24FA:  MOVWF  FEA
24FC:  MOVLW  C8
24FE:  MOVWF  FEF
.................... 
.................... 	/* control the actual coil depending on what channel we are on */
.................... 	if ( 0==c ) {
2500:  MOVF   x1E,F
2502:  BNZ   250E
.................... 		/* contactor A pins */
.................... 		output_low(BRIDGE_A_A);
2504:  BCF    F94.3
2506:  BCF    F8B.3
.................... 		output_high(BRIDGE_A_B);
2508:  BCF    F94.4
250A:  BSF    F8B.4
.................... 	} else {
250C:  BRA    2516
.................... 		/* contactor B pins */
.................... 		output_low(BRIDGE_B_A);
250E:  BCF    F94.5
2510:  BCF    F8B.5
.................... 		output_high(BRIDGE_B_B);
2512:  BCF    F94.6
2514:  BSF    F8B.6
.................... 	}
.................... 
.................... 	/* save state for next time */
.................... 	timers.contactor[c]=1;
2516:  CLRF   03
2518:  MOVF   x1E,W
251A:  ADDLW  D6
251C:  MOVWF  FE9
251E:  MOVLW  00
2520:  ADDWFC 03,W
2522:  MOVWF  FEA
2524:  MOVLW  01
2526:  MOVWF  FEF
2528:  MOVLB  0
252A:  GOTO   258E (RETURN)
.................... }
.................... 
.................... void contactor_off(int8 c) {
.................... 	/* only turn off contactor if it isn't on or needs a refresh */
.................... 	if ( 0 == timers.contactor[c] ) {
*
2482:  CLRF   03
2484:  MOVLB  1
2486:  MOVF   x1E,W
2488:  ADDLW  D6
248A:  MOVWF  FE9
248C:  MOVLW  00
248E:  ADDWFC 03,W
2490:  MOVWF  FEA
2492:  MOVF   FEF,W
2494:  BNZ   2498
.................... 		return;
2496:  BRA    24D0
.................... 	}
.................... 
.................... 	/* we start the powersave count down */
.................... 	timers.contactor_powersave[c]=CONTACTOR_POWER_SAVE_MS;
2498:  CLRF   03
249A:  MOVF   x1E,W
249C:  ADDLW  D8
249E:  MOVWF  FE9
24A0:  MOVLW  00
24A2:  ADDWFC 03,W
24A4:  MOVWF  FEA
24A6:  MOVLW  C8
24A8:  MOVWF  FEF
.................... 
.................... 	/* control the actual coil depending on what channel we are on */
.................... 	if ( 0==c ) {
24AA:  MOVF   x1E,F
24AC:  BNZ   24B8
.................... 		output_high(BRIDGE_A_A);
24AE:  BCF    F94.3
24B0:  BSF    F8B.3
.................... 		output_low(BRIDGE_A_B);
24B2:  BCF    F94.4
24B4:  BCF    F8B.4
.................... 	} else {
24B6:  BRA    24C0
.................... 		output_high(BRIDGE_B_A);
24B8:  BCF    F94.5
24BA:  BSF    F8B.5
.................... 		output_low(BRIDGE_B_B);
24BC:  BCF    F94.6
24BE:  BCF    F8B.6
.................... 	}
.................... 
.................... 	/* save state for next time */
.................... 	timers.contactor[c]=0;
24C0:  CLRF   03
24C2:  MOVF   x1E,W
24C4:  ADDLW  D6
24C6:  MOVWF  FE9
24C8:  MOVLW  00
24CA:  ADDWFC 03,W
24CC:  MOVWF  FEA
24CE:  CLRF   FEF
24D0:  MOVLB  0
24D2:  GOTO   2582 (RETURN)
.................... }
.................... 
.................... void contactor_set(int8 c) {
*
252E:  MOVLW  01
2530:  MOVLB  1
2532:  MOVWF  x1D
.................... 	int8 state=1;
.................... 
.................... 	/* if nothing is set in channel[c].state, contactor is on */
.................... 	state=1; 
2534:  MOVWF  x1D
.................... 
.................... 	if ( channel[c].state & CH_STATE_MASK_ON ) {
2536:  MOVF   x1C,W
2538:  MULLW  19
253A:  MOVF   FF3,W
253C:  CLRF   x1F
253E:  MOVWF  x1E
2540:  MOVLW  DA
2542:  ADDWF  x1E,W
2544:  MOVWF  FE9
2546:  MOVLW  00
2548:  ADDWFC x1F,W
254A:  MOVWF  FEA
254C:  MOVF   FEF,W
254E:  ANDLW  03
2550:  BZ    2558
.................... 		/* if override button (switch) is set or we are commanded on, then we will be on */
.................... 		state=1;
2552:  MOVLW  01
2554:  MOVWF  x1D
.................... 	} else if ( channel[c].state & CH_STATE_MASK_OFF ) {
2556:  BRA    2576
2558:  MOVF   x1C,W
255A:  MULLW  19
255C:  MOVF   FF3,W
255E:  CLRF   x1F
2560:  MOVWF  x1E
2562:  MOVLW  DA
2564:  ADDWF  x1E,W
2566:  MOVWF  FE9
2568:  MOVLW  00
256A:  ADDWFC x1F,W
256C:  MOVWF  FEA
256E:  MOVF   FEF,W
2570:  ANDLW  7C
2572:  BZ    2576
.................... 		/* if one of the disconnect bits is set, we will be off */
.................... 		state=0;
2574:  CLRF   x1D
.................... 	}
.................... 
.................... 	if ( 0==state ) {
2576:  MOVF   x1D,F
2578:  BNZ   2586
.................... 		contactor_off(c);
257A:  MOVFF  11C,11E
257E:  MOVLB  0
2580:  BRA    2482
.................... 	} else {
2582:  BRA    258E
2584:  MOVLB  1
.................... 		contactor_on(c);
2586:  MOVFF  11C,11E
258A:  MOVLB  0
258C:  BRA    24D6
.................... 	}
258E:  RETURN 0
.................... 
.................... }
.................... 
.................... void contactor_logic(int8 c) {
.................... 	int16 adc;
.................... 
.................... 	/* override button / switch */
.................... 	if ( (0==c && 0==input(SW_OVERRIDE_A)) || (1==c && 0==input(SW_OVERRIDE_B)) ) {
*
18D2:  MOVLB  1
18D4:  MOVF   x1C,F
18D6:  BNZ   18DE
18D8:  BSF    F92.5
18DA:  BTFSS  F80.5
18DC:  BRA    18E8
18DE:  DECFSZ x1C,W
18E0:  BRA    1906
18E2:  BSF    F92.4
18E4:  BTFSC  F80.4
18E6:  BRA    1906
.................... 		bit_set(channel[c].state,CH_STATE_BIT_OVERRIDE);
18E8:  MOVF   x1C,W
18EA:  MULLW  19
18EC:  MOVF   FF3,W
18EE:  CLRF   x20
18F0:  MOVWF  x1F
18F2:  MOVLW  DA
18F4:  ADDWF  x1F,W
18F6:  MOVWF  01
18F8:  MOVLW  00
18FA:  ADDWFC x20,W
18FC:  MOVFF  01,FE9
1900:  MOVWF  FEA
1902:  BSF    FEF.0
.................... 	} else {
1904:  BRA    1922
.................... 		bit_clear(channel[c].state,CH_STATE_BIT_OVERRIDE);
1906:  MOVF   x1C,W
1908:  MULLW  19
190A:  MOVF   FF3,W
190C:  CLRF   x20
190E:  MOVWF  x1F
1910:  MOVLW  DA
1912:  ADDWF  x1F,W
1914:  MOVWF  01
1916:  MOVLW  00
1918:  ADDWFC x20,W
191A:  MOVFF  01,FE9
191E:  MOVWF  FEA
1920:  BCF    FEF.0
.................... 	}
.................... 
.................... 	/* command on. 65535 disables */
.................... 	if ( 65535 != channel[c].command_on_seconds ) {
1922:  MOVF   x1C,W
1924:  MULLW  19
1926:  MOVF   FF3,W
1928:  CLRF   x20
192A:  MOVWF  x1F
192C:  MOVLW  01
192E:  ADDWF  x1F,W
1930:  MOVWF  01
1932:  MOVLW  00
1934:  ADDWFC x20,W
1936:  MOVWF  03
1938:  MOVF   01,W
193A:  ADDLW  DA
193C:  MOVWF  FE9
193E:  MOVLW  00
1940:  ADDWFC 03,W
1942:  MOVWF  FEA
1944:  MOVFF  FEC,03
1948:  MOVF   FED,F
194A:  MOVF   FEF,W
194C:  SUBLW  FF
194E:  BNZ   1956
1950:  INCFSZ 03,W
1952:  BRA    1956
1954:  BRA    1AEC
.................... 		if ( channel[c].command_on_seconds > 0 ) {
1956:  MOVF   x1C,W
1958:  MULLW  19
195A:  MOVF   FF3,W
195C:  CLRF   x20
195E:  MOVWF  x1F
1960:  MOVLW  01
1962:  ADDWF  x1F,W
1964:  MOVWF  01
1966:  MOVLW  00
1968:  ADDWFC x20,W
196A:  MOVWF  03
196C:  MOVF   01,W
196E:  ADDLW  DA
1970:  MOVWF  FE9
1972:  MOVLW  00
1974:  ADDWFC 03,W
1976:  MOVWF  FEA
1978:  MOVFF  FEC,120
197C:  MOVF   FED,F
197E:  MOVFF  FEF,11F
1982:  MOVF   x1F,F
1984:  BNZ   198A
1986:  MOVF   x20,F
1988:  BZ    19B8
.................... 			/* waiting to power on */
.................... 			channel[c].command_on_seconds--;
198A:  MOVF   x1C,W
198C:  MULLW  19
198E:  MOVF   FF3,W
1990:  CLRF   x20
1992:  MOVWF  x1F
1994:  MOVLW  01
1996:  ADDWF  x1F,W
1998:  MOVWF  01
199A:  MOVLW  00
199C:  ADDWFC x20,W
199E:  MOVWF  03
19A0:  MOVF   01,W
19A2:  ADDLW  DA
19A4:  MOVWF  FE9
19A6:  MOVLW  00
19A8:  ADDWFC 03,W
19AA:  MOVWF  FEA
19AC:  MOVLW  FF
19AE:  ADDWF  FEF,F
19B0:  BC    19B6
19B2:  MOVF   FEE,F
19B4:  DECF   FED,F
.................... 		} else {
19B6:  BRA    1AEC
.................... 			/* timer at zero, ready to power on or already powered on */
.................... 			if ( ! bit_test(channel[c].state,CH_STATE_BIT_CMD_ON) ) {
19B8:  MOVF   x1C,W
19BA:  MULLW  19
19BC:  MOVF   FF3,W
19BE:  CLRF   x20
19C0:  MOVWF  x1F
19C2:  MOVLW  DA
19C4:  ADDWF  x1F,W
19C6:  MOVWF  FE9
19C8:  MOVLW  00
19CA:  ADDWFC x20,W
19CC:  MOVWF  FEA
19CE:  MOVFF  FEF,121
19D2:  BTFSC  x21.1
19D4:  BRA    1A4A
.................... 				/* not currently set, so we set it and start the countdown */
.................... 				bit_set(channel[c].state,CH_STATE_BIT_CMD_ON);
19D6:  MOVF   x1C,W
19D8:  MULLW  19
19DA:  MOVF   FF3,W
19DC:  CLRF   x20
19DE:  MOVWF  x1F
19E0:  MOVLW  DA
19E2:  ADDWF  x1F,W
19E4:  MOVWF  01
19E6:  MOVLW  00
19E8:  ADDWFC x20,W
19EA:  MOVFF  01,FE9
19EE:  MOVWF  FEA
19F0:  BSF    FEF.1
.................... 				channel[c].command_on_hold_seconds=config.ch[c].command_on_hold_time;
19F2:  MOVF   x1C,W
19F4:  MULLW  19
19F6:  MOVF   FF3,W
19F8:  CLRF   x20
19FA:  MOVWF  x1F
19FC:  MOVLW  03
19FE:  ADDWF  x1F,W
1A00:  MOVWF  01
1A02:  MOVLW  00
1A04:  ADDWFC x20,W
1A06:  MOVWF  03
1A08:  MOVF   01,W
1A0A:  ADDLW  DA
1A0C:  MOVWF  01
1A0E:  MOVLW  00
1A10:  ADDWFC 03,F
1A12:  MOVFF  03,120
1A16:  MOVF   x1C,W
1A18:  MULLW  24
1A1A:  MOVF   FF3,W
1A1C:  CLRF   x22
1A1E:  MOVWF  x21
1A20:  MOVLW  1B
1A22:  ADDWF  x21,W
1A24:  MOVWF  FE9
1A26:  MOVLW  00
1A28:  ADDWFC x22,W
1A2A:  MOVWF  FEA
1A2C:  MOVFF  FEC,03
1A30:  MOVF   FED,F
1A32:  MOVFF  FEF,123
1A36:  MOVFF  120,FEA
1A3A:  MOVFF  01,FE9
1A3E:  MOVFF  03,FEC
1A42:  MOVF   FED,F
1A44:  MOVFF  123,FEF
.................... 			} else {
1A48:  BRA    1AEC
.................... 				/* set, so we clear it once countdown has elapsed */
.................... 				if ( 0==channel[c].command_on_hold_seconds ) {
1A4A:  MOVF   x1C,W
1A4C:  MULLW  19
1A4E:  MOVF   FF3,W
1A50:  CLRF   x20
1A52:  MOVWF  x1F
1A54:  MOVLW  03
1A56:  ADDWF  x1F,W
1A58:  MOVWF  01
1A5A:  MOVLW  00
1A5C:  ADDWFC x20,W
1A5E:  MOVWF  03
1A60:  MOVF   01,W
1A62:  ADDLW  DA
1A64:  MOVWF  FE9
1A66:  MOVLW  00
1A68:  ADDWFC 03,W
1A6A:  MOVWF  FEA
1A6C:  MOVFF  FEC,03
1A70:  MOVF   FED,F
1A72:  MOVF   FEF,W
1A74:  BNZ   1AC0
1A76:  MOVF   03,F
1A78:  BNZ   1AC0
.................... 					/* countdown elapsed, clear the flag and reset the timer */
.................... 					bit_clear(channel[c].state,CH_STATE_BIT_CMD_ON);
1A7A:  MOVF   x1C,W
1A7C:  MULLW  19
1A7E:  MOVF   FF3,W
1A80:  CLRF   x20
1A82:  MOVWF  x1F
1A84:  MOVLW  DA
1A86:  ADDWF  x1F,W
1A88:  MOVWF  01
1A8A:  MOVLW  00
1A8C:  ADDWFC x20,W
1A8E:  MOVFF  01,FE9
1A92:  MOVWF  FEA
1A94:  BCF    FEF.1
.................... 					channel[c].command_on_seconds=65535;
1A96:  MOVF   x1C,W
1A98:  MULLW  19
1A9A:  MOVF   FF3,W
1A9C:  CLRF   x20
1A9E:  MOVWF  x1F
1AA0:  MOVLW  01
1AA2:  ADDWF  x1F,W
1AA4:  MOVWF  01
1AA6:  MOVLW  00
1AA8:  ADDWFC x20,W
1AAA:  MOVWF  03
1AAC:  MOVF   01,W
1AAE:  ADDLW  DA
1AB0:  MOVWF  FE9
1AB2:  MOVLW  00
1AB4:  ADDWFC 03,W
1AB6:  MOVWF  FEA
1AB8:  SETF   FEC
1ABA:  MOVF   FED,F
1ABC:  SETF   FEF
.................... 				} else {
1ABE:  BRA    1AEC
.................... 					channel[c].command_on_hold_seconds--;
1AC0:  MOVF   x1C,W
1AC2:  MULLW  19
1AC4:  MOVF   FF3,W
1AC6:  CLRF   x20
1AC8:  MOVWF  x1F
1ACA:  MOVLW  03
1ACC:  ADDWF  x1F,W
1ACE:  MOVWF  01
1AD0:  MOVLW  00
1AD2:  ADDWFC x20,W
1AD4:  MOVWF  03
1AD6:  MOVF   01,W
1AD8:  ADDLW  DA
1ADA:  MOVWF  FE9
1ADC:  MOVLW  00
1ADE:  ADDWFC 03,W
1AE0:  MOVWF  FEA
1AE2:  MOVLW  FF
1AE4:  ADDWF  FEF,F
1AE6:  BC    1AEC
1AE8:  MOVF   FEE,F
1AEA:  DECF   FED,F
.................... 				}
.................... 			}		
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	/* command off. 65535 disables */
.................... 	if ( 65535 != channel[c].command_off_seconds ) {
1AEC:  MOVF   x1C,W
1AEE:  MULLW  19
1AF0:  MOVF   FF3,W
1AF2:  CLRF   x20
1AF4:  MOVWF  x1F
1AF6:  MOVLW  05
1AF8:  ADDWF  x1F,W
1AFA:  MOVWF  01
1AFC:  MOVLW  00
1AFE:  ADDWFC x20,W
1B00:  MOVWF  03
1B02:  MOVF   01,W
1B04:  ADDLW  DA
1B06:  MOVWF  FE9
1B08:  MOVLW  00
1B0A:  ADDWFC 03,W
1B0C:  MOVWF  FEA
1B0E:  MOVFF  FEC,03
1B12:  MOVF   FED,F
1B14:  MOVF   FEF,W
1B16:  SUBLW  FF
1B18:  BNZ   1B20
1B1A:  INCFSZ 03,W
1B1C:  BRA    1B20
1B1E:  BRA    1CC6
.................... 		if ( channel[c].command_off_seconds > 0 ) {
1B20:  MOVF   x1C,W
1B22:  MULLW  19
1B24:  MOVF   FF3,W
1B26:  CLRF   x20
1B28:  MOVWF  x1F
1B2A:  MOVLW  05
1B2C:  ADDWF  x1F,W
1B2E:  MOVWF  01
1B30:  MOVLW  00
1B32:  ADDWFC x20,W
1B34:  MOVWF  03
1B36:  MOVF   01,W
1B38:  ADDLW  DA
1B3A:  MOVWF  FE9
1B3C:  MOVLW  00
1B3E:  ADDWFC 03,W
1B40:  MOVWF  FEA
1B42:  MOVFF  FEC,120
1B46:  MOVF   FED,F
1B48:  MOVFF  FEF,11F
1B4C:  MOVF   x1F,F
1B4E:  BNZ   1B54
1B50:  MOVF   x20,F
1B52:  BZ    1B82
.................... 			/* waiting to power off */
.................... 			channel[c].command_off_seconds--;
1B54:  MOVF   x1C,W
1B56:  MULLW  19
1B58:  MOVF   FF3,W
1B5A:  CLRF   x20
1B5C:  MOVWF  x1F
1B5E:  MOVLW  05
1B60:  ADDWF  x1F,W
1B62:  MOVWF  01
1B64:  MOVLW  00
1B66:  ADDWFC x20,W
1B68:  MOVWF  03
1B6A:  MOVF   01,W
1B6C:  ADDLW  DA
1B6E:  MOVWF  FE9
1B70:  MOVLW  00
1B72:  ADDWFC 03,W
1B74:  MOVWF  FEA
1B76:  MOVLW  FF
1B78:  ADDWF  FEF,F
1B7A:  BC    1B80
1B7C:  MOVF   FEE,F
1B7E:  DECF   FED,F
.................... 		} else {
1B80:  BRA    1CC6
.................... 			/* timer at zero, ready to power off or already powered off */
.................... 			if ( ! bit_test(channel[c].state,CH_STATE_BIT_CMD_OFF) ) {
1B82:  MOVF   x1C,W
1B84:  MULLW  19
1B86:  MOVF   FF3,W
1B88:  CLRF   x20
1B8A:  MOVWF  x1F
1B8C:  MOVLW  DA
1B8E:  ADDWF  x1F,W
1B90:  MOVWF  FE9
1B92:  MOVLW  00
1B94:  ADDWFC x20,W
1B96:  MOVWF  FEA
1B98:  MOVFF  FEF,121
1B9C:  BTFSC  x21.2
1B9E:  BRA    1C24
.................... 				/* not currently set, so we set it and start the countdown */
.................... 				bit_set(channel[c].state,CH_STATE_BIT_CMD_OFF);
1BA0:  MOVF   x1C,W
1BA2:  MULLW  19
1BA4:  MOVF   FF3,W
1BA6:  CLRF   x20
1BA8:  MOVWF  x1F
1BAA:  MOVLW  DA
1BAC:  ADDWF  x1F,W
1BAE:  MOVWF  01
1BB0:  MOVLW  00
1BB2:  ADDWFC x20,W
1BB4:  MOVFF  01,FE9
1BB8:  MOVWF  FEA
1BBA:  BSF    FEF.2
.................... 				channel[c].command_off_hold_seconds=config.ch[c].command_off_hold_time;
1BBC:  MOVF   x1C,W
1BBE:  MULLW  19
1BC0:  MOVF   FF3,W
1BC2:  CLRF   x20
1BC4:  MOVWF  x1F
1BC6:  MOVLW  07
1BC8:  ADDWF  x1F,W
1BCA:  MOVWF  01
1BCC:  MOVLW  00
1BCE:  ADDWFC x20,W
1BD0:  MOVWF  03
1BD2:  MOVF   01,W
1BD4:  ADDLW  DA
1BD6:  MOVWF  01
1BD8:  MOVLW  00
1BDA:  ADDWFC 03,F
1BDC:  MOVFF  01,11F
1BE0:  MOVFF  03,120
1BE4:  MOVF   x1C,W
1BE6:  MULLW  24
1BE8:  MOVF   FF3,W
1BEA:  CLRF   x22
1BEC:  MOVWF  x21
1BEE:  MOVLW  02
1BF0:  ADDWF  x21,W
1BF2:  MOVWF  01
1BF4:  MOVLW  00
1BF6:  ADDWFC x22,W
1BF8:  MOVWF  03
1BFA:  MOVF   01,W
1BFC:  ADDLW  1B
1BFE:  MOVWF  FE9
1C00:  MOVLW  00
1C02:  ADDWFC 03,W
1C04:  MOVWF  FEA
1C06:  MOVFF  FEC,03
1C0A:  MOVF   FED,F
1C0C:  MOVFF  FEF,121
1C10:  MOVFF  120,FEA
1C14:  MOVFF  11F,FE9
1C18:  MOVFF  03,FEC
1C1C:  MOVF   FED,F
1C1E:  MOVFF  121,FEF
.................... 			} else {
1C22:  BRA    1CC6
.................... 				/* set, so we clear it once countdown has elapsed */
.................... 				if ( 0==channel[c].command_off_hold_seconds ) {
1C24:  MOVF   x1C,W
1C26:  MULLW  19
1C28:  MOVF   FF3,W
1C2A:  CLRF   x20
1C2C:  MOVWF  x1F
1C2E:  MOVLW  07
1C30:  ADDWF  x1F,W
1C32:  MOVWF  01
1C34:  MOVLW  00
1C36:  ADDWFC x20,W
1C38:  MOVWF  03
1C3A:  MOVF   01,W
1C3C:  ADDLW  DA
1C3E:  MOVWF  FE9
1C40:  MOVLW  00
1C42:  ADDWFC 03,W
1C44:  MOVWF  FEA
1C46:  MOVFF  FEC,03
1C4A:  MOVF   FED,F
1C4C:  MOVF   FEF,W
1C4E:  BNZ   1C9A
1C50:  MOVF   03,F
1C52:  BNZ   1C9A
.................... 					/* countdown elapsed, clear the flag and reset the timer */
.................... 					bit_clear(channel[c].state,CH_STATE_BIT_CMD_OFF);
1C54:  MOVF   x1C,W
1C56:  MULLW  19
1C58:  MOVF   FF3,W
1C5A:  CLRF   x20
1C5C:  MOVWF  x1F
1C5E:  MOVLW  DA
1C60:  ADDWF  x1F,W
1C62:  MOVWF  01
1C64:  MOVLW  00
1C66:  ADDWFC x20,W
1C68:  MOVFF  01,FE9
1C6C:  MOVWF  FEA
1C6E:  BCF    FEF.2
.................... 					channel[c].command_off_seconds=65535;
1C70:  MOVF   x1C,W
1C72:  MULLW  19
1C74:  MOVF   FF3,W
1C76:  CLRF   x20
1C78:  MOVWF  x1F
1C7A:  MOVLW  05
1C7C:  ADDWF  x1F,W
1C7E:  MOVWF  01
1C80:  MOVLW  00
1C82:  ADDWFC x20,W
1C84:  MOVWF  03
1C86:  MOVF   01,W
1C88:  ADDLW  DA
1C8A:  MOVWF  FE9
1C8C:  MOVLW  00
1C8E:  ADDWFC 03,W
1C90:  MOVWF  FEA
1C92:  SETF   FEC
1C94:  MOVF   FED,F
1C96:  SETF   FEF
.................... 				} else {
1C98:  BRA    1CC6
.................... 					channel[c].command_off_hold_seconds--;
1C9A:  MOVF   x1C,W
1C9C:  MULLW  19
1C9E:  MOVF   FF3,W
1CA0:  CLRF   x20
1CA2:  MOVWF  x1F
1CA4:  MOVLW  07
1CA6:  ADDWF  x1F,W
1CA8:  MOVWF  01
1CAA:  MOVLW  00
1CAC:  ADDWFC x20,W
1CAE:  MOVWF  03
1CB0:  MOVF   01,W
1CB2:  ADDLW  DA
1CB4:  MOVWF  FE9
1CB6:  MOVLW  00
1CB8:  ADDWFC 03,W
1CBA:  MOVWF  FEA
1CBC:  MOVLW  FF
1CBE:  ADDWF  FEF,F
1CC0:  BC    1CC6
1CC2:  MOVF   FEE,F
1CC4:  DECF   FED,F
.................... 				}
.................... 			}		
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	/* LVD. 65535 disables */
.................... 	if ( 65535 != config.ch[c].lvd_disconnect_delay ) {
1CC6:  MOVF   x1C,W
1CC8:  MULLW  24
1CCA:  MOVF   FF3,W
1CCC:  CLRF   x20
1CCE:  MOVWF  x1F
1CD0:  MOVLW  06
1CD2:  ADDWF  x1F,W
1CD4:  MOVWF  01
1CD6:  MOVLW  00
1CD8:  ADDWFC x20,W
1CDA:  MOVWF  03
1CDC:  MOVF   01,W
1CDE:  ADDLW  1B
1CE0:  MOVWF  FE9
1CE2:  MOVLW  00
1CE4:  ADDWFC 03,W
1CE6:  MOVWF  FEA
1CE8:  MOVFF  FEC,03
1CEC:  MOVF   FED,F
1CEE:  MOVF   FEF,W
1CF0:  SUBLW  FF
1CF2:  BNZ   1CFA
1CF4:  INCFSZ 03,W
1CF6:  BRA    1CFA
1CF8:  BRA    1F58
1CFA:  CLRF   19
1CFC:  BTFSC  FF2.7
1CFE:  BSF    19.7
1D00:  BCF    FF2.7
.................... 		adc=adc_get(0);
1D02:  CLRF   x2F
1D04:  MOVLB  0
1D06:  CALL   0594
1D0A:  BTFSC  19.7
1D0C:  BSF    FF2.7
1D0E:  MOVFF  02,11E
1D12:  MOVFF  01,11D
.................... 
.................... 		if ( adc > config.ch[c].lvd_reconnect_adc ) {
1D16:  MOVLB  1
1D18:  MOVF   x1C,W
1D1A:  MULLW  24
1D1C:  MOVF   FF3,W
1D1E:  CLRF   x20
1D20:  MOVWF  x1F
1D22:  MOVLW  08
1D24:  ADDWF  x1F,W
1D26:  MOVWF  01
1D28:  MOVLW  00
1D2A:  ADDWFC x20,W
1D2C:  MOVWF  03
1D2E:  MOVF   01,W
1D30:  ADDLW  1B
1D32:  MOVWF  FE9
1D34:  MOVLW  00
1D36:  ADDWFC 03,W
1D38:  MOVWF  FEA
1D3A:  MOVFF  FEC,03
1D3E:  MOVF   FED,F
1D40:  MOVFF  FEF,01
1D44:  MOVF   03,W
1D46:  SUBWF  x1E,W
1D48:  BNC   1DD2
1D4A:  BNZ   1D52
1D4C:  MOVF   x1D,W
1D4E:  SUBWF  01,W
1D50:  BC    1DD2
.................... 			if ( channel[c].lvd_reconnect_delay_seconds > 0 ) {
1D52:  MOVF   x1C,W
1D54:  MULLW  19
1D56:  MOVF   FF3,W
1D58:  CLRF   x20
1D5A:  MOVWF  x1F
1D5C:  MOVLW  0B
1D5E:  ADDWF  x1F,W
1D60:  MOVWF  01
1D62:  MOVLW  00
1D64:  ADDWFC x20,W
1D66:  MOVWF  03
1D68:  MOVF   01,W
1D6A:  ADDLW  DA
1D6C:  MOVWF  FE9
1D6E:  MOVLW  00
1D70:  ADDWFC 03,W
1D72:  MOVWF  FEA
1D74:  MOVFF  FEC,120
1D78:  MOVF   FED,F
1D7A:  MOVFF  FEF,11F
1D7E:  MOVF   x1F,F
1D80:  BNZ   1D86
1D82:  MOVF   x20,F
1D84:  BZ    1DB4
.................... 				channel[c].lvd_reconnect_delay_seconds--;
1D86:  MOVF   x1C,W
1D88:  MULLW  19
1D8A:  MOVF   FF3,W
1D8C:  CLRF   x20
1D8E:  MOVWF  x1F
1D90:  MOVLW  0B
1D92:  ADDWF  x1F,W
1D94:  MOVWF  01
1D96:  MOVLW  00
1D98:  ADDWFC x20,W
1D9A:  MOVWF  03
1D9C:  MOVF   01,W
1D9E:  ADDLW  DA
1DA0:  MOVWF  FE9
1DA2:  MOVLW  00
1DA4:  ADDWFC 03,W
1DA6:  MOVWF  FEA
1DA8:  MOVLW  FF
1DAA:  ADDWF  FEF,F
1DAC:  BC    1DB2
1DAE:  MOVF   FEE,F
1DB0:  DECF   FED,F
.................... 			} else {
1DB2:  BRA    1DD0
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_LVD);
1DB4:  MOVF   x1C,W
1DB6:  MULLW  19
1DB8:  MOVF   FF3,W
1DBA:  CLRF   x20
1DBC:  MOVWF  x1F
1DBE:  MOVLW  DA
1DC0:  ADDWF  x1F,W
1DC2:  MOVWF  01
1DC4:  MOVLW  00
1DC6:  ADDWFC x20,W
1DC8:  MOVFF  01,FE9
1DCC:  MOVWF  FEA
1DCE:  BCF    FEF.3
.................... 			}
.................... 		} else {
1DD0:  BRA    1E38
.................... 			channel[c].lvd_reconnect_delay_seconds=config.ch[c].lvd_reconnect_delay;
1DD2:  MOVF   x1C,W
1DD4:  MULLW  19
1DD6:  MOVF   FF3,W
1DD8:  CLRF   x20
1DDA:  MOVWF  x1F
1DDC:  MOVLW  0B
1DDE:  ADDWF  x1F,W
1DE0:  MOVWF  01
1DE2:  MOVLW  00
1DE4:  ADDWFC x20,W
1DE6:  MOVWF  03
1DE8:  MOVF   01,W
1DEA:  ADDLW  DA
1DEC:  MOVWF  01
1DEE:  MOVLW  00
1DF0:  ADDWFC 03,F
1DF2:  MOVFF  01,11F
1DF6:  MOVFF  03,120
1DFA:  MOVF   x1C,W
1DFC:  MULLW  24
1DFE:  MOVF   FF3,W
1E00:  CLRF   x22
1E02:  MOVWF  x21
1E04:  MOVLW  0A
1E06:  ADDWF  x21,W
1E08:  MOVWF  01
1E0A:  MOVLW  00
1E0C:  ADDWFC x22,W
1E0E:  MOVWF  03
1E10:  MOVF   01,W
1E12:  ADDLW  1B
1E14:  MOVWF  FE9
1E16:  MOVLW  00
1E18:  ADDWFC 03,W
1E1A:  MOVWF  FEA
1E1C:  MOVFF  FEC,03
1E20:  MOVF   FED,F
1E22:  MOVFF  FEF,121
1E26:  MOVFF  120,FEA
1E2A:  MOVFF  11F,FE9
1E2E:  MOVFF  03,FEC
1E32:  MOVF   FED,F
1E34:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc < config.ch[c].lvd_disconnect_adc ) {
1E38:  MOVF   x1C,W
1E3A:  MULLW  24
1E3C:  MOVF   FF3,W
1E3E:  CLRF   x20
1E40:  MOVWF  x1F
1E42:  MOVLW  04
1E44:  ADDWF  x1F,W
1E46:  MOVWF  01
1E48:  MOVLW  00
1E4A:  ADDWFC x20,W
1E4C:  MOVWF  03
1E4E:  MOVF   01,W
1E50:  ADDLW  1B
1E52:  MOVWF  FE9
1E54:  MOVLW  00
1E56:  ADDWFC 03,W
1E58:  MOVWF  FEA
1E5A:  MOVFF  FEC,03
1E5E:  MOVF   FED,F
1E60:  MOVFF  FEF,01
1E64:  MOVF   x1E,W
1E66:  SUBWF  03,W
1E68:  BNC   1EF2
1E6A:  BNZ   1E72
1E6C:  MOVF   01,W
1E6E:  SUBWF  x1D,W
1E70:  BC    1EF2
.................... 			if ( channel[c].lvd_disconnect_delay_seconds > 0 ) {
1E72:  MOVF   x1C,W
1E74:  MULLW  19
1E76:  MOVF   FF3,W
1E78:  CLRF   x20
1E7A:  MOVWF  x1F
1E7C:  MOVLW  09
1E7E:  ADDWF  x1F,W
1E80:  MOVWF  01
1E82:  MOVLW  00
1E84:  ADDWFC x20,W
1E86:  MOVWF  03
1E88:  MOVF   01,W
1E8A:  ADDLW  DA
1E8C:  MOVWF  FE9
1E8E:  MOVLW  00
1E90:  ADDWFC 03,W
1E92:  MOVWF  FEA
1E94:  MOVFF  FEC,120
1E98:  MOVF   FED,F
1E9A:  MOVFF  FEF,11F
1E9E:  MOVF   x1F,F
1EA0:  BNZ   1EA6
1EA2:  MOVF   x20,F
1EA4:  BZ    1ED4
.................... 				channel[c].lvd_disconnect_delay_seconds--;
1EA6:  MOVF   x1C,W
1EA8:  MULLW  19
1EAA:  MOVF   FF3,W
1EAC:  CLRF   x20
1EAE:  MOVWF  x1F
1EB0:  MOVLW  09
1EB2:  ADDWF  x1F,W
1EB4:  MOVWF  01
1EB6:  MOVLW  00
1EB8:  ADDWFC x20,W
1EBA:  MOVWF  03
1EBC:  MOVF   01,W
1EBE:  ADDLW  DA
1EC0:  MOVWF  FE9
1EC2:  MOVLW  00
1EC4:  ADDWFC 03,W
1EC6:  MOVWF  FEA
1EC8:  MOVLW  FF
1ECA:  ADDWF  FEF,F
1ECC:  BC    1ED2
1ECE:  MOVF   FEE,F
1ED0:  DECF   FED,F
.................... 			} else {
1ED2:  BRA    1EF0
.................... 				bit_set(channel[c].state,CH_STATE_BIT_LVD);
1ED4:  MOVF   x1C,W
1ED6:  MULLW  19
1ED8:  MOVF   FF3,W
1EDA:  CLRF   x20
1EDC:  MOVWF  x1F
1EDE:  MOVLW  DA
1EE0:  ADDWF  x1F,W
1EE2:  MOVWF  01
1EE4:  MOVLW  00
1EE6:  ADDWFC x20,W
1EE8:  MOVFF  01,FE9
1EEC:  MOVWF  FEA
1EEE:  BSF    FEF.3
.................... 			}
.................... 		} else {
1EF0:  BRA    1F58
.................... 			channel[c].lvd_disconnect_delay_seconds=config.ch[c].lvd_disconnect_delay;
1EF2:  MOVF   x1C,W
1EF4:  MULLW  19
1EF6:  MOVF   FF3,W
1EF8:  CLRF   x20
1EFA:  MOVWF  x1F
1EFC:  MOVLW  09
1EFE:  ADDWF  x1F,W
1F00:  MOVWF  01
1F02:  MOVLW  00
1F04:  ADDWFC x20,W
1F06:  MOVWF  03
1F08:  MOVF   01,W
1F0A:  ADDLW  DA
1F0C:  MOVWF  01
1F0E:  MOVLW  00
1F10:  ADDWFC 03,F
1F12:  MOVFF  01,11F
1F16:  MOVFF  03,120
1F1A:  MOVF   x1C,W
1F1C:  MULLW  24
1F1E:  MOVF   FF3,W
1F20:  CLRF   x22
1F22:  MOVWF  x21
1F24:  MOVLW  06
1F26:  ADDWF  x21,W
1F28:  MOVWF  01
1F2A:  MOVLW  00
1F2C:  ADDWFC x22,W
1F2E:  MOVWF  03
1F30:  MOVF   01,W
1F32:  ADDLW  1B
1F34:  MOVWF  FE9
1F36:  MOVLW  00
1F38:  ADDWFC 03,W
1F3A:  MOVWF  FEA
1F3C:  MOVFF  FEC,03
1F40:  MOVF   FED,F
1F42:  MOVFF  FEF,121
1F46:  MOVFF  120,FEA
1F4A:  MOVFF  11F,FE9
1F4E:  MOVFF  03,FEC
1F52:  MOVF   FED,F
1F54:  MOVFF  121,FEF
.................... 		}
.................... 	}
.................... 
.................... 	/* HVD. 65535 disables */
.................... 	if ( 65535 != config.ch[c].hvd_disconnect_delay ) {
1F58:  MOVF   x1C,W
1F5A:  MULLW  24
1F5C:  MOVF   FF3,W
1F5E:  CLRF   x20
1F60:  MOVWF  x1F
1F62:  MOVLW  0E
1F64:  ADDWF  x1F,W
1F66:  MOVWF  01
1F68:  MOVLW  00
1F6A:  ADDWFC x20,W
1F6C:  MOVWF  03
1F6E:  MOVF   01,W
1F70:  ADDLW  1B
1F72:  MOVWF  FE9
1F74:  MOVLW  00
1F76:  ADDWFC 03,W
1F78:  MOVWF  FEA
1F7A:  MOVFF  FEC,03
1F7E:  MOVF   FED,F
1F80:  MOVF   FEF,W
1F82:  SUBLW  FF
1F84:  BNZ   1F8C
1F86:  INCFSZ 03,W
1F88:  BRA    1F8C
1F8A:  BRA    21EA
1F8C:  CLRF   19
1F8E:  BTFSC  FF2.7
1F90:  BSF    19.7
1F92:  BCF    FF2.7
.................... 		adc=adc_get(0);
1F94:  CLRF   x2F
1F96:  MOVLB  0
1F98:  CALL   0594
1F9C:  BTFSC  19.7
1F9E:  BSF    FF2.7
1FA0:  MOVFF  02,11E
1FA4:  MOVFF  01,11D
.................... 
.................... 		if ( adc < config.ch[c].hvd_reconnect_adc ) {
1FA8:  MOVLB  1
1FAA:  MOVF   x1C,W
1FAC:  MULLW  24
1FAE:  MOVF   FF3,W
1FB0:  CLRF   x20
1FB2:  MOVWF  x1F
1FB4:  MOVLW  10
1FB6:  ADDWF  x1F,W
1FB8:  MOVWF  01
1FBA:  MOVLW  00
1FBC:  ADDWFC x20,W
1FBE:  MOVWF  03
1FC0:  MOVF   01,W
1FC2:  ADDLW  1B
1FC4:  MOVWF  FE9
1FC6:  MOVLW  00
1FC8:  ADDWFC 03,W
1FCA:  MOVWF  FEA
1FCC:  MOVFF  FEC,03
1FD0:  MOVF   FED,F
1FD2:  MOVFF  FEF,01
1FD6:  MOVF   x1E,W
1FD8:  SUBWF  03,W
1FDA:  BNC   2064
1FDC:  BNZ   1FE4
1FDE:  MOVF   01,W
1FE0:  SUBWF  x1D,W
1FE2:  BC    2064
.................... 			if ( channel[c].hvd_reconnect_delay_seconds > 0 ) {
1FE4:  MOVF   x1C,W
1FE6:  MULLW  19
1FE8:  MOVF   FF3,W
1FEA:  CLRF   x20
1FEC:  MOVWF  x1F
1FEE:  MOVLW  0F
1FF0:  ADDWF  x1F,W
1FF2:  MOVWF  01
1FF4:  MOVLW  00
1FF6:  ADDWFC x20,W
1FF8:  MOVWF  03
1FFA:  MOVF   01,W
1FFC:  ADDLW  DA
1FFE:  MOVWF  FE9
2000:  MOVLW  00
2002:  ADDWFC 03,W
2004:  MOVWF  FEA
2006:  MOVFF  FEC,120
200A:  MOVF   FED,F
200C:  MOVFF  FEF,11F
2010:  MOVF   x1F,F
2012:  BNZ   2018
2014:  MOVF   x20,F
2016:  BZ    2046
.................... 				channel[c].hvd_reconnect_delay_seconds--;
2018:  MOVF   x1C,W
201A:  MULLW  19
201C:  MOVF   FF3,W
201E:  CLRF   x20
2020:  MOVWF  x1F
2022:  MOVLW  0F
2024:  ADDWF  x1F,W
2026:  MOVWF  01
2028:  MOVLW  00
202A:  ADDWFC x20,W
202C:  MOVWF  03
202E:  MOVF   01,W
2030:  ADDLW  DA
2032:  MOVWF  FE9
2034:  MOVLW  00
2036:  ADDWFC 03,W
2038:  MOVWF  FEA
203A:  MOVLW  FF
203C:  ADDWF  FEF,F
203E:  BC    2044
2040:  MOVF   FEE,F
2042:  DECF   FED,F
.................... 			} else {
2044:  BRA    2062
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_HVD);
2046:  MOVF   x1C,W
2048:  MULLW  19
204A:  MOVF   FF3,W
204C:  CLRF   x20
204E:  MOVWF  x1F
2050:  MOVLW  DA
2052:  ADDWF  x1F,W
2054:  MOVWF  01
2056:  MOVLW  00
2058:  ADDWFC x20,W
205A:  MOVFF  01,FE9
205E:  MOVWF  FEA
2060:  BCF    FEF.4
.................... 			}
.................... 		} else {
2062:  BRA    20CA
.................... 			channel[c].hvd_reconnect_delay_seconds=config.ch[c].hvd_reconnect_delay;
2064:  MOVF   x1C,W
2066:  MULLW  19
2068:  MOVF   FF3,W
206A:  CLRF   x20
206C:  MOVWF  x1F
206E:  MOVLW  0F
2070:  ADDWF  x1F,W
2072:  MOVWF  01
2074:  MOVLW  00
2076:  ADDWFC x20,W
2078:  MOVWF  03
207A:  MOVF   01,W
207C:  ADDLW  DA
207E:  MOVWF  01
2080:  MOVLW  00
2082:  ADDWFC 03,F
2084:  MOVFF  01,11F
2088:  MOVFF  03,120
208C:  MOVF   x1C,W
208E:  MULLW  24
2090:  MOVF   FF3,W
2092:  CLRF   x22
2094:  MOVWF  x21
2096:  MOVLW  12
2098:  ADDWF  x21,W
209A:  MOVWF  01
209C:  MOVLW  00
209E:  ADDWFC x22,W
20A0:  MOVWF  03
20A2:  MOVF   01,W
20A4:  ADDLW  1B
20A6:  MOVWF  FE9
20A8:  MOVLW  00
20AA:  ADDWFC 03,W
20AC:  MOVWF  FEA
20AE:  MOVFF  FEC,03
20B2:  MOVF   FED,F
20B4:  MOVFF  FEF,121
20B8:  MOVFF  120,FEA
20BC:  MOVFF  11F,FE9
20C0:  MOVFF  03,FEC
20C4:  MOVF   FED,F
20C6:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc > config.ch[c].hvd_disconnect_adc ) {
20CA:  MOVF   x1C,W
20CC:  MULLW  24
20CE:  MOVF   FF3,W
20D0:  CLRF   x20
20D2:  MOVWF  x1F
20D4:  MOVLW  0C
20D6:  ADDWF  x1F,W
20D8:  MOVWF  01
20DA:  MOVLW  00
20DC:  ADDWFC x20,W
20DE:  MOVWF  03
20E0:  MOVF   01,W
20E2:  ADDLW  1B
20E4:  MOVWF  FE9
20E6:  MOVLW  00
20E8:  ADDWFC 03,W
20EA:  MOVWF  FEA
20EC:  MOVFF  FEC,03
20F0:  MOVF   FED,F
20F2:  MOVFF  FEF,01
20F6:  MOVF   03,W
20F8:  SUBWF  x1E,W
20FA:  BNC   2184
20FC:  BNZ   2104
20FE:  MOVF   x1D,W
2100:  SUBWF  01,W
2102:  BC    2184
.................... 			if ( channel[c].hvd_disconnect_delay_seconds > 0 ) {
2104:  MOVF   x1C,W
2106:  MULLW  19
2108:  MOVF   FF3,W
210A:  CLRF   x20
210C:  MOVWF  x1F
210E:  MOVLW  0D
2110:  ADDWF  x1F,W
2112:  MOVWF  01
2114:  MOVLW  00
2116:  ADDWFC x20,W
2118:  MOVWF  03
211A:  MOVF   01,W
211C:  ADDLW  DA
211E:  MOVWF  FE9
2120:  MOVLW  00
2122:  ADDWFC 03,W
2124:  MOVWF  FEA
2126:  MOVFF  FEC,120
212A:  MOVF   FED,F
212C:  MOVFF  FEF,11F
2130:  MOVF   x1F,F
2132:  BNZ   2138
2134:  MOVF   x20,F
2136:  BZ    2166
.................... 				channel[c].hvd_disconnect_delay_seconds--;
2138:  MOVF   x1C,W
213A:  MULLW  19
213C:  MOVF   FF3,W
213E:  CLRF   x20
2140:  MOVWF  x1F
2142:  MOVLW  0D
2144:  ADDWF  x1F,W
2146:  MOVWF  01
2148:  MOVLW  00
214A:  ADDWFC x20,W
214C:  MOVWF  03
214E:  MOVF   01,W
2150:  ADDLW  DA
2152:  MOVWF  FE9
2154:  MOVLW  00
2156:  ADDWFC 03,W
2158:  MOVWF  FEA
215A:  MOVLW  FF
215C:  ADDWF  FEF,F
215E:  BC    2164
2160:  MOVF   FEE,F
2162:  DECF   FED,F
.................... 			} else {
2164:  BRA    2182
.................... 				bit_set(channel[c].state,CH_STATE_BIT_HVD);
2166:  MOVF   x1C,W
2168:  MULLW  19
216A:  MOVF   FF3,W
216C:  CLRF   x20
216E:  MOVWF  x1F
2170:  MOVLW  DA
2172:  ADDWF  x1F,W
2174:  MOVWF  01
2176:  MOVLW  00
2178:  ADDWFC x20,W
217A:  MOVFF  01,FE9
217E:  MOVWF  FEA
2180:  BSF    FEF.4
.................... 			}
.................... 		} else {
2182:  BRA    21EA
.................... 			channel[c].hvd_disconnect_delay_seconds=config.ch[c].hvd_disconnect_delay;
2184:  MOVF   x1C,W
2186:  MULLW  19
2188:  MOVF   FF3,W
218A:  CLRF   x20
218C:  MOVWF  x1F
218E:  MOVLW  0D
2190:  ADDWF  x1F,W
2192:  MOVWF  01
2194:  MOVLW  00
2196:  ADDWFC x20,W
2198:  MOVWF  03
219A:  MOVF   01,W
219C:  ADDLW  DA
219E:  MOVWF  01
21A0:  MOVLW  00
21A2:  ADDWFC 03,F
21A4:  MOVFF  01,11F
21A8:  MOVFF  03,120
21AC:  MOVF   x1C,W
21AE:  MULLW  24
21B0:  MOVF   FF3,W
21B2:  CLRF   x22
21B4:  MOVWF  x21
21B6:  MOVLW  0E
21B8:  ADDWF  x21,W
21BA:  MOVWF  01
21BC:  MOVLW  00
21BE:  ADDWFC x22,W
21C0:  MOVWF  03
21C2:  MOVF   01,W
21C4:  ADDLW  1B
21C6:  MOVWF  FE9
21C8:  MOVLW  00
21CA:  ADDWFC 03,W
21CC:  MOVWF  FEA
21CE:  MOVFF  FEC,03
21D2:  MOVF   FED,F
21D4:  MOVFF  FEF,121
21D8:  MOVFF  120,FEA
21DC:  MOVFF  11F,FE9
21E0:  MOVFF  03,FEC
21E4:  MOVF   FED,F
21E6:  MOVFF  121,FEF
.................... 		}
.................... 	}
.................... 
.................... 	/* LTD. 65535 disables */
.................... 	if ( 65535 != config.ch[c].ltd_disconnect_delay ) {
21EA:  MOVF   x1C,W
21EC:  MULLW  24
21EE:  MOVF   FF3,W
21F0:  CLRF   x20
21F2:  MOVWF  x1F
21F4:  MOVLW  16
21F6:  ADDWF  x1F,W
21F8:  MOVWF  01
21FA:  MOVLW  00
21FC:  ADDWFC x20,W
21FE:  MOVWF  03
2200:  MOVF   01,W
2202:  ADDLW  1B
2204:  MOVWF  FE9
2206:  MOVLW  00
2208:  ADDWFC 03,W
220A:  MOVWF  FEA
220C:  MOVFF  FEC,03
2210:  MOVF   FED,F
2212:  MOVF   FEF,W
2214:  SUBLW  FF
2216:  BNZ   221E
2218:  INCFSZ 03,W
221A:  BRA    221E
221C:  BRA    247E
221E:  CLRF   19
2220:  BTFSC  FF2.7
2222:  BSF    19.7
2224:  BCF    FF2.7
.................... 		adc=adc_get(1);
2226:  MOVLW  01
2228:  MOVWF  x2F
222A:  MOVLB  0
222C:  CALL   0594
2230:  BTFSC  19.7
2232:  BSF    FF2.7
2234:  MOVFF  02,11E
2238:  MOVFF  01,11D
.................... 
.................... 		if ( adc < config.ch[c].ltd_reconnect_adc ) {
223C:  MOVLB  1
223E:  MOVF   x1C,W
2240:  MULLW  24
2242:  MOVF   FF3,W
2244:  CLRF   x20
2246:  MOVWF  x1F
2248:  MOVLW  18
224A:  ADDWF  x1F,W
224C:  MOVWF  01
224E:  MOVLW  00
2250:  ADDWFC x20,W
2252:  MOVWF  03
2254:  MOVF   01,W
2256:  ADDLW  1B
2258:  MOVWF  FE9
225A:  MOVLW  00
225C:  ADDWFC 03,W
225E:  MOVWF  FEA
2260:  MOVFF  FEC,03
2264:  MOVF   FED,F
2266:  MOVFF  FEF,01
226A:  MOVF   x1E,W
226C:  SUBWF  03,W
226E:  BNC   22F8
2270:  BNZ   2278
2272:  MOVF   01,W
2274:  SUBWF  x1D,W
2276:  BC    22F8
.................... 			/* above reconnect temperature */
.................... 			if ( channel[c].ltd_reconnect_delay_seconds > 0 ) {
2278:  MOVF   x1C,W
227A:  MULLW  19
227C:  MOVF   FF3,W
227E:  CLRF   x20
2280:  MOVWF  x1F
2282:  MOVLW  13
2284:  ADDWF  x1F,W
2286:  MOVWF  01
2288:  MOVLW  00
228A:  ADDWFC x20,W
228C:  MOVWF  03
228E:  MOVF   01,W
2290:  ADDLW  DA
2292:  MOVWF  FE9
2294:  MOVLW  00
2296:  ADDWFC 03,W
2298:  MOVWF  FEA
229A:  MOVFF  FEC,120
229E:  MOVF   FED,F
22A0:  MOVFF  FEF,11F
22A4:  MOVF   x1F,F
22A6:  BNZ   22AC
22A8:  MOVF   x20,F
22AA:  BZ    22DA
.................... 				channel[c].ltd_reconnect_delay_seconds--;
22AC:  MOVF   x1C,W
22AE:  MULLW  19
22B0:  MOVF   FF3,W
22B2:  CLRF   x20
22B4:  MOVWF  x1F
22B6:  MOVLW  13
22B8:  ADDWF  x1F,W
22BA:  MOVWF  01
22BC:  MOVLW  00
22BE:  ADDWFC x20,W
22C0:  MOVWF  03
22C2:  MOVF   01,W
22C4:  ADDLW  DA
22C6:  MOVWF  FE9
22C8:  MOVLW  00
22CA:  ADDWFC 03,W
22CC:  MOVWF  FEA
22CE:  MOVLW  FF
22D0:  ADDWF  FEF,F
22D2:  BC    22D8
22D4:  MOVF   FEE,F
22D6:  DECF   FED,F
.................... 			} else {
22D8:  BRA    22F6
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_LTD);
22DA:  MOVF   x1C,W
22DC:  MULLW  19
22DE:  MOVF   FF3,W
22E0:  CLRF   x20
22E2:  MOVWF  x1F
22E4:  MOVLW  DA
22E6:  ADDWF  x1F,W
22E8:  MOVWF  01
22EA:  MOVLW  00
22EC:  ADDWFC x20,W
22EE:  MOVFF  01,FE9
22F2:  MOVWF  FEA
22F4:  BCF    FEF.5
.................... 			}
.................... 		} else {
22F6:  BRA    235E
.................... 			channel[c].ltd_reconnect_delay_seconds=config.ch[c].ltd_reconnect_delay;
22F8:  MOVF   x1C,W
22FA:  MULLW  19
22FC:  MOVF   FF3,W
22FE:  CLRF   x20
2300:  MOVWF  x1F
2302:  MOVLW  13
2304:  ADDWF  x1F,W
2306:  MOVWF  01
2308:  MOVLW  00
230A:  ADDWFC x20,W
230C:  MOVWF  03
230E:  MOVF   01,W
2310:  ADDLW  DA
2312:  MOVWF  01
2314:  MOVLW  00
2316:  ADDWFC 03,F
2318:  MOVFF  01,11F
231C:  MOVFF  03,120
2320:  MOVF   x1C,W
2322:  MULLW  24
2324:  MOVF   FF3,W
2326:  CLRF   x22
2328:  MOVWF  x21
232A:  MOVLW  1A
232C:  ADDWF  x21,W
232E:  MOVWF  01
2330:  MOVLW  00
2332:  ADDWFC x22,W
2334:  MOVWF  03
2336:  MOVF   01,W
2338:  ADDLW  1B
233A:  MOVWF  FE9
233C:  MOVLW  00
233E:  ADDWFC 03,W
2340:  MOVWF  FEA
2342:  MOVFF  FEC,03
2346:  MOVF   FED,F
2348:  MOVFF  FEF,121
234C:  MOVFF  120,FEA
2350:  MOVFF  11F,FE9
2354:  MOVFF  03,FEC
2358:  MOVF   FED,F
235A:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc > config.ch[c].ltd_disconnect_adc ) {
235E:  MOVF   x1C,W
2360:  MULLW  24
2362:  MOVF   FF3,W
2364:  CLRF   x20
2366:  MOVWF  x1F
2368:  MOVLW  14
236A:  ADDWF  x1F,W
236C:  MOVWF  01
236E:  MOVLW  00
2370:  ADDWFC x20,W
2372:  MOVWF  03
2374:  MOVF   01,W
2376:  ADDLW  1B
2378:  MOVWF  FE9
237A:  MOVLW  00
237C:  ADDWFC 03,W
237E:  MOVWF  FEA
2380:  MOVFF  FEC,03
2384:  MOVF   FED,F
2386:  MOVFF  FEF,01
238A:  MOVF   03,W
238C:  SUBWF  x1E,W
238E:  BNC   2418
2390:  BNZ   2398
2392:  MOVF   x1D,W
2394:  SUBWF  01,W
2396:  BC    2418
.................... 			/* below disconnect temperature */
.................... 			if ( channel[c].ltd_disconnect_delay_seconds > 0 ) {
2398:  MOVF   x1C,W
239A:  MULLW  19
239C:  MOVF   FF3,W
239E:  CLRF   x20
23A0:  MOVWF  x1F
23A2:  MOVLW  11
23A4:  ADDWF  x1F,W
23A6:  MOVWF  01
23A8:  MOVLW  00
23AA:  ADDWFC x20,W
23AC:  MOVWF  03
23AE:  MOVF   01,W
23B0:  ADDLW  DA
23B2:  MOVWF  FE9
23B4:  MOVLW  00
23B6:  ADDWFC 03,W
23B8:  MOVWF  FEA
23BA:  MOVFF  FEC,120
23BE:  MOVF   FED,F
23C0:  MOVFF  FEF,11F
23C4:  MOVF   x1F,F
23C6:  BNZ   23CC
23C8:  MOVF   x20,F
23CA:  BZ    23FA
.................... 				channel[c].ltd_disconnect_delay_seconds--;
23CC:  MOVF   x1C,W
23CE:  MULLW  19
23D0:  MOVF   FF3,W
23D2:  CLRF   x20
23D4:  MOVWF  x1F
23D6:  MOVLW  11
23D8:  ADDWF  x1F,W
23DA:  MOVWF  01
23DC:  MOVLW  00
23DE:  ADDWFC x20,W
23E0:  MOVWF  03
23E2:  MOVF   01,W
23E4:  ADDLW  DA
23E6:  MOVWF  FE9
23E8:  MOVLW  00
23EA:  ADDWFC 03,W
23EC:  MOVWF  FEA
23EE:  MOVLW  FF
23F0:  ADDWF  FEF,F
23F2:  BC    23F8
23F4:  MOVF   FEE,F
23F6:  DECF   FED,F
.................... 			} else {
23F8:  BRA    2416
.................... 				bit_set(channel[c].state,CH_STATE_BIT_LTD);
23FA:  MOVF   x1C,W
23FC:  MULLW  19
23FE:  MOVF   FF3,W
2400:  CLRF   x20
2402:  MOVWF  x1F
2404:  MOVLW  DA
2406:  ADDWF  x1F,W
2408:  MOVWF  01
240A:  MOVLW  00
240C:  ADDWFC x20,W
240E:  MOVFF  01,FE9
2412:  MOVWF  FEA
2414:  BSF    FEF.5
.................... 			}
.................... 		} else {
2416:  BRA    247E
.................... 			channel[c].ltd_disconnect_delay_seconds=config.ch[c].ltd_disconnect_delay;
2418:  MOVF   x1C,W
241A:  MULLW  19
241C:  MOVF   FF3,W
241E:  CLRF   x20
2420:  MOVWF  x1F
2422:  MOVLW  11
2424:  ADDWF  x1F,W
2426:  MOVWF  01
2428:  MOVLW  00
242A:  ADDWFC x20,W
242C:  MOVWF  03
242E:  MOVF   01,W
2430:  ADDLW  DA
2432:  MOVWF  01
2434:  MOVLW  00
2436:  ADDWFC 03,F
2438:  MOVFF  01,11F
243C:  MOVFF  03,120
2440:  MOVF   x1C,W
2442:  MULLW  24
2444:  MOVF   FF3,W
2446:  CLRF   x22
2448:  MOVWF  x21
244A:  MOVLW  16
244C:  ADDWF  x21,W
244E:  MOVWF  01
2450:  MOVLW  00
2452:  ADDWFC x22,W
2454:  MOVWF  03
2456:  MOVF   01,W
2458:  ADDLW  1B
245A:  MOVWF  FE9
245C:  MOVLW  00
245E:  ADDWFC 03,W
2460:  MOVWF  FEA
2462:  MOVFF  FEC,03
2466:  MOVF   FED,F
2468:  MOVFF  FEF,121
246C:  MOVFF  120,FEA
2470:  MOVFF  11F,FE9
2474:  MOVFF  03,FEC
2478:  MOVF   FED,F
247A:  MOVFF  121,FEF
.................... 		}
.................... 	}
247E:  MOVLB  0
2480:  RETURN 0
.................... 
.................... 
.................... 	/* TODO: implement High Temperature Disconnect (HTD) */
.................... }
.................... 
.................... 
.................... void led_status_second_update(void) {
.................... 	static int8 second=0;
.................... 	static int8 cycle=0;
.................... 	int8 led;
.................... 
.................... 	/* update every four seconds */
.................... 	if ( 4==second ) {
*
2590:  MOVLB  1
2592:  MOVF   x11,W
2594:  SUBLW  04
2596:  BNZ   259C
.................... 		second=0;
2598:  CLRF   x11
.................... 		return;
259A:  BRA    2686
.................... 	}
.................... 
.................... 	for ( led=0 ; led<2 ; led++ ) {
259C:  CLRF   x1C
259E:  MOVF   x1C,W
25A0:  SUBLW  01
25A2:  BNC   2678
.................... 		if ( cycle < 8 ) {
25A4:  MOVF   x12,W
25A6:  SUBLW  07
25A8:  BNC   2610
.................... 			/* first 8 cycles are 8 bits of state bit field */
.................... 
.................... 			/* if bit is set, then we blink the number of times+1 of the bit we are in. So bit 1 set means we blink 2 times */
.................... 			if ( bit_test(channel[led].state,cycle) ) {
25AA:  MOVF   x1C,W
25AC:  MULLW  19
25AE:  MOVF   FF3,W
25B0:  CLRF   x1E
25B2:  MOVWF  x1D
25B4:  MOVLW  DA
25B6:  ADDWF  x1D,W
25B8:  MOVWF  FE9
25BA:  MOVLW  00
25BC:  ADDWFC x1E,W
25BE:  MOVWF  FEA
25C0:  MOVFF  FEF,00
25C4:  MOVF   x12,W
25C6:  MOVWF  01
25C8:  BZ    25D2
25CA:  BCF    FD8.0
25CC:  RRCF   00,F
25CE:  DECFSZ 01,F
25D0:  BRA    25CA
25D2:  BTFSS  00.0
25D4:  BRA    25FE
.................... 				timers.led_blink[led]=cycle+1;      /* number of blinks */
25D6:  CLRF   03
25D8:  MOVF   x1C,W
25DA:  ADDLW  D0
25DC:  MOVWF  FE9
25DE:  MOVLW  00
25E0:  ADDWFC 03,W
25E2:  MOVWF  FEA
25E4:  MOVLW  01
25E6:  ADDWF  x12,W
25E8:  MOVWF  FEF
.................... 				timers.led_on[led]=BLINK_ON_TIME;   /* how long to be on */
25EA:  CLRF   03
25EC:  MOVF   x1C,W
25EE:  ADDLW  D2
25F0:  MOVWF  FE9
25F2:  MOVLW  00
25F4:  ADDWFC 03,W
25F6:  MOVWF  FEA
25F8:  MOVLW  FE
25FA:  MOVWF  FEF
.................... 			} else {
25FC:  BRA    260E
.................... 				timers.led_blink[led]=0;
25FE:  CLRF   03
2600:  MOVF   x1C,W
2602:  ADDLW  D0
2604:  MOVWF  FE9
2606:  MOVLW  00
2608:  ADDWFC 03,W
260A:  MOVWF  FEA
260C:  CLRF   FEF
.................... 			}
.................... 		} else if ( 8 == cycle ) {
260E:  BRA    2674
2610:  MOVF   x12,W
2612:  SUBLW  08
2614:  BNZ   2628
.................... 			/* solid light to mark start of next cycle */
.................... 			timers.led_blink[led]=255;
2616:  CLRF   03
2618:  MOVF   x1C,W
261A:  ADDLW  D0
261C:  MOVWF  FE9
261E:  MOVLW  00
2620:  ADDWFC 03,W
2622:  MOVWF  FEA
2624:  SETF   FEF
.................... 		} else if ( 9 == cycle ) {
2626:  BRA    2674
2628:  MOVF   x12,W
262A:  SUBLW  09
262C:  BNZ   2664
.................... 			/* solid on if contactor state is on, otherwise off */
.................... 			if ( timers.contactor[led] ) {
262E:  CLRF   03
2630:  MOVF   x1C,W
2632:  ADDLW  D6
2634:  MOVWF  FE9
2636:  MOVLW  00
2638:  ADDWFC 03,W
263A:  MOVWF  FEA
263C:  MOVF   FEF,F
263E:  BZ    2652
.................... 				timers.led_blink[led]=255;
2640:  CLRF   03
2642:  MOVF   x1C,W
2644:  ADDLW  D0
2646:  MOVWF  FE9
2648:  MOVLW  00
264A:  ADDWFC 03,W
264C:  MOVWF  FEA
264E:  SETF   FEF
.................... 			} else {
2650:  BRA    2662
.................... 				timers.led_blink[led]=0;
2652:  CLRF   03
2654:  MOVF   x1C,W
2656:  ADDLW  D0
2658:  MOVWF  FE9
265A:  MOVLW  00
265C:  ADDWFC 03,W
265E:  MOVWF  FEA
2660:  CLRF   FEF
.................... 			}
.................... 		} else {
2662:  BRA    2674
.................... 			/* blank period before starting the bit field */
.................... 			timers.led_blink[led]=0;
2664:  CLRF   03
2666:  MOVF   x1C,W
2668:  ADDLW  D0
266A:  MOVWF  FE9
266C:  MOVLW  00
266E:  ADDWFC 03,W
2670:  MOVWF  FEA
2672:  CLRF   FEF
.................... 		}
2674:  INCF   x1C,F
2676:  BRA    259E
.................... 	}
.................... 
.................... //	fprintf(STREAM_FTDI,"# LED %u A=%03u (0x%02X) B=%03u (0x%02X)\r\n",cycle,timers.led_blink[0],channel[0].state,timers.led_blink[1],channel[1].state);
.................... 
.................... 	if ( 10 == cycle ) {
2678:  MOVF   x12,W
267A:  SUBLW  0A
267C:  BNZ   2682
.................... 		cycle=0; 
267E:  CLRF   x12
.................... 	} else {
2680:  BRA    2684
.................... 		cycle++;
2682:  INCF   x12,F
.................... 	}
.................... 
.................... 	second++;
2684:  INCF   x11,F
2686:  MOVLB  0
2688:  GOTO   282C (RETURN)
.................... }
.................... 
.................... void led_on(int8 c) {
.................... 	if ( 0==c ) 
*
18AA:  MOVLB  1
18AC:  MOVF   x1C,F
18AE:  BNZ   18B6
.................... 		output_high(LED_A);
18B0:  BCF    F94.1
18B2:  BSF    F8B.1
18B4:  BRA    18BA
.................... 	else
.................... 		output_high(LED_B);
18B6:  BCF    F94.2
18B8:  BSF    F8B.2
18BA:  MOVLB  0
18BC:  RETURN 0
.................... }
.................... 
.................... void led_off(int8 c) {
.................... 	if ( 0==c ) 
18BE:  MOVLB  1
18C0:  MOVF   x1C,F
18C2:  BNZ   18CA
.................... 		output_low(LED_A);
18C4:  BCF    F94.1
18C6:  BCF    F8B.1
18C8:  BRA    18CE
.................... 	else
.................... 		output_low(LED_B);
18CA:  BCF    F94.2
18CC:  BCF    F8B.2
18CE:  MOVLB  0
18D0:  RETURN 0
.................... }
.................... 
.................... void periodic_millisecond(void) {
.................... 	static int8 uptimeticks=0;
.................... 	static int16 adcTicks=0;
.................... 	static int16 ticks=0;
.................... 
.................... 	int8 i;
.................... 
.................... 
.................... 	timers.now_millisecond=0;
*
268C:  BCF    xCF.2
.................... 
.................... 	/* set LED output */
.................... 	for ( i=0 ; i<2 ; i++ ) {
268E:  MOVLB  1
2690:  CLRF   x1B
2692:  MOVF   x1B,W
2694:  SUBLW  01
2696:  BTFSS  FD8.0
2698:  BRA    2798
.................... 		if ( 255 == timers.led_blink[i] ) {
269A:  CLRF   03
269C:  MOVF   x1B,W
269E:  ADDLW  D0
26A0:  MOVWF  FE9
26A2:  MOVLW  00
26A4:  ADDWFC 03,W
26A6:  MOVWF  FEA
26A8:  MOVF   FEF,W
26AA:  SUBLW  FF
26AC:  BNZ   26BC
.................... 			led_on(i);
26AE:  MOVFF  11B,11C
26B2:  MOVLB  0
26B4:  CALL   18AA
.................... 		} else if ( 0 == timers.led_blink[i] ) {
26B8:  BRA    2792
26BA:  MOVLB  1
26BC:  CLRF   03
26BE:  MOVF   x1B,W
26C0:  ADDLW  D0
26C2:  MOVWF  FE9
26C4:  MOVLW  00
26C6:  ADDWFC 03,W
26C8:  MOVWF  FEA
26CA:  MOVF   FEF,W
26CC:  BNZ   26DC
.................... 			led_off(i);
26CE:  MOVFF  11B,11C
26D2:  MOVLB  0
26D4:  CALL   18BE
.................... 		} else {
26D8:  BRA    2792
26DA:  MOVLB  1
.................... 			/* led_blink[i] is somewhere between 1 and 254 */
.................... 			if ( timers.led_on[i] > 0 ) {
26DC:  CLRF   03
26DE:  MOVF   x1B,W
26E0:  ADDLW  D2
26E2:  MOVWF  FE9
26E4:  MOVLW  00
26E6:  ADDWFC 03,W
26E8:  MOVWF  FEA
26EA:  MOVF   FEF,F
26EC:  BZ    272E
.................... 				led_on(i);
26EE:  MOVFF  11B,11C
26F2:  MOVLB  0
26F4:  CALL   18AA
.................... 				timers.led_on[i]--;
26F8:  CLRF   03
26FA:  MOVLB  1
26FC:  MOVF   x1B,W
26FE:  ADDLW  D2
2700:  MOVWF  FE9
2702:  MOVLW  00
2704:  ADDWFC 03,W
2706:  MOVWF  FEA
2708:  DECF   FEF,F
.................... 
.................... 				if ( 0==timers.led_on[i] ) {
270A:  CLRF   03
270C:  MOVF   x1B,W
270E:  ADDLW  D2
2710:  MOVWF  FE9
2712:  MOVLW  00
2714:  ADDWFC 03,W
2716:  MOVWF  FEA
2718:  MOVF   FEF,W
271A:  BNZ   272E
.................... 					/* hit zero, switch to our off timer */
.................... 					timers.led_off[i]=BLINK_OFF_TIME;
271C:  CLRF   03
271E:  MOVF   x1B,W
2720:  ADDLW  D4
2722:  MOVWF  FE9
2724:  MOVLW  00
2726:  ADDWFC 03,W
2728:  MOVWF  FEA
272A:  MOVLW  C8
272C:  MOVWF  FEF
.................... 				}
.................... 			}
.................... 
.................... 			if ( timers.led_off[i] > 0 ) {
272E:  CLRF   03
2730:  MOVF   x1B,W
2732:  ADDLW  D4
2734:  MOVWF  FE9
2736:  MOVLW  00
2738:  ADDWFC 03,W
273A:  MOVWF  FEA
273C:  MOVF   FEF,F
273E:  BZ    2790
.................... 				led_off(i);
2740:  MOVFF  11B,11C
2744:  MOVLB  0
2746:  CALL   18BE
.................... 				timers.led_off[i]--;
274A:  CLRF   03
274C:  MOVLB  1
274E:  MOVF   x1B,W
2750:  ADDLW  D4
2752:  MOVWF  FE9
2754:  MOVLW  00
2756:  ADDWFC 03,W
2758:  MOVWF  FEA
275A:  DECF   FEF,F
.................... 
.................... 				if ( 0==timers.led_off[i] ) {
275C:  CLRF   03
275E:  MOVF   x1B,W
2760:  ADDLW  D4
2762:  MOVWF  FE9
2764:  MOVLW  00
2766:  ADDWFC 03,W
2768:  MOVWF  FEA
276A:  MOVF   FEF,W
276C:  BNZ   2790
.................... 					/* hit zero, preload for next */
.................... 					timers.led_on[i]=BLINK_ON_TIME;
276E:  CLRF   03
2770:  MOVF   x1B,W
2772:  ADDLW  D2
2774:  MOVWF  FE9
2776:  MOVLW  00
2778:  ADDWFC 03,W
277A:  MOVWF  FEA
277C:  MOVLW  FE
277E:  MOVWF  FEF
.................... 					/* done with this blink cycle */	
.................... 					timers.led_blink[i]--;
2780:  CLRF   03
2782:  MOVF   x1B,W
2784:  ADDLW  D0
2786:  MOVWF  FE9
2788:  MOVLW  00
278A:  ADDWFC 03,W
278C:  MOVWF  FEA
278E:  DECF   FEF,F
2790:  MOVLB  0
.................... 				}
.................... 			}
.................... 		}
2792:  MOVLB  1
2794:  INCF   x1B,F
2796:  BRA    2692
.................... 	}
.................... 
.................... 
.................... 	/* some other random stuff that we don't need to do every cycle in main */
.................... 	if ( current.interval_milliseconds < 65535 ) {
2798:  MOVLB  0
279A:  INCFSZ xC8,W
279C:  BRA    27A4
279E:  INCFSZ xC9,W
27A0:  BRA    27A4
27A2:  BRA    27AA
.................... 		current.interval_milliseconds++;
27A4:  INCF   xC8,F
27A6:  BTFSC  FD8.2
27A8:  INCF   xC9,F
.................... 	}
.................... 
.................... 
.................... 	/* contactor timeout */
.................... 	if ( 0 == timers.contactor_powersave[0] ) {
27AA:  MOVF   xD8,F
27AC:  BNZ   27B8
.................... 		output_low(BRIDGE_A_A);
27AE:  BCF    F94.3
27B0:  BCF    F8B.3
.................... 		output_low(BRIDGE_A_B);
27B2:  BCF    F94.4
27B4:  BCF    F8B.4
.................... 	} else {
27B6:  BRA    27BA
.................... 		timers.contactor_powersave[0]--;
27B8:  DECF   xD8,F
.................... 	}
.................... 	if ( 0 == timers.contactor_powersave[1] ) {
27BA:  MOVF   xD9,F
27BC:  BNZ   27C8
.................... 		output_low(BRIDGE_B_A);
27BE:  BCF    F94.5
27C0:  BCF    F8B.5
.................... 		output_low(BRIDGE_B_B);
27C2:  BCF    F94.6
27C4:  BCF    F8B.6
.................... 	} else {
27C6:  BRA    27CA
.................... 		timers.contactor_powersave[1]--;
27C8:  DECF   xD9,F
.................... 	}
.................... 
.................... 
.................... 
.................... 
.................... 	/* seconds */
.................... 	ticks++;
27CA:  MOVLB  1
27CC:  INCF   x16,F
27CE:  BTFSC  FD8.2
27D0:  INCF   x17,F
.................... 	if ( 1000 == ticks ) {
27D2:  MOVF   x16,W
27D4:  SUBLW  E8
27D6:  BNZ   282E
27D8:  MOVF   x17,W
27DA:  SUBLW  03
27DC:  BNZ   282E
.................... 		ticks=0;
27DE:  CLRF   x17
27E0:  CLRF   x16
.................... 
.................... 		/* set channe[n].state based on logic */
.................... 		contactor_logic(0);
27E2:  CLRF   x1C
27E4:  MOVLB  0
27E6:  CALL   18D2
.................... 		contactor_logic(1);
27EA:  MOVLW  01
27EC:  MOVLB  1
27EE:  MOVWF  x1C
27F0:  MOVLB  0
27F2:  CALL   18D2
.................... 
.................... 		/* set contactor outputs based on their state bit field */
.................... 		contactor_set(0);
27F6:  MOVLB  1
27F8:  CLRF   x1C
27FA:  MOVLB  0
27FC:  RCALL  252E
.................... 		contactor_set(1);		
27FE:  MOVLW  01
2800:  MOVLB  1
2802:  MOVWF  x1C
2804:  MOVLB  0
2806:  RCALL  252E
.................... 
.................... 		/* uptime counter */
.................... 		uptimeTicks++;
2808:  MOVLB  1
280A:  INCF   x13,F
.................... 		if ( 60 == uptimeTicks ) {
280C:  MOVF   x13,W
280E:  SUBLW  3C
2810:  BNZ   2828
.................... 			uptimeTicks=0;
2812:  CLRF   x13
.................... 			if ( current.uptime_minutes < 65535 ) 
2814:  MOVLB  0
2816:  INCFSZ xC6,W
2818:  BRA    2820
281A:  INCFSZ xC7,W
281C:  BRA    2820
281E:  BRA    2826
.................... 				current.uptime_minutes++;
2820:  INCF   xC6,F
2822:  BTFSC  FD8.2
2824:  INCF   xC7,F
2826:  MOVLB  1
.................... 		}
.................... 
.................... 		/* LED state display update */
.................... 		led_status_second_update();
2828:  MOVLB  0
282A:  BRA    2590
282C:  MOVLB  1
.................... 	}
.................... 
.................... 	/* ADC sample counter */
.................... 	if ( timers.now_adc_reset_count ) {
282E:  MOVLB  0
2830:  BTFSS  xCF.1
2832:  BRA    283E
.................... 		timers.now_adc_reset_count=0;
2834:  BCF    xCF.1
.................... 		adcTicks=0;
2836:  MOVLB  1
2838:  CLRF   x15
283A:  CLRF   x14
283C:  MOVLB  0
.................... 	}
.................... 
.................... 	/* ADC sampling trigger */
.................... 	adcTicks++;
283E:  MOVLB  1
2840:  INCF   x14,F
2842:  BTFSC  FD8.2
2844:  INCF   x15,F
.................... 	if ( ADC_SAMPLE_TICKS == adcTicks ) {
2846:  MOVF   x14,W
2848:  SUBLW  14
284A:  BNZ   285A
284C:  MOVF   x15,F
284E:  BNZ   285A
.................... 		adcTicks=0;
2850:  CLRF   x15
2852:  CLRF   x14
.................... 		timers.now_adc_sample=1;
2854:  MOVLB  0
2856:  BSF    xCF.0
2858:  MOVLB  1
.................... 	}
285A:  MOVLB  0
285C:  GOTO   2C3E (RETURN)
.................... 
.................... }
.................... 
.................... void init(void) {
.................... 	int8 i;
.................... 	int8 buff[10];
.................... 	setup_oscillator(OSC_16MHZ);
*
1100:  MOVLW  70
1102:  MOVWF  FD3
1104:  BCF    F9B.6
1106:  BCF    F9B.7
.................... 
.................... 	setup_adc(ADC_CLOCK_DIV_16);
1108:  MOVF   FC0,W
110A:  ANDLW  C0
110C:  IORLW  05
110E:  MOVWF  FC0
1110:  BSF    FC0.7
1112:  BSF    FC2.0
.................... 	/* NTC thermistor on sAN2, input voltage divider on sAN4, DIP switch analog on sAN9
.................... 	voltage spans between 0 and Vdd */
.................... 	setup_adc_ports(sAN2 | sAN4 | sAN9,VSS_VDD);
1114:  MOVLW  14
1116:  MOVWF  F7E
1118:  BCF    FC1.0
111A:  BCF    FC1.1
111C:  BCF    FC1.2
111E:  BCF    FC1.3
1120:  MOVLW  02
1122:  MOVWF  F7F
.................... 
.................... 	setup_wdt(WDT_512MS);
1124:  BSF    FD1.0
.................... 
.................... 	set_tris_a(0b00111111);
1126:  MOVLW  3F
1128:  MOVWF  F92
.................... 	set_tris_b(0b01110000);
112A:  MOVLW  70
112C:  MOVWF  F93
.................... 	set_tris_c(0b10000001);
112E:  MOVLW  81
1130:  MOVWF  F94
.................... //               76543210
.................... 
.................... 	port_a_pullups(0b00110000);
1132:  MOVLW  30
1134:  MOVWF  F77
1136:  BCF    FF1.7
.................... 	port_b_pullups(0b00000000);
1138:  CLRF   F78
.................... //                   76543210
.................... 
.................... 	/* data structure initialization */
.................... 	/* all initialized to 0 on declaration. Just do this if need non-zero */
.................... 	for ( i=0 ; i<=1 ; i++ ) {
113A:  MOVLB  1
113C:  CLRF   x1B
113E:  MOVF   x1B,W
1140:  SUBLW  01
1142:  BNC   1198
.................... 		channel[i].command_off_seconds=65535;
1144:  MOVF   x1B,W
1146:  MULLW  19
1148:  MOVF   FF3,W
114A:  CLRF   x27
114C:  MOVWF  x26
114E:  MOVLW  05
1150:  ADDWF  x26,W
1152:  MOVWF  01
1154:  MOVLW  00
1156:  ADDWFC x27,W
1158:  MOVWF  03
115A:  MOVF   01,W
115C:  ADDLW  DA
115E:  MOVWF  FE9
1160:  MOVLW  00
1162:  ADDWFC 03,W
1164:  MOVWF  FEA
1166:  SETF   FEC
1168:  MOVF   FED,F
116A:  SETF   FEF
.................... 		channel[i].command_on_seconds =65535;
116C:  MOVF   x1B,W
116E:  MULLW  19
1170:  MOVF   FF3,W
1172:  CLRF   x27
1174:  MOVWF  x26
1176:  MOVLW  01
1178:  ADDWF  x26,W
117A:  MOVWF  01
117C:  MOVLW  00
117E:  ADDWFC x27,W
1180:  MOVWF  03
1182:  MOVF   01,W
1184:  ADDLW  DA
1186:  MOVWF  FE9
1188:  MOVLW  00
118A:  ADDWFC 03,W
118C:  MOVWF  FEA
118E:  SETF   FEC
1190:  MOVF   FED,F
1192:  SETF   FEF
1194:  INCF   x1B,F
1196:  BRA    113E
.................... 	}
.................... 
.................... 	/* get our compiled date from constant  
.................... 	'5-Feb-22'
.................... 	 01234567
.................... 
.................... 	'25-Feb-22'
.................... 	 012345678
.................... 	*/
.................... 	strcpy(buff,__DATE__);
1198:  MOVLW  01
119A:  MOVWF  FEA
119C:  MOVLW  1C
119E:  MOVWF  FE9
11A0:  MOVLW  00
11A2:  MOVLB  0
11A4:  CALL   00BA
11A8:  TBLRD*-
11AA:  TBLRD*+
11AC:  MOVF   FF5,W
11AE:  MOVWF  FEE
11B0:  IORLW  00
11B2:  BNZ   11AA
.................... 	i=0;
11B4:  MOVLB  1
11B6:  CLRF   x1B
.................... 	if ( '-' != buff[1] ) {
11B8:  MOVF   x1D,W
11BA:  SUBLW  2D
11BC:  BZ    11DC
.................... 		/* day can be one or two digits */
.................... 		current.compile_day =(buff[i]-'0')*10;
11BE:  CLRF   03
11C0:  MOVF   x1B,W
11C2:  ADDLW  1C
11C4:  MOVWF  FE9
11C6:  MOVLW  01
11C8:  ADDWFC 03,W
11CA:  MOVWF  FEA
11CC:  MOVLW  30
11CE:  SUBWF  FEF,W
11D0:  MULLW  0A
11D2:  MOVFF  FF3,CD
11D6:  MOVLB  0
.................... 		i++;
11D8:  MOVLB  1
11DA:  INCF   x1B,F
.................... 	}
.................... 	current.compile_day+=(buff[i]-'0');
11DC:  CLRF   03
11DE:  MOVF   x1B,W
11E0:  ADDLW  1C
11E2:  MOVWF  FE9
11E4:  MOVLW  01
11E6:  ADDWFC 03,W
11E8:  MOVWF  FEA
11EA:  MOVLW  30
11EC:  SUBWF  FEF,W
11EE:  MOVLB  0
11F0:  ADDWF  xCD,F
.................... 	i+=2; /* now points to month */
11F2:  MOVLW  02
11F4:  MOVLB  1
11F6:  ADDWF  x1B,F
.................... 
.................... 	/* determine month ... how annoying */
.................... 	if ( 'J'==buff[i+0] ) {
11F8:  CLRF   03
11FA:  MOVF   x1B,W
11FC:  ADDLW  1C
11FE:  MOVWF  FE9
1200:  MOVLW  01
1202:  ADDWFC 03,W
1204:  MOVWF  FEA
1206:  MOVF   FEF,W
1208:  SUBLW  4A
120A:  BNZ   1256
.................... 		if ( 'A'==buff[i+1] )
120C:  MOVLW  01
120E:  ADDWF  x1B,W
1210:  CLRF   03
1212:  ADDLW  1C
1214:  MOVWF  FE9
1216:  MOVLW  01
1218:  ADDWFC 03,W
121A:  MOVWF  FEA
121C:  MOVF   FEF,W
121E:  SUBLW  41
1220:  BNZ   122C
.................... 			current.compile_month=1;
1222:  MOVLW  01
1224:  MOVLB  0
1226:  MOVWF  xCC
1228:  BRA    1252
122A:  MOVLB  1
.................... 		else if ( 'N'==buff[i+2] )
122C:  MOVLW  02
122E:  ADDWF  x1B,W
1230:  CLRF   03
1232:  ADDLW  1C
1234:  MOVWF  FE9
1236:  MOVLW  01
1238:  ADDWFC 03,W
123A:  MOVWF  FEA
123C:  MOVF   FEF,W
123E:  SUBLW  4E
1240:  BNZ   124C
.................... 			current.compile_month=6;
1242:  MOVLW  06
1244:  MOVLB  0
1246:  MOVWF  xCC
1248:  BRA    1252
124A:  MOVLB  1
.................... 		else
.................... 			current.compile_month=7;
124C:  MOVLW  07
124E:  MOVLB  0
1250:  MOVWF  xCC
.................... 	} else if ( 'A'==buff[i+0] ) {
1252:  BRA    136C
1254:  MOVLB  1
1256:  CLRF   03
1258:  MOVF   x1B,W
125A:  ADDLW  1C
125C:  MOVWF  FE9
125E:  MOVLW  01
1260:  ADDWFC 03,W
1262:  MOVWF  FEA
1264:  MOVF   FEF,W
1266:  SUBLW  41
1268:  BNZ   1294
.................... 		if ( 'P'==buff[i+1] )
126A:  MOVLW  01
126C:  ADDWF  x1B,W
126E:  CLRF   03
1270:  ADDLW  1C
1272:  MOVWF  FE9
1274:  MOVLW  01
1276:  ADDWFC 03,W
1278:  MOVWF  FEA
127A:  MOVF   FEF,W
127C:  SUBLW  50
127E:  BNZ   128A
.................... 			current.compile_month=4;
1280:  MOVLW  04
1282:  MOVLB  0
1284:  MOVWF  xCC
1286:  BRA    1290
1288:  MOVLB  1
.................... 		else
.................... 			current.compile_month=8;
128A:  MOVLW  08
128C:  MOVLB  0
128E:  MOVWF  xCC
.................... 	} else if ( 'M'==buff[i+0] ) {
1290:  BRA    136C
1292:  MOVLB  1
1294:  CLRF   03
1296:  MOVF   x1B,W
1298:  ADDLW  1C
129A:  MOVWF  FE9
129C:  MOVLW  01
129E:  ADDWFC 03,W
12A0:  MOVWF  FEA
12A2:  MOVF   FEF,W
12A4:  SUBLW  4D
12A6:  BNZ   12D2
.................... 		if ( 'R'==buff[i+2] )
12A8:  MOVLW  02
12AA:  ADDWF  x1B,W
12AC:  CLRF   03
12AE:  ADDLW  1C
12B0:  MOVWF  FE9
12B2:  MOVLW  01
12B4:  ADDWFC 03,W
12B6:  MOVWF  FEA
12B8:  MOVF   FEF,W
12BA:  SUBLW  52
12BC:  BNZ   12C8
.................... 			current.compile_month=3;
12BE:  MOVLW  03
12C0:  MOVLB  0
12C2:  MOVWF  xCC
12C4:  BRA    12CE
12C6:  MOVLB  1
.................... 		else
.................... 			current.compile_month=5;
12C8:  MOVLW  05
12CA:  MOVLB  0
12CC:  MOVWF  xCC
.................... 	} else if ( 'F'==buff[i+0] ) {
12CE:  BRA    136C
12D0:  MOVLB  1
12D2:  CLRF   03
12D4:  MOVF   x1B,W
12D6:  ADDLW  1C
12D8:  MOVWF  FE9
12DA:  MOVLW  01
12DC:  ADDWFC 03,W
12DE:  MOVWF  FEA
12E0:  MOVF   FEF,W
12E2:  SUBLW  46
12E4:  BNZ   12F0
.................... 		current.compile_month=2;
12E6:  MOVLW  02
12E8:  MOVLB  0
12EA:  MOVWF  xCC
.................... 	} else if ( 'S'==buff[i+0] ) {
12EC:  BRA    136C
12EE:  MOVLB  1
12F0:  CLRF   03
12F2:  MOVF   x1B,W
12F4:  ADDLW  1C
12F6:  MOVWF  FE9
12F8:  MOVLW  01
12FA:  ADDWFC 03,W
12FC:  MOVWF  FEA
12FE:  MOVF   FEF,W
1300:  SUBLW  53
1302:  BNZ   130E
.................... 		current.compile_month=9;
1304:  MOVLW  09
1306:  MOVLB  0
1308:  MOVWF  xCC
.................... 	} else if ( 'O'==buff[i+0] ) {
130A:  BRA    136C
130C:  MOVLB  1
130E:  CLRF   03
1310:  MOVF   x1B,W
1312:  ADDLW  1C
1314:  MOVWF  FE9
1316:  MOVLW  01
1318:  ADDWFC 03,W
131A:  MOVWF  FEA
131C:  MOVF   FEF,W
131E:  SUBLW  4F
1320:  BNZ   132C
.................... 		current.compile_month=10;
1322:  MOVLW  0A
1324:  MOVLB  0
1326:  MOVWF  xCC
.................... 	} else if ( 'N'==buff[i+0] ) {
1328:  BRA    136C
132A:  MOVLB  1
132C:  CLRF   03
132E:  MOVF   x1B,W
1330:  ADDLW  1C
1332:  MOVWF  FE9
1334:  MOVLW  01
1336:  ADDWFC 03,W
1338:  MOVWF  FEA
133A:  MOVF   FEF,W
133C:  SUBLW  4E
133E:  BNZ   134A
.................... 		current.compile_month=11;
1340:  MOVLW  0B
1342:  MOVLB  0
1344:  MOVWF  xCC
.................... 	} else if ( 'D'==buff[i+0] ) {
1346:  BRA    136C
1348:  MOVLB  1
134A:  CLRF   03
134C:  MOVF   x1B,W
134E:  ADDLW  1C
1350:  MOVWF  FE9
1352:  MOVLW  01
1354:  ADDWFC 03,W
1356:  MOVWF  FEA
1358:  MOVF   FEF,W
135A:  SUBLW  44
135C:  BNZ   1368
.................... 		current.compile_month=12;
135E:  MOVLW  0C
1360:  MOVLB  0
1362:  MOVWF  xCC
.................... 	} else {
1364:  BRA    136C
1366:  MOVLB  1
.................... 		/* error parsing, shouldn't happen */
.................... 		current.compile_month=255;
1368:  MOVLB  0
136A:  SETF   xCC
.................... 	}
.................... 	current.compile_year =(buff[i+4]-'0')*10;
136C:  MOVLW  04
136E:  MOVLB  1
1370:  ADDWF  x1B,W
1372:  CLRF   03
1374:  ADDLW  1C
1376:  MOVWF  FE9
1378:  MOVLW  01
137A:  ADDWFC 03,W
137C:  MOVWF  FEA
137E:  MOVLW  30
1380:  SUBWF  FEF,W
1382:  MULLW  0A
1384:  MOVFF  FF3,CB
1388:  MOVLB  0
.................... 	current.compile_year+=(buff[i+5]-'0');
138A:  MOVLW  05
138C:  MOVLB  1
138E:  ADDWF  x1B,W
1390:  CLRF   03
1392:  ADDLW  1C
1394:  MOVWF  FE9
1396:  MOVLW  01
1398:  ADDWFC 03,W
139A:  MOVWF  FEA
139C:  MOVLW  30
139E:  SUBWF  FEF,W
13A0:  MOVLB  0
13A2:  ADDWF  xCB,F
.................... 
.................... 
.................... 	/* one periodic interrupt @ 1mS. Generated from system 16 MHz clock */
.................... 	/* prescale=16, match=249, postscale=1. Match is 249 because when match occurs, one cycle is lost */
.................... 	setup_timer_2(T2_DIV_BY_16,249,1);
13A4:  MOVLW  00
13A6:  IORLW  06
13A8:  MOVWF  FCA
13AA:  MOVLW  F9
13AC:  MOVWF  FCB
.................... 
.................... 	enable_interrupts(INT_TIMER2);
13AE:  BSF    F9D.1
.................... 
.................... 	/* set I2C slave address, which is always an even number */
.................... 	i2c_slaveaddr(STREAM_SLAVE,0x3e + (read_dip_switch()<<1) );
13B0:  BRA    108E
13B2:  BCF    FD8.0
13B4:  RLCF   01,W
13B6:  ADDLW  3E
13B8:  MOVLB  1
13BA:  MOVWF  FC8
13BC:  MOVLB  0
13BE:  GOTO   2B0A (RETURN)
.................... }
.................... 
.................... 
.................... void main(void) {
*
2A7C:  CLRF   FF8
2A7E:  BCF    FD0.7
2A80:  BSF    07.7
2A82:  BSF    F93.6
2A84:  BSF    F93.4
2A86:  CLRF   FC8
2A88:  MOVLW  36
2A8A:  MOVWF  FC6
2A8C:  BSF    FC5.0
2A8E:  BSF    FC5.7
2A90:  CLRF   1A
2A92:  BSF    FB8.3
2A94:  MOVLW  44
2A96:  MOVWF  FAF
2A98:  MOVLW  00
2A9A:  MOVWF  FB0
2A9C:  MOVLW  A6
2A9E:  MOVWF  FAC
2AA0:  MOVLW  90
2AA2:  MOVWF  FAB
2AA4:  MOVLB  1
2AA6:  CLRF   x19
2AA8:  CLRF   x18
2AAA:  MOVLW  00
2AAC:  MOVWF  F7E
2AAE:  BCF    FC1.0
2AB0:  BCF    FC1.1
2AB2:  BCF    FC1.2
2AB4:  BCF    FC1.3
2AB6:  MOVWF  F7F
2AB8:  CLRF   F6C
2ABA:  CLRF   F6B
2ABC:  CLRF   F6D
2ABE:  BRA    2AC6
2AC0:  DATA FD,40
2AC2:  DATA 1B,00
2AC4:  DATA 00,00
2AC6:  MOVLW  00
2AC8:  MOVWF  FF8
2ACA:  MOVLW  2A
2ACC:  MOVWF  FF7
2ACE:  MOVLW  C0
2AD0:  MOVWF  FF6
2AD2:  TBLRD*+
2AD4:  MOVF   FF5,W
2AD6:  MOVWF  00
2AD8:  XORLW  00
2ADA:  BZ    2B02
2ADC:  TBLRD*+
2ADE:  MOVF   FF5,W
2AE0:  MOVWF  01
2AE2:  BTFSC  FE8.7
2AE4:  BRA    2AF0
2AE6:  ANDLW  3F
2AE8:  MOVWF  FEA
2AEA:  TBLRD*+
2AEC:  MOVFF  FF5,FE9
2AF0:  BTFSC  01.6
2AF2:  TBLRD*+
2AF4:  BTFSS  01.6
2AF6:  TBLRD*+
2AF8:  MOVFF  FF5,FEE
2AFC:  DCFSNZ 00,F
2AFE:  BRA    2AD2
2B00:  BRA    2AF4
2B02:  CLRF   FF8
.................... 	int8 i;
.................... 
.................... 	init();
2B04:  MOVLB  0
2B06:  GOTO   1100
.................... 
.................... 
.................... 	/* read parameters from EEPROM and write defaults if CRC doesn't match */
.................... 	read_param_file();
2B0A:  GOTO   1778
.................... 
.................... 
.................... 	/* flash on startup */
.................... 	for ( i=0 ; i<5 ; i++ ) {
2B0E:  MOVLB  1
2B10:  CLRF   x1A
2B12:  MOVF   x1A,W
2B14:  SUBLW  04
2B16:  BNC   2B3E
.................... 		restart_wdt();
2B18:  CLRWDT
.................... 		output_high(LED_A);
2B1A:  BCF    F94.1
2B1C:  BSF    F8B.1
.................... 		delay_ms(200);
2B1E:  MOVLW  C8
2B20:  MOVWF  x28
2B22:  MOVLB  0
2B24:  CALL   1064
.................... 		output_low(LED_A);
2B28:  BCF    F94.1
2B2A:  BCF    F8B.1
.................... 		delay_ms(200);
2B2C:  MOVLW  C8
2B2E:  MOVLB  1
2B30:  MOVWF  x28
2B32:  MOVLB  0
2B34:  CALL   1064
2B38:  MOVLB  1
2B3A:  INCF   x1A,F
2B3C:  BRA    2B12
.................... 	}
.................... 
.................... 	fprintf(STREAM_FTDI,"# dcswc_module_latching_contactor %s\r\n# ",__DATE__);
2B3E:  MOVLW  B8
2B40:  MOVWF  FF6
2B42:  MOVLW  0F
2B44:  MOVWF  FF7
2B46:  MOVLW  22
2B48:  MOVWF  x1E
2B4A:  MOVLB  0
2B4C:  CALL   17BE
2B50:  MOVLW  E2
2B52:  MOVWF  FF6
2B54:  MOVLW  0F
2B56:  MOVWF  FF7
2B58:  CALL   17E8
2B5C:  MOVLW  DC
2B5E:  MOVWF  FF6
2B60:  MOVLW  0F
2B62:  MOVWF  FF7
2B64:  MOVLW  04
2B66:  MOVLB  1
2B68:  MOVWF  x1E
2B6A:  MOVLB  0
2B6C:  CALL   17BE
.................... 	switch ( restart_cause ) {
2B70:  MOVLW  07
2B72:  SUBWF  00,W
2B74:  BZ    2B9A
2B76:  MOVLW  0B
2B78:  SUBWF  00,W
2B7A:  BZ    2BA8
2B7C:  MOVLW  0F
2B7E:  SUBWF  00,W
2B80:  BZ    2BB6
2B82:  MOVLW  0C
2B84:  SUBWF  00,W
2B86:  BZ    2BC4
2B88:  MOVLW  0E
2B8A:  SUBWF  00,W
2B8C:  BZ    2BD2
2B8E:  MOVLW  03
2B90:  SUBWF  00,W
2B92:  BZ    2BE0
2B94:  MOVF   00,F
2B96:  BZ    2BEE
2B98:  BRA    2BFC
.................... 		case WDT_TIMEOUT:       fprintf(STREAM_FTDI,"WDT TIMEOUT"); break;
2B9A:  MOVLW  EC
2B9C:  MOVWF  FF6
2B9E:  MOVLW  0F
2BA0:  MOVWF  FF7
2BA2:  CALL   17E8
2BA6:  BRA    2C08
.................... 		case MCLR_FROM_SLEEP:   fprintf(STREAM_FTDI,"MCLR FROM SLEEP"); break;
2BA8:  MOVLW  F8
2BAA:  MOVWF  FF6
2BAC:  MOVLW  0F
2BAE:  MOVWF  FF7
2BB0:  CALL   17E8
2BB4:  BRA    2C08
.................... 		case MCLR_FROM_RUN:     fprintf(STREAM_FTDI,"MCLR FROM RUN"); break;
2BB6:  MOVLW  08
2BB8:  MOVWF  FF6
2BBA:  MOVLW  10
2BBC:  MOVWF  FF7
2BBE:  CALL   17E8
2BC2:  BRA    2C08
.................... 		case NORMAL_POWER_UP:   fprintf(STREAM_FTDI,"NORMAL POWER UP"); break;
2BC4:  MOVLW  16
2BC6:  MOVWF  FF6
2BC8:  MOVLW  10
2BCA:  MOVWF  FF7
2BCC:  CALL   17E8
2BD0:  BRA    2C08
.................... 		case BROWNOUT_RESTART:  fprintf(STREAM_FTDI,"BROWNOUT RESTART"); break;
2BD2:  MOVLW  26
2BD4:  MOVWF  FF6
2BD6:  MOVLW  10
2BD8:  MOVWF  FF7
2BDA:  CALL   17E8
2BDE:  BRA    2C08
.................... 		case WDT_FROM_SLEEP:    fprintf(STREAM_FTDI,"WDT FROM SLEEP"); break;
2BE0:  MOVLW  38
2BE2:  MOVWF  FF6
2BE4:  MOVLW  10
2BE6:  MOVWF  FF7
2BE8:  CALL   17E8
2BEC:  BRA    2C08
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_FTDI,"RESET INSTRUCTION"); break;
2BEE:  MOVLW  48
2BF0:  MOVWF  FF6
2BF2:  MOVLW  10
2BF4:  MOVWF  FF7
2BF6:  CALL   17E8
2BFA:  BRA    2C08
.................... 		default:                fprintf(STREAM_FTDI,"UNKNOWN!");
2BFC:  MOVLW  5A
2BFE:  MOVWF  FF6
2C00:  MOVLW  10
2C02:  MOVWF  FF7
2C04:  CALL   17E8
.................... 	}
.................... 	fprintf(STREAM_FTDI,"\r\n");
2C08:  MOVLW  0D
2C0A:  BTFSS  F9E.4
2C0C:  BRA    2C0A
2C0E:  MOVWF  FAD
2C10:  MOVLW  0A
2C12:  BTFSS  F9E.4
2C14:  BRA    2C12
2C16:  MOVWF  FAD
.................... 
.................... 	enable_interrupts(GLOBAL);
2C18:  MOVLW  C0
2C1A:  IORWF  FF2,F
.................... 
.................... 	/* Prime ADC filter */
.................... 	for ( i=0 ; i<30 ; i++ ) {
2C1C:  MOVLB  1
2C1E:  CLRF   x1A
2C20:  MOVF   x1A,W
2C22:  SUBLW  1D
2C24:  BNC   2C32
.................... 		adc_update();
2C26:  MOVLB  0
2C28:  CALL   180A
2C2C:  MOVLB  1
2C2E:  INCF   x1A,F
2C30:  BRA    2C20
.................... 	}
.................... 
.................... 
.................... 	/* enable I2C slave interrupt */
.................... 	enable_interrupts(INT_SSP);
2C32:  BSF    F9D.3
.................... 
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
2C34:  CLRWDT
.................... 
.................... 		if ( timers.now_millisecond ) {
2C36:  MOVLB  0
2C38:  BTFSS  xCF.2
2C3A:  BRA    2C3E
.................... 			periodic_millisecond();
2C3C:  BRA    268C
.................... 		}
.................... 
.................... 		if ( kbhit() ) {
2C3E:  BTFSS  F9E.5
2C40:  BRA    2C46
.................... 			getc();
2C42:  BRA    2860
.................... 			timers.now_debug_dump=1;
2C44:  BSF    xCF.5
.................... 		}
.................... 
.................... 		if ( timers.now_debug_dump ) {
2C46:  BTFSS  xCF.5
2C48:  BRA    2C4E
.................... 			timers.now_debug_dump=0;
2C4A:  BCF    xCF.5
.................... 
.................... 			debug_dump();
2C4C:  BRA    2970
.................... 		}
.................... 
.................... 		if ( timers.now_adc_sample ) {
2C4E:  BTFSS  xCF.0
2C50:  BRA    2C58
.................... 			timers.now_adc_sample=0;
2C52:  BCF    xCF.0
.................... 			adc_update();
2C54:  CALL   180A
.................... 		}
.................... 
.................... 		if ( timers.now_write_config ) {
2C58:  BTFSS  xCF.3
2C5A:  BRA    2C62
.................... 			timers.now_write_config=0;
2C5C:  BCF    xCF.3
.................... 			write_param_file();
2C5E:  CALL   14E2
.................... 		}
.................... 		if ( timers.now_reset_config ) {
2C62:  BTFSS  xCF.4
2C64:  BRA    2C6C
.................... 			timers.now_reset_config=0;
2C66:  BCF    xCF.4
.................... 			write_default_param_file();
2C68:  CALL   152E
.................... 		}
2C6C:  MOVLB  1
2C6E:  BRA    2C34
.................... 
.................... 
.................... 	}
.................... 
.................... 
.................... }
2C70:  BRA    2C70

Configuration Fuses:
   Word  1: 2800   INTRC_IO NOPLLEN PCLKEN NOFCMEN NOIESO
   Word  2: 0E19   NOPUT NOBROWNOUT BORV19 NOWDT WDT128
   Word  3: 0000   NOHFOFST NOMCLR
   Word  4: 0009   STVREN NOLVP BBSIZ2K NOXINST DEBUG
   Word  5: C003   NOPROTECT NOCPB NOCPD
   Word  6: E003   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 4003   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.

ROM data:
F00000: 00 00 40 00                                        ..@.
