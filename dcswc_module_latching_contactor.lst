CCS PCH C Compiler, Version 5.090, 49113               06-Feb-22 15:35

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\dcswc_module_latching_contactor\dcswc_module_latching_contactor.lst

               ROM used:   12282 bytes (79%)
                           Largest free fragment is 3266
               RAM used:   283 (55%) at main() level
                           311 (61%) worst case
               Stack used: 2 locations (0 in main + 2 for interrupts)
               Stack size: 30

0000:  GOTO   2E06
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   00D4
0060:  BTFSS  F9D.3
0062:  GOTO   006C
0066:  BTFSC  F9E.3
0068:  GOTO   0E8A
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include "dcswc_module_latching_contactor.h"
.................... #include <18F14K22.h>
.................... //////////// Standard Header file for the PIC18F14K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F14K22
00BA:  CLRF   FF7
00BC:  ADDLW  CA
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  RETURN 0
00CA:  DATA 36,2D
00CC:  DATA 46,65
00CE:  DATA 62,2D
00D0:  DATA 32,32
00D2:  DATA 00,00
*
0F5C:  DATA 23,20
0F5E:  DATA 27,25
0F60:  DATA 73,27
0F62:  DATA 0D,0A
0F64:  DATA 00,00
0F66:  DATA 23,20
0F68:  DATA 20,63
0F6A:  DATA 6F,6D
0F6C:  DATA 70,69
0F6E:  DATA 6C,65
0F70:  DATA 5F,79
0F72:  DATA 65,61
0F74:  DATA 72,3D
0F76:  DATA 25,75
0F78:  DATA 0D,0A
0F7A:  DATA 00,00
0F7C:  DATA 23,20
0F7E:  DATA 63,6F
0F80:  DATA 6D,70
0F82:  DATA 69,6C
0F84:  DATA 65,5F
0F86:  DATA 6D,6F
0F88:  DATA 6E,74
0F8A:  DATA 68,3D
0F8C:  DATA 25,75
0F8E:  DATA 0D,0A
0F90:  DATA 00,00
0F92:  DATA 23,20
0F94:  DATA 20,20
0F96:  DATA 63,6F
0F98:  DATA 6D,70
0F9A:  DATA 69,6C
0F9C:  DATA 65,5F
0F9E:  DATA 64,61
0FA0:  DATA 79,3D
0FA2:  DATA 25,75
0FA4:  DATA 0D,0A
0FA6:  DATA 00,00
0FA8:  DATA 23,20
0FAA:  DATA 20,20
0FAC:  DATA 20,20
0FAE:  DATA 20,20
0FB0:  DATA 76,69
0FB2:  DATA 6E,20
0FB4:  DATA 61,64
0FB6:  DATA 63,3D
0FB8:  DATA 25,6C
0FBA:  DATA 75,0D
0FBC:  DATA 0A,00
0FBE:  DATA 23,20
0FC0:  DATA 20,20
0FC2:  DATA 20,20
0FC4:  DATA 20,74
0FC6:  DATA 65,6D
0FC8:  DATA 70,20
0FCA:  DATA 61,64
0FCC:  DATA 63,3D
0FCE:  DATA 25,6C
0FD0:  DATA 75,0D
0FD2:  DATA 0A,00
0FD4:  DATA 23,2D
0FD6:  DATA 2D,2D
0FD8:  DATA 2D,2D
0FDA:  DATA 2D,2D
0FDC:  DATA 0D,0A
0FDE:  DATA 00,00
0FE0:  DATA 23,20
0FE2:  DATA 63,6F
0FE4:  DATA 6E,66
0FE6:  DATA 69,67
0FE8:  DATA 2E,63
0FEA:  DATA 68,5B
0FEC:  DATA 25,75
0FEE:  DATA 5D,0D
0FF0:  DATA 0A,00
0FF2:  DATA 23,20
0FF4:  DATA 63,6F
0FF6:  DATA 6D,6D
0FF8:  DATA 61,6E
0FFA:  DATA 64,5F
0FFC:  DATA 6F,66
0FFE:  DATA 66,5F
1000:  DATA 68,6F
1002:  DATA 6C,64
1004:  DATA 5F,74
1006:  DATA 69,6D
1008:  DATA 65,3D
100A:  DATA 25,6C
100C:  DATA 75,0D
100E:  DATA 0A,00
1010:  DATA 23,20
1012:  DATA 20,20
1014:  DATA 20,6C
1016:  DATA 76,64
1018:  DATA 5F,64
101A:  DATA 69,73
101C:  DATA 63,6F
101E:  DATA 6E,6E
1020:  DATA 65,63
1022:  DATA 74,5F
1024:  DATA 61,64
1026:  DATA 63,3D
1028:  DATA 25,6C
102A:  DATA 75,0D
102C:  DATA 0A,00
102E:  DATA 23,20
1030:  DATA 20,6C
1032:  DATA 76,64
1034:  DATA 5F,64
1036:  DATA 69,73
1038:  DATA 63,6F
103A:  DATA 6E,6E
103C:  DATA 65,63
103E:  DATA 74,5F
1040:  DATA 64,65
1042:  DATA 6C,61
1044:  DATA 79,3D
1046:  DATA 25,6C
1048:  DATA 75,0D
104A:  DATA 0A,00
104C:  DATA 23,20
104E:  DATA 20,20
1050:  DATA 20,20
1052:  DATA 6C,76
1054:  DATA 64,5F
1056:  DATA 72,65
1058:  DATA 63,6F
105A:  DATA 6E,6E
105C:  DATA 65,63
105E:  DATA 74,5F
1060:  DATA 61,64
1062:  DATA 63,3D
1064:  DATA 25,6C
1066:  DATA 75,0D
1068:  DATA 0A,00
106A:  DATA 23,20
106C:  DATA 20,20
106E:  DATA 6C,76
1070:  DATA 64,5F
1072:  DATA 72,65
1074:  DATA 63,6F
1076:  DATA 6E,6E
1078:  DATA 65,63
107A:  DATA 74,5F
107C:  DATA 64,65
107E:  DATA 6C,61
1080:  DATA 79,3D
1082:  DATA 25,6C
1084:  DATA 75,0D
1086:  DATA 0A,00
1088:  DATA 23,20
108A:  DATA 20,20
108C:  DATA 20,68
108E:  DATA 76,64
1090:  DATA 5F,64
1092:  DATA 69,73
1094:  DATA 63,6F
1096:  DATA 6E,6E
1098:  DATA 65,63
109A:  DATA 74,5F
109C:  DATA 61,64
109E:  DATA 63,3D
10A0:  DATA 25,6C
10A2:  DATA 75,0D
10A4:  DATA 0A,00
10A6:  DATA 23,20
10A8:  DATA 20,68
10AA:  DATA 76,64
10AC:  DATA 5F,64
10AE:  DATA 69,73
10B0:  DATA 63,6F
10B2:  DATA 6E,6E
10B4:  DATA 65,63
10B6:  DATA 74,5F
10B8:  DATA 64,65
10BA:  DATA 6C,61
10BC:  DATA 79,3D
10BE:  DATA 25,6C
10C0:  DATA 75,0D
10C2:  DATA 0A,00
10C4:  DATA 23,20
10C6:  DATA 20,20
10C8:  DATA 20,20
10CA:  DATA 68,76
10CC:  DATA 64,5F
10CE:  DATA 72,65
10D0:  DATA 63,6F
10D2:  DATA 6E,6E
10D4:  DATA 65,63
10D6:  DATA 74,5F
10D8:  DATA 61,64
10DA:  DATA 63,3D
10DC:  DATA 25,6C
10DE:  DATA 75,0D
10E0:  DATA 0A,00
10E2:  DATA 23,20
10E4:  DATA 20,20
10E6:  DATA 68,76
10E8:  DATA 64,5F
10EA:  DATA 72,65
10EC:  DATA 63,6F
10EE:  DATA 6E,6E
10F0:  DATA 65,63
10F2:  DATA 74,5F
10F4:  DATA 64,65
10F6:  DATA 6C,61
10F8:  DATA 79,3D
10FA:  DATA 25,6C
10FC:  DATA 75,0D
10FE:  DATA 0A,00
1100:  DATA 23,20
1102:  DATA 20,20
1104:  DATA 20,6C
1106:  DATA 74,64
1108:  DATA 5F,64
110A:  DATA 69,73
110C:  DATA 63,6F
110E:  DATA 6E,6E
1110:  DATA 65,63
1112:  DATA 74,5F
1114:  DATA 61,64
1116:  DATA 63,3D
1118:  DATA 25,6C
111A:  DATA 75,0D
111C:  DATA 0A,00
111E:  DATA 23,20
1120:  DATA 20,6C
1122:  DATA 74,64
1124:  DATA 5F,64
1126:  DATA 69,73
1128:  DATA 63,6F
112A:  DATA 6E,6E
112C:  DATA 65,63
112E:  DATA 74,5F
1130:  DATA 64,65
1132:  DATA 6C,61
1134:  DATA 79,3D
1136:  DATA 25,6C
1138:  DATA 75,0D
113A:  DATA 0A,00
113C:  DATA 23,20
113E:  DATA 20,20
1140:  DATA 20,20
1142:  DATA 6C,74
1144:  DATA 64,5F
1146:  DATA 72,65
1148:  DATA 63,6F
114A:  DATA 6E,6E
114C:  DATA 65,63
114E:  DATA 74,5F
1150:  DATA 61,64
1152:  DATA 63,3D
1154:  DATA 25,6C
1156:  DATA 75,0D
1158:  DATA 0A,00
115A:  DATA 23,20
115C:  DATA 20,20
115E:  DATA 6C,74
1160:  DATA 64,5F
1162:  DATA 72,65
1164:  DATA 63,6F
1166:  DATA 6E,6E
1168:  DATA 65,63
116A:  DATA 74,5F
116C:  DATA 64,65
116E:  DATA 6C,61
1170:  DATA 79,3D
1172:  DATA 25,6C
1174:  DATA 75,0D
1176:  DATA 0A,00
1178:  DATA 23,20
117A:  DATA 20,20
117C:  DATA 20,68
117E:  DATA 74,64
1180:  DATA 5F,64
1182:  DATA 69,73
1184:  DATA 63,6F
1186:  DATA 6E,6E
1188:  DATA 65,63
118A:  DATA 74,5F
118C:  DATA 61,64
118E:  DATA 63,3D
1190:  DATA 25,6C
1192:  DATA 75,0D
1194:  DATA 0A,00
1196:  DATA 23,20
1198:  DATA 20,68
119A:  DATA 74,64
119C:  DATA 5F,64
119E:  DATA 69,73
11A0:  DATA 63,6F
11A2:  DATA 6E,6E
11A4:  DATA 65,63
11A6:  DATA 74,5F
11A8:  DATA 64,65
11AA:  DATA 6C,61
11AC:  DATA 79,3D
11AE:  DATA 25,6C
11B0:  DATA 75,0D
11B2:  DATA 0A,00
11B4:  DATA 23,20
11B6:  DATA 20,20
11B8:  DATA 20,20
11BA:  DATA 68,74
11BC:  DATA 64,5F
11BE:  DATA 72,65
11C0:  DATA 63,6F
11C2:  DATA 6E,6E
11C4:  DATA 65,63
11C6:  DATA 74,5F
11C8:  DATA 61,64
11CA:  DATA 63,3D
11CC:  DATA 25,6C
11CE:  DATA 75,0D
11D0:  DATA 0A,00
11D2:  DATA 23,20
11D4:  DATA 20,20
11D6:  DATA 68,74
11D8:  DATA 64,5F
11DA:  DATA 72,65
11DC:  DATA 63,6F
11DE:  DATA 6E,6E
11E0:  DATA 65,63
11E2:  DATA 74,5F
11E4:  DATA 64,65
11E6:  DATA 6C,61
11E8:  DATA 79,3D
11EA:  DATA 25,6C
11EC:  DATA 75,0D
11EE:  DATA 0A,00
11F0:  DATA 23,0D
11F2:  DATA 0A,00
11F4:  DATA 23,20
11F6:  DATA 63,68
11F8:  DATA 61,6E
11FA:  DATA 6E,65
11FC:  DATA 6C,5B
11FE:  DATA 25,75
1200:  DATA 5D,0D
1202:  DATA 0A,00
1204:  DATA 23,20
1206:  DATA 20,20
1208:  DATA 20,20
120A:  DATA 20,20
120C:  DATA 20,20
120E:  DATA 20,20
1210:  DATA 20,20
1212:  DATA 20,20
1214:  DATA 20,20
1216:  DATA 20,20
1218:  DATA 20,20
121A:  DATA 20,20
121C:  DATA 20,73
121E:  DATA 74,61
1220:  DATA 74,65
1222:  DATA 3D,30
1224:  DATA 78,25
1226:  DATA 30,32
1228:  DATA 78,0D
122A:  DATA 0A,00
122C:  DATA 23,20
122E:  DATA 20,20
1230:  DATA 20,20
1232:  DATA 20,20
1234:  DATA 20,20
1236:  DATA 20,20
1238:  DATA 63,6F
123A:  DATA 6D,6D
123C:  DATA 61,6E
123E:  DATA 64,5F
1240:  DATA 6F,6E
1242:  DATA 5F,73
1244:  DATA 65,63
1246:  DATA 6F,6E
1248:  DATA 64,73
124A:  DATA 3D,25
124C:  DATA 6C,75
124E:  DATA 0D,0A
1250:  DATA 00,00
1252:  DATA 23,20
1254:  DATA 20,20
1256:  DATA 20,20
1258:  DATA 20,63
125A:  DATA 6F,6D
125C:  DATA 6D,61
125E:  DATA 6E,64
1260:  DATA 5F,6F
1262:  DATA 6E,5F
1264:  DATA 68,6F
1266:  DATA 6C,64
1268:  DATA 5F,73
126A:  DATA 65,63
126C:  DATA 6F,6E
126E:  DATA 64,73
1270:  DATA 3D,25
1272:  DATA 6C,75
1274:  DATA 0D,0A
1276:  DATA 00,00
1278:  DATA 23,20
127A:  DATA 20,20
127C:  DATA 20,20
127E:  DATA 20,20
1280:  DATA 20,20
1282:  DATA 20,63
1284:  DATA 6F,6D
1286:  DATA 6D,61
1288:  DATA 6E,64
128A:  DATA 5F,6F
128C:  DATA 66,66
128E:  DATA 5F,73
1290:  DATA 65,63
1292:  DATA 6F,6E
1294:  DATA 64,73
1296:  DATA 3D,25
1298:  DATA 6C,75
129A:  DATA 0D,0A
129C:  DATA 00,00
129E:  DATA 23,20
12A0:  DATA 20,20
12A2:  DATA 20,20
12A4:  DATA 63,6F
12A6:  DATA 6D,6D
12A8:  DATA 61,6E
12AA:  DATA 64,5F
12AC:  DATA 6F,66
12AE:  DATA 66,5F
12B0:  DATA 68,6F
12B2:  DATA 6C,64
12B4:  DATA 5F,73
12B6:  DATA 65,63
12B8:  DATA 6F,6E
12BA:  DATA 64,73
12BC:  DATA 3D,25
12BE:  DATA 6C,75
12C0:  DATA 0D,0A
12C2:  DATA 00,00
12C4:  DATA 23,20
12C6:  DATA 6C,76
12C8:  DATA 64,5F
12CA:  DATA 64,69
12CC:  DATA 73,63
12CE:  DATA 6F,6E
12D0:  DATA 6E,65
12D2:  DATA 63,74
12D4:  DATA 5F,64
12D6:  DATA 65,6C
12D8:  DATA 61,79
12DA:  DATA 5F,73
12DC:  DATA 65,63
12DE:  DATA 6F,6E
12E0:  DATA 64,73
12E2:  DATA 3D,25
12E4:  DATA 6C,75
12E6:  DATA 0D,0A
12E8:  DATA 00,00
12EA:  DATA 23,20
12EC:  DATA 20,6C
12EE:  DATA 76,64
12F0:  DATA 5F,72
12F2:  DATA 65,63
12F4:  DATA 6F,6E
12F6:  DATA 6E,65
12F8:  DATA 63,74
12FA:  DATA 5F,64
12FC:  DATA 65,6C
12FE:  DATA 61,79
1300:  DATA 5F,73
1302:  DATA 65,63
1304:  DATA 6F,6E
1306:  DATA 64,73
1308:  DATA 3D,25
130A:  DATA 6C,75
130C:  DATA 0D,0A
130E:  DATA 00,00
1310:  DATA 23,20
1312:  DATA 68,76
1314:  DATA 64,5F
1316:  DATA 64,69
1318:  DATA 73,63
131A:  DATA 6F,6E
131C:  DATA 6E,65
131E:  DATA 63,74
1320:  DATA 5F,64
1322:  DATA 65,6C
1324:  DATA 61,79
1326:  DATA 5F,73
1328:  DATA 65,63
132A:  DATA 6F,6E
132C:  DATA 64,73
132E:  DATA 3D,25
1330:  DATA 6C,75
1332:  DATA 0D,0A
1334:  DATA 00,00
1336:  DATA 23,20
1338:  DATA 20,68
133A:  DATA 76,64
133C:  DATA 5F,72
133E:  DATA 65,63
1340:  DATA 6F,6E
1342:  DATA 6E,65
1344:  DATA 63,74
1346:  DATA 5F,64
1348:  DATA 65,6C
134A:  DATA 61,79
134C:  DATA 5F,73
134E:  DATA 65,63
1350:  DATA 6F,6E
1352:  DATA 64,73
1354:  DATA 3D,25
1356:  DATA 6C,75
1358:  DATA 0D,0A
135A:  DATA 00,00
135C:  DATA 23,20
135E:  DATA 6C,74
1360:  DATA 64,5F
1362:  DATA 64,69
1364:  DATA 73,63
1366:  DATA 6F,6E
1368:  DATA 6E,65
136A:  DATA 63,74
136C:  DATA 5F,64
136E:  DATA 65,6C
1370:  DATA 61,79
1372:  DATA 5F,73
1374:  DATA 65,63
1376:  DATA 6F,6E
1378:  DATA 64,73
137A:  DATA 3D,25
137C:  DATA 6C,75
137E:  DATA 0D,0A
1380:  DATA 00,00
1382:  DATA 23,20
1384:  DATA 20,6C
1386:  DATA 74,64
1388:  DATA 5F,72
138A:  DATA 65,63
138C:  DATA 6F,6E
138E:  DATA 6E,65
1390:  DATA 63,74
1392:  DATA 5F,64
1394:  DATA 65,6C
1396:  DATA 61,79
1398:  DATA 5F,73
139A:  DATA 65,63
139C:  DATA 6F,6E
139E:  DATA 64,73
13A0:  DATA 3D,25
13A2:  DATA 6C,75
13A4:  DATA 0D,0A
13A6:  DATA 00,00
13A8:  DATA 23,20
13AA:  DATA 68,74
13AC:  DATA 64,5F
13AE:  DATA 64,69
13B0:  DATA 73,63
13B2:  DATA 6F,6E
13B4:  DATA 6E,65
13B6:  DATA 63,74
13B8:  DATA 5F,64
13BA:  DATA 65,6C
13BC:  DATA 61,79
13BE:  DATA 5F,73
13C0:  DATA 65,63
13C2:  DATA 6F,6E
13C4:  DATA 64,73
13C6:  DATA 3D,25
13C8:  DATA 6C,75
13CA:  DATA 0D,0A
13CC:  DATA 00,00
13CE:  DATA 23,20
13D0:  DATA 20,68
13D2:  DATA 74,64
13D4:  DATA 5F,72
13D6:  DATA 65,63
13D8:  DATA 6F,6E
13DA:  DATA 6E,65
13DC:  DATA 63,74
13DE:  DATA 5F,64
13E0:  DATA 65,6C
13E2:  DATA 61,79
13E4:  DATA 5F,73
13E6:  DATA 65,63
13E8:  DATA 6F,6E
13EA:  DATA 64,73
13EC:  DATA 3D,25
13EE:  DATA 6C,75
13F0:  DATA 0D,0A
13F2:  DATA 00,00
13F4:  DATA 23,20
13F6:  DATA 4C,45
13F8:  DATA 44,20
13FA:  DATA 25,75
13FC:  DATA 20,41
13FE:  DATA 3D,25
1400:  DATA 30,33
1402:  DATA 75,20
1404:  DATA 28,30
1406:  DATA 78,25
1408:  DATA 30,32
140A:  DATA 58,29
140C:  DATA 20,42
140E:  DATA 3D,25
1410:  DATA 30,33
1412:  DATA 75,20
1414:  DATA 28,30
1416:  DATA 78,25
1418:  DATA 30,32
141A:  DATA 58,29
141C:  DATA 0D,0A
141E:  DATA 00,00
1420:  DATA 23,20
1422:  DATA 64,63
1424:  DATA 73,77
1426:  DATA 63,5F
1428:  DATA 6D,6F
142A:  DATA 64,75
142C:  DATA 6C,65
142E:  DATA 5F,6C
1430:  DATA 61,74
1432:  DATA 63,68
1434:  DATA 69,6E
1436:  DATA 67,5F
1438:  DATA 63,6F
143A:  DATA 6E,74
143C:  DATA 61,63
143E:  DATA 74,6F
1440:  DATA 72,20
1442:  DATA 25,73
1444:  DATA 0D,0A
1446:  DATA 23,20
1448:  DATA 00,00
144A:  DATA 36,2D
144C:  DATA 46,65
144E:  DATA 62,2D
1450:  DATA 32,32
1452:  DATA 00,00
1454:  DATA 57,44
1456:  DATA 54,20
1458:  DATA 54,49
145A:  DATA 4D,45
145C:  DATA 4F,55
145E:  DATA 54,00
1460:  DATA 4D,43
1462:  DATA 4C,52
1464:  DATA 20,46
1466:  DATA 52,4F
1468:  DATA 4D,20
146A:  DATA 53,4C
146C:  DATA 45,45
146E:  DATA 50,00
1470:  DATA 4D,43
1472:  DATA 4C,52
1474:  DATA 20,46
1476:  DATA 52,4F
1478:  DATA 4D,20
147A:  DATA 52,55
147C:  DATA 4E,00
147E:  DATA 4E,4F
1480:  DATA 52,4D
1482:  DATA 41,4C
1484:  DATA 20,50
1486:  DATA 4F,57
1488:  DATA 45,52
148A:  DATA 20,55
148C:  DATA 50,00
148E:  DATA 42,52
1490:  DATA 4F,57
1492:  DATA 4E,4F
1494:  DATA 55,54
1496:  DATA 20,52
1498:  DATA 45,53
149A:  DATA 54,41
149C:  DATA 52,54
149E:  DATA 00,00
14A0:  DATA 57,44
14A2:  DATA 54,20
14A4:  DATA 46,52
14A6:  DATA 4F,4D
14A8:  DATA 20,53
14AA:  DATA 4C,45
14AC:  DATA 45,50
14AE:  DATA 00,00
14B0:  DATA 52,45
14B2:  DATA 53,45
14B4:  DATA 54,20
14B6:  DATA 49,4E
14B8:  DATA 53,54
14BA:  DATA 52,55
14BC:  DATA 43,54
14BE:  DATA 49,4F
14C0:  DATA 4E,00
14C2:  DATA 55,4E
14C4:  DATA 4B,4E
14C6:  DATA 4F,57
14C8:  DATA 4E,21
14CA:  DATA 00,00
*
1BA2:  TBLRD*+
1BA4:  MOVFF  FF6,11E
1BA8:  MOVFF  FF7,11F
1BAC:  MOVF   FF5,W
1BAE:  BTFSS  F9E.4
1BB0:  BRA    1BAE
1BB2:  MOVWF  FAD
1BB4:  MOVFF  11E,FF6
1BB8:  MOVFF  11F,FF7
1BBC:  MOVLB  1
1BBE:  DECFSZ x1D,F
1BC0:  BRA    1BC4
1BC2:  BRA    1BC8
1BC4:  MOVLB  0
1BC6:  BRA    1BA2
1BC8:  MOVLB  0
1BCA:  RETURN 0
1BCC:  TBLRD*+
1BCE:  MOVF   FF5,F
1BD0:  BZ    1BEC
1BD2:  MOVFF  FF6,11B
1BD6:  MOVFF  FF7,11C
1BDA:  MOVF   FF5,W
1BDC:  BTFSS  F9E.4
1BDE:  BRA    1BDC
1BE0:  MOVWF  FAD
1BE2:  MOVFF  11B,FF6
1BE6:  MOVFF  11C,FF7
1BEA:  BRA    1BCC
1BEC:  RETURN 0
*
2972:  MOVLB  1
2974:  MOVF   x20,W
2976:  CLRF   01
2978:  SUBWF  x1F,W
297A:  BC    2982
297C:  MOVFF  11F,00
2980:  BRA    299A
2982:  CLRF   00
2984:  MOVLW  08
2986:  MOVWF  x21
2988:  RLCF   x1F,F
298A:  RLCF   00,F
298C:  MOVF   x20,W
298E:  SUBWF  00,W
2990:  BTFSC  FD8.0
2992:  MOVWF  00
2994:  RLCF   01,F
2996:  DECFSZ x21,F
2998:  BRA    2988
299A:  MOVLB  0
299C:  RETURN 0
299E:  MOVF   01,W
29A0:  MOVFF  11D,11F
29A4:  MOVLW  64
29A6:  MOVLB  1
29A8:  MOVWF  x20
29AA:  MOVLB  0
29AC:  RCALL  2972
29AE:  MOVFF  00,11D
29B2:  MOVF   01,W
29B4:  MOVLW  30
29B6:  BNZ   29C8
29B8:  MOVLB  1
29BA:  BTFSS  x1E.1
29BC:  BRA    29DA
29BE:  BTFSC  x1E.3
29C0:  BRA    29DA
29C2:  BTFSC  x1E.4
29C4:  MOVLW  20
29C6:  BRA    29D0
29C8:  MOVLB  1
29CA:  BCF    x1E.3
29CC:  BCF    x1E.4
29CE:  BSF    x1E.0
29D0:  ADDWF  01,F
29D2:  MOVF   01,W
29D4:  BTFSS  F9E.4
29D6:  BRA    29D4
29D8:  MOVWF  FAD
29DA:  MOVFF  11D,11F
29DE:  MOVLW  0A
29E0:  MOVWF  x20
29E2:  MOVLB  0
29E4:  RCALL  2972
29E6:  MOVFF  00,11D
29EA:  MOVF   01,W
29EC:  MOVLW  30
29EE:  BNZ   2A00
29F0:  MOVLB  1
29F2:  BTFSC  x1E.3
29F4:  BRA    2A0C
29F6:  BTFSS  x1E.0
29F8:  BRA    2A0C
29FA:  BTFSC  x1E.4
29FC:  MOVLW  20
29FE:  MOVLB  0
2A00:  ADDWF  01,F
2A02:  MOVF   01,W
2A04:  BTFSS  F9E.4
2A06:  BRA    2A04
2A08:  MOVWF  FAD
2A0A:  MOVLB  1
2A0C:  MOVLW  30
2A0E:  ADDWF  x1D,F
2A10:  MOVF   x1D,W
2A12:  BTFSS  F9E.4
2A14:  BRA    2A12
2A16:  MOVWF  FAD
2A18:  MOVLB  0
2A1A:  RETURN 0
2A1C:  MOVLB  1
2A1E:  BTFSC  x1E.7
2A20:  BRA    2A42
2A22:  MOVLW  0F
2A24:  MOVWF  00
2A26:  SWAPF  x1D,W
2A28:  ANDWF  00,F
2A2A:  MOVLW  0A
2A2C:  SUBWF  00,W
2A2E:  BC    2A36
2A30:  MOVLW  30
2A32:  ADDWF  00,F
2A34:  BRA    2A3A
2A36:  MOVF   x1E,W
2A38:  ADDWF  00,F
2A3A:  MOVF   00,W
2A3C:  BTFSS  F9E.4
2A3E:  BRA    2A3C
2A40:  MOVWF  FAD
2A42:  MOVLW  0F
2A44:  ANDWF  x1D,F
2A46:  MOVLW  0A
2A48:  SUBWF  x1D,W
2A4A:  BC    2A50
2A4C:  MOVLW  30
2A4E:  BRA    2A54
2A50:  BCF    x1E.7
2A52:  MOVF   x1E,W
2A54:  ADDWF  x1D,F
2A56:  MOVF   x1D,W
2A58:  BTFSS  F9E.4
2A5A:  BRA    2A58
2A5C:  MOVWF  FAD
2A5E:  MOVLB  0
2A60:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #device *=16
.................... #use delay(clock=16MHz)
*
14CC:  MOVLW  01
14CE:  MOVWF  FEA
14D0:  MOVLW  28
14D2:  MOVWF  FE9
14D4:  MOVF   FEF,W
14D6:  BZ    14F4
14D8:  MOVLW  05
14DA:  MOVWF  01
14DC:  CLRF   00
14DE:  DECFSZ 00,F
14E0:  BRA    14DE
14E2:  DECFSZ 01,F
14E4:  BRA    14DC
14E6:  MOVLW  2E
14E8:  MOVWF  00
14EA:  DECFSZ 00,F
14EC:  BRA    14EA
14EE:  BRA    14F0
14F0:  DECFSZ FEF,F
14F2:  BRA    14D8
14F4:  RETURN 0
.................... 
.................... /* hardware I2C port is slave and is connected to DCSWC bus */
.................... #use i2c(stream=STREAM_SLAVE,SLAVE, I2C1, FORCE_HW)
*
0E74:  MOVF   FC9,W
0E76:  MOVFF  12D,FC9
0E7A:  BSF    FC6.4
0E7C:  BCF    F9E.3
0E7E:  BTFSC  FC7.0
0E80:  BRA    0E7E
0E82:  CLRF   01
0E84:  BTFSS  FC5.6
0E86:  INCF   01,F
0E88:  RETURN 0
.................... /* slave address set based on dip switch in init() */
.................... 
.................... 
.................... #fuses INTRC_IO
.................... #fuses NOPLLEN
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses PUT
.................... #fuses BROWNOUT
.................... #fuses WDT512
.................... #fuses NOHFOFST
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses NOLVP
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... #fuses NOPROTECT
.................... #fuses NOWRT
.................... #fuses NOWRTC 
.................... #fuses NOWRTB
.................... #fuses NOWRTD
.................... #fuses NOEBTR
.................... #fuses NOEBTRB
.................... 
.................... #use standard_io(ALL)
.................... 
.................... #use rs232(UART1,stream=STREAM_FTDI,baud=57600,errors)	
*
2DEE:  BTFSS  F9E.5
2DF0:  BRA    2DEE
2DF2:  MOVFF  FAB,1A
2DF6:  MOVFF  FAE,01
2DFA:  BTFSS  1A.1
2DFC:  BRA    2E02
2DFE:  BCF    FAB.4
2E00:  BSF    FAB.4
2E02:  GOTO   2FD2 (RETURN)
.................... 
.................... /* program config CRC of 0 and a serial_prefix of 'A' ... that will trigger a write default on first boot */
.................... #ROM 0xF00000 = { 0x00, 0x00, 0x40, 0x00 }
.................... 
.................... 
.................... 
.................... 
.................... #define SW_OVERRIDE_A        PIN_A5
.................... #define SW_OVERRIDE_B        PIN_A4
.................... #define BRIDGE_B_A           PIN_C5
.................... #define BRIDGE_A_B           PIN_C4
.................... #define BRIDGE_A_A           PIN_C3
.................... #define BRIDGE_B_B           PIN_C6
.................... #define AN_DIP               PIN_C7
.................... #define SER_TO_PC            PIN_B7
.................... #define AN_VTEMP             PIN_A2
.................... #define AN_IN_VOLTS          PIN_C0
.................... #define LED_A                PIN_C1
.................... #define LED_B                PIN_C2
.................... #define I2C_SDA              PIN_B4
.................... #define SER_FROM_PC          PIN_B5
.................... #define I2C_SCL              PIN_B6
.................... 
.................... 
.................... /* 
.................... Parameters are stored in EEPROM
.................... */
.................... #define PARAM_CRC_ADDRESS  0x00
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2
.................... 
.................... 
.................... 
.................... /* bit positions for a channel state byte */
.................... #define CH_STATE_BIT_FUTURE   7  /* reserved for future use */
.................... #define CH_STATE_BIT_HTD      6  /* high temperature disconnect */
.................... #define CH_STATE_BIT_LTD      5  /* low temperature disconnect */
.................... #define CH_STATE_BIT_HVD      4  /* high voltage disconnect */
.................... #define CH_STATE_BIT_LVD      3  /* low voltage disconnect */
.................... #define CH_STATE_BIT_CMD_OFF  2  /* commanded off */
.................... #define CH_STATE_BIT_CMD_ON   1  /* commanded on (takes presedence over commanded off) */
.................... #define CH_STATE_BIT_OVERRIDE 0  /* override switch */
.................... 
.................... /* _OVERRIDE or _CMD_ON set means output on */
.................... #define CH_STATE_MASK_ON     0b00000011 
.................... /* _CMD_OFF, _LVD, _HVD, _LTD, _HTD means output off, unless override by on mask */
.................... #define CH_STATE_MASK_OFF    0b01111100 
.................... 
.................... #define ADC_SAMPLE_TICKS              20
.................... #define CONTACTOR_POWER_SAVE_MS       200 /* milliseconds for contactor be on. Must be >0 and <= 255 */
.................... #define CONTACTOR_REFRESH_CYCLES      10  /* re-appply contactor coil voltage every N cycles. 65525 disables */
.................... 
.................... #define BLINK_ON_TIME                 250
.................... #define BLINK_OFF_TIME                100
.................... 
.................... 
.................... typedef struct {
.................... 	/* command on hold time */
.................... 	int16 command_on_hold_time;
.................... 
.................... 	/* command off hold time */
.................... 	int16 command_off_hold_time;
.................... 
.................... 	/* low voltage disconnect */
.................... 	int16 lvd_disconnect_adc;
.................... 	int16 lvd_disconnect_delay;
.................... 	int16 lvd_reconnect_adc;
.................... 	int16 lvd_reconnect_delay;
.................... 
.................... 	/* high voltage disconnect */
.................... 	int16 hvd_disconnect_adc;
.................... 	int16 hvd_disconnect_delay;
.................... 	int16 hvd_reconnect_adc;
.................... 	int16 hvd_reconnect_delay;
.................... 
.................... 	/* low temperature disconnect */
.................... 	int16 ltd_disconnect_adc;
.................... 	int16 ltd_disconnect_delay;
.................... 	int16 ltd_reconnect_adc;
.................... 	int16 ltd_reconnect_delay;
.................... 
.................... 	/* high temperature disconnect */
.................... 	int16 htd_disconnect_adc;
.................... 	int16 htd_disconnect_delay;
.................... 	int16 htd_reconnect_adc;
.................... 	int16 htd_reconnect_delay;
.................... } struct_config_channel;
.................... 
.................... typedef struct {
.................... 	/* not much going on here */
.................... 	struct_config_channel ch[2];
.................... } struct_config;
.................... 
.................... 
.................... typedef struct {
.................... 	int8 state;
.................... 
.................... 	int16 command_on_seconds;			/* counts down. Off at zero. */
.................... 	int16 command_on_hold_seconds;      /* counts down. Off at zero. */
.................... 
.................... 	int16 command_off_seconds;			/* counts down. Off at zero. */
.................... 	int16 command_off_hold_seconds;     /* counts down. Off at zero. */
.................... 
.................... 	int16 lvd_disconnect_delay_seconds;	/* counts down */
.................... 	int16  lvd_reconnect_delay_seconds;	/* counts down */
.................... 
.................... 	int16 hvd_disconnect_delay_seconds;	/* counts down */
.................... 	int16  hvd_reconnect_delay_seconds;	/* counts down */
.................... 
.................... 	int16 ltd_disconnect_delay_seconds; /* counts down */
.................... 	int16 ltd_reconnect_delay_seconds;  /* counts down */
.................... 
.................... 	int16 htd_disconnect_delay_seconds; /* counts down */
.................... 	int16 htd_reconnect_delay_seconds;  /* counts down */
.................... } struct_channel;
.................... 
.................... typedef struct {
.................... 	/* circular buffer for ADC readings */
.................... 	int16 adc_buffer[3][16];
.................... 	int8  adc_buffer_index;
.................... 
.................... 	int16 sequence_number;
.................... 	int16 uptime_minutes;
.................... 	int16 interval_milliseconds;
.................... 
.................... 	int8 factory_unlocked;
.................... 
.................... 
.................... 	int8 compile_year;
.................... 	int8 compile_month;
.................... 	int8 compile_day;
.................... 
.................... 
.................... 	int8 default_params_written;
.................... } struct_current;
.................... 
.................... typedef struct {
.................... 	/* action flags */
.................... 	int1 now_adc_sample;
.................... 	int1 now_adc_reset_count;
.................... 
.................... 	int1 now_millisecond;
.................... 
.................... 	int1 now_write_config;
.................... 	int1 now_reset_config;
.................... 
.................... 	int1 now_debug_dump;
.................... 
.................... 
.................... 	/* timers */
.................... 	int8 led_blink[2];
.................... 	int8 led_on[2];
.................... 	int8 led_off[2];
.................... 
.................... 	/* contactors */
.................... 	int8 contactor[2]; 	         /* current state */
.................... 	int8 contactor_powersave[2]; /* countdown to shut off power to coil at 0 */
.................... } struct_time_keep;
.................... 
.................... /* global structures */
.................... struct_config config={0};
.................... struct_current current={0};
.................... struct_time_keep timers={0};
.................... struct_channel channel[2]={0};
.................... 
.................... #include "adc_dcswc_module_latching_contactor.c"
.................... int16 adc_get(int8 ch) {
.................... 	int16 sum;
.................... 	int8 i;
.................... 
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */
.................... 	int16 *p;
.................... 	p = current.adc_buffer[ch];
*
0594:  MOVLB  1
0596:  MOVF   x2F,W
0598:  MULLW  20
059A:  MOVF   FF3,W
059C:  CLRF   03
059E:  ADDLW  63
05A0:  MOVWF  01
05A2:  MOVLW  00
05A4:  ADDWFC 03,F
05A6:  MOVFF  01,133
05AA:  MOVFF  03,134
.................... 
.................... 	// Calculate the mean.  This is done by summing up the
.................... 	// values and dividing by the number of elements.
.................... 	sum = 0;
05AE:  CLRF   x31
05B0:  CLRF   x30
.................... 	for( i = 0; i < 16 ; i++ ) {
05B2:  CLRF   x32
05B4:  MOVF   x32,W
05B6:  SUBLW  0F
05B8:  BNC   05E4
.................... //		sum += current.adc_buffer[ch][i];
.................... 		sum += p[i];
05BA:  CLRF   03
05BC:  MOVFF  132,02
05C0:  BCF    FD8.0
05C2:  RLCF   02,F
05C4:  RLCF   03,F
05C6:  MOVF   02,W
05C8:  ADDWF  x33,W
05CA:  MOVWF  FE9
05CC:  MOVF   x34,W
05CE:  ADDWFC 03,W
05D0:  MOVWF  FEA
05D2:  MOVFF  FEC,03
05D6:  MOVF   FED,F
05D8:  MOVF   FEF,W
05DA:  ADDWF  x30,F
05DC:  MOVF   03,W
05DE:  ADDWFC x31,F
05E0:  INCF   x32,F
05E2:  BRA    05B4
.................... 	}
.................... 
.................... 	/* divide sum by our 16 samples and round by adding 8 */
.................... 	return ( (sum+8) >> 4 );
05E4:  MOVLW  08
05E6:  ADDWF  x30,W
05E8:  MOVWF  x35
05EA:  MOVLW  00
05EC:  ADDWFC x31,W
05EE:  MOVWF  x36
05F0:  RRCF   x36,W
05F2:  MOVWF  03
05F4:  RRCF   x35,W
05F6:  MOVWF  02
05F8:  RRCF   03,F
05FA:  RRCF   02,F
05FC:  RRCF   03,F
05FE:  RRCF   02,F
0600:  RRCF   03,F
0602:  RRCF   02,F
0604:  MOVLW  0F
0606:  ANDWF  03,F
0608:  MOVFF  02,01
060C:  MOVFF  03,02
0610:  MOVLB  0
0612:  RETURN 0
.................... }
.................... 
.................... 
.................... void adc_update(void) {
.................... 
.................... 	/* wrap buffer around */
.................... 	current.adc_buffer_index++;
*
1BEE:  INCF   xC3,F
.................... 	if ( current.adc_buffer_index >= 16 )
1BF0:  MOVF   xC3,W
1BF2:  SUBLW  0F
1BF4:  BC    1BF8
.................... 		current.adc_buffer_index=0;
1BF6:  CLRF   xC3
.................... 
.................... 	set_adc_channel(4);
1BF8:  MOVLW  10
1BFA:  MOVWF  01
1BFC:  MOVF   FC2,W
1BFE:  ANDLW  C3
1C00:  IORWF  01,W
1C02:  MOVWF  FC2
.................... 	current.adc_buffer[0][current.adc_buffer_index] = read_adc();
1C04:  BCF    FD8.0
1C06:  RLCF   xC3,W
1C08:  CLRF   03
1C0A:  ADDLW  63
1C0C:  MOVWF  FE9
1C0E:  MOVLW  00
1C10:  ADDWFC 03,W
1C12:  MOVWF  FEA
1C14:  BSF    FC2.1
1C16:  BTFSC  FC2.1
1C18:  BRA    1C16
1C1A:  MOVFF  FC3,FEF
1C1E:  MOVFF  FC4,FEC
.................... 
.................... 
.................... 	set_adc_channel(2);
1C22:  MOVLW  08
1C24:  MOVWF  01
1C26:  MOVF   FC2,W
1C28:  ANDLW  C3
1C2A:  IORWF  01,W
1C2C:  MOVWF  FC2
.................... 	delay_ms(1);
1C2E:  MOVLW  01
1C30:  MOVLB  1
1C32:  MOVWF  x28
1C34:  MOVLB  0
1C36:  RCALL  14CC
.................... 	current.adc_buffer[1][current.adc_buffer_index] = read_adc();
1C38:  BCF    FD8.0
1C3A:  RLCF   xC3,W
1C3C:  CLRF   03
1C3E:  ADDLW  83
1C40:  MOVWF  FE9
1C42:  MOVLW  00
1C44:  ADDWFC 03,W
1C46:  MOVWF  FEA
1C48:  BSF    FC2.1
1C4A:  BTFSC  FC2.1
1C4C:  BRA    1C4A
1C4E:  MOVFF  FC3,FEF
1C52:  MOVFF  FC4,FEC
.................... 
.................... 	set_adc_channel(9);
1C56:  MOVLW  24
1C58:  MOVWF  01
1C5A:  MOVF   FC2,W
1C5C:  ANDLW  C3
1C5E:  IORWF  01,W
1C60:  MOVWF  FC2
.................... 	delay_ms(1);
1C62:  MOVLW  01
1C64:  MOVLB  1
1C66:  MOVWF  x28
1C68:  MOVLB  0
1C6A:  RCALL  14CC
.................... 	current.adc_buffer[2][current.adc_buffer_index] = read_adc();
1C6C:  BCF    FD8.0
1C6E:  RLCF   xC3,W
1C70:  CLRF   03
1C72:  ADDLW  A3
1C74:  MOVWF  FE9
1C76:  MOVLW  00
1C78:  ADDWFC 03,W
1C7A:  MOVWF  FEA
1C7C:  BSF    FC2.1
1C7E:  BTFSC  FC2.1
1C80:  BRA    1C7E
1C82:  MOVFF  FC3,FEF
1C86:  MOVFF  FC4,FEC
1C8A:  RETURN 0
.................... }
.................... 
.................... int8 read_dip_switch(void) {
.................... 	int16 adc;
.................... 
.................... 	set_adc_channel(9);
*
14F6:  MOVLW  24
14F8:  MOVWF  01
14FA:  MOVF   FC2,W
14FC:  ANDLW  C3
14FE:  IORWF  01,W
1500:  MOVWF  FC2
.................... 	delay_ms(1);
1502:  MOVLW  01
1504:  MOVLB  1
1506:  MOVWF  x28
1508:  MOVLB  0
150A:  RCALL  14CC
.................... 	adc=read_adc();
150C:  BSF    FC2.1
150E:  BTFSC  FC2.1
1510:  BRA    150E
1512:  MOVFF  FC4,127
1516:  MOVFF  FC3,126
.................... 
.................... 	/* (note that table is sorted by vout reading 
.................... 	SW3.1 (LSB) SW3.2 (MSB) VALUE ADC
....................     OFF         OFF         0     1023
.................... 	OFF         ON          2     682
....................     ON          OFF         1     511
.................... 	ON          ON          3     409
.................... 	*/
.................... 
.................... 	if ( adc > (1023-64) )
151A:  MOVLB  1
151C:  MOVF   x27,W
151E:  SUBLW  02
1520:  BC    1532
1522:  XORLW  FF
1524:  BNZ   152C
1526:  MOVF   x26,W
1528:  SUBLW  BF
152A:  BC    1532
.................... 		return 0;
152C:  MOVLW  00
152E:  MOVWF  01
1530:  BRA    1562
.................... 	if ( adc > (682-64) )
1532:  MOVF   x27,W
1534:  SUBLW  01
1536:  BC    1548
1538:  XORLW  FF
153A:  BNZ   1542
153C:  MOVF   x26,W
153E:  SUBLW  6A
1540:  BC    1548
.................... 		return 2;
1542:  MOVLW  02
1544:  MOVWF  01
1546:  BRA    1562
.................... 	if ( adc > (511-64) )
1548:  MOVF   x27,W
154A:  SUBLW  00
154C:  BC    155E
154E:  XORLW  FF
1550:  BNZ   1558
1552:  MOVF   x26,W
1554:  SUBLW  BF
1556:  BC    155E
.................... 		return 1;
1558:  MOVLW  01
155A:  MOVWF  01
155C:  BRA    1562
.................... 
.................... 	return 3;
155E:  MOVLW  03
1560:  MOVWF  01
1562:  MOVLB  0
1564:  GOTO   181A (RETURN)
.................... }
.................... 
.................... #include "param_dcswc_module_latching_contactor.c"
.................... #inline
.................... char xor_crc(char oldcrc, char data) {
.................... 	return oldcrc ^ data;
*
1892:  MOVF   x28,W
1894:  XORWF  x29,W
1896:  MOVWF  01
*
18E0:  MOVF   x28,W
18E2:  XORWF  x29,W
18E4:  MOVWF  01
.................... }
.................... 
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) {
*
182A:  MOVLB  1
182C:  CLRF   x24
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
182E:  MOVFF  123,126
1832:  MOVF   x22,W
1834:  BTFSC  FD8.2
1836:  DECF   x23,F
1838:  DECF   x22,F
183A:  MOVWF  x25
183C:  MOVF   x25,F
183E:  BNZ   1844
1840:  MOVF   x26,F
1842:  BZ    18A4
.................... 		*data = read_eeprom( address++ );
1844:  MOVFF  121,03
1848:  MOVF   x20,W
184A:  MOVWF  FE9
184C:  MOVFF  03,FEA
1850:  MOVF   x1F,W
1852:  MOVWF  03
1854:  MOVF   x1E,W
1856:  INCF   x1E,F
1858:  BTFSC  FD8.2
185A:  INCF   x1F,F
185C:  MOVWF  x27
185E:  MOVFF  03,128
1862:  MOVFF  FF2,129
1866:  BCF    FF2.7
1868:  MOVFF  127,FA9
186C:  BCF    FA6.6
186E:  BCF    FA6.7
1870:  BSF    FA6.0
1872:  MOVF   FA8,W
1874:  BTFSC  x29.7
1876:  BSF    FF2.7
1878:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data);
187A:  MOVFF  121,03
187E:  MOVF   x20,W
1880:  MOVWF  FE9
1882:  MOVFF  03,FEA
1886:  MOVFF  FEF,125
188A:  MOVFF  124,128
188E:  MOVFF  125,129
*
1898:  MOVFF  01,124
.................... 		data++;
189C:  INCF   x20,F
189E:  BTFSC  FD8.2
18A0:  INCF   x21,F
18A2:  BRA    182E
.................... 	}
.................... 	return crc;
18A4:  MOVFF  124,01
18A8:  MOVLB  0
18AA:  GOTO   1B78 (RETURN)
.................... }
.................... 
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) {
18AE:  MOVLB  1
18B0:  CLRF   x26
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
18B2:  MOVFF  125,128
18B6:  MOVF   x24,W
18B8:  BTFSC  FD8.2
18BA:  DECF   x25,F
18BC:  DECF   x24,F
18BE:  MOVWF  x27
18C0:  MOVF   x27,F
18C2:  BNZ   18C8
18C4:  MOVF   x28,F
18C6:  BZ    1940
.................... 		/* restart_wdt() */
.................... 		crc = xor_crc(crc,*data);
18C8:  MOVFF  123,03
18CC:  MOVF   x22,W
18CE:  MOVWF  FE9
18D0:  MOVFF  03,FEA
18D4:  MOVFF  FEF,127
18D8:  MOVFF  126,128
18DC:  MOVFF  127,129
*
18E6:  MOVFF  01,126
.................... 		write_eeprom( address++, *data++ );
18EA:  MOVF   x21,W
18EC:  MOVWF  03
18EE:  MOVF   x20,W
18F0:  INCF   x20,F
18F2:  BTFSC  FD8.2
18F4:  INCF   x21,F
18F6:  MOVWF  x27
18F8:  MOVFF  03,128
18FC:  MOVF   x23,W
18FE:  MOVWF  03
1900:  MOVF   x22,W
1902:  INCF   x22,F
1904:  BTFSC  FD8.2
1906:  INCF   x23,F
1908:  MOVWF  FE9
190A:  MOVFF  03,FEA
190E:  MOVFF  FEF,129
1912:  MOVF   FF2,W
1914:  MOVWF  00
1916:  BCF    FF2.7
1918:  MOVFF  127,FA9
191C:  MOVFF  129,FA8
1920:  BCF    FA6.6
1922:  BCF    FA6.7
1924:  BSF    FA6.2
1926:  MOVLB  F
1928:  MOVLW  55
192A:  MOVWF  FA7
192C:  MOVLW  AA
192E:  MOVWF  FA7
1930:  BSF    FA6.1
1932:  BTFSC  FA6.1
1934:  BRA    1932
1936:  BCF    FA6.2
1938:  MOVF   00,W
193A:  IORWF  FF2,F
193C:  MOVLB  1
193E:  BRA    18B2
.................... 	}
.................... 
.................... 	return crc;
1940:  MOVFF  126,01
1944:  MOVLB  0
1946:  GOTO   1966 (RETURN)
.................... }
.................... 
.................... void write_param_file() {
.................... 	int8 crc;
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config));
194A:  MOVLB  1
194C:  MOVLW  1B
194E:  MOVWF  x1E
1950:  CLRF   x21
1952:  MOVLW  02
1954:  MOVWF  x20
1956:  CLRF   x23
1958:  MOVFF  11E,122
195C:  CLRF   x25
195E:  MOVLW  48
1960:  MOVWF  x24
1962:  MOVLB  0
1964:  BRA    18AE
1966:  MOVFF  01,11D
.................... 	/* write the CRC was calculated on the structure */
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc);
196A:  MOVF   FF2,W
196C:  MOVWF  00
196E:  BCF    FF2.7
1970:  CLRF   FA9
1972:  MOVFF  11D,FA8
1976:  BCF    FA6.6
1978:  BCF    FA6.7
197A:  BSF    FA6.2
197C:  MOVLB  F
197E:  MOVLW  55
1980:  MOVWF  FA7
1982:  MOVLW  AA
1984:  MOVWF  FA7
1986:  BSF    FA6.1
1988:  BTFSC  FA6.1
198A:  BRA    1988
198C:  BCF    FA6.2
198E:  MOVF   00,W
1990:  IORWF  FF2,F
1992:  MOVLB  0
1994:  RETURN 0
.................... }
.................... 
.................... void write_default_param_file() {
.................... 	int8 i;
.................... 
.................... 	current.default_params_written=1;
1996:  MOVLW  01
1998:  MOVWF  xCE
.................... 
.................... 	/* both LEDs on */
.................... 	timers.led_blink[0]=255;
199A:  SETF   xD0
.................... 	timers.led_blink[1]=255;
199C:  SETF   xD1
.................... 
.................... 
.................... 	for ( i=0 ; i<2 ; i++ ) {
199E:  MOVLB  1
19A0:  CLRF   x1C
19A2:  MOVF   x1C,W
19A4:  SUBLW  01
19A6:  BTFSS  FD8.0
19A8:  BRA    1B56
.................... 		config.ch[i].lvd_disconnect_adc=606;
19AA:  MOVF   x1C,W
19AC:  MULLW  24
19AE:  MOVF   FF3,W
19B0:  CLRF   x1E
19B2:  MOVWF  x1D
19B4:  MOVLW  04
19B6:  ADDWF  x1D,W
19B8:  MOVWF  01
19BA:  MOVLW  00
19BC:  ADDWFC x1E,W
19BE:  MOVWF  03
19C0:  MOVF   01,W
19C2:  ADDLW  1B
19C4:  MOVWF  FE9
19C6:  MOVLW  00
19C8:  ADDWFC 03,W
19CA:  MOVWF  FEA
19CC:  MOVLW  02
19CE:  MOVWF  FEC
19D0:  MOVF   FED,F
19D2:  MOVLW  5E
19D4:  MOVWF  FEF
.................... 		config.ch[i].lvd_disconnect_delay=20;
19D6:  MOVF   x1C,W
19D8:  MULLW  24
19DA:  MOVF   FF3,W
19DC:  CLRF   x1E
19DE:  MOVWF  x1D
19E0:  MOVLW  06
19E2:  ADDWF  x1D,W
19E4:  MOVWF  01
19E6:  MOVLW  00
19E8:  ADDWFC x1E,W
19EA:  MOVWF  03
19EC:  MOVF   01,W
19EE:  ADDLW  1B
19F0:  MOVWF  FE9
19F2:  MOVLW  00
19F4:  ADDWFC 03,W
19F6:  MOVWF  FEA
19F8:  CLRF   FEC
19FA:  MOVF   FED,F
19FC:  MOVLW  14
19FE:  MOVWF  FEF
.................... 		config.ch[i].lvd_reconnect_adc=616;
1A00:  MOVF   x1C,W
1A02:  MULLW  24
1A04:  MOVF   FF3,W
1A06:  CLRF   x1E
1A08:  MOVWF  x1D
1A0A:  MOVLW  08
1A0C:  ADDWF  x1D,W
1A0E:  MOVWF  01
1A10:  MOVLW  00
1A12:  ADDWFC x1E,W
1A14:  MOVWF  03
1A16:  MOVF   01,W
1A18:  ADDLW  1B
1A1A:  MOVWF  FE9
1A1C:  MOVLW  00
1A1E:  ADDWFC 03,W
1A20:  MOVWF  FEA
1A22:  MOVLW  02
1A24:  MOVWF  FEC
1A26:  MOVF   FED,F
1A28:  MOVLW  68
1A2A:  MOVWF  FEF
.................... 		config.ch[i].lvd_reconnect_delay=10;
1A2C:  MOVF   x1C,W
1A2E:  MULLW  24
1A30:  MOVF   FF3,W
1A32:  CLRF   x1E
1A34:  MOVWF  x1D
1A36:  MOVLW  0A
1A38:  ADDWF  x1D,W
1A3A:  MOVWF  01
1A3C:  MOVLW  00
1A3E:  ADDWFC x1E,W
1A40:  MOVWF  03
1A42:  MOVF   01,W
1A44:  ADDLW  1B
1A46:  MOVWF  FE9
1A48:  MOVLW  00
1A4A:  ADDWFC 03,W
1A4C:  MOVWF  FEA
1A4E:  CLRF   FEC
1A50:  MOVF   FED,F
1A52:  MOVLW  0A
1A54:  MOVWF  FEF
.................... 		
.................... 
.................... 		config.ch[i].hvd_disconnect_adc=700;
1A56:  MOVF   x1C,W
1A58:  MULLW  24
1A5A:  MOVF   FF3,W
1A5C:  CLRF   x1E
1A5E:  MOVWF  x1D
1A60:  MOVLW  0C
1A62:  ADDWF  x1D,W
1A64:  MOVWF  01
1A66:  MOVLW  00
1A68:  ADDWFC x1E,W
1A6A:  MOVWF  03
1A6C:  MOVF   01,W
1A6E:  ADDLW  1B
1A70:  MOVWF  FE9
1A72:  MOVLW  00
1A74:  ADDWFC 03,W
1A76:  MOVWF  FEA
1A78:  MOVLW  02
1A7A:  MOVWF  FEC
1A7C:  MOVF   FED,F
1A7E:  MOVLW  BC
1A80:  MOVWF  FEF
.................... 		config.ch[i].hvd_disconnect_delay=1;
1A82:  MOVF   x1C,W
1A84:  MULLW  24
1A86:  MOVF   FF3,W
1A88:  CLRF   x1E
1A8A:  MOVWF  x1D
1A8C:  MOVLW  0E
1A8E:  ADDWF  x1D,W
1A90:  MOVWF  01
1A92:  MOVLW  00
1A94:  ADDWFC x1E,W
1A96:  MOVWF  03
1A98:  MOVF   01,W
1A9A:  ADDLW  1B
1A9C:  MOVWF  FE9
1A9E:  MOVLW  00
1AA0:  ADDWFC 03,W
1AA2:  MOVWF  FEA
1AA4:  CLRF   FEC
1AA6:  MOVF   FED,F
1AA8:  MOVLW  01
1AAA:  MOVWF  FEF
.................... 		config.ch[i].hvd_reconnect_adc=650;
1AAC:  MOVF   x1C,W
1AAE:  MULLW  24
1AB0:  MOVF   FF3,W
1AB2:  CLRF   x1E
1AB4:  MOVWF  x1D
1AB6:  MOVLW  10
1AB8:  ADDWF  x1D,W
1ABA:  MOVWF  01
1ABC:  MOVLW  00
1ABE:  ADDWFC x1E,W
1AC0:  MOVWF  03
1AC2:  MOVF   01,W
1AC4:  ADDLW  1B
1AC6:  MOVWF  FE9
1AC8:  MOVLW  00
1ACA:  ADDWFC 03,W
1ACC:  MOVWF  FEA
1ACE:  MOVLW  02
1AD0:  MOVWF  FEC
1AD2:  MOVF   FED,F
1AD4:  MOVLW  8A
1AD6:  MOVWF  FEF
.................... 		config.ch[i].hvd_reconnect_delay=60;
1AD8:  MOVF   x1C,W
1ADA:  MULLW  24
1ADC:  MOVF   FF3,W
1ADE:  CLRF   x1E
1AE0:  MOVWF  x1D
1AE2:  MOVLW  12
1AE4:  ADDWF  x1D,W
1AE6:  MOVWF  01
1AE8:  MOVLW  00
1AEA:  ADDWFC x1E,W
1AEC:  MOVWF  03
1AEE:  MOVF   01,W
1AF0:  ADDLW  1B
1AF2:  MOVWF  FE9
1AF4:  MOVLW  00
1AF6:  ADDWFC 03,W
1AF8:  MOVWF  FEA
1AFA:  CLRF   FEC
1AFC:  MOVF   FED,F
1AFE:  MOVLW  3C
1B00:  MOVWF  FEF
.................... 
.................... 
.................... 		config.ch[i].ltd_disconnect_delay=65535;
1B02:  MOVF   x1C,W
1B04:  MULLW  24
1B06:  MOVF   FF3,W
1B08:  CLRF   x1E
1B0A:  MOVWF  x1D
1B0C:  MOVLW  16
1B0E:  ADDWF  x1D,W
1B10:  MOVWF  01
1B12:  MOVLW  00
1B14:  ADDWFC x1E,W
1B16:  MOVWF  03
1B18:  MOVF   01,W
1B1A:  ADDLW  1B
1B1C:  MOVWF  FE9
1B1E:  MOVLW  00
1B20:  ADDWFC 03,W
1B22:  MOVWF  FEA
1B24:  SETF   FEC
1B26:  MOVF   FED,F
1B28:  SETF   FEF
.................... 		config.ch[i].htd_disconnect_delay=65535;
1B2A:  MOVF   x1C,W
1B2C:  MULLW  24
1B2E:  MOVF   FF3,W
1B30:  CLRF   x1E
1B32:  MOVWF  x1D
1B34:  MOVLW  1E
1B36:  ADDWF  x1D,W
1B38:  MOVWF  01
1B3A:  MOVLW  00
1B3C:  ADDWFC x1E,W
1B3E:  MOVWF  03
1B40:  MOVF   01,W
1B42:  ADDLW  1B
1B44:  MOVWF  FE9
1B46:  MOVLW  00
1B48:  ADDWFC 03,W
1B4A:  MOVWF  FEA
1B4C:  SETF   FEC
1B4E:  MOVF   FED,F
1B50:  SETF   FEF
1B52:  INCF   x1C,F
1B54:  BRA    19A2
.................... 	}
.................... 	
.................... 	/* write them so next time we use from EEPROM */
.................... 	write_param_file();
1B56:  MOVLB  0
1B58:  RCALL  194A
1B5A:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void read_param_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config)); 
1B5C:  MOVLB  1
1B5E:  MOVLW  1B
1B60:  MOVWF  x1C
1B62:  CLRF   x1F
1B64:  MOVLW  02
1B66:  MOVWF  x1E
1B68:  CLRF   x21
1B6A:  MOVFF  11C,120
1B6E:  CLRF   x23
1B70:  MOVLW  48
1B72:  MOVWF  x22
1B74:  MOVLB  0
1B76:  BRA    182A
1B78:  MOVFF  01,11B
.................... 		
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) {
1B7C:  MOVFF  FF2,11C
1B80:  BCF    FF2.7
1B82:  CLRF   FA9
1B84:  BCF    FA6.6
1B86:  BCF    FA6.7
1B88:  BSF    FA6.0
1B8A:  MOVF   FA8,W
1B8C:  MOVLB  1
1B8E:  BTFSC  x1C.7
1B90:  BSF    FF2.7
1B92:  SUBWF  x1B,W
1B94:  BZ    1B9C
.................... 		write_default_param_file();
1B96:  MOVLB  0
1B98:  RCALL  1996
1B9A:  MOVLB  1
.................... 	}
1B9C:  MOVLB  0
1B9E:  GOTO   2E9C (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... #include "i2c_handler_dcswc_module_latching_contactor.c"
.................... #include "registers_dcswc_module_latching_contactor.h"
.................... 
.................... /* first two or three registers will give enough information for telemetry */
.................... /* 10 bit input voltage ADC averaged value */
.................... #define I2C_REG_VOLTAGE_INPUT_AVG             0  
.................... /* two 8 bit channel states (A is MSB / B is LSB) */
.................... #define I2C_REG_STATE_CONTACTORS              1 
.................... /* 10 bit NTC thermistor ADC averaged value */
.................... #define I2C_REG_TEMPERATURE_BOARD_AVG         2
.................... 
....................   
.................... /* channel 0 / A */
.................... /* command can only come from I2C interface */
.................... #define I2C_REG_CH0_COMMAND_ON                3 /* R/W seconds */
.................... #define I2C_REG_CH0_COMMAND_ON_HOLD           4
.................... 
.................... #define I2C_REG_CH0_COMMAND_OFF               5 /* R/W seconds */
.................... #define I2C_REG_CH0_COMMAND_OFF_HOLD          6
.................... 
.................... /* low voltage disconnect */
.................... #define I2C_REG_CH0_LVD_DISCONNECT            7  /* R seconds */
.................... #define I2C_REG_CH0_LVD_RECONNECT             8 
.................... 
.................... /* high voltage disconnect */
.................... #define I2C_REG_CH0_HVD_DISCONNECT            9 /* R seconds */
.................... #define I2C_REG_CH0_HVD_RECONNECT             10
.................... 
.................... /* low temperature disconnect */
.................... #define I2C_REG_CH0_LTD_DISCONNECT            11  /* R seconds */
.................... #define I2C_REG_CH0_LTD_RECONNECT             12
.................... 
.................... /* high temperature disconnect */
.................... #define I2C_REG_CH0_HTD_DISCONNECT            13 /* R seconds */
.................... #define I2C_REG_CH0_HTD_RECONNECT             14
.................... 
.................... /* reserved for future, unimplemented */
.................... #define I2C_REG_CH0_FUT_DISCONNECT            15 /* R seconds */
.................... #define I2C_REG_CH0_FUT_RECONNECT             16
.................... 
.................... /* channel 1 / B */
.................... /* command can only come from I2C interface */
.................... #define I2C_REG_CH1_COMMAND_ON                17 /* R/W seconds */
.................... #define I2C_REG_CH1_COMMAND_ON_HOLD           18
.................... 
.................... #define I2C_REG_CH1_COMMAND_OFF               19 /* R/W seconds */
.................... #define I2C_REG_CH1_COMMAND_OFF_HOLD          20
.................... 
.................... /* low voltage disconnect */
.................... #define I2C_REG_CH1_LVD_DISCONNECT            21 /* R seconds */
.................... #define I2C_REG_CH1_LVD_RECONNECT             22 
.................... 
.................... /* high voltage disconnect */
.................... #define I2C_REG_CH1_HVD_DISCONNECT            23 /* R seconds */
.................... #define I2C_REG_CH1_HVD_RECONNECT             24
.................... 
.................... /* low temperature disconnect */
.................... #define I2C_REG_CH1_LTD_DISCONNECT            25  /* R seconds */
.................... #define I2C_REG_CH1_LTD_RECONNECT             26
.................... 
.................... /* high temperature disconnect */
.................... #define I2C_REG_CH1_HTD_DISCONNECT            27 /* R seconds */
.................... #define I2C_REG_CH1_HTD_RECONNECT             28
.................... 
.................... /* reserved for future, unimplemented */
.................... #define I2C_REG_CH1_FUT_DISCONNECT            29 /* R seconds */
.................... #define I2C_REG_CH1_FUT_RECONNECT             30
.................... 
.................... /* meta */
.................... #define I2C_REG_SEQUENCE_NUMBER               31 /* R */
.................... #define I2C_REG_TIME_INTERVAL_MILLISECONDS    32
.................... #define I2C_REG_TIME_UPTIME_MINUTES           33
.................... #define I2C_REG_DEFAULT_PARAMS_WRITTEN        34
.................... 
.................... /* channel configuration */
.................... /* channel 0 / A */
.................... #define I2C_REG_CH0_COMMAND_ON_HOLD_INITIAL   64
.................... 
.................... #define I2C_REG_CH0_COMMAND_OFF_HOLD_INITIAL  65
.................... 
.................... #define I2C_REG_CH0_LVD_DISCONNECT_ADC        66
.................... #define I2C_REG_CH0_LVD_DISCONNECT_DELAY      67
.................... #define I2C_REG_CH0_LVD_RECONNECT_ADC         68
.................... #define I2C_REG_CH0_LVD_RECONNECT_DELAY       69
.................... 
.................... #define I2C_REG_CH0_HVD_DISCONNECT_ADC        70
.................... #define I2C_REG_CH0_HVD_DISCONNECT_DELAY      71
.................... #define I2C_REG_CH0_HVD_RECONNECT_ADC         72
.................... #define I2C_REG_CH0_HVD_RECONNECT_DELAY       73
.................... 
.................... #define I2C_REG_CH0_LTD_DISCONNECT_ADC        74
.................... #define I2C_REG_CH0_LTD_DISCONNECT_DELAY      75
.................... #define I2C_REG_CH0_LTD_RECONNECT_ADC         76
.................... #define I2C_REG_CH0_LTD_RECONNECT_DELAY       77
.................... 
.................... #define I2C_REG_CH0_HTD_DISCONNECT_ADC        78
.................... #define I2C_REG_CH0_HTD_DISCONNECT_DELAY      79
.................... #define I2C_REG_CH0_HTD_RECONNECT_ADC         80
.................... #define I2C_REG_CH0_HTD_RECONNECT_DELAY       81
.................... 
.................... #define I2C_REG_CH0_FUT_DISCONNECT_VALUE      82
.................... #define I2C_REG_CH0_FUT_DISCONNECT_DELAY      83
.................... #define I2C_REG_CH0_FUT_RECONNECT_VALUE       84
.................... #define I2C_REG_CH0_FUT_RECONNECT_DELAY       85
.................... 
.................... /* channel 1 / B */
.................... #define I2C_REG_CH1_COMMAND_ON_HOLD_INITIAL   86
.................... 
.................... #define I2C_REG_CH1_COMMAND_OFF_HOLD_INITIAL  87
.................... 
.................... #define I2C_REG_CH1_LVD_DISCONNECT_ADC        88
.................... #define I2C_REG_CH1_LVD_DISCONNECT_DELAY      89
.................... #define I2C_REG_CH1_LVD_RECONNECT_ADC         90
.................... #define I2C_REG_CH1_LVD_RECONNECT_DELAY       91
.................... 
.................... #define I2C_REG_CH1_HVD_DISCONNECT_ADC        92
.................... #define I2C_REG_CH1_HVD_DISCONNECT_DELAY      93
.................... #define I2C_REG_CH1_HVD_RECONNECT_ADC         94
.................... #define I2C_REG_CH1_HVD_RECONNECT_DELAY       95
.................... 
.................... #define I2C_REG_CH1_LTD_DISCONNECT_ADC        96
.................... #define I2C_REG_CH1_LTD_DISCONNECT_DELAY      97
.................... #define I2C_REG_CH1_LTD_RECONNECT_ADC         98
.................... #define I2C_REG_CH1_LTD_RECONNECT_DELAY       99
.................... 
.................... #define I2C_REG_CH1_HTD_DISCONNECT_ADC        100
.................... #define I2C_REG_CH1_HTD_DISCONNECT_DELAY      101
.................... #define I2C_REG_CH1_HTD_RECONNECT_ADC         102
.................... #define I2C_REG_CH1_HTD_RECONNECT_DELAY       103
.................... 
.................... #define I2C_REG_CH1_FUT_DISCONNECT_VALUE      104
.................... #define I2C_REG_CH1_FUT_DISCONNECT_DELAY      105
.................... #define I2C_REG_CH1_FUT_RECONNECT_VALUE       106
.................... #define I2C_REG_CH1_FUT_RECONNECT_DELAY       107
.................... 
.................... 
.................... /* configuration */
.................... #define I2C_REG_CONFIG_HARDWARE_MODEL              128 /* R */
.................... #define I2C_REG_CONFIG_HARDWARE_VERSION            129
.................... #define I2C_REG_CONFIG_SOFTWARE_MODEL              130
.................... #define I2C_REG_CONFIG_SOFTWARE_VERSION            131
.................... #define I2C_REG_CONFIG_SOFTWARE_YEAR               132
.................... #define I2C_REG_CONFIG_SOFTWARE_MONTH              133
.................... #define I2C_REG_CONFIG_SOFTWARE_DAY                134
.................... 
.................... #define I2C_REG_CONFIG_PARAM_WRITE                 135 /* R / W */
.................... 
.................... 
.................... 
.................... void write_i2c(int8 addr, int16 value) {
.................... 	int8 c;
.................... 
.................... 	/* c is the channel we are accessing based on register range */
.................... 	if ( addr >= I2C_REG_CH1_COMMAND_ON && addr <= I2C_REG_CH1_FUT_RECONNECT ) {
*
00DC:  MOVLB  1
00DE:  MOVF   x2F,W
00E0:  SUBLW  10
00E2:  BC    00F4
00E4:  MOVF   x2F,W
00E6:  SUBLW  1E
00E8:  BNC   00F4
.................... 		/* channel 1 status region */
.................... 		c=1;
00EA:  MOVLW  01
00EC:  MOVWF  x32
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON - I2C_REG_CH0_COMMAND_ON);
00EE:  MOVLW  0E
00F0:  SUBWF  x2F,F
.................... 	} else if ( addr >= I2C_REG_CH1_COMMAND_ON_HOLD && addr <= I2C_REG_CH1_FUT_RECONNECT_DELAY ) {
00F2:  BRA    010C
00F4:  MOVF   x2F,W
00F6:  SUBLW  11
00F8:  BC    010A
00FA:  MOVF   x2F,W
00FC:  SUBLW  6B
00FE:  BNC   010A
.................... 		/* channel 1 configuration region */
.................... 		c=1;
0100:  MOVLW  01
0102:  MOVWF  x32
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON_HOLD - I2C_REG_CH0_COMMAND_ON_HOLD );
0104:  MOVLW  0E
0106:  SUBWF  x2F,F
.................... 	} else {
0108:  BRA    010C
.................... 		c=0;
010A:  CLRF   x32
.................... 	}
.................... 
.................... 	switch ( addr ) {
010C:  MOVF   x2F,W
010E:  XORLW  03
0110:  MOVLB  0
0112:  BZ    018A
0114:  XORLW  07
0116:  BZ    01BA
0118:  XORLW  01
011A:  BZ    01EA
011C:  XORLW  03
011E:  BTFSC  FD8.2
0120:  BRA    021A
0122:  XORLW  44
0124:  BTFSC  FD8.2
0126:  BRA    024A
0128:  XORLW  01
012A:  BTFSC  FD8.2
012C:  BRA    027A
012E:  XORLW  07
0130:  BTFSC  FD8.2
0132:  BRA    02AA
0134:  XORLW  01
0136:  BTFSC  FD8.2
0138:  BRA    02DA
013A:  XORLW  03
013C:  BTFSC  FD8.2
013E:  BRA    030A
0140:  XORLW  01
0142:  BTFSC  FD8.2
0144:  BRA    033A
0146:  XORLW  0F
0148:  BTFSC  FD8.2
014A:  BRA    036A
014C:  XORLW  01
014E:  BTFSC  FD8.2
0150:  BRA    039A
0152:  XORLW  03
0154:  BTFSC  FD8.2
0156:  BRA    03CA
0158:  XORLW  01
015A:  BTFSC  FD8.2
015C:  BRA    03FA
015E:  XORLW  07
0160:  BTFSC  FD8.2
0162:  BRA    042A
0164:  XORLW  01
0166:  BTFSC  FD8.2
0168:  BRA    045A
016A:  XORLW  03
016C:  BTFSC  FD8.2
016E:  BRA    048A
0170:  XORLW  01
0172:  BTFSC  FD8.2
0174:  BRA    04BA
0176:  XORLW  1F
0178:  BTFSC  FD8.2
017A:  BRA    04EA
017C:  XORLW  01
017E:  BTFSC  FD8.2
0180:  BRA    051A
0182:  XORLW  D6
0184:  BTFSC  FD8.2
0186:  BRA    054A
0188:  BRA    0590
.................... 		case I2C_REG_CH0_COMMAND_ON:
.................... 			channel[c].command_on_seconds=value;
018A:  MOVLB  1
018C:  MOVF   x32,W
018E:  MULLW  19
0190:  MOVF   FF3,W
0192:  CLRF   x34
0194:  MOVWF  x33
0196:  MOVLW  01
0198:  ADDWF  x33,W
019A:  MOVWF  01
019C:  MOVLW  00
019E:  ADDWFC x34,W
01A0:  MOVWF  03
01A2:  MOVF   01,W
01A4:  ADDLW  DA
01A6:  MOVWF  FE9
01A8:  MOVLW  00
01AA:  ADDWFC 03,W
01AC:  MOVWF  FEA
01AE:  MOVFF  131,FEC
01B2:  MOVF   FED,F
01B4:  MOVFF  130,FEF
01B8:  MOVLB  0
.................... 		case I2C_REG_CH0_COMMAND_ON_HOLD:
.................... 			channel[c].command_on_hold_seconds=value;
01BA:  MOVLB  1
01BC:  MOVF   x32,W
01BE:  MULLW  19
01C0:  MOVF   FF3,W
01C2:  CLRF   x34
01C4:  MOVWF  x33
01C6:  MOVLW  03
01C8:  ADDWF  x33,W
01CA:  MOVWF  01
01CC:  MOVLW  00
01CE:  ADDWFC x34,W
01D0:  MOVWF  03
01D2:  MOVF   01,W
01D4:  ADDLW  DA
01D6:  MOVWF  FE9
01D8:  MOVLW  00
01DA:  ADDWFC 03,W
01DC:  MOVWF  FEA
01DE:  MOVFF  131,FEC
01E2:  MOVF   FED,F
01E4:  MOVFF  130,FEF
01E8:  MOVLB  0
.................... 	
.................... 		case I2C_REG_CH0_COMMAND_OFF:
.................... 			channel[c].command_off_seconds=value;
01EA:  MOVLB  1
01EC:  MOVF   x32,W
01EE:  MULLW  19
01F0:  MOVF   FF3,W
01F2:  CLRF   x34
01F4:  MOVWF  x33
01F6:  MOVLW  05
01F8:  ADDWF  x33,W
01FA:  MOVWF  01
01FC:  MOVLW  00
01FE:  ADDWFC x34,W
0200:  MOVWF  03
0202:  MOVF   01,W
0204:  ADDLW  DA
0206:  MOVWF  FE9
0208:  MOVLW  00
020A:  ADDWFC 03,W
020C:  MOVWF  FEA
020E:  MOVFF  131,FEC
0212:  MOVF   FED,F
0214:  MOVFF  130,FEF
0218:  MOVLB  0
.................... 		case I2C_REG_CH0_COMMAND_OFF_HOLD:
.................... 			channel[c].command_off_hold_seconds=value;
021A:  MOVLB  1
021C:  MOVF   x32,W
021E:  MULLW  19
0220:  MOVF   FF3,W
0222:  CLRF   x34
0224:  MOVWF  x33
0226:  MOVLW  07
0228:  ADDWF  x33,W
022A:  MOVWF  01
022C:  MOVLW  00
022E:  ADDWFC x34,W
0230:  MOVWF  03
0232:  MOVF   01,W
0234:  ADDLW  DA
0236:  MOVWF  FE9
0238:  MOVLW  00
023A:  ADDWFC 03,W
023C:  MOVWF  FEA
023E:  MOVFF  131,FEC
0242:  MOVF   FED,F
0244:  MOVFF  130,FEF
0248:  MOVLB  0
.................... 
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_ADC:
.................... 			config.ch[c].lvd_disconnect_adc=value;
024A:  MOVLB  1
024C:  MOVF   x32,W
024E:  MULLW  24
0250:  MOVF   FF3,W
0252:  CLRF   x34
0254:  MOVWF  x33
0256:  MOVLW  04
0258:  ADDWF  x33,W
025A:  MOVWF  01
025C:  MOVLW  00
025E:  ADDWFC x34,W
0260:  MOVWF  03
0262:  MOVF   01,W
0264:  ADDLW  1B
0266:  MOVWF  FE9
0268:  MOVLW  00
026A:  ADDWFC 03,W
026C:  MOVWF  FEA
026E:  MOVFF  131,FEC
0272:  MOVF   FED,F
0274:  MOVFF  130,FEF
0278:  MOVLB  0
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_DELAY:
.................... 			config.ch[c].lvd_disconnect_delay=value;
027A:  MOVLB  1
027C:  MOVF   x32,W
027E:  MULLW  24
0280:  MOVF   FF3,W
0282:  CLRF   x34
0284:  MOVWF  x33
0286:  MOVLW  06
0288:  ADDWF  x33,W
028A:  MOVWF  01
028C:  MOVLW  00
028E:  ADDWFC x34,W
0290:  MOVWF  03
0292:  MOVF   01,W
0294:  ADDLW  1B
0296:  MOVWF  FE9
0298:  MOVLW  00
029A:  ADDWFC 03,W
029C:  MOVWF  FEA
029E:  MOVFF  131,FEC
02A2:  MOVF   FED,F
02A4:  MOVFF  130,FEF
02A8:  MOVLB  0
.................... 		case I2C_REG_CH0_LVD_RECONNECT_ADC:
.................... 			config.ch[c].lvd_reconnect_adc=value;
02AA:  MOVLB  1
02AC:  MOVF   x32,W
02AE:  MULLW  24
02B0:  MOVF   FF3,W
02B2:  CLRF   x34
02B4:  MOVWF  x33
02B6:  MOVLW  08
02B8:  ADDWF  x33,W
02BA:  MOVWF  01
02BC:  MOVLW  00
02BE:  ADDWFC x34,W
02C0:  MOVWF  03
02C2:  MOVF   01,W
02C4:  ADDLW  1B
02C6:  MOVWF  FE9
02C8:  MOVLW  00
02CA:  ADDWFC 03,W
02CC:  MOVWF  FEA
02CE:  MOVFF  131,FEC
02D2:  MOVF   FED,F
02D4:  MOVFF  130,FEF
02D8:  MOVLB  0
.................... 		case I2C_REG_CH0_LVD_RECONNECT_DELAY:
.................... 			config.ch[c].lvd_reconnect_delay=value;
02DA:  MOVLB  1
02DC:  MOVF   x32,W
02DE:  MULLW  24
02E0:  MOVF   FF3,W
02E2:  CLRF   x34
02E4:  MOVWF  x33
02E6:  MOVLW  0A
02E8:  ADDWF  x33,W
02EA:  MOVWF  01
02EC:  MOVLW  00
02EE:  ADDWFC x34,W
02F0:  MOVWF  03
02F2:  MOVF   01,W
02F4:  ADDLW  1B
02F6:  MOVWF  FE9
02F8:  MOVLW  00
02FA:  ADDWFC 03,W
02FC:  MOVWF  FEA
02FE:  MOVFF  131,FEC
0302:  MOVF   FED,F
0304:  MOVFF  130,FEF
0308:  MOVLB  0
.................... 
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_ADC:
.................... 			config.ch[c].hvd_disconnect_adc=value;
030A:  MOVLB  1
030C:  MOVF   x32,W
030E:  MULLW  24
0310:  MOVF   FF3,W
0312:  CLRF   x34
0314:  MOVWF  x33
0316:  MOVLW  0C
0318:  ADDWF  x33,W
031A:  MOVWF  01
031C:  MOVLW  00
031E:  ADDWFC x34,W
0320:  MOVWF  03
0322:  MOVF   01,W
0324:  ADDLW  1B
0326:  MOVWF  FE9
0328:  MOVLW  00
032A:  ADDWFC 03,W
032C:  MOVWF  FEA
032E:  MOVFF  131,FEC
0332:  MOVF   FED,F
0334:  MOVFF  130,FEF
0338:  MOVLB  0
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_DELAY:
.................... 			config.ch[c].hvd_disconnect_delay=value;
033A:  MOVLB  1
033C:  MOVF   x32,W
033E:  MULLW  24
0340:  MOVF   FF3,W
0342:  CLRF   x34
0344:  MOVWF  x33
0346:  MOVLW  0E
0348:  ADDWF  x33,W
034A:  MOVWF  01
034C:  MOVLW  00
034E:  ADDWFC x34,W
0350:  MOVWF  03
0352:  MOVF   01,W
0354:  ADDLW  1B
0356:  MOVWF  FE9
0358:  MOVLW  00
035A:  ADDWFC 03,W
035C:  MOVWF  FEA
035E:  MOVFF  131,FEC
0362:  MOVF   FED,F
0364:  MOVFF  130,FEF
0368:  MOVLB  0
.................... 		case I2C_REG_CH0_HVD_RECONNECT_ADC:
.................... 			config.ch[c].hvd_reconnect_adc=value;
036A:  MOVLB  1
036C:  MOVF   x32,W
036E:  MULLW  24
0370:  MOVF   FF3,W
0372:  CLRF   x34
0374:  MOVWF  x33
0376:  MOVLW  10
0378:  ADDWF  x33,W
037A:  MOVWF  01
037C:  MOVLW  00
037E:  ADDWFC x34,W
0380:  MOVWF  03
0382:  MOVF   01,W
0384:  ADDLW  1B
0386:  MOVWF  FE9
0388:  MOVLW  00
038A:  ADDWFC 03,W
038C:  MOVWF  FEA
038E:  MOVFF  131,FEC
0392:  MOVF   FED,F
0394:  MOVFF  130,FEF
0398:  MOVLB  0
.................... 		case I2C_REG_CH0_HVD_RECONNECT_DELAY:
.................... 			config.ch[c].hvd_reconnect_delay=value;
039A:  MOVLB  1
039C:  MOVF   x32,W
039E:  MULLW  24
03A0:  MOVF   FF3,W
03A2:  CLRF   x34
03A4:  MOVWF  x33
03A6:  MOVLW  12
03A8:  ADDWF  x33,W
03AA:  MOVWF  01
03AC:  MOVLW  00
03AE:  ADDWFC x34,W
03B0:  MOVWF  03
03B2:  MOVF   01,W
03B4:  ADDLW  1B
03B6:  MOVWF  FE9
03B8:  MOVLW  00
03BA:  ADDWFC 03,W
03BC:  MOVWF  FEA
03BE:  MOVFF  131,FEC
03C2:  MOVF   FED,F
03C4:  MOVFF  130,FEF
03C8:  MOVLB  0
.................... 
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_ADC:
.................... 			config.ch[c].ltd_disconnect_adc=value;
03CA:  MOVLB  1
03CC:  MOVF   x32,W
03CE:  MULLW  24
03D0:  MOVF   FF3,W
03D2:  CLRF   x34
03D4:  MOVWF  x33
03D6:  MOVLW  14
03D8:  ADDWF  x33,W
03DA:  MOVWF  01
03DC:  MOVLW  00
03DE:  ADDWFC x34,W
03E0:  MOVWF  03
03E2:  MOVF   01,W
03E4:  ADDLW  1B
03E6:  MOVWF  FE9
03E8:  MOVLW  00
03EA:  ADDWFC 03,W
03EC:  MOVWF  FEA
03EE:  MOVFF  131,FEC
03F2:  MOVF   FED,F
03F4:  MOVFF  130,FEF
03F8:  MOVLB  0
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_DELAY:
.................... 			config.ch[c].ltd_disconnect_delay=value;
03FA:  MOVLB  1
03FC:  MOVF   x32,W
03FE:  MULLW  24
0400:  MOVF   FF3,W
0402:  CLRF   x34
0404:  MOVWF  x33
0406:  MOVLW  16
0408:  ADDWF  x33,W
040A:  MOVWF  01
040C:  MOVLW  00
040E:  ADDWFC x34,W
0410:  MOVWF  03
0412:  MOVF   01,W
0414:  ADDLW  1B
0416:  MOVWF  FE9
0418:  MOVLW  00
041A:  ADDWFC 03,W
041C:  MOVWF  FEA
041E:  MOVFF  131,FEC
0422:  MOVF   FED,F
0424:  MOVFF  130,FEF
0428:  MOVLB  0
.................... 		case I2C_REG_CH0_LTD_RECONNECT_ADC:
.................... 			config.ch[c].ltd_reconnect_adc=value;
042A:  MOVLB  1
042C:  MOVF   x32,W
042E:  MULLW  24
0430:  MOVF   FF3,W
0432:  CLRF   x34
0434:  MOVWF  x33
0436:  MOVLW  18
0438:  ADDWF  x33,W
043A:  MOVWF  01
043C:  MOVLW  00
043E:  ADDWFC x34,W
0440:  MOVWF  03
0442:  MOVF   01,W
0444:  ADDLW  1B
0446:  MOVWF  FE9
0448:  MOVLW  00
044A:  ADDWFC 03,W
044C:  MOVWF  FEA
044E:  MOVFF  131,FEC
0452:  MOVF   FED,F
0454:  MOVFF  130,FEF
0458:  MOVLB  0
.................... 		case I2C_REG_CH0_LTD_RECONNECT_DELAY:
.................... 			config.ch[c].ltd_reconnect_delay=value;
045A:  MOVLB  1
045C:  MOVF   x32,W
045E:  MULLW  24
0460:  MOVF   FF3,W
0462:  CLRF   x34
0464:  MOVWF  x33
0466:  MOVLW  1A
0468:  ADDWF  x33,W
046A:  MOVWF  01
046C:  MOVLW  00
046E:  ADDWFC x34,W
0470:  MOVWF  03
0472:  MOVF   01,W
0474:  ADDLW  1B
0476:  MOVWF  FE9
0478:  MOVLW  00
047A:  ADDWFC 03,W
047C:  MOVWF  FEA
047E:  MOVFF  131,FEC
0482:  MOVF   FED,F
0484:  MOVFF  130,FEF
0488:  MOVLB  0
.................... 
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_ADC:
.................... 			config.ch[c].htd_disconnect_adc=value;
048A:  MOVLB  1
048C:  MOVF   x32,W
048E:  MULLW  24
0490:  MOVF   FF3,W
0492:  CLRF   x34
0494:  MOVWF  x33
0496:  MOVLW  1C
0498:  ADDWF  x33,W
049A:  MOVWF  01
049C:  MOVLW  00
049E:  ADDWFC x34,W
04A0:  MOVWF  03
04A2:  MOVF   01,W
04A4:  ADDLW  1B
04A6:  MOVWF  FE9
04A8:  MOVLW  00
04AA:  ADDWFC 03,W
04AC:  MOVWF  FEA
04AE:  MOVFF  131,FEC
04B2:  MOVF   FED,F
04B4:  MOVFF  130,FEF
04B8:  MOVLB  0
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_DELAY:
.................... 			config.ch[c].htd_disconnect_delay=value;
04BA:  MOVLB  1
04BC:  MOVF   x32,W
04BE:  MULLW  24
04C0:  MOVF   FF3,W
04C2:  CLRF   x34
04C4:  MOVWF  x33
04C6:  MOVLW  1E
04C8:  ADDWF  x33,W
04CA:  MOVWF  01
04CC:  MOVLW  00
04CE:  ADDWFC x34,W
04D0:  MOVWF  03
04D2:  MOVF   01,W
04D4:  ADDLW  1B
04D6:  MOVWF  FE9
04D8:  MOVLW  00
04DA:  ADDWFC 03,W
04DC:  MOVWF  FEA
04DE:  MOVFF  131,FEC
04E2:  MOVF   FED,F
04E4:  MOVFF  130,FEF
04E8:  MOVLB  0
.................... 		case I2C_REG_CH0_HTD_RECONNECT_ADC:
.................... 			config.ch[c].htd_reconnect_adc=value;
04EA:  MOVLB  1
04EC:  MOVF   x32,W
04EE:  MULLW  24
04F0:  MOVF   FF3,W
04F2:  CLRF   x34
04F4:  MOVWF  x33
04F6:  MOVLW  20
04F8:  ADDWF  x33,W
04FA:  MOVWF  01
04FC:  MOVLW  00
04FE:  ADDWFC x34,W
0500:  MOVWF  03
0502:  MOVF   01,W
0504:  ADDLW  1B
0506:  MOVWF  FE9
0508:  MOVLW  00
050A:  ADDWFC 03,W
050C:  MOVWF  FEA
050E:  MOVFF  131,FEC
0512:  MOVF   FED,F
0514:  MOVFF  130,FEF
0518:  MOVLB  0
.................... 		case I2C_REG_CH0_HTD_RECONNECT_DELAY:
.................... 			config.ch[c].htd_reconnect_delay=value;
051A:  MOVLB  1
051C:  MOVF   x32,W
051E:  MULLW  24
0520:  MOVF   FF3,W
0522:  CLRF   x34
0524:  MOVWF  x33
0526:  MOVLW  22
0528:  ADDWF  x33,W
052A:  MOVWF  01
052C:  MOVLW  00
052E:  ADDWFC x34,W
0530:  MOVWF  03
0532:  MOVF   01,W
0534:  ADDLW  1B
0536:  MOVWF  FE9
0538:  MOVLW  00
053A:  ADDWFC 03,W
053C:  MOVWF  FEA
053E:  MOVFF  131,FEC
0542:  MOVF   FED,F
0544:  MOVFF  130,FEF
0548:  MOVLB  0
.................... 
.................... 		/* don't need to implement FUT ... there is nowhere for it to go anyhow */
.................... 
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			if ( 1 == value ) {
054A:  MOVLB  1
054C:  DECFSZ x30,W
054E:  BRA    055C
0550:  MOVF   x31,F
0552:  BNZ   055C
.................... 				timers.now_write_config=1;
0554:  MOVLB  0
0556:  BSF    xCF.3
.................... 			} else if ( 2 == value ) {
0558:  BRA    0590
055A:  MOVLB  1
055C:  MOVF   x30,W
055E:  SUBLW  02
0560:  BNZ   056E
0562:  MOVF   x31,F
0564:  BNZ   056E
.................... 				timers.now_reset_config=1;
0566:  MOVLB  0
0568:  BSF    xCF.4
.................... 			} else if ( 1802 == value ) {
056A:  BRA    0590
056C:  MOVLB  1
056E:  MOVF   x30,W
0570:  SUBLW  0A
0572:  BNZ   0584
0574:  MOVF   x31,W
0576:  SUBLW  07
0578:  BNZ   0584
.................... 				current.factory_unlocked =1;
057A:  MOVLW  01
057C:  MOVLB  0
057E:  MOVWF  xCA
.................... 			} else if ( 65535 == value ) {
0580:  BRA    0590
0582:  MOVLB  1
0584:  INCFSZ x30,W
0586:  BRA    058E
0588:  INCFSZ x31,W
058A:  BRA    058E
.................... 				reset_cpu();
058C:  RESET
058E:  MOVLB  0
.................... 			}
.................... 			break;
.................... 		default:
.................... 			/* do nothing */
.................... 	}
0590:  GOTO   0F14 (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... int16 map_i2c(int8 addr) {
.................... 	int8 c;
.................... 
.................... 	/* c is the channel we are accessing based on register range */
.................... 	if ( addr >= I2C_REG_CH1_COMMAND_ON && addr <= I2C_REG_CH1_FUT_RECONNECT ) {
*
0614:  MOVLB  1
0616:  MOVF   x2D,W
0618:  SUBLW  10
061A:  BC    062C
061C:  MOVF   x2D,W
061E:  SUBLW  1E
0620:  BNC   062C
.................... 		/* channel 1 status region */
.................... 		c=1;
0622:  MOVLW  01
0624:  MOVWF  x2E
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON - I2C_REG_CH0_COMMAND_ON);
0626:  MOVLW  0E
0628:  SUBWF  x2D,F
.................... 	} else if ( addr >= I2C_REG_CH1_COMMAND_ON_HOLD && addr <= I2C_REG_CH1_FUT_RECONNECT_DELAY ) {
062A:  BRA    0644
062C:  MOVF   x2D,W
062E:  SUBLW  11
0630:  BC    0642
0632:  MOVF   x2D,W
0634:  SUBLW  6B
0636:  BNC   0642
.................... 		/* channel 1 configuration region */
.................... 		c=1;
0638:  MOVLW  01
063A:  MOVWF  x2E
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON_HOLD - I2C_REG_CH0_COMMAND_ON_HOLD );
063C:  MOVLW  0E
063E:  SUBWF  x2D,F
.................... 	} else {
0640:  BRA    0644
.................... 		c=0;
0642:  CLRF   x2E
.................... 	}
.................... 
.................... 	switch ( addr ) {
0644:  MOVF   x2D,W
0646:  XORLW  00
0648:  MOVLB  0
064A:  BTFSC  FD8.2
064C:  BRA    077C
064E:  XORLW  01
0650:  BTFSC  FD8.2
0652:  BRA    0788
0654:  XORLW  03
0656:  BTFSC  FD8.2
0658:  BRA    0796
065A:  XORLW  01
065C:  BTFSC  FD8.2
065E:  BRA    07A4
0660:  XORLW  07
0662:  BTFSC  FD8.2
0664:  BRA    07DA
0666:  XORLW  01
0668:  BTFSC  FD8.2
066A:  BRA    0810
066C:  XORLW  03
066E:  BTFSC  FD8.2
0670:  BRA    0846
0672:  XORLW  01
0674:  BTFSC  FD8.2
0676:  BRA    087C
0678:  XORLW  0F
067A:  BTFSC  FD8.2
067C:  BRA    08B2
067E:  XORLW  01
0680:  BTFSC  FD8.2
0682:  BRA    08E8
0684:  XORLW  03
0686:  BTFSC  FD8.2
0688:  BRA    091E
068A:  XORLW  01
068C:  BTFSC  FD8.2
068E:  BRA    0954
0690:  XORLW  07
0692:  BTFSC  FD8.2
0694:  BRA    098A
0696:  XORLW  01
0698:  BTFSC  FD8.2
069A:  BRA    09C0
069C:  XORLW  03
069E:  BTFSC  FD8.2
06A0:  BRA    09F6
06A2:  XORLW  01
06A4:  BTFSC  FD8.2
06A6:  BRA    0A2C
06A8:  XORLW  1F
06AA:  BTFSC  FD8.2
06AC:  BRA    0A2C
06AE:  XORLW  0F
06B0:  BTFSC  FD8.2
06B2:  BRA    0A34
06B4:  XORLW  3F
06B6:  BTFSC  FD8.2
06B8:  BRA    0A3E
06BA:  XORLW  01
06BC:  BTFSC  FD8.2
06BE:  BRA    0A48
06C0:  XORLW  03
06C2:  BTFSC  FD8.2
06C4:  BRA    0A52
06C6:  XORLW  62
06C8:  BTFSC  FD8.2
06CA:  BRA    0A5A
06CC:  XORLW  01
06CE:  BTFSC  FD8.2
06D0:  BRA    0A84
06D2:  XORLW  03
06D4:  BTFSC  FD8.2
06D6:  BRA    0ABA
06D8:  XORLW  01
06DA:  BTFSC  FD8.2
06DC:  BRA    0AF0
06DE:  XORLW  07
06E0:  BTFSC  FD8.2
06E2:  BRA    0B26
06E4:  XORLW  01
06E6:  BTFSC  FD8.2
06E8:  BRA    0B5C
06EA:  XORLW  03
06EC:  BTFSC  FD8.2
06EE:  BRA    0B92
06F0:  XORLW  01
06F2:  BTFSC  FD8.2
06F4:  BRA    0BC8
06F6:  XORLW  0F
06F8:  BTFSC  FD8.2
06FA:  BRA    0BFE
06FC:  XORLW  01
06FE:  BTFSC  FD8.2
0700:  BRA    0C34
0702:  XORLW  03
0704:  BTFSC  FD8.2
0706:  BRA    0C6A
0708:  XORLW  01
070A:  BTFSC  FD8.2
070C:  BRA    0CA0
070E:  XORLW  07
0710:  BTFSC  FD8.2
0712:  BRA    0CD6
0714:  XORLW  01
0716:  BTFSC  FD8.2
0718:  BRA    0D0C
071A:  XORLW  03
071C:  BTFSC  FD8.2
071E:  BRA    0D42
0720:  XORLW  01
0722:  BTFSC  FD8.2
0724:  BRA    0D78
0726:  XORLW  1F
0728:  BTFSC  FD8.2
072A:  BRA    0DAE
072C:  XORLW  01
072E:  BTFSC  FD8.2
0730:  BRA    0DE4
0732:  XORLW  03
0734:  BTFSC  FD8.2
0736:  BRA    0E1A
0738:  XORLW  01
073A:  BTFSC  FD8.2
073C:  BRA    0E1A
073E:  XORLW  07
0740:  BTFSC  FD8.2
0742:  BRA    0E1A
0744:  XORLW  01
0746:  BTFSC  FD8.2
0748:  BRA    0E1A
074A:  XORLW  D5
074C:  BTFSC  FD8.2
074E:  BRA    0E22
0750:  XORLW  01
0752:  BTFSC  FD8.2
0754:  BRA    0E2C
0756:  XORLW  03
0758:  BTFSC  FD8.2
075A:  BRA    0E36
075C:  XORLW  01
075E:  BTFSC  FD8.2
0760:  BRA    0E40
0762:  XORLW  07
0764:  BTFSC  FD8.2
0766:  BRA    0E4A
0768:  XORLW  01
076A:  BTFSC  FD8.2
076C:  BRA    0E52
076E:  XORLW  03
0770:  BTFSC  FD8.2
0772:  BRA    0E5A
0774:  XORLW  01
0776:  BTFSC  FD8.2
0778:  BRA    0E62
077A:  BRA    0E6A
.................... 		/* not channel based */
.................... 		case I2C_REG_VOLTAGE_INPUT_AVG: 
.................... 			return (int16) adc_get(0);
077C:  MOVLB  1
077E:  CLRF   x2F
0780:  MOVLB  0
0782:  RCALL  0594
0784:  MOVF   02,W
0786:  BRA    0E70
.................... 		case I2C_REG_STATE_CONTACTORS:
.................... 			return (int16) make16(channel[0].state,channel[1].state);
0788:  MOVFF  DA,03
078C:  MOVFF  F3,01
0790:  MOVFF  DA,02
0794:  BRA    0E70
.................... 		case I2C_REG_TEMPERATURE_BOARD_AVG: 
.................... 			return (int16) adc_get(1);
0796:  MOVLW  01
0798:  MOVLB  1
079A:  MOVWF  x2F
079C:  MOVLB  0
079E:  RCALL  0594
07A0:  MOVF   02,W
07A2:  BRA    0E70
.................... 
.................... 		/* status based on channel value c */
.................... 		case I2C_REG_CH0_COMMAND_ON :
.................... 			return (int16) channel[c].command_on_seconds;
07A4:  MOVLB  1
07A6:  MOVF   x2E,W
07A8:  MULLW  19
07AA:  MOVF   FF3,W
07AC:  CLRF   x30
07AE:  MOVWF  x2F
07B0:  MOVLW  01
07B2:  ADDWF  x2F,W
07B4:  MOVWF  01
07B6:  MOVLW  00
07B8:  ADDWFC x30,W
07BA:  MOVWF  03
07BC:  MOVF   01,W
07BE:  ADDLW  DA
07C0:  MOVWF  FE9
07C2:  MOVLW  00
07C4:  ADDWFC 03,W
07C6:  MOVWF  FEA
07C8:  MOVFF  FEC,03
07CC:  MOVF   FED,F
07CE:  MOVFF  FEF,01
07D2:  MOVFF  03,02
07D6:  MOVLB  0
07D8:  BRA    0E70
.................... 		case I2C_REG_CH0_COMMAND_ON_HOLD:
.................... 			return (int16) channel[c].command_on_hold_seconds;
07DA:  MOVLB  1
07DC:  MOVF   x2E,W
07DE:  MULLW  19
07E0:  MOVF   FF3,W
07E2:  CLRF   x30
07E4:  MOVWF  x2F
07E6:  MOVLW  03
07E8:  ADDWF  x2F,W
07EA:  MOVWF  01
07EC:  MOVLW  00
07EE:  ADDWFC x30,W
07F0:  MOVWF  03
07F2:  MOVF   01,W
07F4:  ADDLW  DA
07F6:  MOVWF  FE9
07F8:  MOVLW  00
07FA:  ADDWFC 03,W
07FC:  MOVWF  FEA
07FE:  MOVFF  FEC,03
0802:  MOVF   FED,F
0804:  MOVFF  FEF,01
0808:  MOVFF  03,02
080C:  MOVLB  0
080E:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_COMMAND_OFF:
.................... 			return (int16) channel[c].command_off_seconds;
0810:  MOVLB  1
0812:  MOVF   x2E,W
0814:  MULLW  19
0816:  MOVF   FF3,W
0818:  CLRF   x30
081A:  MOVWF  x2F
081C:  MOVLW  05
081E:  ADDWF  x2F,W
0820:  MOVWF  01
0822:  MOVLW  00
0824:  ADDWFC x30,W
0826:  MOVWF  03
0828:  MOVF   01,W
082A:  ADDLW  DA
082C:  MOVWF  FE9
082E:  MOVLW  00
0830:  ADDWFC 03,W
0832:  MOVWF  FEA
0834:  MOVFF  FEC,03
0838:  MOVF   FED,F
083A:  MOVFF  FEF,01
083E:  MOVFF  03,02
0842:  MOVLB  0
0844:  BRA    0E70
.................... 		case I2C_REG_CH0_COMMAND_OFF_HOLD:
.................... 			return (int16) channel[c].command_off_hold_seconds;
0846:  MOVLB  1
0848:  MOVF   x2E,W
084A:  MULLW  19
084C:  MOVF   FF3,W
084E:  CLRF   x30
0850:  MOVWF  x2F
0852:  MOVLW  07
0854:  ADDWF  x2F,W
0856:  MOVWF  01
0858:  MOVLW  00
085A:  ADDWFC x30,W
085C:  MOVWF  03
085E:  MOVF   01,W
0860:  ADDLW  DA
0862:  MOVWF  FE9
0864:  MOVLW  00
0866:  ADDWFC 03,W
0868:  MOVWF  FEA
086A:  MOVFF  FEC,03
086E:  MOVF   FED,F
0870:  MOVFF  FEF,01
0874:  MOVFF  03,02
0878:  MOVLB  0
087A:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_LVD_DISCONNECT:
.................... 			return (int16) channel[c].lvd_disconnect_delay_seconds;
087C:  MOVLB  1
087E:  MOVF   x2E,W
0880:  MULLW  19
0882:  MOVF   FF3,W
0884:  CLRF   x30
0886:  MOVWF  x2F
0888:  MOVLW  09
088A:  ADDWF  x2F,W
088C:  MOVWF  01
088E:  MOVLW  00
0890:  ADDWFC x30,W
0892:  MOVWF  03
0894:  MOVF   01,W
0896:  ADDLW  DA
0898:  MOVWF  FE9
089A:  MOVLW  00
089C:  ADDWFC 03,W
089E:  MOVWF  FEA
08A0:  MOVFF  FEC,03
08A4:  MOVF   FED,F
08A6:  MOVFF  FEF,01
08AA:  MOVFF  03,02
08AE:  MOVLB  0
08B0:  BRA    0E70
.................... 		case I2C_REG_CH0_LVD_RECONNECT:
.................... 			return (int16) channel[c].lvd_reconnect_delay_seconds;
08B2:  MOVLB  1
08B4:  MOVF   x2E,W
08B6:  MULLW  19
08B8:  MOVF   FF3,W
08BA:  CLRF   x30
08BC:  MOVWF  x2F
08BE:  MOVLW  0B
08C0:  ADDWF  x2F,W
08C2:  MOVWF  01
08C4:  MOVLW  00
08C6:  ADDWFC x30,W
08C8:  MOVWF  03
08CA:  MOVF   01,W
08CC:  ADDLW  DA
08CE:  MOVWF  FE9
08D0:  MOVLW  00
08D2:  ADDWFC 03,W
08D4:  MOVWF  FEA
08D6:  MOVFF  FEC,03
08DA:  MOVF   FED,F
08DC:  MOVFF  FEF,01
08E0:  MOVFF  03,02
08E4:  MOVLB  0
08E6:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_HVD_DISCONNECT:
.................... 			return (int16) channel[c].hvd_disconnect_delay_seconds;
08E8:  MOVLB  1
08EA:  MOVF   x2E,W
08EC:  MULLW  19
08EE:  MOVF   FF3,W
08F0:  CLRF   x30
08F2:  MOVWF  x2F
08F4:  MOVLW  0D
08F6:  ADDWF  x2F,W
08F8:  MOVWF  01
08FA:  MOVLW  00
08FC:  ADDWFC x30,W
08FE:  MOVWF  03
0900:  MOVF   01,W
0902:  ADDLW  DA
0904:  MOVWF  FE9
0906:  MOVLW  00
0908:  ADDWFC 03,W
090A:  MOVWF  FEA
090C:  MOVFF  FEC,03
0910:  MOVF   FED,F
0912:  MOVFF  FEF,01
0916:  MOVFF  03,02
091A:  MOVLB  0
091C:  BRA    0E70
.................... 		case I2C_REG_CH0_HVD_RECONNECT:
.................... 			return (int16) channel[c].hvd_reconnect_delay_seconds;
091E:  MOVLB  1
0920:  MOVF   x2E,W
0922:  MULLW  19
0924:  MOVF   FF3,W
0926:  CLRF   x30
0928:  MOVWF  x2F
092A:  MOVLW  0F
092C:  ADDWF  x2F,W
092E:  MOVWF  01
0930:  MOVLW  00
0932:  ADDWFC x30,W
0934:  MOVWF  03
0936:  MOVF   01,W
0938:  ADDLW  DA
093A:  MOVWF  FE9
093C:  MOVLW  00
093E:  ADDWFC 03,W
0940:  MOVWF  FEA
0942:  MOVFF  FEC,03
0946:  MOVF   FED,F
0948:  MOVFF  FEF,01
094C:  MOVFF  03,02
0950:  MOVLB  0
0952:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_LTD_DISCONNECT:
.................... 			return (int16) channel[c].ltd_disconnect_delay_seconds;
0954:  MOVLB  1
0956:  MOVF   x2E,W
0958:  MULLW  19
095A:  MOVF   FF3,W
095C:  CLRF   x30
095E:  MOVWF  x2F
0960:  MOVLW  11
0962:  ADDWF  x2F,W
0964:  MOVWF  01
0966:  MOVLW  00
0968:  ADDWFC x30,W
096A:  MOVWF  03
096C:  MOVF   01,W
096E:  ADDLW  DA
0970:  MOVWF  FE9
0972:  MOVLW  00
0974:  ADDWFC 03,W
0976:  MOVWF  FEA
0978:  MOVFF  FEC,03
097C:  MOVF   FED,F
097E:  MOVFF  FEF,01
0982:  MOVFF  03,02
0986:  MOVLB  0
0988:  BRA    0E70
.................... 		case I2C_REG_CH0_LTD_RECONNECT:
.................... 			return (int16) channel[c].ltd_reconnect_delay_seconds;
098A:  MOVLB  1
098C:  MOVF   x2E,W
098E:  MULLW  19
0990:  MOVF   FF3,W
0992:  CLRF   x30
0994:  MOVWF  x2F
0996:  MOVLW  13
0998:  ADDWF  x2F,W
099A:  MOVWF  01
099C:  MOVLW  00
099E:  ADDWFC x30,W
09A0:  MOVWF  03
09A2:  MOVF   01,W
09A4:  ADDLW  DA
09A6:  MOVWF  FE9
09A8:  MOVLW  00
09AA:  ADDWFC 03,W
09AC:  MOVWF  FEA
09AE:  MOVFF  FEC,03
09B2:  MOVF   FED,F
09B4:  MOVFF  FEF,01
09B8:  MOVFF  03,02
09BC:  MOVLB  0
09BE:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_HTD_DISCONNECT:
.................... 			return (int16) channel[c].htd_disconnect_delay_seconds;
09C0:  MOVLB  1
09C2:  MOVF   x2E,W
09C4:  MULLW  19
09C6:  MOVF   FF3,W
09C8:  CLRF   x30
09CA:  MOVWF  x2F
09CC:  MOVLW  15
09CE:  ADDWF  x2F,W
09D0:  MOVWF  01
09D2:  MOVLW  00
09D4:  ADDWFC x30,W
09D6:  MOVWF  03
09D8:  MOVF   01,W
09DA:  ADDLW  DA
09DC:  MOVWF  FE9
09DE:  MOVLW  00
09E0:  ADDWFC 03,W
09E2:  MOVWF  FEA
09E4:  MOVFF  FEC,03
09E8:  MOVF   FED,F
09EA:  MOVFF  FEF,01
09EE:  MOVFF  03,02
09F2:  MOVLB  0
09F4:  BRA    0E70
.................... 		case I2C_REG_CH0_HTD_RECONNECT:
.................... 			return (int16) channel[c].htd_reconnect_delay_seconds;
09F6:  MOVLB  1
09F8:  MOVF   x2E,W
09FA:  MULLW  19
09FC:  MOVF   FF3,W
09FE:  CLRF   x30
0A00:  MOVWF  x2F
0A02:  MOVLW  17
0A04:  ADDWF  x2F,W
0A06:  MOVWF  01
0A08:  MOVLW  00
0A0A:  ADDWFC x30,W
0A0C:  MOVWF  03
0A0E:  MOVF   01,W
0A10:  ADDLW  DA
0A12:  MOVWF  FE9
0A14:  MOVLW  00
0A16:  ADDWFC 03,W
0A18:  MOVWF  FEA
0A1A:  MOVFF  FEC,03
0A1E:  MOVF   FED,F
0A20:  MOVFF  FEF,01
0A24:  MOVFF  03,02
0A28:  MOVLB  0
0A2A:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_FUT_DISCONNECT:
.................... 		case I2C_REG_CH0_FUT_RECONNECT:
.................... 			return (int16) 0xffff; /* not yet implemented */
0A2C:  MOVLW  FF
0A2E:  MOVWF  01
0A30:  MOVWF  02
0A32:  BRA    0E70
.................... 
.................... 
.................... 		/* non-channel based meta */
.................... 		case I2C_REG_SEQUENCE_NUMBER:
.................... 			return (int16) current.sequence_number;
0A34:  MOVFF  C4,01
0A38:  MOVFF  C5,02
0A3C:  BRA    0E70
.................... 		case I2C_REG_TIME_INTERVAL_MILLISECONDS:
.................... 			return (int16) current.interval_milliseconds;
0A3E:  MOVFF  C8,01
0A42:  MOVFF  C9,02
0A46:  BRA    0E70
.................... 		case I2C_REG_TIME_UPTIME_MINUTES:
.................... 			return (int16) current.uptime_minutes;
0A48:  MOVFF  C6,01
0A4C:  MOVFF  C7,02
0A50:  BRA    0E70
.................... 		case I2C_REG_DEFAULT_PARAMS_WRITTEN:
.................... 			return (int16) current.default_params_written;
0A52:  MOVFF  CE,01
0A56:  CLRF   02
0A58:  BRA    0E70
.................... 
.................... 		/* channel based configuration */
.................... 		case I2C_REG_CH0_COMMAND_ON_HOLD_INITIAL:
.................... 			return (int16) config.ch[c].command_on_hold_time;
0A5A:  MOVLB  1
0A5C:  MOVF   x2E,W
0A5E:  MULLW  24
0A60:  MOVF   FF3,W
0A62:  CLRF   x30
0A64:  MOVWF  x2F
0A66:  MOVLW  1B
0A68:  ADDWF  x2F,W
0A6A:  MOVWF  FE9
0A6C:  MOVLW  00
0A6E:  ADDWFC x30,W
0A70:  MOVWF  FEA
0A72:  MOVFF  FEC,03
0A76:  MOVF   FED,F
0A78:  MOVFF  FEF,01
0A7C:  MOVFF  03,02
0A80:  MOVLB  0
0A82:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_COMMAND_OFF_HOLD_INITIAL:
.................... 			return (int16) config.ch[c].command_off_hold_time;
0A84:  MOVLB  1
0A86:  MOVF   x2E,W
0A88:  MULLW  24
0A8A:  MOVF   FF3,W
0A8C:  CLRF   x30
0A8E:  MOVWF  x2F
0A90:  MOVLW  02
0A92:  ADDWF  x2F,W
0A94:  MOVWF  01
0A96:  MOVLW  00
0A98:  ADDWFC x30,W
0A9A:  MOVWF  03
0A9C:  MOVF   01,W
0A9E:  ADDLW  1B
0AA0:  MOVWF  FE9
0AA2:  MOVLW  00
0AA4:  ADDWFC 03,W
0AA6:  MOVWF  FEA
0AA8:  MOVFF  FEC,03
0AAC:  MOVF   FED,F
0AAE:  MOVFF  FEF,01
0AB2:  MOVFF  03,02
0AB6:  MOVLB  0
0AB8:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].lvd_disconnect_adc;
0ABA:  MOVLB  1
0ABC:  MOVF   x2E,W
0ABE:  MULLW  24
0AC0:  MOVF   FF3,W
0AC2:  CLRF   x30
0AC4:  MOVWF  x2F
0AC6:  MOVLW  04
0AC8:  ADDWF  x2F,W
0ACA:  MOVWF  01
0ACC:  MOVLW  00
0ACE:  ADDWFC x30,W
0AD0:  MOVWF  03
0AD2:  MOVF   01,W
0AD4:  ADDLW  1B
0AD6:  MOVWF  FE9
0AD8:  MOVLW  00
0ADA:  ADDWFC 03,W
0ADC:  MOVWF  FEA
0ADE:  MOVFF  FEC,03
0AE2:  MOVF   FED,F
0AE4:  MOVFF  FEF,01
0AE8:  MOVFF  03,02
0AEC:  MOVLB  0
0AEE:  BRA    0E70
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].lvd_disconnect_delay;
0AF0:  MOVLB  1
0AF2:  MOVF   x2E,W
0AF4:  MULLW  24
0AF6:  MOVF   FF3,W
0AF8:  CLRF   x30
0AFA:  MOVWF  x2F
0AFC:  MOVLW  06
0AFE:  ADDWF  x2F,W
0B00:  MOVWF  01
0B02:  MOVLW  00
0B04:  ADDWFC x30,W
0B06:  MOVWF  03
0B08:  MOVF   01,W
0B0A:  ADDLW  1B
0B0C:  MOVWF  FE9
0B0E:  MOVLW  00
0B10:  ADDWFC 03,W
0B12:  MOVWF  FEA
0B14:  MOVFF  FEC,03
0B18:  MOVF   FED,F
0B1A:  MOVFF  FEF,01
0B1E:  MOVFF  03,02
0B22:  MOVLB  0
0B24:  BRA    0E70
.................... 		case I2C_REG_CH0_LVD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].lvd_reconnect_adc;
0B26:  MOVLB  1
0B28:  MOVF   x2E,W
0B2A:  MULLW  24
0B2C:  MOVF   FF3,W
0B2E:  CLRF   x30
0B30:  MOVWF  x2F
0B32:  MOVLW  08
0B34:  ADDWF  x2F,W
0B36:  MOVWF  01
0B38:  MOVLW  00
0B3A:  ADDWFC x30,W
0B3C:  MOVWF  03
0B3E:  MOVF   01,W
0B40:  ADDLW  1B
0B42:  MOVWF  FE9
0B44:  MOVLW  00
0B46:  ADDWFC 03,W
0B48:  MOVWF  FEA
0B4A:  MOVFF  FEC,03
0B4E:  MOVF   FED,F
0B50:  MOVFF  FEF,01
0B54:  MOVFF  03,02
0B58:  MOVLB  0
0B5A:  BRA    0E70
.................... 		case I2C_REG_CH0_LVD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].lvd_reconnect_delay;
0B5C:  MOVLB  1
0B5E:  MOVF   x2E,W
0B60:  MULLW  24
0B62:  MOVF   FF3,W
0B64:  CLRF   x30
0B66:  MOVWF  x2F
0B68:  MOVLW  0A
0B6A:  ADDWF  x2F,W
0B6C:  MOVWF  01
0B6E:  MOVLW  00
0B70:  ADDWFC x30,W
0B72:  MOVWF  03
0B74:  MOVF   01,W
0B76:  ADDLW  1B
0B78:  MOVWF  FE9
0B7A:  MOVLW  00
0B7C:  ADDWFC 03,W
0B7E:  MOVWF  FEA
0B80:  MOVFF  FEC,03
0B84:  MOVF   FED,F
0B86:  MOVFF  FEF,01
0B8A:  MOVFF  03,02
0B8E:  MOVLB  0
0B90:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].hvd_disconnect_adc;
0B92:  MOVLB  1
0B94:  MOVF   x2E,W
0B96:  MULLW  24
0B98:  MOVF   FF3,W
0B9A:  CLRF   x30
0B9C:  MOVWF  x2F
0B9E:  MOVLW  0C
0BA0:  ADDWF  x2F,W
0BA2:  MOVWF  01
0BA4:  MOVLW  00
0BA6:  ADDWFC x30,W
0BA8:  MOVWF  03
0BAA:  MOVF   01,W
0BAC:  ADDLW  1B
0BAE:  MOVWF  FE9
0BB0:  MOVLW  00
0BB2:  ADDWFC 03,W
0BB4:  MOVWF  FEA
0BB6:  MOVFF  FEC,03
0BBA:  MOVF   FED,F
0BBC:  MOVFF  FEF,01
0BC0:  MOVFF  03,02
0BC4:  MOVLB  0
0BC6:  BRA    0E70
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].hvd_disconnect_delay;
0BC8:  MOVLB  1
0BCA:  MOVF   x2E,W
0BCC:  MULLW  24
0BCE:  MOVF   FF3,W
0BD0:  CLRF   x30
0BD2:  MOVWF  x2F
0BD4:  MOVLW  0E
0BD6:  ADDWF  x2F,W
0BD8:  MOVWF  01
0BDA:  MOVLW  00
0BDC:  ADDWFC x30,W
0BDE:  MOVWF  03
0BE0:  MOVF   01,W
0BE2:  ADDLW  1B
0BE4:  MOVWF  FE9
0BE6:  MOVLW  00
0BE8:  ADDWFC 03,W
0BEA:  MOVWF  FEA
0BEC:  MOVFF  FEC,03
0BF0:  MOVF   FED,F
0BF2:  MOVFF  FEF,01
0BF6:  MOVFF  03,02
0BFA:  MOVLB  0
0BFC:  BRA    0E70
.................... 		case I2C_REG_CH0_HVD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].hvd_reconnect_adc;
0BFE:  MOVLB  1
0C00:  MOVF   x2E,W
0C02:  MULLW  24
0C04:  MOVF   FF3,W
0C06:  CLRF   x30
0C08:  MOVWF  x2F
0C0A:  MOVLW  10
0C0C:  ADDWF  x2F,W
0C0E:  MOVWF  01
0C10:  MOVLW  00
0C12:  ADDWFC x30,W
0C14:  MOVWF  03
0C16:  MOVF   01,W
0C18:  ADDLW  1B
0C1A:  MOVWF  FE9
0C1C:  MOVLW  00
0C1E:  ADDWFC 03,W
0C20:  MOVWF  FEA
0C22:  MOVFF  FEC,03
0C26:  MOVF   FED,F
0C28:  MOVFF  FEF,01
0C2C:  MOVFF  03,02
0C30:  MOVLB  0
0C32:  BRA    0E70
.................... 		case I2C_REG_CH0_HVD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].hvd_reconnect_delay;
0C34:  MOVLB  1
0C36:  MOVF   x2E,W
0C38:  MULLW  24
0C3A:  MOVF   FF3,W
0C3C:  CLRF   x30
0C3E:  MOVWF  x2F
0C40:  MOVLW  12
0C42:  ADDWF  x2F,W
0C44:  MOVWF  01
0C46:  MOVLW  00
0C48:  ADDWFC x30,W
0C4A:  MOVWF  03
0C4C:  MOVF   01,W
0C4E:  ADDLW  1B
0C50:  MOVWF  FE9
0C52:  MOVLW  00
0C54:  ADDWFC 03,W
0C56:  MOVWF  FEA
0C58:  MOVFF  FEC,03
0C5C:  MOVF   FED,F
0C5E:  MOVFF  FEF,01
0C62:  MOVFF  03,02
0C66:  MOVLB  0
0C68:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_disconnect_adc;
0C6A:  MOVLB  1
0C6C:  MOVF   x2E,W
0C6E:  MULLW  24
0C70:  MOVF   FF3,W
0C72:  CLRF   x30
0C74:  MOVWF  x2F
0C76:  MOVLW  14
0C78:  ADDWF  x2F,W
0C7A:  MOVWF  01
0C7C:  MOVLW  00
0C7E:  ADDWFC x30,W
0C80:  MOVWF  03
0C82:  MOVF   01,W
0C84:  ADDLW  1B
0C86:  MOVWF  FE9
0C88:  MOVLW  00
0C8A:  ADDWFC 03,W
0C8C:  MOVWF  FEA
0C8E:  MOVFF  FEC,03
0C92:  MOVF   FED,F
0C94:  MOVFF  FEF,01
0C98:  MOVFF  03,02
0C9C:  MOVLB  0
0C9E:  BRA    0E70
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_disconnect_delay;
0CA0:  MOVLB  1
0CA2:  MOVF   x2E,W
0CA4:  MULLW  24
0CA6:  MOVF   FF3,W
0CA8:  CLRF   x30
0CAA:  MOVWF  x2F
0CAC:  MOVLW  16
0CAE:  ADDWF  x2F,W
0CB0:  MOVWF  01
0CB2:  MOVLW  00
0CB4:  ADDWFC x30,W
0CB6:  MOVWF  03
0CB8:  MOVF   01,W
0CBA:  ADDLW  1B
0CBC:  MOVWF  FE9
0CBE:  MOVLW  00
0CC0:  ADDWFC 03,W
0CC2:  MOVWF  FEA
0CC4:  MOVFF  FEC,03
0CC8:  MOVF   FED,F
0CCA:  MOVFF  FEF,01
0CCE:  MOVFF  03,02
0CD2:  MOVLB  0
0CD4:  BRA    0E70
.................... 		case I2C_REG_CH0_LTD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_reconnect_adc;
0CD6:  MOVLB  1
0CD8:  MOVF   x2E,W
0CDA:  MULLW  24
0CDC:  MOVF   FF3,W
0CDE:  CLRF   x30
0CE0:  MOVWF  x2F
0CE2:  MOVLW  18
0CE4:  ADDWF  x2F,W
0CE6:  MOVWF  01
0CE8:  MOVLW  00
0CEA:  ADDWFC x30,W
0CEC:  MOVWF  03
0CEE:  MOVF   01,W
0CF0:  ADDLW  1B
0CF2:  MOVWF  FE9
0CF4:  MOVLW  00
0CF6:  ADDWFC 03,W
0CF8:  MOVWF  FEA
0CFA:  MOVFF  FEC,03
0CFE:  MOVF   FED,F
0D00:  MOVFF  FEF,01
0D04:  MOVFF  03,02
0D08:  MOVLB  0
0D0A:  BRA    0E70
.................... 		case I2C_REG_CH0_LTD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_reconnect_delay;
0D0C:  MOVLB  1
0D0E:  MOVF   x2E,W
0D10:  MULLW  24
0D12:  MOVF   FF3,W
0D14:  CLRF   x30
0D16:  MOVWF  x2F
0D18:  MOVLW  1A
0D1A:  ADDWF  x2F,W
0D1C:  MOVWF  01
0D1E:  MOVLW  00
0D20:  ADDWFC x30,W
0D22:  MOVWF  03
0D24:  MOVF   01,W
0D26:  ADDLW  1B
0D28:  MOVWF  FE9
0D2A:  MOVLW  00
0D2C:  ADDWFC 03,W
0D2E:  MOVWF  FEA
0D30:  MOVFF  FEC,03
0D34:  MOVF   FED,F
0D36:  MOVFF  FEF,01
0D3A:  MOVFF  03,02
0D3E:  MOVLB  0
0D40:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_disconnect_adc;
0D42:  MOVLB  1
0D44:  MOVF   x2E,W
0D46:  MULLW  24
0D48:  MOVF   FF3,W
0D4A:  CLRF   x30
0D4C:  MOVWF  x2F
0D4E:  MOVLW  14
0D50:  ADDWF  x2F,W
0D52:  MOVWF  01
0D54:  MOVLW  00
0D56:  ADDWFC x30,W
0D58:  MOVWF  03
0D5A:  MOVF   01,W
0D5C:  ADDLW  1B
0D5E:  MOVWF  FE9
0D60:  MOVLW  00
0D62:  ADDWFC 03,W
0D64:  MOVWF  FEA
0D66:  MOVFF  FEC,03
0D6A:  MOVF   FED,F
0D6C:  MOVFF  FEF,01
0D70:  MOVFF  03,02
0D74:  MOVLB  0
0D76:  BRA    0E70
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_disconnect_delay;
0D78:  MOVLB  1
0D7A:  MOVF   x2E,W
0D7C:  MULLW  24
0D7E:  MOVF   FF3,W
0D80:  CLRF   x30
0D82:  MOVWF  x2F
0D84:  MOVLW  16
0D86:  ADDWF  x2F,W
0D88:  MOVWF  01
0D8A:  MOVLW  00
0D8C:  ADDWFC x30,W
0D8E:  MOVWF  03
0D90:  MOVF   01,W
0D92:  ADDLW  1B
0D94:  MOVWF  FE9
0D96:  MOVLW  00
0D98:  ADDWFC 03,W
0D9A:  MOVWF  FEA
0D9C:  MOVFF  FEC,03
0DA0:  MOVF   FED,F
0DA2:  MOVFF  FEF,01
0DA6:  MOVFF  03,02
0DAA:  MOVLB  0
0DAC:  BRA    0E70
.................... 		case I2C_REG_CH0_HTD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_reconnect_adc;
0DAE:  MOVLB  1
0DB0:  MOVF   x2E,W
0DB2:  MULLW  24
0DB4:  MOVF   FF3,W
0DB6:  CLRF   x30
0DB8:  MOVWF  x2F
0DBA:  MOVLW  18
0DBC:  ADDWF  x2F,W
0DBE:  MOVWF  01
0DC0:  MOVLW  00
0DC2:  ADDWFC x30,W
0DC4:  MOVWF  03
0DC6:  MOVF   01,W
0DC8:  ADDLW  1B
0DCA:  MOVWF  FE9
0DCC:  MOVLW  00
0DCE:  ADDWFC 03,W
0DD0:  MOVWF  FEA
0DD2:  MOVFF  FEC,03
0DD6:  MOVF   FED,F
0DD8:  MOVFF  FEF,01
0DDC:  MOVFF  03,02
0DE0:  MOVLB  0
0DE2:  BRA    0E70
.................... 		case I2C_REG_CH0_HTD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_reconnect_delay;	
0DE4:  MOVLB  1
0DE6:  MOVF   x2E,W
0DE8:  MULLW  24
0DEA:  MOVF   FF3,W
0DEC:  CLRF   x30
0DEE:  MOVWF  x2F
0DF0:  MOVLW  1A
0DF2:  ADDWF  x2F,W
0DF4:  MOVWF  01
0DF6:  MOVLW  00
0DF8:  ADDWFC x30,W
0DFA:  MOVWF  03
0DFC:  MOVF   01,W
0DFE:  ADDLW  1B
0E00:  MOVWF  FE9
0E02:  MOVLW  00
0E04:  ADDWFC 03,W
0E06:  MOVWF  FEA
0E08:  MOVFF  FEC,03
0E0C:  MOVF   FED,F
0E0E:  MOVFF  FEF,01
0E12:  MOVFF  03,02
0E16:  MOVLB  0
0E18:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_FUT_DISCONNECT_VALUE:
.................... 		case I2C_REG_CH0_FUT_DISCONNECT_DELAY:
.................... 		case I2C_REG_CH0_FUT_RECONNECT_VALUE:
.................... 		case I2C_REG_CH0_FUT_RECONNECT_DELAY:
.................... 			return (int16) 0xffff; /* not yet implemented */
0E1A:  MOVLW  FF
0E1C:  MOVWF  01
0E1E:  MOVWF  02
0E20:  BRA    0E70
.................... 		
.................... 		/* configuration */
.................... 		case I2C_REG_CONFIG_HARDWARE_MODEL: 
.................... 			return (int16) 'D';
0E22:  MOVLW  44
0E24:  MOVWF  01
0E26:  MOVLW  00
0E28:  MOVWF  02
0E2A:  BRA    0E70
.................... 		case I2C_REG_CONFIG_HARDWARE_VERSION: 
.................... 			return (int16) '2';
0E2C:  MOVLW  32
0E2E:  MOVWF  01
0E30:  MOVLW  00
0E32:  MOVWF  02
0E34:  BRA    0E70
.................... 		case I2C_REG_CONFIG_SOFTWARE_MODEL: 
.................... 			return (int16) 'L';
0E36:  MOVLW  4C
0E38:  MOVWF  01
0E3A:  MOVLW  00
0E3C:  MOVWF  02
0E3E:  BRA    0E70
.................... 		case I2C_REG_CONFIG_SOFTWARE_VERSION: 
.................... 			return (int16) '0';
0E40:  MOVLW  30
0E42:  MOVWF  01
0E44:  MOVLW  00
0E46:  MOVWF  02
0E48:  BRA    0E70
.................... 		case I2C_REG_CONFIG_SOFTWARE_YEAR:
.................... 			return (int16) current.compile_year;
0E4A:  MOVFF  CB,01
0E4E:  CLRF   02
0E50:  BRA    0E70
.................... 		case I2C_REG_CONFIG_SOFTWARE_MONTH:
.................... 			return (int16) current.compile_month;
0E52:  MOVFF  CC,01
0E56:  CLRF   02
0E58:  BRA    0E70
.................... 		case I2C_REG_CONFIG_SOFTWARE_DAY:
.................... 			return (int16) current.compile_day;
0E5A:  MOVFF  CD,01
0E5E:  CLRF   02
0E60:  BRA    0E70
.................... 
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			/* 1 if factory unlocked */ 
.................... 			return (int16) current.factory_unlocked; 	
0E62:  MOVFF  CA,01
0E66:  CLRF   02
0E68:  BRA    0E70
.................... 
.................... 		/* we should have range checked, and never gotten here ... or read unimplemented (future) register */
.................... 		default: return (int16) 0xffff;
0E6A:  MOVLW  FF
0E6C:  MOVWF  01
0E6E:  MOVWF  02
.................... 	}
0E70:  GOTO   0F2E (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... 
.................... 
.................... #include "interrupt_dcswc_module_latching_contactor.c"
.................... #int_timer2
.................... void isr_timer2() {
.................... 	timers.now_millisecond=1;
*
00D4:  BSF    xCF.2
.................... }
.................... 
.................... 
.................... 
.................... /* I2C slave interrupt */
00D6:  BCF    F9E.1
00D8:  GOTO   006C
.................... #byte SSPSTAT=GETENV("SFR:SSPSTAT")
.................... #INT_SSP
.................... void ssp_interrupt () {
.................... 	static int8 sstate;
.................... 	int8 state;
.................... 	int8 incoming;
.................... 	static int16 lastValue;
.................... 	static int8 lastMSB;
.................... 
.................... 	static int8 address; 
.................... 
.................... 	/* 
.................... 	our implementation of i2c_isr_state() that won't overflow and switch states
.................... 	but it will quit counting at 127 bytes. 
.................... 	If more bytes are needed, external counting variables can be used or the size of state can be made larger
.................... 	*/
.................... 
.................... 
.................... 	if ( ! bit_test(SSPSTAT,5) ) {
*
0E8A:  BTFSC  FC7.5
0E8C:  BRA    0E9A
.................... 		/* address */
.................... 		sstate=0;
0E8E:  MOVLB  1
0E90:  CLRF   x0C
.................... 
.................... 		if ( bit_test(SSPSTAT,2) ) {
0E92:  BTFSS  FC7.2
0E94:  BRA    0E98
.................... 			/* set high bit if read */
.................... 			bit_set(sstate,7);
0E96:  BSF    x0C.7
.................... 		}
.................... 	} else {
0E98:  MOVLB  0
.................... 		/* data */
.................... 	}
.................... 
.................... 	/* state variable used below is not incremented */
.................... 	state=sstate;
0E9A:  MOVFF  10C,12A
.................... 
.................... 	/* increment the state counter for next pass through unless it will overflow us into another state */
.................... 	if ( sstate != 0x7f && sstate != 0xff) {
0E9E:  MOVLB  1
0EA0:  MOVF   x0C,W
0EA2:  SUBLW  7F
0EA4:  BZ    0EAE
0EA6:  INCFSZ x0C,W
0EA8:  BRA    0EAC
0EAA:  BRA    0EAE
.................... 		sstate++;
0EAC:  INCF   x0C,F
.................... 	}
.................... 
.................... 	
.................... 	/* i2c_isr_state() return an 8 bit int
.................... 		0 - Address match received with R/W bit clear, perform i2c_read( ) to read the I2C address.
.................... 		1-0x7F - Master has written data; i2c_read() will immediately return the data
.................... 		0x80 - Address match received with R/W bit set; perform i2c_read( ) to read the I2C address,
.................... 		and use i2c_write( ) to pre-load the transmit buffer for the next transaction (next I2C read
.................... 		performed by master will read this byte).
.................... 		0x81-0xFF - Transmission completed and acknowledged; respond with i2c_write() to pre-load
.................... 		the transmit buffer for the next transition (the next I2C read performed by master will read this
.................... 		byte).
.................... 		Function:
.................... 		Returns the state of I2C communications in I2C slave mode after an SSP interrupt. The return
.................... 		value increments with each byte received or sent.
.................... 		If 0x00 or 0x80 is returned, an i2C_read( ) needs to be performed to read the I2C address that
.................... 		was sent (it will match the address configured by #USE I2C so this value can be ignored)
.................... 	*/
.................... 
.................... 	if ( state <= 0x80 ) {                      
0EAE:  MOVF   x2A,W
0EB0:  SUBLW  80
0EB2:  BNC   0F16
.................... 		/* I2C master is sending us data */
.................... 		if ( 0x80 == state ) {
0EB4:  MOVF   x2A,W
0EB6:  SUBLW  80
0EB8:  BNZ   0EC0
.................... 			/* i2c_read(2) casues the function to read the SSPBUF without releasing the clock */
.................... 			incoming = i2c_read(STREAM_SLAVE,2);
0EBA:  MOVFF  FC9,12B
.................... 		} else {
0EBE:  BRA    0ECC
.................... 			incoming = i2c_read(STREAM_SLAVE);
0EC0:  BCF    FC6.6
0EC2:  BTFSS  FC7.0
0EC4:  BRA    0EC2
0EC6:  MOVF   FC9,W
0EC8:  BSF    FC6.4
0ECA:  MOVWF  x2B
.................... 		}
.................... 
.................... 		if ( 1 == state ) {             
0ECC:  DECFSZ x2A,W
0ECE:  BRA    0ED8
.................... 			address = incoming<<1;
0ED0:  BCF    FD8.0
0ED2:  RLCF   x2B,W
0ED4:  MOVWF  x10
.................... 		} else if ( state >= 2 && 0x80 != state ) {
0ED6:  BRA    0F16
0ED8:  MOVF   x2A,W
0EDA:  SUBLW  01
0EDC:  BC    0F16
0EDE:  MOVF   x2A,W
0EE0:  SUBLW  80
0EE2:  BZ    0F16
.................... 			/* received byte is data */
.................... 		
.................... 			/* save MSB and we'll process it on next */
.................... 			if ( 2 == state ) {
0EE4:  MOVF   x2A,W
0EE6:  SUBLW  02
0EE8:  BNZ   0EF0
.................... 				lastMSB=incoming;
0EEA:  MOVFF  12B,10F
.................... 			} else if ( 3 == state ) {
0EEE:  BRA    0F16
0EF0:  MOVF   x2A,W
0EF2:  SUBLW  03
0EF4:  BNZ   0F16
.................... 				/* 16 bit value made of previous byte and this byte */
.................... 				write_i2c(address>>1,make16(lastMSB,incoming));
0EF6:  BCF    FD8.0
0EF8:  RRCF   x10,W
0EFA:  MOVWF  x2C
0EFC:  MOVFF  10F,12E
0F00:  MOVFF  12B,12D
0F04:  MOVWF  x2F
0F06:  MOVFF  10F,131
0F0A:  MOVFF  12B,130
0F0E:  MOVLB  0
0F10:  GOTO   00DC
0F14:  MOVLB  1
.................... 
.................... 				/* this write only works for a single register per I2C transaction */
.................... 				/* this is not a BUG, but it would need to be implemented if this functionality is needed */
.................... 			}
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	if ( state >= 0x80 ) {
0F16:  MOVF   x2A,W
0F18:  SUBLW  7F
0F1A:  BC    0F54
.................... 		/* I2C master is requesting data from us */
.................... 
.................... 		if ( ! bit_test(address,0) ) {
0F1C:  BTFSC  x10.0
0F1E:  BRA    0F44
.................... 			/* read 16 bit register (register address half of I2C address) on even address */
.................... 			lastValue=map_i2c(address>>1);
0F20:  BCF    FD8.0
0F22:  RRCF   x10,W
0F24:  MOVWF  x2C
0F26:  MOVWF  x2D
0F28:  MOVLB  0
0F2A:  GOTO   0614
0F2E:  MOVFF  02,10E
0F32:  MOVFF  01,10D
.................... 
.................... 			/* send the MSB */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,1));
0F36:  MOVFF  10E,12C
0F3A:  MOVFF  10E,12D
0F3E:  RCALL  0E74
.................... 		} else {
0F40:  BRA    0F50
0F42:  MOVLB  1
.................... 			/* send LSB of 16 bit register on odd address */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,0));
0F44:  MOVFF  10D,12C
0F48:  MOVFF  10D,12D
0F4C:  MOVLB  0
0F4E:  RCALL  0E74
.................... 		}
.................... 		address++;
0F50:  MOVLB  1
0F52:  INCF   x10,F
.................... 	}
.................... }
.................... 
.................... 
.................... 
.................... 
0F54:  BCF    F9E.3
0F56:  MOVLB  0
0F58:  GOTO   006C
.................... #include "debug_dcswc_module_latching_contactor.c"
.................... void debug_dump(void) {
.................... 
.................... 	int8 i;
.................... 
.................... 	
.................... 	restart_wdt();
.................... 	fprintf(STREAM_FTDI,"# '%s'\r\n",__DATE__);
.................... 	fprintf(STREAM_FTDI,"#  compile_year=%u\r\n",current.compile_year);
.................... 	fprintf(STREAM_FTDI,"# compile_month=%u\r\n",current.compile_month);
.................... 	fprintf(STREAM_FTDI,"#   compile_day=%u\r\n",current.compile_day);
.................... 	fprintf(STREAM_FTDI,"#       vin adc=%lu\r\n",adc_get(0));
.................... 	fprintf(STREAM_FTDI,"#      temp adc=%lu\r\n",adc_get(1));
.................... //	fprintf(STREAM_FTDI,"# read_dip_sw()=%u\r\n",read_dip_switch());
.................... //	fprintf(STREAM_FTDI,"#    dip sw adc=%lu\r\n",adc_get(2));
.................... 
.................... 	for ( i=0 ; i<2 ; i++ ) {
.................... 		restart_wdt();
.................... 		fprintf(STREAM_FTDI,"#-------\r\n");
.................... 		fprintf(STREAM_FTDI,"# config.ch[%u]\r\n",i);
.................... 		fprintf(STREAM_FTDI,"# command_off_hold_time=%lu\r\n",config.ch[i].command_off_hold_time);
.................... 
.................... 		fprintf(STREAM_FTDI,"#    lvd_disconnect_adc=%lu\r\n",config.ch[i].lvd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  lvd_disconnect_delay=%lu\r\n",config.ch[i].lvd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     lvd_reconnect_adc=%lu\r\n",config.ch[i].lvd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   lvd_reconnect_delay=%lu\r\n",config.ch[i].lvd_reconnect_delay);
.................... 
.................... 		fprintf(STREAM_FTDI,"#    hvd_disconnect_adc=%lu\r\n",config.ch[i].hvd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  hvd_disconnect_delay=%lu\r\n",config.ch[i].hvd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     hvd_reconnect_adc=%lu\r\n",config.ch[i].hvd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   hvd_reconnect_delay=%lu\r\n",config.ch[i].hvd_reconnect_delay);
.................... 
.................... 		restart_wdt();
.................... 		fprintf(STREAM_FTDI,"#    ltd_disconnect_adc=%lu\r\n",config.ch[i].ltd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  ltd_disconnect_delay=%lu\r\n",config.ch[i].ltd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     ltd_reconnect_adc=%lu\r\n",config.ch[i].ltd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   ltd_reconnect_delay=%lu\r\n",config.ch[i].ltd_reconnect_delay);
.................... 
.................... 		fprintf(STREAM_FTDI,"#    htd_disconnect_adc=%lu\r\n",config.ch[i].htd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  htd_disconnect_delay=%lu\r\n",config.ch[i].htd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     htd_reconnect_adc=%lu\r\n",config.ch[i].htd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   htd_reconnect_delay=%lu\r\n",config.ch[i].htd_reconnect_delay);
.................... 
.................... 
.................... 		restart_wdt();
.................... 		fprintf(STREAM_FTDI,"#\r\n");
.................... 		fprintf(STREAM_FTDI,"# channel[%u]\r\n",i);
.................... 		fprintf(STREAM_FTDI,"#                        state=0x%02x\r\n",channel[i].state);
.................... 		fprintf(STREAM_FTDI,"#           command_on_seconds=%lu\r\n",channel[i].command_on_seconds);
.................... 		fprintf(STREAM_FTDI,"#      command_on_hold_seconds=%lu\r\n",channel[i].command_on_hold_seconds);
.................... 
.................... 		fprintf(STREAM_FTDI,"#          command_off_seconds=%lu\r\n",channel[i].command_off_seconds);
.................... 		fprintf(STREAM_FTDI,"#     command_off_hold_seconds=%lu\r\n",channel[i].command_off_hold_seconds);
.................... 
.................... 		fprintf(STREAM_FTDI,"# lvd_disconnect_delay_seconds=%lu\r\n",channel[i].lvd_disconnect_delay_seconds);
.................... 		fprintf(STREAM_FTDI,"#  lvd_reconnect_delay_seconds=%lu\r\n",channel[i].lvd_reconnect_delay_seconds);
.................... 
.................... 		fprintf(STREAM_FTDI,"# hvd_disconnect_delay_seconds=%lu\r\n",channel[i].hvd_disconnect_delay_seconds);
.................... 		fprintf(STREAM_FTDI,"#  hvd_reconnect_delay_seconds=%lu\r\n",channel[i].hvd_reconnect_delay_seconds);
.................... 
.................... 		restart_wdt();
.................... 		fprintf(STREAM_FTDI,"# ltd_disconnect_delay_seconds=%lu\r\n",channel[i].ltd_disconnect_delay_seconds);
.................... 		fprintf(STREAM_FTDI,"#  ltd_reconnect_delay_seconds=%lu\r\n",channel[i].ltd_reconnect_delay_seconds);
.................... 
.................... 		fprintf(STREAM_FTDI,"# htd_disconnect_delay_seconds=%lu\r\n",channel[i].htd_disconnect_delay_seconds);
.................... 		fprintf(STREAM_FTDI,"#  htd_reconnect_delay_seconds=%lu\r\n",channel[i].htd_reconnect_delay_seconds);
.................... 
.................... 	}
.................... 	
.................... }
.................... 
.................... 
.................... 
.................... void contactor_on(int8 c) {
.................... 	/* only turn on contactor if it isn't on or needs a refresh */
.................... 	if ( 1 == timers.contactor[c] ) {
*
28B8:  CLRF   03
28BA:  MOVLB  1
28BC:  MOVF   x1E,W
28BE:  ADDLW  D6
28C0:  MOVWF  FE9
28C2:  MOVLW  00
28C4:  ADDWFC 03,W
28C6:  MOVWF  FEA
28C8:  MOVF   FEF,W
28CA:  SUBLW  01
28CC:  BNZ   28D0
.................... 		return;
28CE:  BRA    290A
.................... 	}
.................... 
.................... 	/* we start the powersave count down */
.................... 	timers.contactor_powersave[c]=CONTACTOR_POWER_SAVE_MS;
28D0:  CLRF   03
28D2:  MOVF   x1E,W
28D4:  ADDLW  D8
28D6:  MOVWF  FE9
28D8:  MOVLW  00
28DA:  ADDWFC 03,W
28DC:  MOVWF  FEA
28DE:  MOVLW  C8
28E0:  MOVWF  FEF
.................... 
.................... 	/* control the actual coil depending on what channel we are on */
.................... 	if ( 0==c ) {
28E2:  MOVF   x1E,F
28E4:  BNZ   28F0
.................... 		/* contactor A pins */
.................... 		output_low(BRIDGE_A_A);
28E6:  BCF    F94.3
28E8:  BCF    F8B.3
.................... 		output_high(BRIDGE_A_B);
28EA:  BCF    F94.4
28EC:  BSF    F8B.4
.................... 	} else {
28EE:  BRA    28F8
.................... 		/* contactor B pins */
.................... 		output_low(BRIDGE_B_A);
28F0:  BCF    F94.5
28F2:  BCF    F8B.5
.................... 		output_high(BRIDGE_B_B);
28F4:  BCF    F94.6
28F6:  BSF    F8B.6
.................... 	}
.................... 
.................... 	/* save state for next time */
.................... 	timers.contactor[c]=1;
28F8:  CLRF   03
28FA:  MOVF   x1E,W
28FC:  ADDLW  D6
28FE:  MOVWF  FE9
2900:  MOVLW  00
2902:  ADDWFC 03,W
2904:  MOVWF  FEA
2906:  MOVLW  01
2908:  MOVWF  FEF
290A:  MOVLB  0
290C:  GOTO   2970 (RETURN)
.................... }
.................... 
.................... void contactor_off(int8 c) {
.................... 	/* only turn off contactor if it isn't on or needs a refresh */
.................... 	if ( 0 == timers.contactor[c] ) {
*
2864:  CLRF   03
2866:  MOVLB  1
2868:  MOVF   x1E,W
286A:  ADDLW  D6
286C:  MOVWF  FE9
286E:  MOVLW  00
2870:  ADDWFC 03,W
2872:  MOVWF  FEA
2874:  MOVF   FEF,W
2876:  BNZ   287A
.................... 		return;
2878:  BRA    28B2
.................... 	}
.................... 
.................... 	/* we start the powersave count down */
.................... 	timers.contactor_powersave[c]=CONTACTOR_POWER_SAVE_MS;
287A:  CLRF   03
287C:  MOVF   x1E,W
287E:  ADDLW  D8
2880:  MOVWF  FE9
2882:  MOVLW  00
2884:  ADDWFC 03,W
2886:  MOVWF  FEA
2888:  MOVLW  C8
288A:  MOVWF  FEF
.................... 
.................... 	/* control the actual coil depending on what channel we are on */
.................... 	if ( 0==c ) {
288C:  MOVF   x1E,F
288E:  BNZ   289A
.................... 		output_high(BRIDGE_A_A);
2890:  BCF    F94.3
2892:  BSF    F8B.3
.................... 		output_low(BRIDGE_A_B);
2894:  BCF    F94.4
2896:  BCF    F8B.4
.................... 	} else {
2898:  BRA    28A2
.................... 		output_high(BRIDGE_B_A);
289A:  BCF    F94.5
289C:  BSF    F8B.5
.................... 		output_low(BRIDGE_B_B);
289E:  BCF    F94.6
28A0:  BCF    F8B.6
.................... 	}
.................... 
.................... 	/* save state for next time */
.................... 	timers.contactor[c]=0;
28A2:  CLRF   03
28A4:  MOVF   x1E,W
28A6:  ADDLW  D6
28A8:  MOVWF  FE9
28AA:  MOVLW  00
28AC:  ADDWFC 03,W
28AE:  MOVWF  FEA
28B0:  CLRF   FEF
28B2:  MOVLB  0
28B4:  GOTO   2964 (RETURN)
.................... }
.................... 
.................... void contactor_set(int8 c) {
*
2910:  MOVLW  01
2912:  MOVLB  1
2914:  MOVWF  x1D
.................... 	int8 state=1;
.................... 
.................... 	/* if nothing is set in channel[c].state, contactor is on */
.................... 	state=1; 
2916:  MOVWF  x1D
.................... 
.................... 	if ( channel[c].state & CH_STATE_MASK_ON ) {
2918:  MOVF   x1C,W
291A:  MULLW  19
291C:  MOVF   FF3,W
291E:  CLRF   x1F
2920:  MOVWF  x1E
2922:  MOVLW  DA
2924:  ADDWF  x1E,W
2926:  MOVWF  FE9
2928:  MOVLW  00
292A:  ADDWFC x1F,W
292C:  MOVWF  FEA
292E:  MOVF   FEF,W
2930:  ANDLW  03
2932:  BZ    293A
.................... 		/* if override button (switch) is set or we are commanded on, then we will be on */
.................... 		state=1;
2934:  MOVLW  01
2936:  MOVWF  x1D
.................... 	} else if ( channel[c].state & CH_STATE_MASK_OFF ) {
2938:  BRA    2958
293A:  MOVF   x1C,W
293C:  MULLW  19
293E:  MOVF   FF3,W
2940:  CLRF   x1F
2942:  MOVWF  x1E
2944:  MOVLW  DA
2946:  ADDWF  x1E,W
2948:  MOVWF  FE9
294A:  MOVLW  00
294C:  ADDWFC x1F,W
294E:  MOVWF  FEA
2950:  MOVF   FEF,W
2952:  ANDLW  7C
2954:  BZ    2958
.................... 		/* if one of the disconnect bits is set, we will be off */
.................... 		state=0;
2956:  CLRF   x1D
.................... 	}
.................... 
.................... 	if ( 0==state ) {
2958:  MOVF   x1D,F
295A:  BNZ   2968
.................... 		contactor_off(c);
295C:  MOVFF  11C,11E
2960:  MOVLB  0
2962:  BRA    2864
.................... 	} else {
2964:  BRA    2970
2966:  MOVLB  1
.................... 		contactor_on(c);
2968:  MOVFF  11C,11E
296C:  MOVLB  0
296E:  BRA    28B8
.................... 	}
2970:  RETURN 0
.................... 
.................... }
.................... 
.................... void contactor_logic(int8 c) {
.................... 	int16 adc;
.................... 
.................... 	/* override button / switch */
.................... 	if ( (0==c && 0==input(SW_OVERRIDE_A)) || (1==c && 0==input(SW_OVERRIDE_B)) ) {
*
1CB4:  MOVLB  1
1CB6:  MOVF   x1C,F
1CB8:  BNZ   1CC0
1CBA:  BSF    F92.5
1CBC:  BTFSS  F80.5
1CBE:  BRA    1CCA
1CC0:  DECFSZ x1C,W
1CC2:  BRA    1CE8
1CC4:  BSF    F92.4
1CC6:  BTFSC  F80.4
1CC8:  BRA    1CE8
.................... 		bit_set(channel[c].state,CH_STATE_BIT_OVERRIDE);
1CCA:  MOVF   x1C,W
1CCC:  MULLW  19
1CCE:  MOVF   FF3,W
1CD0:  CLRF   x20
1CD2:  MOVWF  x1F
1CD4:  MOVLW  DA
1CD6:  ADDWF  x1F,W
1CD8:  MOVWF  01
1CDA:  MOVLW  00
1CDC:  ADDWFC x20,W
1CDE:  MOVFF  01,FE9
1CE2:  MOVWF  FEA
1CE4:  BSF    FEF.0
.................... 	} else {
1CE6:  BRA    1D04
.................... 		bit_clear(channel[c].state,CH_STATE_BIT_OVERRIDE);
1CE8:  MOVF   x1C,W
1CEA:  MULLW  19
1CEC:  MOVF   FF3,W
1CEE:  CLRF   x20
1CF0:  MOVWF  x1F
1CF2:  MOVLW  DA
1CF4:  ADDWF  x1F,W
1CF6:  MOVWF  01
1CF8:  MOVLW  00
1CFA:  ADDWFC x20,W
1CFC:  MOVFF  01,FE9
1D00:  MOVWF  FEA
1D02:  BCF    FEF.0
.................... 	}
.................... 
.................... 	/* command on. 65535 disables */
.................... 	if ( 65535 != channel[c].command_on_seconds ) {
1D04:  MOVF   x1C,W
1D06:  MULLW  19
1D08:  MOVF   FF3,W
1D0A:  CLRF   x20
1D0C:  MOVWF  x1F
1D0E:  MOVLW  01
1D10:  ADDWF  x1F,W
1D12:  MOVWF  01
1D14:  MOVLW  00
1D16:  ADDWFC x20,W
1D18:  MOVWF  03
1D1A:  MOVF   01,W
1D1C:  ADDLW  DA
1D1E:  MOVWF  FE9
1D20:  MOVLW  00
1D22:  ADDWFC 03,W
1D24:  MOVWF  FEA
1D26:  MOVFF  FEC,03
1D2A:  MOVF   FED,F
1D2C:  MOVF   FEF,W
1D2E:  SUBLW  FF
1D30:  BNZ   1D38
1D32:  INCFSZ 03,W
1D34:  BRA    1D38
1D36:  BRA    1ECE
.................... 		if ( channel[c].command_on_seconds > 0 ) {
1D38:  MOVF   x1C,W
1D3A:  MULLW  19
1D3C:  MOVF   FF3,W
1D3E:  CLRF   x20
1D40:  MOVWF  x1F
1D42:  MOVLW  01
1D44:  ADDWF  x1F,W
1D46:  MOVWF  01
1D48:  MOVLW  00
1D4A:  ADDWFC x20,W
1D4C:  MOVWF  03
1D4E:  MOVF   01,W
1D50:  ADDLW  DA
1D52:  MOVWF  FE9
1D54:  MOVLW  00
1D56:  ADDWFC 03,W
1D58:  MOVWF  FEA
1D5A:  MOVFF  FEC,120
1D5E:  MOVF   FED,F
1D60:  MOVFF  FEF,11F
1D64:  MOVF   x1F,F
1D66:  BNZ   1D6C
1D68:  MOVF   x20,F
1D6A:  BZ    1D9A
.................... 			/* waiting to power on */
.................... 			channel[c].command_on_seconds--;
1D6C:  MOVF   x1C,W
1D6E:  MULLW  19
1D70:  MOVF   FF3,W
1D72:  CLRF   x20
1D74:  MOVWF  x1F
1D76:  MOVLW  01
1D78:  ADDWF  x1F,W
1D7A:  MOVWF  01
1D7C:  MOVLW  00
1D7E:  ADDWFC x20,W
1D80:  MOVWF  03
1D82:  MOVF   01,W
1D84:  ADDLW  DA
1D86:  MOVWF  FE9
1D88:  MOVLW  00
1D8A:  ADDWFC 03,W
1D8C:  MOVWF  FEA
1D8E:  MOVLW  FF
1D90:  ADDWF  FEF,F
1D92:  BC    1D98
1D94:  MOVF   FEE,F
1D96:  DECF   FED,F
.................... 		} else {
1D98:  BRA    1ECE
.................... 			/* timer at zero, ready to power on or already powered on */
.................... 			if ( ! bit_test(channel[c].state,CH_STATE_BIT_CMD_ON) ) {
1D9A:  MOVF   x1C,W
1D9C:  MULLW  19
1D9E:  MOVF   FF3,W
1DA0:  CLRF   x20
1DA2:  MOVWF  x1F
1DA4:  MOVLW  DA
1DA6:  ADDWF  x1F,W
1DA8:  MOVWF  FE9
1DAA:  MOVLW  00
1DAC:  ADDWFC x20,W
1DAE:  MOVWF  FEA
1DB0:  MOVFF  FEF,121
1DB4:  BTFSC  x21.1
1DB6:  BRA    1E2C
.................... 				/* not currently set, so we set it and start the countdown */
.................... 				bit_set(channel[c].state,CH_STATE_BIT_CMD_ON);
1DB8:  MOVF   x1C,W
1DBA:  MULLW  19
1DBC:  MOVF   FF3,W
1DBE:  CLRF   x20
1DC0:  MOVWF  x1F
1DC2:  MOVLW  DA
1DC4:  ADDWF  x1F,W
1DC6:  MOVWF  01
1DC8:  MOVLW  00
1DCA:  ADDWFC x20,W
1DCC:  MOVFF  01,FE9
1DD0:  MOVWF  FEA
1DD2:  BSF    FEF.1
.................... 				channel[c].command_on_hold_seconds=config.ch[c].command_on_hold_time;
1DD4:  MOVF   x1C,W
1DD6:  MULLW  19
1DD8:  MOVF   FF3,W
1DDA:  CLRF   x20
1DDC:  MOVWF  x1F
1DDE:  MOVLW  03
1DE0:  ADDWF  x1F,W
1DE2:  MOVWF  01
1DE4:  MOVLW  00
1DE6:  ADDWFC x20,W
1DE8:  MOVWF  03
1DEA:  MOVF   01,W
1DEC:  ADDLW  DA
1DEE:  MOVWF  01
1DF0:  MOVLW  00
1DF2:  ADDWFC 03,F
1DF4:  MOVFF  03,120
1DF8:  MOVF   x1C,W
1DFA:  MULLW  24
1DFC:  MOVF   FF3,W
1DFE:  CLRF   x22
1E00:  MOVWF  x21
1E02:  MOVLW  1B
1E04:  ADDWF  x21,W
1E06:  MOVWF  FE9
1E08:  MOVLW  00
1E0A:  ADDWFC x22,W
1E0C:  MOVWF  FEA
1E0E:  MOVFF  FEC,03
1E12:  MOVF   FED,F
1E14:  MOVFF  FEF,123
1E18:  MOVFF  120,FEA
1E1C:  MOVFF  01,FE9
1E20:  MOVFF  03,FEC
1E24:  MOVF   FED,F
1E26:  MOVFF  123,FEF
.................... 			} else {
1E2A:  BRA    1ECE
.................... 				/* set, so we clear it once countdown has elapsed */
.................... 				if ( 0==channel[c].command_on_hold_seconds ) {
1E2C:  MOVF   x1C,W
1E2E:  MULLW  19
1E30:  MOVF   FF3,W
1E32:  CLRF   x20
1E34:  MOVWF  x1F
1E36:  MOVLW  03
1E38:  ADDWF  x1F,W
1E3A:  MOVWF  01
1E3C:  MOVLW  00
1E3E:  ADDWFC x20,W
1E40:  MOVWF  03
1E42:  MOVF   01,W
1E44:  ADDLW  DA
1E46:  MOVWF  FE9
1E48:  MOVLW  00
1E4A:  ADDWFC 03,W
1E4C:  MOVWF  FEA
1E4E:  MOVFF  FEC,03
1E52:  MOVF   FED,F
1E54:  MOVF   FEF,W
1E56:  BNZ   1EA2
1E58:  MOVF   03,F
1E5A:  BNZ   1EA2
.................... 					/* countdown elapsed, clear the flag and reset the timer */
.................... 					bit_clear(channel[c].state,CH_STATE_BIT_CMD_ON);
1E5C:  MOVF   x1C,W
1E5E:  MULLW  19
1E60:  MOVF   FF3,W
1E62:  CLRF   x20
1E64:  MOVWF  x1F
1E66:  MOVLW  DA
1E68:  ADDWF  x1F,W
1E6A:  MOVWF  01
1E6C:  MOVLW  00
1E6E:  ADDWFC x20,W
1E70:  MOVFF  01,FE9
1E74:  MOVWF  FEA
1E76:  BCF    FEF.1
.................... 					channel[c].command_on_seconds=65535;
1E78:  MOVF   x1C,W
1E7A:  MULLW  19
1E7C:  MOVF   FF3,W
1E7E:  CLRF   x20
1E80:  MOVWF  x1F
1E82:  MOVLW  01
1E84:  ADDWF  x1F,W
1E86:  MOVWF  01
1E88:  MOVLW  00
1E8A:  ADDWFC x20,W
1E8C:  MOVWF  03
1E8E:  MOVF   01,W
1E90:  ADDLW  DA
1E92:  MOVWF  FE9
1E94:  MOVLW  00
1E96:  ADDWFC 03,W
1E98:  MOVWF  FEA
1E9A:  SETF   FEC
1E9C:  MOVF   FED,F
1E9E:  SETF   FEF
.................... 				} else {
1EA0:  BRA    1ECE
.................... 					channel[c].command_on_hold_seconds--;
1EA2:  MOVF   x1C,W
1EA4:  MULLW  19
1EA6:  MOVF   FF3,W
1EA8:  CLRF   x20
1EAA:  MOVWF  x1F
1EAC:  MOVLW  03
1EAE:  ADDWF  x1F,W
1EB0:  MOVWF  01
1EB2:  MOVLW  00
1EB4:  ADDWFC x20,W
1EB6:  MOVWF  03
1EB8:  MOVF   01,W
1EBA:  ADDLW  DA
1EBC:  MOVWF  FE9
1EBE:  MOVLW  00
1EC0:  ADDWFC 03,W
1EC2:  MOVWF  FEA
1EC4:  MOVLW  FF
1EC6:  ADDWF  FEF,F
1EC8:  BC    1ECE
1ECA:  MOVF   FEE,F
1ECC:  DECF   FED,F
.................... 				}
.................... 			}		
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	/* command off. 65535 disables */
.................... 	if ( 65535 != channel[c].command_off_seconds ) {
1ECE:  MOVF   x1C,W
1ED0:  MULLW  19
1ED2:  MOVF   FF3,W
1ED4:  CLRF   x20
1ED6:  MOVWF  x1F
1ED8:  MOVLW  05
1EDA:  ADDWF  x1F,W
1EDC:  MOVWF  01
1EDE:  MOVLW  00
1EE0:  ADDWFC x20,W
1EE2:  MOVWF  03
1EE4:  MOVF   01,W
1EE6:  ADDLW  DA
1EE8:  MOVWF  FE9
1EEA:  MOVLW  00
1EEC:  ADDWFC 03,W
1EEE:  MOVWF  FEA
1EF0:  MOVFF  FEC,03
1EF4:  MOVF   FED,F
1EF6:  MOVF   FEF,W
1EF8:  SUBLW  FF
1EFA:  BNZ   1F02
1EFC:  INCFSZ 03,W
1EFE:  BRA    1F02
1F00:  BRA    20A8
.................... 		if ( channel[c].command_off_seconds > 0 ) {
1F02:  MOVF   x1C,W
1F04:  MULLW  19
1F06:  MOVF   FF3,W
1F08:  CLRF   x20
1F0A:  MOVWF  x1F
1F0C:  MOVLW  05
1F0E:  ADDWF  x1F,W
1F10:  MOVWF  01
1F12:  MOVLW  00
1F14:  ADDWFC x20,W
1F16:  MOVWF  03
1F18:  MOVF   01,W
1F1A:  ADDLW  DA
1F1C:  MOVWF  FE9
1F1E:  MOVLW  00
1F20:  ADDWFC 03,W
1F22:  MOVWF  FEA
1F24:  MOVFF  FEC,120
1F28:  MOVF   FED,F
1F2A:  MOVFF  FEF,11F
1F2E:  MOVF   x1F,F
1F30:  BNZ   1F36
1F32:  MOVF   x20,F
1F34:  BZ    1F64
.................... 			/* waiting to power off */
.................... 			channel[c].command_off_seconds--;
1F36:  MOVF   x1C,W
1F38:  MULLW  19
1F3A:  MOVF   FF3,W
1F3C:  CLRF   x20
1F3E:  MOVWF  x1F
1F40:  MOVLW  05
1F42:  ADDWF  x1F,W
1F44:  MOVWF  01
1F46:  MOVLW  00
1F48:  ADDWFC x20,W
1F4A:  MOVWF  03
1F4C:  MOVF   01,W
1F4E:  ADDLW  DA
1F50:  MOVWF  FE9
1F52:  MOVLW  00
1F54:  ADDWFC 03,W
1F56:  MOVWF  FEA
1F58:  MOVLW  FF
1F5A:  ADDWF  FEF,F
1F5C:  BC    1F62
1F5E:  MOVF   FEE,F
1F60:  DECF   FED,F
.................... 		} else {
1F62:  BRA    20A8
.................... 			/* timer at zero, ready to power off or already powered off */
.................... 			if ( ! bit_test(channel[c].state,CH_STATE_BIT_CMD_OFF) ) {
1F64:  MOVF   x1C,W
1F66:  MULLW  19
1F68:  MOVF   FF3,W
1F6A:  CLRF   x20
1F6C:  MOVWF  x1F
1F6E:  MOVLW  DA
1F70:  ADDWF  x1F,W
1F72:  MOVWF  FE9
1F74:  MOVLW  00
1F76:  ADDWFC x20,W
1F78:  MOVWF  FEA
1F7A:  MOVFF  FEF,121
1F7E:  BTFSC  x21.2
1F80:  BRA    2006
.................... 				/* not currently set, so we set it and start the countdown */
.................... 				bit_set(channel[c].state,CH_STATE_BIT_CMD_OFF);
1F82:  MOVF   x1C,W
1F84:  MULLW  19
1F86:  MOVF   FF3,W
1F88:  CLRF   x20
1F8A:  MOVWF  x1F
1F8C:  MOVLW  DA
1F8E:  ADDWF  x1F,W
1F90:  MOVWF  01
1F92:  MOVLW  00
1F94:  ADDWFC x20,W
1F96:  MOVFF  01,FE9
1F9A:  MOVWF  FEA
1F9C:  BSF    FEF.2
.................... 				channel[c].command_off_hold_seconds=config.ch[c].command_off_hold_time;
1F9E:  MOVF   x1C,W
1FA0:  MULLW  19
1FA2:  MOVF   FF3,W
1FA4:  CLRF   x20
1FA6:  MOVWF  x1F
1FA8:  MOVLW  07
1FAA:  ADDWF  x1F,W
1FAC:  MOVWF  01
1FAE:  MOVLW  00
1FB0:  ADDWFC x20,W
1FB2:  MOVWF  03
1FB4:  MOVF   01,W
1FB6:  ADDLW  DA
1FB8:  MOVWF  01
1FBA:  MOVLW  00
1FBC:  ADDWFC 03,F
1FBE:  MOVFF  01,11F
1FC2:  MOVFF  03,120
1FC6:  MOVF   x1C,W
1FC8:  MULLW  24
1FCA:  MOVF   FF3,W
1FCC:  CLRF   x22
1FCE:  MOVWF  x21
1FD0:  MOVLW  02
1FD2:  ADDWF  x21,W
1FD4:  MOVWF  01
1FD6:  MOVLW  00
1FD8:  ADDWFC x22,W
1FDA:  MOVWF  03
1FDC:  MOVF   01,W
1FDE:  ADDLW  1B
1FE0:  MOVWF  FE9
1FE2:  MOVLW  00
1FE4:  ADDWFC 03,W
1FE6:  MOVWF  FEA
1FE8:  MOVFF  FEC,03
1FEC:  MOVF   FED,F
1FEE:  MOVFF  FEF,121
1FF2:  MOVFF  120,FEA
1FF6:  MOVFF  11F,FE9
1FFA:  MOVFF  03,FEC
1FFE:  MOVF   FED,F
2000:  MOVFF  121,FEF
.................... 			} else {
2004:  BRA    20A8
.................... 				/* set, so we clear it once countdown has elapsed */
.................... 				if ( 0==channel[c].command_off_hold_seconds ) {
2006:  MOVF   x1C,W
2008:  MULLW  19
200A:  MOVF   FF3,W
200C:  CLRF   x20
200E:  MOVWF  x1F
2010:  MOVLW  07
2012:  ADDWF  x1F,W
2014:  MOVWF  01
2016:  MOVLW  00
2018:  ADDWFC x20,W
201A:  MOVWF  03
201C:  MOVF   01,W
201E:  ADDLW  DA
2020:  MOVWF  FE9
2022:  MOVLW  00
2024:  ADDWFC 03,W
2026:  MOVWF  FEA
2028:  MOVFF  FEC,03
202C:  MOVF   FED,F
202E:  MOVF   FEF,W
2030:  BNZ   207C
2032:  MOVF   03,F
2034:  BNZ   207C
.................... 					/* countdown elapsed, clear the flag and reset the timer */
.................... 					bit_clear(channel[c].state,CH_STATE_BIT_CMD_OFF);
2036:  MOVF   x1C,W
2038:  MULLW  19
203A:  MOVF   FF3,W
203C:  CLRF   x20
203E:  MOVWF  x1F
2040:  MOVLW  DA
2042:  ADDWF  x1F,W
2044:  MOVWF  01
2046:  MOVLW  00
2048:  ADDWFC x20,W
204A:  MOVFF  01,FE9
204E:  MOVWF  FEA
2050:  BCF    FEF.2
.................... 					channel[c].command_off_seconds=65535;
2052:  MOVF   x1C,W
2054:  MULLW  19
2056:  MOVF   FF3,W
2058:  CLRF   x20
205A:  MOVWF  x1F
205C:  MOVLW  05
205E:  ADDWF  x1F,W
2060:  MOVWF  01
2062:  MOVLW  00
2064:  ADDWFC x20,W
2066:  MOVWF  03
2068:  MOVF   01,W
206A:  ADDLW  DA
206C:  MOVWF  FE9
206E:  MOVLW  00
2070:  ADDWFC 03,W
2072:  MOVWF  FEA
2074:  SETF   FEC
2076:  MOVF   FED,F
2078:  SETF   FEF
.................... 				} else {
207A:  BRA    20A8
.................... 					channel[c].command_off_hold_seconds--;
207C:  MOVF   x1C,W
207E:  MULLW  19
2080:  MOVF   FF3,W
2082:  CLRF   x20
2084:  MOVWF  x1F
2086:  MOVLW  07
2088:  ADDWF  x1F,W
208A:  MOVWF  01
208C:  MOVLW  00
208E:  ADDWFC x20,W
2090:  MOVWF  03
2092:  MOVF   01,W
2094:  ADDLW  DA
2096:  MOVWF  FE9
2098:  MOVLW  00
209A:  ADDWFC 03,W
209C:  MOVWF  FEA
209E:  MOVLW  FF
20A0:  ADDWF  FEF,F
20A2:  BC    20A8
20A4:  MOVF   FEE,F
20A6:  DECF   FED,F
.................... 				}
.................... 			}		
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	/* LVD. 65535 disables */
.................... 	if ( 65535 != config.ch[c].lvd_disconnect_delay ) {
20A8:  MOVF   x1C,W
20AA:  MULLW  24
20AC:  MOVF   FF3,W
20AE:  CLRF   x20
20B0:  MOVWF  x1F
20B2:  MOVLW  06
20B4:  ADDWF  x1F,W
20B6:  MOVWF  01
20B8:  MOVLW  00
20BA:  ADDWFC x20,W
20BC:  MOVWF  03
20BE:  MOVF   01,W
20C0:  ADDLW  1B
20C2:  MOVWF  FE9
20C4:  MOVLW  00
20C6:  ADDWFC 03,W
20C8:  MOVWF  FEA
20CA:  MOVFF  FEC,03
20CE:  MOVF   FED,F
20D0:  MOVF   FEF,W
20D2:  SUBLW  FF
20D4:  BNZ   20DC
20D6:  INCFSZ 03,W
20D8:  BRA    20DC
20DA:  BRA    233A
20DC:  CLRF   19
20DE:  BTFSC  FF2.7
20E0:  BSF    19.7
20E2:  BCF    FF2.7
.................... 		adc=adc_get(0);
20E4:  CLRF   x2F
20E6:  MOVLB  0
20E8:  CALL   0594
20EC:  BTFSC  19.7
20EE:  BSF    FF2.7
20F0:  MOVFF  02,11E
20F4:  MOVFF  01,11D
.................... 
.................... 		if ( adc > config.ch[c].lvd_reconnect_adc ) {
20F8:  MOVLB  1
20FA:  MOVF   x1C,W
20FC:  MULLW  24
20FE:  MOVF   FF3,W
2100:  CLRF   x20
2102:  MOVWF  x1F
2104:  MOVLW  08
2106:  ADDWF  x1F,W
2108:  MOVWF  01
210A:  MOVLW  00
210C:  ADDWFC x20,W
210E:  MOVWF  03
2110:  MOVF   01,W
2112:  ADDLW  1B
2114:  MOVWF  FE9
2116:  MOVLW  00
2118:  ADDWFC 03,W
211A:  MOVWF  FEA
211C:  MOVFF  FEC,03
2120:  MOVF   FED,F
2122:  MOVFF  FEF,01
2126:  MOVF   03,W
2128:  SUBWF  x1E,W
212A:  BNC   21B4
212C:  BNZ   2134
212E:  MOVF   x1D,W
2130:  SUBWF  01,W
2132:  BC    21B4
.................... 			if ( channel[c].lvd_reconnect_delay_seconds > 0 ) {
2134:  MOVF   x1C,W
2136:  MULLW  19
2138:  MOVF   FF3,W
213A:  CLRF   x20
213C:  MOVWF  x1F
213E:  MOVLW  0B
2140:  ADDWF  x1F,W
2142:  MOVWF  01
2144:  MOVLW  00
2146:  ADDWFC x20,W
2148:  MOVWF  03
214A:  MOVF   01,W
214C:  ADDLW  DA
214E:  MOVWF  FE9
2150:  MOVLW  00
2152:  ADDWFC 03,W
2154:  MOVWF  FEA
2156:  MOVFF  FEC,120
215A:  MOVF   FED,F
215C:  MOVFF  FEF,11F
2160:  MOVF   x1F,F
2162:  BNZ   2168
2164:  MOVF   x20,F
2166:  BZ    2196
.................... 				channel[c].lvd_reconnect_delay_seconds--;
2168:  MOVF   x1C,W
216A:  MULLW  19
216C:  MOVF   FF3,W
216E:  CLRF   x20
2170:  MOVWF  x1F
2172:  MOVLW  0B
2174:  ADDWF  x1F,W
2176:  MOVWF  01
2178:  MOVLW  00
217A:  ADDWFC x20,W
217C:  MOVWF  03
217E:  MOVF   01,W
2180:  ADDLW  DA
2182:  MOVWF  FE9
2184:  MOVLW  00
2186:  ADDWFC 03,W
2188:  MOVWF  FEA
218A:  MOVLW  FF
218C:  ADDWF  FEF,F
218E:  BC    2194
2190:  MOVF   FEE,F
2192:  DECF   FED,F
.................... 			} else {
2194:  BRA    21B2
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_LVD);
2196:  MOVF   x1C,W
2198:  MULLW  19
219A:  MOVF   FF3,W
219C:  CLRF   x20
219E:  MOVWF  x1F
21A0:  MOVLW  DA
21A2:  ADDWF  x1F,W
21A4:  MOVWF  01
21A6:  MOVLW  00
21A8:  ADDWFC x20,W
21AA:  MOVFF  01,FE9
21AE:  MOVWF  FEA
21B0:  BCF    FEF.3
.................... 			}
.................... 		} else {
21B2:  BRA    221A
.................... 			channel[c].lvd_reconnect_delay_seconds=config.ch[c].lvd_reconnect_delay;
21B4:  MOVF   x1C,W
21B6:  MULLW  19
21B8:  MOVF   FF3,W
21BA:  CLRF   x20
21BC:  MOVWF  x1F
21BE:  MOVLW  0B
21C0:  ADDWF  x1F,W
21C2:  MOVWF  01
21C4:  MOVLW  00
21C6:  ADDWFC x20,W
21C8:  MOVWF  03
21CA:  MOVF   01,W
21CC:  ADDLW  DA
21CE:  MOVWF  01
21D0:  MOVLW  00
21D2:  ADDWFC 03,F
21D4:  MOVFF  01,11F
21D8:  MOVFF  03,120
21DC:  MOVF   x1C,W
21DE:  MULLW  24
21E0:  MOVF   FF3,W
21E2:  CLRF   x22
21E4:  MOVWF  x21
21E6:  MOVLW  0A
21E8:  ADDWF  x21,W
21EA:  MOVWF  01
21EC:  MOVLW  00
21EE:  ADDWFC x22,W
21F0:  MOVWF  03
21F2:  MOVF   01,W
21F4:  ADDLW  1B
21F6:  MOVWF  FE9
21F8:  MOVLW  00
21FA:  ADDWFC 03,W
21FC:  MOVWF  FEA
21FE:  MOVFF  FEC,03
2202:  MOVF   FED,F
2204:  MOVFF  FEF,121
2208:  MOVFF  120,FEA
220C:  MOVFF  11F,FE9
2210:  MOVFF  03,FEC
2214:  MOVF   FED,F
2216:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc < config.ch[c].lvd_disconnect_adc ) {
221A:  MOVF   x1C,W
221C:  MULLW  24
221E:  MOVF   FF3,W
2220:  CLRF   x20
2222:  MOVWF  x1F
2224:  MOVLW  04
2226:  ADDWF  x1F,W
2228:  MOVWF  01
222A:  MOVLW  00
222C:  ADDWFC x20,W
222E:  MOVWF  03
2230:  MOVF   01,W
2232:  ADDLW  1B
2234:  MOVWF  FE9
2236:  MOVLW  00
2238:  ADDWFC 03,W
223A:  MOVWF  FEA
223C:  MOVFF  FEC,03
2240:  MOVF   FED,F
2242:  MOVFF  FEF,01
2246:  MOVF   x1E,W
2248:  SUBWF  03,W
224A:  BNC   22D4
224C:  BNZ   2254
224E:  MOVF   01,W
2250:  SUBWF  x1D,W
2252:  BC    22D4
.................... 			if ( channel[c].lvd_disconnect_delay_seconds > 0 ) {
2254:  MOVF   x1C,W
2256:  MULLW  19
2258:  MOVF   FF3,W
225A:  CLRF   x20
225C:  MOVWF  x1F
225E:  MOVLW  09
2260:  ADDWF  x1F,W
2262:  MOVWF  01
2264:  MOVLW  00
2266:  ADDWFC x20,W
2268:  MOVWF  03
226A:  MOVF   01,W
226C:  ADDLW  DA
226E:  MOVWF  FE9
2270:  MOVLW  00
2272:  ADDWFC 03,W
2274:  MOVWF  FEA
2276:  MOVFF  FEC,120
227A:  MOVF   FED,F
227C:  MOVFF  FEF,11F
2280:  MOVF   x1F,F
2282:  BNZ   2288
2284:  MOVF   x20,F
2286:  BZ    22B6
.................... 				channel[c].lvd_disconnect_delay_seconds--;
2288:  MOVF   x1C,W
228A:  MULLW  19
228C:  MOVF   FF3,W
228E:  CLRF   x20
2290:  MOVWF  x1F
2292:  MOVLW  09
2294:  ADDWF  x1F,W
2296:  MOVWF  01
2298:  MOVLW  00
229A:  ADDWFC x20,W
229C:  MOVWF  03
229E:  MOVF   01,W
22A0:  ADDLW  DA
22A2:  MOVWF  FE9
22A4:  MOVLW  00
22A6:  ADDWFC 03,W
22A8:  MOVWF  FEA
22AA:  MOVLW  FF
22AC:  ADDWF  FEF,F
22AE:  BC    22B4
22B0:  MOVF   FEE,F
22B2:  DECF   FED,F
.................... 			} else {
22B4:  BRA    22D2
.................... 				bit_set(channel[c].state,CH_STATE_BIT_LVD);
22B6:  MOVF   x1C,W
22B8:  MULLW  19
22BA:  MOVF   FF3,W
22BC:  CLRF   x20
22BE:  MOVWF  x1F
22C0:  MOVLW  DA
22C2:  ADDWF  x1F,W
22C4:  MOVWF  01
22C6:  MOVLW  00
22C8:  ADDWFC x20,W
22CA:  MOVFF  01,FE9
22CE:  MOVWF  FEA
22D0:  BSF    FEF.3
.................... 			}
.................... 		} else {
22D2:  BRA    233A
.................... 			channel[c].lvd_disconnect_delay_seconds=config.ch[c].lvd_disconnect_delay;
22D4:  MOVF   x1C,W
22D6:  MULLW  19
22D8:  MOVF   FF3,W
22DA:  CLRF   x20
22DC:  MOVWF  x1F
22DE:  MOVLW  09
22E0:  ADDWF  x1F,W
22E2:  MOVWF  01
22E4:  MOVLW  00
22E6:  ADDWFC x20,W
22E8:  MOVWF  03
22EA:  MOVF   01,W
22EC:  ADDLW  DA
22EE:  MOVWF  01
22F0:  MOVLW  00
22F2:  ADDWFC 03,F
22F4:  MOVFF  01,11F
22F8:  MOVFF  03,120
22FC:  MOVF   x1C,W
22FE:  MULLW  24
2300:  MOVF   FF3,W
2302:  CLRF   x22
2304:  MOVWF  x21
2306:  MOVLW  06
2308:  ADDWF  x21,W
230A:  MOVWF  01
230C:  MOVLW  00
230E:  ADDWFC x22,W
2310:  MOVWF  03
2312:  MOVF   01,W
2314:  ADDLW  1B
2316:  MOVWF  FE9
2318:  MOVLW  00
231A:  ADDWFC 03,W
231C:  MOVWF  FEA
231E:  MOVFF  FEC,03
2322:  MOVF   FED,F
2324:  MOVFF  FEF,121
2328:  MOVFF  120,FEA
232C:  MOVFF  11F,FE9
2330:  MOVFF  03,FEC
2334:  MOVF   FED,F
2336:  MOVFF  121,FEF
.................... 		}
.................... 	}
.................... 
.................... 	/* HVD. 65535 disables */
.................... 	if ( 65535 != config.ch[c].hvd_disconnect_delay ) {
233A:  MOVF   x1C,W
233C:  MULLW  24
233E:  MOVF   FF3,W
2340:  CLRF   x20
2342:  MOVWF  x1F
2344:  MOVLW  0E
2346:  ADDWF  x1F,W
2348:  MOVWF  01
234A:  MOVLW  00
234C:  ADDWFC x20,W
234E:  MOVWF  03
2350:  MOVF   01,W
2352:  ADDLW  1B
2354:  MOVWF  FE9
2356:  MOVLW  00
2358:  ADDWFC 03,W
235A:  MOVWF  FEA
235C:  MOVFF  FEC,03
2360:  MOVF   FED,F
2362:  MOVF   FEF,W
2364:  SUBLW  FF
2366:  BNZ   236E
2368:  INCFSZ 03,W
236A:  BRA    236E
236C:  BRA    25CC
236E:  CLRF   19
2370:  BTFSC  FF2.7
2372:  BSF    19.7
2374:  BCF    FF2.7
.................... 		adc=adc_get(0);
2376:  CLRF   x2F
2378:  MOVLB  0
237A:  CALL   0594
237E:  BTFSC  19.7
2380:  BSF    FF2.7
2382:  MOVFF  02,11E
2386:  MOVFF  01,11D
.................... 
.................... 		if ( adc < config.ch[c].hvd_reconnect_adc ) {
238A:  MOVLB  1
238C:  MOVF   x1C,W
238E:  MULLW  24
2390:  MOVF   FF3,W
2392:  CLRF   x20
2394:  MOVWF  x1F
2396:  MOVLW  10
2398:  ADDWF  x1F,W
239A:  MOVWF  01
239C:  MOVLW  00
239E:  ADDWFC x20,W
23A0:  MOVWF  03
23A2:  MOVF   01,W
23A4:  ADDLW  1B
23A6:  MOVWF  FE9
23A8:  MOVLW  00
23AA:  ADDWFC 03,W
23AC:  MOVWF  FEA
23AE:  MOVFF  FEC,03
23B2:  MOVF   FED,F
23B4:  MOVFF  FEF,01
23B8:  MOVF   x1E,W
23BA:  SUBWF  03,W
23BC:  BNC   2446
23BE:  BNZ   23C6
23C0:  MOVF   01,W
23C2:  SUBWF  x1D,W
23C4:  BC    2446
.................... 			if ( channel[c].hvd_reconnect_delay_seconds > 0 ) {
23C6:  MOVF   x1C,W
23C8:  MULLW  19
23CA:  MOVF   FF3,W
23CC:  CLRF   x20
23CE:  MOVWF  x1F
23D0:  MOVLW  0F
23D2:  ADDWF  x1F,W
23D4:  MOVWF  01
23D6:  MOVLW  00
23D8:  ADDWFC x20,W
23DA:  MOVWF  03
23DC:  MOVF   01,W
23DE:  ADDLW  DA
23E0:  MOVWF  FE9
23E2:  MOVLW  00
23E4:  ADDWFC 03,W
23E6:  MOVWF  FEA
23E8:  MOVFF  FEC,120
23EC:  MOVF   FED,F
23EE:  MOVFF  FEF,11F
23F2:  MOVF   x1F,F
23F4:  BNZ   23FA
23F6:  MOVF   x20,F
23F8:  BZ    2428
.................... 				channel[c].hvd_reconnect_delay_seconds--;
23FA:  MOVF   x1C,W
23FC:  MULLW  19
23FE:  MOVF   FF3,W
2400:  CLRF   x20
2402:  MOVWF  x1F
2404:  MOVLW  0F
2406:  ADDWF  x1F,W
2408:  MOVWF  01
240A:  MOVLW  00
240C:  ADDWFC x20,W
240E:  MOVWF  03
2410:  MOVF   01,W
2412:  ADDLW  DA
2414:  MOVWF  FE9
2416:  MOVLW  00
2418:  ADDWFC 03,W
241A:  MOVWF  FEA
241C:  MOVLW  FF
241E:  ADDWF  FEF,F
2420:  BC    2426
2422:  MOVF   FEE,F
2424:  DECF   FED,F
.................... 			} else {
2426:  BRA    2444
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_HVD);
2428:  MOVF   x1C,W
242A:  MULLW  19
242C:  MOVF   FF3,W
242E:  CLRF   x20
2430:  MOVWF  x1F
2432:  MOVLW  DA
2434:  ADDWF  x1F,W
2436:  MOVWF  01
2438:  MOVLW  00
243A:  ADDWFC x20,W
243C:  MOVFF  01,FE9
2440:  MOVWF  FEA
2442:  BCF    FEF.4
.................... 			}
.................... 		} else {
2444:  BRA    24AC
.................... 			channel[c].hvd_reconnect_delay_seconds=config.ch[c].hvd_reconnect_delay;
2446:  MOVF   x1C,W
2448:  MULLW  19
244A:  MOVF   FF3,W
244C:  CLRF   x20
244E:  MOVWF  x1F
2450:  MOVLW  0F
2452:  ADDWF  x1F,W
2454:  MOVWF  01
2456:  MOVLW  00
2458:  ADDWFC x20,W
245A:  MOVWF  03
245C:  MOVF   01,W
245E:  ADDLW  DA
2460:  MOVWF  01
2462:  MOVLW  00
2464:  ADDWFC 03,F
2466:  MOVFF  01,11F
246A:  MOVFF  03,120
246E:  MOVF   x1C,W
2470:  MULLW  24
2472:  MOVF   FF3,W
2474:  CLRF   x22
2476:  MOVWF  x21
2478:  MOVLW  12
247A:  ADDWF  x21,W
247C:  MOVWF  01
247E:  MOVLW  00
2480:  ADDWFC x22,W
2482:  MOVWF  03
2484:  MOVF   01,W
2486:  ADDLW  1B
2488:  MOVWF  FE9
248A:  MOVLW  00
248C:  ADDWFC 03,W
248E:  MOVWF  FEA
2490:  MOVFF  FEC,03
2494:  MOVF   FED,F
2496:  MOVFF  FEF,121
249A:  MOVFF  120,FEA
249E:  MOVFF  11F,FE9
24A2:  MOVFF  03,FEC
24A6:  MOVF   FED,F
24A8:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc > config.ch[c].hvd_disconnect_adc ) {
24AC:  MOVF   x1C,W
24AE:  MULLW  24
24B0:  MOVF   FF3,W
24B2:  CLRF   x20
24B4:  MOVWF  x1F
24B6:  MOVLW  0C
24B8:  ADDWF  x1F,W
24BA:  MOVWF  01
24BC:  MOVLW  00
24BE:  ADDWFC x20,W
24C0:  MOVWF  03
24C2:  MOVF   01,W
24C4:  ADDLW  1B
24C6:  MOVWF  FE9
24C8:  MOVLW  00
24CA:  ADDWFC 03,W
24CC:  MOVWF  FEA
24CE:  MOVFF  FEC,03
24D2:  MOVF   FED,F
24D4:  MOVFF  FEF,01
24D8:  MOVF   03,W
24DA:  SUBWF  x1E,W
24DC:  BNC   2566
24DE:  BNZ   24E6
24E0:  MOVF   x1D,W
24E2:  SUBWF  01,W
24E4:  BC    2566
.................... 			if ( channel[c].hvd_disconnect_delay_seconds > 0 ) {
24E6:  MOVF   x1C,W
24E8:  MULLW  19
24EA:  MOVF   FF3,W
24EC:  CLRF   x20
24EE:  MOVWF  x1F
24F0:  MOVLW  0D
24F2:  ADDWF  x1F,W
24F4:  MOVWF  01
24F6:  MOVLW  00
24F8:  ADDWFC x20,W
24FA:  MOVWF  03
24FC:  MOVF   01,W
24FE:  ADDLW  DA
2500:  MOVWF  FE9
2502:  MOVLW  00
2504:  ADDWFC 03,W
2506:  MOVWF  FEA
2508:  MOVFF  FEC,120
250C:  MOVF   FED,F
250E:  MOVFF  FEF,11F
2512:  MOVF   x1F,F
2514:  BNZ   251A
2516:  MOVF   x20,F
2518:  BZ    2548
.................... 				channel[c].hvd_disconnect_delay_seconds--;
251A:  MOVF   x1C,W
251C:  MULLW  19
251E:  MOVF   FF3,W
2520:  CLRF   x20
2522:  MOVWF  x1F
2524:  MOVLW  0D
2526:  ADDWF  x1F,W
2528:  MOVWF  01
252A:  MOVLW  00
252C:  ADDWFC x20,W
252E:  MOVWF  03
2530:  MOVF   01,W
2532:  ADDLW  DA
2534:  MOVWF  FE9
2536:  MOVLW  00
2538:  ADDWFC 03,W
253A:  MOVWF  FEA
253C:  MOVLW  FF
253E:  ADDWF  FEF,F
2540:  BC    2546
2542:  MOVF   FEE,F
2544:  DECF   FED,F
.................... 			} else {
2546:  BRA    2564
.................... 				bit_set(channel[c].state,CH_STATE_BIT_HVD);
2548:  MOVF   x1C,W
254A:  MULLW  19
254C:  MOVF   FF3,W
254E:  CLRF   x20
2550:  MOVWF  x1F
2552:  MOVLW  DA
2554:  ADDWF  x1F,W
2556:  MOVWF  01
2558:  MOVLW  00
255A:  ADDWFC x20,W
255C:  MOVFF  01,FE9
2560:  MOVWF  FEA
2562:  BSF    FEF.4
.................... 			}
.................... 		} else {
2564:  BRA    25CC
.................... 			channel[c].hvd_disconnect_delay_seconds=config.ch[c].hvd_disconnect_delay;
2566:  MOVF   x1C,W
2568:  MULLW  19
256A:  MOVF   FF3,W
256C:  CLRF   x20
256E:  MOVWF  x1F
2570:  MOVLW  0D
2572:  ADDWF  x1F,W
2574:  MOVWF  01
2576:  MOVLW  00
2578:  ADDWFC x20,W
257A:  MOVWF  03
257C:  MOVF   01,W
257E:  ADDLW  DA
2580:  MOVWF  01
2582:  MOVLW  00
2584:  ADDWFC 03,F
2586:  MOVFF  01,11F
258A:  MOVFF  03,120
258E:  MOVF   x1C,W
2590:  MULLW  24
2592:  MOVF   FF3,W
2594:  CLRF   x22
2596:  MOVWF  x21
2598:  MOVLW  0E
259A:  ADDWF  x21,W
259C:  MOVWF  01
259E:  MOVLW  00
25A0:  ADDWFC x22,W
25A2:  MOVWF  03
25A4:  MOVF   01,W
25A6:  ADDLW  1B
25A8:  MOVWF  FE9
25AA:  MOVLW  00
25AC:  ADDWFC 03,W
25AE:  MOVWF  FEA
25B0:  MOVFF  FEC,03
25B4:  MOVF   FED,F
25B6:  MOVFF  FEF,121
25BA:  MOVFF  120,FEA
25BE:  MOVFF  11F,FE9
25C2:  MOVFF  03,FEC
25C6:  MOVF   FED,F
25C8:  MOVFF  121,FEF
.................... 		}
.................... 	}
.................... 
.................... 	/* LTD. 65535 disables */
.................... 	if ( 65535 != config.ch[c].ltd_disconnect_delay ) {
25CC:  MOVF   x1C,W
25CE:  MULLW  24
25D0:  MOVF   FF3,W
25D2:  CLRF   x20
25D4:  MOVWF  x1F
25D6:  MOVLW  16
25D8:  ADDWF  x1F,W
25DA:  MOVWF  01
25DC:  MOVLW  00
25DE:  ADDWFC x20,W
25E0:  MOVWF  03
25E2:  MOVF   01,W
25E4:  ADDLW  1B
25E6:  MOVWF  FE9
25E8:  MOVLW  00
25EA:  ADDWFC 03,W
25EC:  MOVWF  FEA
25EE:  MOVFF  FEC,03
25F2:  MOVF   FED,F
25F4:  MOVF   FEF,W
25F6:  SUBLW  FF
25F8:  BNZ   2600
25FA:  INCFSZ 03,W
25FC:  BRA    2600
25FE:  BRA    2860
2600:  CLRF   19
2602:  BTFSC  FF2.7
2604:  BSF    19.7
2606:  BCF    FF2.7
.................... 		adc=adc_get(1);
2608:  MOVLW  01
260A:  MOVWF  x2F
260C:  MOVLB  0
260E:  CALL   0594
2612:  BTFSC  19.7
2614:  BSF    FF2.7
2616:  MOVFF  02,11E
261A:  MOVFF  01,11D
.................... 
.................... 		if ( adc < config.ch[c].ltd_reconnect_adc ) {
261E:  MOVLB  1
2620:  MOVF   x1C,W
2622:  MULLW  24
2624:  MOVF   FF3,W
2626:  CLRF   x20
2628:  MOVWF  x1F
262A:  MOVLW  18
262C:  ADDWF  x1F,W
262E:  MOVWF  01
2630:  MOVLW  00
2632:  ADDWFC x20,W
2634:  MOVWF  03
2636:  MOVF   01,W
2638:  ADDLW  1B
263A:  MOVWF  FE9
263C:  MOVLW  00
263E:  ADDWFC 03,W
2640:  MOVWF  FEA
2642:  MOVFF  FEC,03
2646:  MOVF   FED,F
2648:  MOVFF  FEF,01
264C:  MOVF   x1E,W
264E:  SUBWF  03,W
2650:  BNC   26DA
2652:  BNZ   265A
2654:  MOVF   01,W
2656:  SUBWF  x1D,W
2658:  BC    26DA
.................... 			if ( channel[c].ltd_reconnect_delay_seconds > 0 ) {
265A:  MOVF   x1C,W
265C:  MULLW  19
265E:  MOVF   FF3,W
2660:  CLRF   x20
2662:  MOVWF  x1F
2664:  MOVLW  13
2666:  ADDWF  x1F,W
2668:  MOVWF  01
266A:  MOVLW  00
266C:  ADDWFC x20,W
266E:  MOVWF  03
2670:  MOVF   01,W
2672:  ADDLW  DA
2674:  MOVWF  FE9
2676:  MOVLW  00
2678:  ADDWFC 03,W
267A:  MOVWF  FEA
267C:  MOVFF  FEC,120
2680:  MOVF   FED,F
2682:  MOVFF  FEF,11F
2686:  MOVF   x1F,F
2688:  BNZ   268E
268A:  MOVF   x20,F
268C:  BZ    26BC
.................... 				channel[c].ltd_reconnect_delay_seconds--;
268E:  MOVF   x1C,W
2690:  MULLW  19
2692:  MOVF   FF3,W
2694:  CLRF   x20
2696:  MOVWF  x1F
2698:  MOVLW  13
269A:  ADDWF  x1F,W
269C:  MOVWF  01
269E:  MOVLW  00
26A0:  ADDWFC x20,W
26A2:  MOVWF  03
26A4:  MOVF   01,W
26A6:  ADDLW  DA
26A8:  MOVWF  FE9
26AA:  MOVLW  00
26AC:  ADDWFC 03,W
26AE:  MOVWF  FEA
26B0:  MOVLW  FF
26B2:  ADDWF  FEF,F
26B4:  BC    26BA
26B6:  MOVF   FEE,F
26B8:  DECF   FED,F
.................... 			} else {
26BA:  BRA    26D8
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_LTD);
26BC:  MOVF   x1C,W
26BE:  MULLW  19
26C0:  MOVF   FF3,W
26C2:  CLRF   x20
26C4:  MOVWF  x1F
26C6:  MOVLW  DA
26C8:  ADDWF  x1F,W
26CA:  MOVWF  01
26CC:  MOVLW  00
26CE:  ADDWFC x20,W
26D0:  MOVFF  01,FE9
26D4:  MOVWF  FEA
26D6:  BCF    FEF.5
.................... 			}
.................... 		} else {
26D8:  BRA    2740
.................... 			channel[c].ltd_reconnect_delay_seconds=config.ch[c].ltd_reconnect_delay;
26DA:  MOVF   x1C,W
26DC:  MULLW  19
26DE:  MOVF   FF3,W
26E0:  CLRF   x20
26E2:  MOVWF  x1F
26E4:  MOVLW  13
26E6:  ADDWF  x1F,W
26E8:  MOVWF  01
26EA:  MOVLW  00
26EC:  ADDWFC x20,W
26EE:  MOVWF  03
26F0:  MOVF   01,W
26F2:  ADDLW  DA
26F4:  MOVWF  01
26F6:  MOVLW  00
26F8:  ADDWFC 03,F
26FA:  MOVFF  01,11F
26FE:  MOVFF  03,120
2702:  MOVF   x1C,W
2704:  MULLW  24
2706:  MOVF   FF3,W
2708:  CLRF   x22
270A:  MOVWF  x21
270C:  MOVLW  1A
270E:  ADDWF  x21,W
2710:  MOVWF  01
2712:  MOVLW  00
2714:  ADDWFC x22,W
2716:  MOVWF  03
2718:  MOVF   01,W
271A:  ADDLW  1B
271C:  MOVWF  FE9
271E:  MOVLW  00
2720:  ADDWFC 03,W
2722:  MOVWF  FEA
2724:  MOVFF  FEC,03
2728:  MOVF   FED,F
272A:  MOVFF  FEF,121
272E:  MOVFF  120,FEA
2732:  MOVFF  11F,FE9
2736:  MOVFF  03,FEC
273A:  MOVF   FED,F
273C:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc > config.ch[c].ltd_disconnect_adc ) {
2740:  MOVF   x1C,W
2742:  MULLW  24
2744:  MOVF   FF3,W
2746:  CLRF   x20
2748:  MOVWF  x1F
274A:  MOVLW  14
274C:  ADDWF  x1F,W
274E:  MOVWF  01
2750:  MOVLW  00
2752:  ADDWFC x20,W
2754:  MOVWF  03
2756:  MOVF   01,W
2758:  ADDLW  1B
275A:  MOVWF  FE9
275C:  MOVLW  00
275E:  ADDWFC 03,W
2760:  MOVWF  FEA
2762:  MOVFF  FEC,03
2766:  MOVF   FED,F
2768:  MOVFF  FEF,01
276C:  MOVF   03,W
276E:  SUBWF  x1E,W
2770:  BNC   27FA
2772:  BNZ   277A
2774:  MOVF   x1D,W
2776:  SUBWF  01,W
2778:  BC    27FA
.................... 			if ( channel[c].ltd_disconnect_delay_seconds > 0 ) {
277A:  MOVF   x1C,W
277C:  MULLW  19
277E:  MOVF   FF3,W
2780:  CLRF   x20
2782:  MOVWF  x1F
2784:  MOVLW  11
2786:  ADDWF  x1F,W
2788:  MOVWF  01
278A:  MOVLW  00
278C:  ADDWFC x20,W
278E:  MOVWF  03
2790:  MOVF   01,W
2792:  ADDLW  DA
2794:  MOVWF  FE9
2796:  MOVLW  00
2798:  ADDWFC 03,W
279A:  MOVWF  FEA
279C:  MOVFF  FEC,120
27A0:  MOVF   FED,F
27A2:  MOVFF  FEF,11F
27A6:  MOVF   x1F,F
27A8:  BNZ   27AE
27AA:  MOVF   x20,F
27AC:  BZ    27DC
.................... 				channel[c].ltd_disconnect_delay_seconds--;
27AE:  MOVF   x1C,W
27B0:  MULLW  19
27B2:  MOVF   FF3,W
27B4:  CLRF   x20
27B6:  MOVWF  x1F
27B8:  MOVLW  11
27BA:  ADDWF  x1F,W
27BC:  MOVWF  01
27BE:  MOVLW  00
27C0:  ADDWFC x20,W
27C2:  MOVWF  03
27C4:  MOVF   01,W
27C6:  ADDLW  DA
27C8:  MOVWF  FE9
27CA:  MOVLW  00
27CC:  ADDWFC 03,W
27CE:  MOVWF  FEA
27D0:  MOVLW  FF
27D2:  ADDWF  FEF,F
27D4:  BC    27DA
27D6:  MOVF   FEE,F
27D8:  DECF   FED,F
.................... 			} else {
27DA:  BRA    27F8
.................... 				bit_set(channel[c].state,CH_STATE_BIT_LTD);
27DC:  MOVF   x1C,W
27DE:  MULLW  19
27E0:  MOVF   FF3,W
27E2:  CLRF   x20
27E4:  MOVWF  x1F
27E6:  MOVLW  DA
27E8:  ADDWF  x1F,W
27EA:  MOVWF  01
27EC:  MOVLW  00
27EE:  ADDWFC x20,W
27F0:  MOVFF  01,FE9
27F4:  MOVWF  FEA
27F6:  BSF    FEF.5
.................... 			}
.................... 		} else {
27F8:  BRA    2860
.................... 			channel[c].ltd_disconnect_delay_seconds=config.ch[c].ltd_disconnect_delay;
27FA:  MOVF   x1C,W
27FC:  MULLW  19
27FE:  MOVF   FF3,W
2800:  CLRF   x20
2802:  MOVWF  x1F
2804:  MOVLW  11
2806:  ADDWF  x1F,W
2808:  MOVWF  01
280A:  MOVLW  00
280C:  ADDWFC x20,W
280E:  MOVWF  03
2810:  MOVF   01,W
2812:  ADDLW  DA
2814:  MOVWF  01
2816:  MOVLW  00
2818:  ADDWFC 03,F
281A:  MOVFF  01,11F
281E:  MOVFF  03,120
2822:  MOVF   x1C,W
2824:  MULLW  24
2826:  MOVF   FF3,W
2828:  CLRF   x22
282A:  MOVWF  x21
282C:  MOVLW  16
282E:  ADDWF  x21,W
2830:  MOVWF  01
2832:  MOVLW  00
2834:  ADDWFC x22,W
2836:  MOVWF  03
2838:  MOVF   01,W
283A:  ADDLW  1B
283C:  MOVWF  FE9
283E:  MOVLW  00
2840:  ADDWFC 03,W
2842:  MOVWF  FEA
2844:  MOVFF  FEC,03
2848:  MOVF   FED,F
284A:  MOVFF  FEF,121
284E:  MOVFF  120,FEA
2852:  MOVFF  11F,FE9
2856:  MOVFF  03,FEC
285A:  MOVF   FED,F
285C:  MOVFF  121,FEF
.................... 		}
.................... 	}
2860:  MOVLB  0
2862:  RETURN 0
.................... 
.................... 
.................... 	/* TODO: implement High Temperature Disconnect (HTD) */
.................... }
.................... 
.................... 
.................... void led_status_second_update(void) {
.................... 	static int8 second=0;
.................... 	static int8 cycle=0;
.................... 	int8 led;
.................... 
.................... 	/* update every other second */
.................... 	if ( second ) {
*
2A62:  MOVLB  1
2A64:  MOVF   x13,F
2A66:  BZ    2A6C
.................... 		second=0;
2A68:  CLRF   x13
.................... 		return;
2A6A:  BRA    2C14
.................... 	}
.................... 
.................... 	for ( led=0 ; led<2 ; led++ ) {
2A6C:  CLRF   x1C
2A6E:  MOVF   x1C,W
2A70:  SUBLW  01
2A72:  BNC   2B48
.................... 		if ( cycle < 8 ) {
2A74:  MOVF   x14,W
2A76:  SUBLW  07
2A78:  BNC   2AE0
.................... 			/* first 8 cycles are 8 bits of state bit field */
.................... 
.................... 			/* if bit is set, then we blink the number of times+1 of the bit we are in. So bit 1 set means we blink 2 times */
.................... 			if ( bit_test(channel[led].state,cycle) ) {
2A7A:  MOVF   x1C,W
2A7C:  MULLW  19
2A7E:  MOVF   FF3,W
2A80:  CLRF   x1E
2A82:  MOVWF  x1D
2A84:  MOVLW  DA
2A86:  ADDWF  x1D,W
2A88:  MOVWF  FE9
2A8A:  MOVLW  00
2A8C:  ADDWFC x1E,W
2A8E:  MOVWF  FEA
2A90:  MOVFF  FEF,00
2A94:  MOVF   x14,W
2A96:  MOVWF  01
2A98:  BZ    2AA2
2A9A:  BCF    FD8.0
2A9C:  RRCF   00,F
2A9E:  DECFSZ 01,F
2AA0:  BRA    2A9A
2AA2:  BTFSS  00.0
2AA4:  BRA    2ACE
.................... 				timers.led_blink[led]=cycle+1;      /* number of blinks */
2AA6:  CLRF   03
2AA8:  MOVF   x1C,W
2AAA:  ADDLW  D0
2AAC:  MOVWF  FE9
2AAE:  MOVLW  00
2AB0:  ADDWFC 03,W
2AB2:  MOVWF  FEA
2AB4:  MOVLW  01
2AB6:  ADDWF  x14,W
2AB8:  MOVWF  FEF
.................... 				timers.led_on[led]=BLINK_ON_TIME;   /* how long to be on */
2ABA:  CLRF   03
2ABC:  MOVF   x1C,W
2ABE:  ADDLW  D2
2AC0:  MOVWF  FE9
2AC2:  MOVLW  00
2AC4:  ADDWFC 03,W
2AC6:  MOVWF  FEA
2AC8:  MOVLW  FA
2ACA:  MOVWF  FEF
.................... 			} else {
2ACC:  BRA    2ADE
.................... 				timers.led_blink[led]=0;
2ACE:  CLRF   03
2AD0:  MOVF   x1C,W
2AD2:  ADDLW  D0
2AD4:  MOVWF  FE9
2AD6:  MOVLW  00
2AD8:  ADDWFC 03,W
2ADA:  MOVWF  FEA
2ADC:  CLRF   FEF
.................... 			}
.................... 		} else if ( 8 == cycle ) {
2ADE:  BRA    2B44
2AE0:  MOVF   x14,W
2AE2:  SUBLW  08
2AE4:  BNZ   2AF8
.................... 			/* solid light to mark start of next cycle */
.................... 			timers.led_blink[led]=255;
2AE6:  CLRF   03
2AE8:  MOVF   x1C,W
2AEA:  ADDLW  D0
2AEC:  MOVWF  FE9
2AEE:  MOVLW  00
2AF0:  ADDWFC 03,W
2AF2:  MOVWF  FEA
2AF4:  SETF   FEF
.................... 		} else if ( 9 == cycle ) {
2AF6:  BRA    2B44
2AF8:  MOVF   x14,W
2AFA:  SUBLW  09
2AFC:  BNZ   2B34
.................... 			/* solid on if contactor state is on, otherwise off */
.................... 			if ( timers.contactor[led] ) {
2AFE:  CLRF   03
2B00:  MOVF   x1C,W
2B02:  ADDLW  D6
2B04:  MOVWF  FE9
2B06:  MOVLW  00
2B08:  ADDWFC 03,W
2B0A:  MOVWF  FEA
2B0C:  MOVF   FEF,F
2B0E:  BZ    2B22
.................... 				timers.led_blink[led]=255;
2B10:  CLRF   03
2B12:  MOVF   x1C,W
2B14:  ADDLW  D0
2B16:  MOVWF  FE9
2B18:  MOVLW  00
2B1A:  ADDWFC 03,W
2B1C:  MOVWF  FEA
2B1E:  SETF   FEF
.................... 			} else {
2B20:  BRA    2B32
.................... 				timers.led_blink[led]=0;
2B22:  CLRF   03
2B24:  MOVF   x1C,W
2B26:  ADDLW  D0
2B28:  MOVWF  FE9
2B2A:  MOVLW  00
2B2C:  ADDWFC 03,W
2B2E:  MOVWF  FEA
2B30:  CLRF   FEF
.................... 			}
.................... 		} else {
2B32:  BRA    2B44
.................... 			/* blank period before starting the bit field */
.................... 			timers.led_blink[led]=0;
2B34:  CLRF   03
2B36:  MOVF   x1C,W
2B38:  ADDLW  D0
2B3A:  MOVWF  FE9
2B3C:  MOVLW  00
2B3E:  ADDWFC 03,W
2B40:  MOVWF  FEA
2B42:  CLRF   FEF
.................... 		}
2B44:  INCF   x1C,F
2B46:  BRA    2A6E
.................... 	}
.................... 
.................... 	fprintf(STREAM_FTDI,"# LED %u A=%03u (0x%02X) B=%03u (0x%02X)\r\n",cycle,timers.led_blink[0],channel[0].state,timers.led_blink[1],channel[1].state);
2B48:  MOVLW  F4
2B4A:  MOVWF  FF6
2B4C:  MOVLW  13
2B4E:  MOVWF  FF7
2B50:  MOVLW  06
2B52:  MOVWF  x1D
2B54:  MOVLB  0
2B56:  CALL   1BA2
2B5A:  MOVFF  114,11D
2B5E:  MOVLW  1B
2B60:  MOVLB  1
2B62:  MOVWF  x1E
2B64:  MOVLB  0
2B66:  RCALL  299E
2B68:  MOVLW  FC
2B6A:  MOVWF  FF6
2B6C:  MOVLW  13
2B6E:  MOVWF  FF7
2B70:  MOVLW  03
2B72:  MOVLB  1
2B74:  MOVWF  x1D
2B76:  MOVLB  0
2B78:  CALL   1BA2
2B7C:  MOVFF  D0,11D
2B80:  MOVLW  03
2B82:  MOVLB  1
2B84:  MOVWF  x1E
2B86:  MOVLB  0
2B88:  RCALL  299E
2B8A:  MOVLW  03
2B8C:  MOVWF  FF6
2B8E:  MOVLW  14
2B90:  MOVWF  FF7
2B92:  MOVLW  04
2B94:  MOVLB  1
2B96:  MOVWF  x1D
2B98:  MOVLB  0
2B9A:  CALL   1BA2
2B9E:  MOVFF  DA,11D
2BA2:  MOVLW  37
2BA4:  MOVLB  1
2BA6:  MOVWF  x1E
2BA8:  MOVLB  0
2BAA:  RCALL  2A1C
2BAC:  MOVLW  0B
2BAE:  MOVWF  FF6
2BB0:  MOVLW  14
2BB2:  MOVWF  FF7
2BB4:  MOVLW  04
2BB6:  MOVLB  1
2BB8:  MOVWF  x1D
2BBA:  MOVLB  0
2BBC:  CALL   1BA2
2BC0:  MOVFF  D1,11D
2BC4:  MOVLW  03
2BC6:  MOVLB  1
2BC8:  MOVWF  x1E
2BCA:  MOVLB  0
2BCC:  RCALL  299E
2BCE:  MOVLW  13
2BD0:  MOVWF  FF6
2BD2:  MOVLW  14
2BD4:  MOVWF  FF7
2BD6:  MOVLW  04
2BD8:  MOVLB  1
2BDA:  MOVWF  x1D
2BDC:  MOVLB  0
2BDE:  CALL   1BA2
2BE2:  MOVFF  F3,11D
2BE6:  MOVLW  37
2BE8:  MOVLB  1
2BEA:  MOVWF  x1E
2BEC:  MOVLB  0
2BEE:  RCALL  2A1C
2BF0:  MOVLW  1B
2BF2:  MOVWF  FF6
2BF4:  MOVLW  14
2BF6:  MOVWF  FF7
2BF8:  MOVLW  03
2BFA:  MOVLB  1
2BFC:  MOVWF  x1D
2BFE:  MOVLB  0
2C00:  CALL   1BA2
.................... 
.................... 	if ( 10 == cycle ) {
2C04:  MOVLB  1
2C06:  MOVF   x14,W
2C08:  SUBLW  0A
2C0A:  BNZ   2C10
.................... 		cycle=0; 
2C0C:  CLRF   x14
.................... 	} else {
2C0E:  BRA    2C12
.................... 		cycle++;
2C10:  INCF   x14,F
.................... 	}
.................... 
.................... 	second++;
2C12:  INCF   x13,F
2C14:  MOVLB  0
2C16:  GOTO   2DBA (RETURN)
.................... }
.................... 
.................... void led_on(int8 c) {
.................... 	if ( 0==c ) 
*
1C8C:  MOVLB  1
1C8E:  MOVF   x1C,F
1C90:  BNZ   1C98
.................... 		output_high(LED_A);
1C92:  BCF    F94.1
1C94:  BSF    F8B.1
1C96:  BRA    1C9C
.................... 	else
.................... 		output_high(LED_B);
1C98:  BCF    F94.2
1C9A:  BSF    F8B.2
1C9C:  MOVLB  0
1C9E:  RETURN 0
.................... }
.................... 
.................... void led_off(int8 c) {
.................... 	if ( 0==c ) 
1CA0:  MOVLB  1
1CA2:  MOVF   x1C,F
1CA4:  BNZ   1CAC
.................... 		output_low(LED_A);
1CA6:  BCF    F94.1
1CA8:  BCF    F8B.1
1CAA:  BRA    1CB0
.................... 	else
.................... 		output_low(LED_B);
1CAC:  BCF    F94.2
1CAE:  BCF    F8B.2
1CB0:  MOVLB  0
1CB2:  RETURN 0
.................... }
.................... 
.................... void periodic_millisecond(void) {
.................... 	static int8 uptimeticks=0;
.................... 	static int16 adcTicks=0;
.................... 	static int16 ticks=0;
.................... 
.................... 	int8 i;
.................... 
.................... 
.................... 	timers.now_millisecond=0;
*
2C1A:  BCF    xCF.2
.................... 
.................... 	/* set LED output */
.................... 	for ( i=0 ; i<2 ; i++ ) {
2C1C:  MOVLB  1
2C1E:  CLRF   x1B
2C20:  MOVF   x1B,W
2C22:  SUBLW  01
2C24:  BTFSS  FD8.0
2C26:  BRA    2D26
.................... 		if ( 255 == timers.led_blink[i] ) {
2C28:  CLRF   03
2C2A:  MOVF   x1B,W
2C2C:  ADDLW  D0
2C2E:  MOVWF  FE9
2C30:  MOVLW  00
2C32:  ADDWFC 03,W
2C34:  MOVWF  FEA
2C36:  MOVF   FEF,W
2C38:  SUBLW  FF
2C3A:  BNZ   2C4A
.................... 			led_on(i);
2C3C:  MOVFF  11B,11C
2C40:  MOVLB  0
2C42:  CALL   1C8C
.................... 		} else if ( 0 == timers.led_blink[i] ) {
2C46:  BRA    2D20
2C48:  MOVLB  1
2C4A:  CLRF   03
2C4C:  MOVF   x1B,W
2C4E:  ADDLW  D0
2C50:  MOVWF  FE9
2C52:  MOVLW  00
2C54:  ADDWFC 03,W
2C56:  MOVWF  FEA
2C58:  MOVF   FEF,W
2C5A:  BNZ   2C6A
.................... 			led_off(i);
2C5C:  MOVFF  11B,11C
2C60:  MOVLB  0
2C62:  CALL   1CA0
.................... 		} else {
2C66:  BRA    2D20
2C68:  MOVLB  1
.................... 			/* led_blink[i] is somewhere between 1 and 254 */
.................... 			if ( timers.led_on[i] > 0 ) {
2C6A:  CLRF   03
2C6C:  MOVF   x1B,W
2C6E:  ADDLW  D2
2C70:  MOVWF  FE9
2C72:  MOVLW  00
2C74:  ADDWFC 03,W
2C76:  MOVWF  FEA
2C78:  MOVF   FEF,F
2C7A:  BZ    2CBC
.................... 				led_on(i);
2C7C:  MOVFF  11B,11C
2C80:  MOVLB  0
2C82:  CALL   1C8C
.................... 				timers.led_on[i]--;
2C86:  CLRF   03
2C88:  MOVLB  1
2C8A:  MOVF   x1B,W
2C8C:  ADDLW  D2
2C8E:  MOVWF  FE9
2C90:  MOVLW  00
2C92:  ADDWFC 03,W
2C94:  MOVWF  FEA
2C96:  DECF   FEF,F
.................... 
.................... 				if ( 0==timers.led_on[i] ) {
2C98:  CLRF   03
2C9A:  MOVF   x1B,W
2C9C:  ADDLW  D2
2C9E:  MOVWF  FE9
2CA0:  MOVLW  00
2CA2:  ADDWFC 03,W
2CA4:  MOVWF  FEA
2CA6:  MOVF   FEF,W
2CA8:  BNZ   2CBC
.................... 					/* hit zero, switch to our off timer */
.................... 					timers.led_off[i]=BLINK_OFF_TIME;
2CAA:  CLRF   03
2CAC:  MOVF   x1B,W
2CAE:  ADDLW  D4
2CB0:  MOVWF  FE9
2CB2:  MOVLW  00
2CB4:  ADDWFC 03,W
2CB6:  MOVWF  FEA
2CB8:  MOVLW  64
2CBA:  MOVWF  FEF
.................... 				}
.................... 			}
.................... 
.................... 			if ( timers.led_off[i] > 0 ) {
2CBC:  CLRF   03
2CBE:  MOVF   x1B,W
2CC0:  ADDLW  D4
2CC2:  MOVWF  FE9
2CC4:  MOVLW  00
2CC6:  ADDWFC 03,W
2CC8:  MOVWF  FEA
2CCA:  MOVF   FEF,F
2CCC:  BZ    2D1E
.................... 				led_off(i);
2CCE:  MOVFF  11B,11C
2CD2:  MOVLB  0
2CD4:  CALL   1CA0
.................... 				timers.led_off[i]--;
2CD8:  CLRF   03
2CDA:  MOVLB  1
2CDC:  MOVF   x1B,W
2CDE:  ADDLW  D4
2CE0:  MOVWF  FE9
2CE2:  MOVLW  00
2CE4:  ADDWFC 03,W
2CE6:  MOVWF  FEA
2CE8:  DECF   FEF,F
.................... 
.................... 				if ( 0==timers.led_off[i] ) {
2CEA:  CLRF   03
2CEC:  MOVF   x1B,W
2CEE:  ADDLW  D4
2CF0:  MOVWF  FE9
2CF2:  MOVLW  00
2CF4:  ADDWFC 03,W
2CF6:  MOVWF  FEA
2CF8:  MOVF   FEF,W
2CFA:  BNZ   2D1E
.................... 					/* hit zero, preload for next */
.................... 					timers.led_on[i]=BLINK_ON_TIME;
2CFC:  CLRF   03
2CFE:  MOVF   x1B,W
2D00:  ADDLW  D2
2D02:  MOVWF  FE9
2D04:  MOVLW  00
2D06:  ADDWFC 03,W
2D08:  MOVWF  FEA
2D0A:  MOVLW  FA
2D0C:  MOVWF  FEF
.................... 					/* done with this blink cycle */	
.................... 					timers.led_blink[i]--;
2D0E:  CLRF   03
2D10:  MOVF   x1B,W
2D12:  ADDLW  D0
2D14:  MOVWF  FE9
2D16:  MOVLW  00
2D18:  ADDWFC 03,W
2D1A:  MOVWF  FEA
2D1C:  DECF   FEF,F
2D1E:  MOVLB  0
.................... 				}
.................... 			}
.................... 		}
2D20:  MOVLB  1
2D22:  INCF   x1B,F
2D24:  BRA    2C20
.................... 	}
.................... 
.................... 
.................... 	/* some other random stuff that we don't need to do every cycle in main */
.................... 	if ( current.interval_milliseconds < 65535 ) {
2D26:  MOVLB  0
2D28:  INCFSZ xC8,W
2D2A:  BRA    2D32
2D2C:  INCFSZ xC9,W
2D2E:  BRA    2D32
2D30:  BRA    2D38
.................... 		current.interval_milliseconds++;
2D32:  INCF   xC8,F
2D34:  BTFSC  FD8.2
2D36:  INCF   xC9,F
.................... 	}
.................... 
.................... 
.................... 	/* contactor timeout */
.................... 	if ( 0 == timers.contactor_powersave[0] ) {
2D38:  MOVF   xD8,F
2D3A:  BNZ   2D46
.................... 		output_low(BRIDGE_A_A);
2D3C:  BCF    F94.3
2D3E:  BCF    F8B.3
.................... 		output_low(BRIDGE_A_B);
2D40:  BCF    F94.4
2D42:  BCF    F8B.4
.................... 	} else {
2D44:  BRA    2D48
.................... 		timers.contactor_powersave[0]--;
2D46:  DECF   xD8,F
.................... 	}
.................... 	if ( 0 == timers.contactor_powersave[1] ) {
2D48:  MOVF   xD9,F
2D4A:  BNZ   2D56
.................... 		output_low(BRIDGE_B_A);
2D4C:  BCF    F94.5
2D4E:  BCF    F8B.5
.................... 		output_low(BRIDGE_B_B);
2D50:  BCF    F94.6
2D52:  BCF    F8B.6
.................... 	} else {
2D54:  BRA    2D58
.................... 		timers.contactor_powersave[1]--;
2D56:  DECF   xD9,F
.................... 	}
.................... 
.................... 
.................... 
.................... 
.................... 	/* seconds */
.................... 	ticks++;
2D58:  MOVLB  1
2D5A:  INCF   x18,F
2D5C:  BTFSC  FD8.2
2D5E:  INCF   x19,F
.................... 	if ( 1000 == ticks ) {
2D60:  MOVF   x18,W
2D62:  SUBLW  E8
2D64:  BNZ   2DBC
2D66:  MOVF   x19,W
2D68:  SUBLW  03
2D6A:  BNZ   2DBC
.................... 		ticks=0;
2D6C:  CLRF   x19
2D6E:  CLRF   x18
.................... 
.................... 		/* set channe[n].state based on logic */
.................... 		contactor_logic(0);
2D70:  CLRF   x1C
2D72:  MOVLB  0
2D74:  CALL   1CB4
.................... 		contactor_logic(1);
2D78:  MOVLW  01
2D7A:  MOVLB  1
2D7C:  MOVWF  x1C
2D7E:  MOVLB  0
2D80:  CALL   1CB4
.................... 
.................... 		/* set contactor outputs based on their state bit field */
.................... 		contactor_set(0);
2D84:  MOVLB  1
2D86:  CLRF   x1C
2D88:  MOVLB  0
2D8A:  RCALL  2910
.................... 		contactor_set(1);		
2D8C:  MOVLW  01
2D8E:  MOVLB  1
2D90:  MOVWF  x1C
2D92:  MOVLB  0
2D94:  RCALL  2910
.................... 
.................... 		/* uptime counter */
.................... 		uptimeTicks++;
2D96:  MOVLB  1
2D98:  INCF   x15,F
.................... 		if ( 60 == uptimeTicks ) {
2D9A:  MOVF   x15,W
2D9C:  SUBLW  3C
2D9E:  BNZ   2DB6
.................... 			uptimeTicks=0;
2DA0:  CLRF   x15
.................... 			if ( current.uptime_minutes < 65535 ) 
2DA2:  MOVLB  0
2DA4:  INCFSZ xC6,W
2DA6:  BRA    2DAE
2DA8:  INCFSZ xC7,W
2DAA:  BRA    2DAE
2DAC:  BRA    2DB4
.................... 				current.uptime_minutes++;
2DAE:  INCF   xC6,F
2DB0:  BTFSC  FD8.2
2DB2:  INCF   xC7,F
2DB4:  MOVLB  1
.................... 		}
.................... 
.................... 		/* LED state display update */
.................... 		led_status_second_update();
2DB6:  MOVLB  0
2DB8:  BRA    2A62
2DBA:  MOVLB  1
.................... 	}
.................... 
.................... 	/* ADC sample counter */
.................... 	if ( timers.now_adc_reset_count ) {
2DBC:  MOVLB  0
2DBE:  BTFSS  xCF.1
2DC0:  BRA    2DCC
.................... 		timers.now_adc_reset_count=0;
2DC2:  BCF    xCF.1
.................... 		adcTicks=0;
2DC4:  MOVLB  1
2DC6:  CLRF   x17
2DC8:  CLRF   x16
2DCA:  MOVLB  0
.................... 	}
.................... 
.................... 	/* ADC sampling trigger */
.................... 	adcTicks++;
2DCC:  MOVLB  1
2DCE:  INCF   x16,F
2DD0:  BTFSC  FD8.2
2DD2:  INCF   x17,F
.................... 	if ( ADC_SAMPLE_TICKS == adcTicks ) {
2DD4:  MOVF   x16,W
2DD6:  SUBLW  14
2DD8:  BNZ   2DE8
2DDA:  MOVF   x17,F
2DDC:  BNZ   2DE8
.................... 		adcTicks=0;
2DDE:  CLRF   x17
2DE0:  CLRF   x16
.................... 		timers.now_adc_sample=1;
2DE2:  MOVLB  0
2DE4:  BSF    xCF.0
2DE6:  MOVLB  1
.................... 	}
2DE8:  MOVLB  0
2DEA:  GOTO   2FCC (RETURN)
.................... 
.................... }
.................... 
.................... void init(void) {
.................... 	int8 i;
.................... 	int8 buff[10];
.................... 	setup_oscillator(OSC_16MHZ);
*
1568:  MOVLW  70
156A:  MOVWF  FD3
156C:  BCF    F9B.6
156E:  BCF    F9B.7
.................... 
.................... 	setup_adc(ADC_CLOCK_DIV_16);
1570:  MOVF   FC0,W
1572:  ANDLW  C0
1574:  IORLW  05
1576:  MOVWF  FC0
1578:  BSF    FC0.7
157A:  BSF    FC2.0
.................... 	/* NTC thermistor on sAN2, input voltage divider on sAN4, DIP switch analog on sAN9
.................... 	voltage spans between 0 and Vdd */
.................... 	setup_adc_ports(sAN2 | sAN4 | sAN9,VSS_VDD);
157C:  MOVLW  14
157E:  MOVWF  F7E
1580:  BCF    FC1.0
1582:  BCF    FC1.1
1584:  BCF    FC1.2
1586:  BCF    FC1.3
1588:  MOVLW  02
158A:  MOVWF  F7F
.................... 
.................... 	setup_wdt(WDT_512MS);
158C:  BSF    FD1.0
.................... 
.................... 	set_tris_a(0b00111111);
158E:  MOVLW  3F
1590:  MOVWF  F92
.................... 	set_tris_b(0b01110000);
1592:  MOVLW  70
1594:  MOVWF  F93
.................... 	set_tris_c(0b10000001);
1596:  MOVLW  81
1598:  MOVWF  F94
.................... //               76543210
.................... 
.................... 	port_a_pullups(0b00110000);
159A:  MOVLW  30
159C:  MOVWF  F77
159E:  BCF    FF1.7
.................... 	port_b_pullups(0b00000000);
15A0:  CLRF   F78
.................... //                   76543210
.................... 
.................... 	/* data structure initialization */
.................... 	/* all initialized to 0 on declaration. Just do this if need non-zero */
.................... 	for ( i=0 ; i<=1 ; i++ ) {
15A2:  MOVLB  1
15A4:  CLRF   x1B
15A6:  MOVF   x1B,W
15A8:  SUBLW  01
15AA:  BNC   1600
.................... 		channel[i].command_off_seconds=65535;
15AC:  MOVF   x1B,W
15AE:  MULLW  19
15B0:  MOVF   FF3,W
15B2:  CLRF   x27
15B4:  MOVWF  x26
15B6:  MOVLW  05
15B8:  ADDWF  x26,W
15BA:  MOVWF  01
15BC:  MOVLW  00
15BE:  ADDWFC x27,W
15C0:  MOVWF  03
15C2:  MOVF   01,W
15C4:  ADDLW  DA
15C6:  MOVWF  FE9
15C8:  MOVLW  00
15CA:  ADDWFC 03,W
15CC:  MOVWF  FEA
15CE:  SETF   FEC
15D0:  MOVF   FED,F
15D2:  SETF   FEF
.................... 		channel[i].command_on_seconds =65535;
15D4:  MOVF   x1B,W
15D6:  MULLW  19
15D8:  MOVF   FF3,W
15DA:  CLRF   x27
15DC:  MOVWF  x26
15DE:  MOVLW  01
15E0:  ADDWF  x26,W
15E2:  MOVWF  01
15E4:  MOVLW  00
15E6:  ADDWFC x27,W
15E8:  MOVWF  03
15EA:  MOVF   01,W
15EC:  ADDLW  DA
15EE:  MOVWF  FE9
15F0:  MOVLW  00
15F2:  ADDWFC 03,W
15F4:  MOVWF  FEA
15F6:  SETF   FEC
15F8:  MOVF   FED,F
15FA:  SETF   FEF
15FC:  INCF   x1B,F
15FE:  BRA    15A6
.................... 	}
.................... 
.................... 	/* get our compiled date from constant  
.................... 	'5-Feb-22'
.................... 	 01234567
.................... 
.................... 	'25-Feb-22'
.................... 	 012345678
.................... 	*/
.................... 	strcpy(buff,__DATE__);
1600:  MOVLW  01
1602:  MOVWF  FEA
1604:  MOVLW  1C
1606:  MOVWF  FE9
1608:  MOVLW  00
160A:  MOVLB  0
160C:  CALL   00BA
1610:  TBLRD*-
1612:  TBLRD*+
1614:  MOVF   FF5,W
1616:  MOVWF  FEE
1618:  IORLW  00
161A:  BNZ   1612
.................... 	i=0;
161C:  MOVLB  1
161E:  CLRF   x1B
.................... 	if ( '-' != buff[1] ) {
1620:  MOVF   x1D,W
1622:  SUBLW  2D
1624:  BZ    1644
.................... 		/* day can be one or two digits */
.................... 		current.compile_day =(buff[i]-'0')*10;
1626:  CLRF   03
1628:  MOVF   x1B,W
162A:  ADDLW  1C
162C:  MOVWF  FE9
162E:  MOVLW  01
1630:  ADDWFC 03,W
1632:  MOVWF  FEA
1634:  MOVLW  30
1636:  SUBWF  FEF,W
1638:  MULLW  0A
163A:  MOVFF  FF3,CD
163E:  MOVLB  0
.................... 		i++;
1640:  MOVLB  1
1642:  INCF   x1B,F
.................... 	}
.................... 	current.compile_day+=(buff[i]-'0');
1644:  CLRF   03
1646:  MOVF   x1B,W
1648:  ADDLW  1C
164A:  MOVWF  FE9
164C:  MOVLW  01
164E:  ADDWFC 03,W
1650:  MOVWF  FEA
1652:  MOVLW  30
1654:  SUBWF  FEF,W
1656:  MOVLB  0
1658:  ADDWF  xCD,F
.................... 	i+=2; /* now points to month */
165A:  MOVLW  02
165C:  MOVLB  1
165E:  ADDWF  x1B,F
.................... 
.................... 	/* determine month ... how annoying */
.................... 	if ( 'J'==buff[i+0] ) {
1660:  CLRF   03
1662:  MOVF   x1B,W
1664:  ADDLW  1C
1666:  MOVWF  FE9
1668:  MOVLW  01
166A:  ADDWFC 03,W
166C:  MOVWF  FEA
166E:  MOVF   FEF,W
1670:  SUBLW  4A
1672:  BNZ   16BE
.................... 		if ( 'A'==buff[i+1] )
1674:  MOVLW  01
1676:  ADDWF  x1B,W
1678:  CLRF   03
167A:  ADDLW  1C
167C:  MOVWF  FE9
167E:  MOVLW  01
1680:  ADDWFC 03,W
1682:  MOVWF  FEA
1684:  MOVF   FEF,W
1686:  SUBLW  41
1688:  BNZ   1694
.................... 			current.compile_month=1;
168A:  MOVLW  01
168C:  MOVLB  0
168E:  MOVWF  xCC
1690:  BRA    16BA
1692:  MOVLB  1
.................... 		else if ( 'N'==buff[i+2] )
1694:  MOVLW  02
1696:  ADDWF  x1B,W
1698:  CLRF   03
169A:  ADDLW  1C
169C:  MOVWF  FE9
169E:  MOVLW  01
16A0:  ADDWFC 03,W
16A2:  MOVWF  FEA
16A4:  MOVF   FEF,W
16A6:  SUBLW  4E
16A8:  BNZ   16B4
.................... 			current.compile_month=6;
16AA:  MOVLW  06
16AC:  MOVLB  0
16AE:  MOVWF  xCC
16B0:  BRA    16BA
16B2:  MOVLB  1
.................... 		else
.................... 			current.compile_month=7;
16B4:  MOVLW  07
16B6:  MOVLB  0
16B8:  MOVWF  xCC
.................... 	} else if ( 'A'==buff[i+0] ) {
16BA:  BRA    17D4
16BC:  MOVLB  1
16BE:  CLRF   03
16C0:  MOVF   x1B,W
16C2:  ADDLW  1C
16C4:  MOVWF  FE9
16C6:  MOVLW  01
16C8:  ADDWFC 03,W
16CA:  MOVWF  FEA
16CC:  MOVF   FEF,W
16CE:  SUBLW  41
16D0:  BNZ   16FC
.................... 		if ( 'P'==buff[i+1] )
16D2:  MOVLW  01
16D4:  ADDWF  x1B,W
16D6:  CLRF   03
16D8:  ADDLW  1C
16DA:  MOVWF  FE9
16DC:  MOVLW  01
16DE:  ADDWFC 03,W
16E0:  MOVWF  FEA
16E2:  MOVF   FEF,W
16E4:  SUBLW  50
16E6:  BNZ   16F2
.................... 			current.compile_month=4;
16E8:  MOVLW  04
16EA:  MOVLB  0
16EC:  MOVWF  xCC
16EE:  BRA    16F8
16F0:  MOVLB  1
.................... 		else
.................... 			current.compile_month=8;
16F2:  MOVLW  08
16F4:  MOVLB  0
16F6:  MOVWF  xCC
.................... 	} else if ( 'M'==buff[i+0] ) {
16F8:  BRA    17D4
16FA:  MOVLB  1
16FC:  CLRF   03
16FE:  MOVF   x1B,W
1700:  ADDLW  1C
1702:  MOVWF  FE9
1704:  MOVLW  01
1706:  ADDWFC 03,W
1708:  MOVWF  FEA
170A:  MOVF   FEF,W
170C:  SUBLW  4D
170E:  BNZ   173A
.................... 		if ( 'R'==buff[i+2] )
1710:  MOVLW  02
1712:  ADDWF  x1B,W
1714:  CLRF   03
1716:  ADDLW  1C
1718:  MOVWF  FE9
171A:  MOVLW  01
171C:  ADDWFC 03,W
171E:  MOVWF  FEA
1720:  MOVF   FEF,W
1722:  SUBLW  52
1724:  BNZ   1730
.................... 			current.compile_month=3;
1726:  MOVLW  03
1728:  MOVLB  0
172A:  MOVWF  xCC
172C:  BRA    1736
172E:  MOVLB  1
.................... 		else
.................... 			current.compile_month=5;
1730:  MOVLW  05
1732:  MOVLB  0
1734:  MOVWF  xCC
.................... 	} else if ( 'F'==buff[i+0] ) {
1736:  BRA    17D4
1738:  MOVLB  1
173A:  CLRF   03
173C:  MOVF   x1B,W
173E:  ADDLW  1C
1740:  MOVWF  FE9
1742:  MOVLW  01
1744:  ADDWFC 03,W
1746:  MOVWF  FEA
1748:  MOVF   FEF,W
174A:  SUBLW  46
174C:  BNZ   1758
.................... 		current.compile_month=2;
174E:  MOVLW  02
1750:  MOVLB  0
1752:  MOVWF  xCC
.................... 	} else if ( 'S'==buff[i+0] ) {
1754:  BRA    17D4
1756:  MOVLB  1
1758:  CLRF   03
175A:  MOVF   x1B,W
175C:  ADDLW  1C
175E:  MOVWF  FE9
1760:  MOVLW  01
1762:  ADDWFC 03,W
1764:  MOVWF  FEA
1766:  MOVF   FEF,W
1768:  SUBLW  53
176A:  BNZ   1776
.................... 		current.compile_month=9;
176C:  MOVLW  09
176E:  MOVLB  0
1770:  MOVWF  xCC
.................... 	} else if ( 'O'==buff[i+0] ) {
1772:  BRA    17D4
1774:  MOVLB  1
1776:  CLRF   03
1778:  MOVF   x1B,W
177A:  ADDLW  1C
177C:  MOVWF  FE9
177E:  MOVLW  01
1780:  ADDWFC 03,W
1782:  MOVWF  FEA
1784:  MOVF   FEF,W
1786:  SUBLW  4F
1788:  BNZ   1794
.................... 		current.compile_month=10;
178A:  MOVLW  0A
178C:  MOVLB  0
178E:  MOVWF  xCC
.................... 	} else if ( 'N'==buff[i+0] ) {
1790:  BRA    17D4
1792:  MOVLB  1
1794:  CLRF   03
1796:  MOVF   x1B,W
1798:  ADDLW  1C
179A:  MOVWF  FE9
179C:  MOVLW  01
179E:  ADDWFC 03,W
17A0:  MOVWF  FEA
17A2:  MOVF   FEF,W
17A4:  SUBLW  4E
17A6:  BNZ   17B2
.................... 		current.compile_month=11;
17A8:  MOVLW  0B
17AA:  MOVLB  0
17AC:  MOVWF  xCC
.................... 	} else if ( 'D'==buff[i+0] ) {
17AE:  BRA    17D4
17B0:  MOVLB  1
17B2:  CLRF   03
17B4:  MOVF   x1B,W
17B6:  ADDLW  1C
17B8:  MOVWF  FE9
17BA:  MOVLW  01
17BC:  ADDWFC 03,W
17BE:  MOVWF  FEA
17C0:  MOVF   FEF,W
17C2:  SUBLW  44
17C4:  BNZ   17D0
.................... 		current.compile_month=12;
17C6:  MOVLW  0C
17C8:  MOVLB  0
17CA:  MOVWF  xCC
.................... 	} else {
17CC:  BRA    17D4
17CE:  MOVLB  1
.................... 		/* error parsing, shouldn't happen */
.................... 		current.compile_month=255;
17D0:  MOVLB  0
17D2:  SETF   xCC
.................... 	}
.................... 	current.compile_year =(buff[i+4]-'0')*10;
17D4:  MOVLW  04
17D6:  MOVLB  1
17D8:  ADDWF  x1B,W
17DA:  CLRF   03
17DC:  ADDLW  1C
17DE:  MOVWF  FE9
17E0:  MOVLW  01
17E2:  ADDWFC 03,W
17E4:  MOVWF  FEA
17E6:  MOVLW  30
17E8:  SUBWF  FEF,W
17EA:  MULLW  0A
17EC:  MOVFF  FF3,CB
17F0:  MOVLB  0
.................... 	current.compile_year+=(buff[i+5]-'0');
17F2:  MOVLW  05
17F4:  MOVLB  1
17F6:  ADDWF  x1B,W
17F8:  CLRF   03
17FA:  ADDLW  1C
17FC:  MOVWF  FE9
17FE:  MOVLW  01
1800:  ADDWFC 03,W
1802:  MOVWF  FEA
1804:  MOVLW  30
1806:  SUBWF  FEF,W
1808:  MOVLB  0
180A:  ADDWF  xCB,F
.................... 
.................... 
.................... 	/* one periodic interrupt @ 1mS. Generated from system 16 MHz clock */
.................... 	/* prescale=16, match=249, postscale=1. Match is 249 because when match occurs, one cycle is lost */
.................... 	setup_timer_2(T2_DIV_BY_16,249,1);
180C:  MOVLW  00
180E:  IORLW  06
1810:  MOVWF  FCA
1812:  MOVLW  F9
1814:  MOVWF  FCB
.................... 
.................... 	enable_interrupts(INT_TIMER2);
1816:  BSF    F9D.1
.................... 
.................... 	/* set I2C slave address, which is always an even number */
.................... 	i2c_slaveaddr(STREAM_SLAVE,0x3e + (read_dip_switch()<<1) );
1818:  BRA    14F6
181A:  BCF    FD8.0
181C:  RLCF   01,W
181E:  ADDLW  3E
1820:  MOVLB  1
1822:  MOVWF  FC8
1824:  MOVLB  0
1826:  GOTO   2E98 (RETURN)
.................... }
.................... 
.................... 
.................... void main(void) {
*
2E06:  CLRF   FF8
2E08:  BCF    FD0.7
2E0A:  BSF    07.7
2E0C:  BSF    F93.6
2E0E:  BSF    F93.4
2E10:  CLRF   FC8
2E12:  MOVLW  36
2E14:  MOVWF  FC6
2E16:  BSF    FC5.0
2E18:  BSF    FC5.7
2E1A:  CLRF   1A
2E1C:  BSF    FB8.3
2E1E:  MOVLW  44
2E20:  MOVWF  FAF
2E22:  MOVLW  00
2E24:  MOVWF  FB0
2E26:  MOVLW  A6
2E28:  MOVWF  FAC
2E2A:  MOVLW  90
2E2C:  MOVWF  FAB
2E2E:  MOVLB  1
2E30:  CLRF   x12
2E32:  CLRF   x11
2E34:  MOVLW  00
2E36:  MOVWF  F7E
2E38:  BCF    FC1.0
2E3A:  BCF    FC1.1
2E3C:  BCF    FC1.2
2E3E:  BCF    FC1.3
2E40:  MOVWF  F7F
2E42:  CLRF   F6C
2E44:  CLRF   F6B
2E46:  CLRF   F6D
2E48:  BRA    2E54
2E4A:  DATA F6,40
2E4C:  DATA 1B,00
2E4E:  DATA 07,41
2E50:  DATA 13,00
2E52:  DATA 00,00
2E54:  MOVLW  00
2E56:  MOVWF  FF8
2E58:  MOVLW  2E
2E5A:  MOVWF  FF7
2E5C:  MOVLW  4A
2E5E:  MOVWF  FF6
2E60:  TBLRD*+
2E62:  MOVF   FF5,W
2E64:  MOVWF  00
2E66:  XORLW  00
2E68:  BZ    2E90
2E6A:  TBLRD*+
2E6C:  MOVF   FF5,W
2E6E:  MOVWF  01
2E70:  BTFSC  FE8.7
2E72:  BRA    2E7E
2E74:  ANDLW  3F
2E76:  MOVWF  FEA
2E78:  TBLRD*+
2E7A:  MOVFF  FF5,FE9
2E7E:  BTFSC  01.6
2E80:  TBLRD*+
2E82:  BTFSS  01.6
2E84:  TBLRD*+
2E86:  MOVFF  FF5,FEE
2E8A:  DCFSNZ 00,F
2E8C:  BRA    2E60
2E8E:  BRA    2E82
2E90:  CLRF   FF8
.................... 	int8 i;
.................... 
.................... 	init();
2E92:  MOVLB  0
2E94:  GOTO   1568
.................... 
.................... 
.................... 	/* read parameters from EEPROM and write defaults if CRC doesn't match */
.................... 	read_param_file();
2E98:  GOTO   1B5C
.................... 
.................... 
.................... 	/* flash on startup */
.................... 	for ( i=0 ; i<5 ; i++ ) {
2E9C:  MOVLB  1
2E9E:  CLRF   x1A
2EA0:  MOVF   x1A,W
2EA2:  SUBLW  04
2EA4:  BNC   2ECC
.................... 		restart_wdt();
2EA6:  CLRWDT
.................... 		output_high(LED_A);
2EA8:  BCF    F94.1
2EAA:  BSF    F8B.1
.................... 		delay_ms(200);
2EAC:  MOVLW  C8
2EAE:  MOVWF  x28
2EB0:  MOVLB  0
2EB2:  CALL   14CC
.................... 		output_low(LED_A);
2EB6:  BCF    F94.1
2EB8:  BCF    F8B.1
.................... 		delay_ms(200);
2EBA:  MOVLW  C8
2EBC:  MOVLB  1
2EBE:  MOVWF  x28
2EC0:  MOVLB  0
2EC2:  CALL   14CC
2EC6:  MOVLB  1
2EC8:  INCF   x1A,F
2ECA:  BRA    2EA0
.................... 	}
.................... 
.................... 	fprintf(STREAM_FTDI,"# dcswc_module_latching_contactor %s\r\n# ",__DATE__);
2ECC:  MOVLW  20
2ECE:  MOVWF  FF6
2ED0:  MOVLW  14
2ED2:  MOVWF  FF7
2ED4:  MOVLW  22
2ED6:  MOVWF  x1D
2ED8:  MOVLB  0
2EDA:  CALL   1BA2
2EDE:  MOVLW  4A
2EE0:  MOVWF  FF6
2EE2:  MOVLW  14
2EE4:  MOVWF  FF7
2EE6:  CALL   1BCC
2EEA:  MOVLW  44
2EEC:  MOVWF  FF6
2EEE:  MOVLW  14
2EF0:  MOVWF  FF7
2EF2:  MOVLW  04
2EF4:  MOVLB  1
2EF6:  MOVWF  x1D
2EF8:  MOVLB  0
2EFA:  CALL   1BA2
.................... 	switch ( restart_cause ) {
2EFE:  MOVLW  07
2F00:  SUBWF  00,W
2F02:  BZ    2F28
2F04:  MOVLW  0B
2F06:  SUBWF  00,W
2F08:  BZ    2F36
2F0A:  MOVLW  0F
2F0C:  SUBWF  00,W
2F0E:  BZ    2F44
2F10:  MOVLW  0C
2F12:  SUBWF  00,W
2F14:  BZ    2F52
2F16:  MOVLW  0E
2F18:  SUBWF  00,W
2F1A:  BZ    2F60
2F1C:  MOVLW  03
2F1E:  SUBWF  00,W
2F20:  BZ    2F6E
2F22:  MOVF   00,F
2F24:  BZ    2F7C
2F26:  BRA    2F8A
.................... 		case WDT_TIMEOUT:       fprintf(STREAM_FTDI,"WDT TIMEOUT"); break;
2F28:  MOVLW  54
2F2A:  MOVWF  FF6
2F2C:  MOVLW  14
2F2E:  MOVWF  FF7
2F30:  CALL   1BCC
2F34:  BRA    2F96
.................... 		case MCLR_FROM_SLEEP:   fprintf(STREAM_FTDI,"MCLR FROM SLEEP"); break;
2F36:  MOVLW  60
2F38:  MOVWF  FF6
2F3A:  MOVLW  14
2F3C:  MOVWF  FF7
2F3E:  CALL   1BCC
2F42:  BRA    2F96
.................... 		case MCLR_FROM_RUN:     fprintf(STREAM_FTDI,"MCLR FROM RUN"); break;
2F44:  MOVLW  70
2F46:  MOVWF  FF6
2F48:  MOVLW  14
2F4A:  MOVWF  FF7
2F4C:  CALL   1BCC
2F50:  BRA    2F96
.................... 		case NORMAL_POWER_UP:   fprintf(STREAM_FTDI,"NORMAL POWER UP"); break;
2F52:  MOVLW  7E
2F54:  MOVWF  FF6
2F56:  MOVLW  14
2F58:  MOVWF  FF7
2F5A:  CALL   1BCC
2F5E:  BRA    2F96
.................... 		case BROWNOUT_RESTART:  fprintf(STREAM_FTDI,"BROWNOUT RESTART"); break;
2F60:  MOVLW  8E
2F62:  MOVWF  FF6
2F64:  MOVLW  14
2F66:  MOVWF  FF7
2F68:  CALL   1BCC
2F6C:  BRA    2F96
.................... 		case WDT_FROM_SLEEP:    fprintf(STREAM_FTDI,"WDT FROM SLEEP"); break;
2F6E:  MOVLW  A0
2F70:  MOVWF  FF6
2F72:  MOVLW  14
2F74:  MOVWF  FF7
2F76:  CALL   1BCC
2F7A:  BRA    2F96
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_FTDI,"RESET INSTRUCTION"); break;
2F7C:  MOVLW  B0
2F7E:  MOVWF  FF6
2F80:  MOVLW  14
2F82:  MOVWF  FF7
2F84:  CALL   1BCC
2F88:  BRA    2F96
.................... 		default:                fprintf(STREAM_FTDI,"UNKNOWN!");
2F8A:  MOVLW  C2
2F8C:  MOVWF  FF6
2F8E:  MOVLW  14
2F90:  MOVWF  FF7
2F92:  CALL   1BCC
.................... 	}
.................... 	fprintf(STREAM_FTDI,"\r\n");
2F96:  MOVLW  0D
2F98:  BTFSS  F9E.4
2F9A:  BRA    2F98
2F9C:  MOVWF  FAD
2F9E:  MOVLW  0A
2FA0:  BTFSS  F9E.4
2FA2:  BRA    2FA0
2FA4:  MOVWF  FAD
.................... 
.................... 	enable_interrupts(GLOBAL);
2FA6:  MOVLW  C0
2FA8:  IORWF  FF2,F
.................... 
.................... 	/* Prime ADC filter */
.................... 	for ( i=0 ; i<30 ; i++ ) {
2FAA:  MOVLB  1
2FAC:  CLRF   x1A
2FAE:  MOVF   x1A,W
2FB0:  SUBLW  1D
2FB2:  BNC   2FC0
.................... 		adc_update();
2FB4:  MOVLB  0
2FB6:  CALL   1BEE
2FBA:  MOVLB  1
2FBC:  INCF   x1A,F
2FBE:  BRA    2FAE
.................... 	}
.................... 
.................... 
.................... 	/* enable I2C slave interrupt */
.................... 	enable_interrupts(INT_SSP);
2FC0:  BSF    F9D.3
.................... 
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
2FC2:  CLRWDT
.................... 
.................... 		if ( timers.now_millisecond ) {
2FC4:  MOVLB  0
2FC6:  BTFSS  xCF.2
2FC8:  BRA    2FCC
.................... 			periodic_millisecond();
2FCA:  BRA    2C1A
.................... 		}
.................... 
.................... 		if ( kbhit() ) {
2FCC:  BTFSS  F9E.5
2FCE:  BRA    2FD4
.................... 			getc();
2FD0:  BRA    2DEE
.................... 			timers.now_debug_dump=1;
2FD2:  BSF    xCF.5
.................... 		}
.................... 
.................... 		if ( timers.now_debug_dump ) {
2FD4:  BTFSS  xCF.5
2FD6:  BRA    2FDA
.................... 			timers.now_debug_dump=0;
2FD8:  BCF    xCF.5
.................... 
.................... //			debug_dump();
.................... 		}
.................... 
.................... 		if ( timers.now_adc_sample ) {
2FDA:  BTFSS  xCF.0
2FDC:  BRA    2FE4
.................... 			timers.now_adc_sample=0;
2FDE:  BCF    xCF.0
.................... 			adc_update();
2FE0:  CALL   1BEE
.................... 		}
.................... 
.................... 		if ( timers.now_write_config ) {
2FE4:  BTFSS  xCF.3
2FE6:  BRA    2FEE
.................... 			timers.now_write_config=0;
2FE8:  BCF    xCF.3
.................... 			write_param_file();
2FEA:  CALL   194A
.................... 		}
.................... 		if ( timers.now_reset_config ) {
2FEE:  BTFSS  xCF.4
2FF0:  BRA    2FF8
.................... 			timers.now_reset_config=0;
2FF2:  BCF    xCF.4
.................... 			write_default_param_file();
2FF4:  CALL   1996
.................... 		}
2FF8:  MOVLB  1
2FFA:  BRA    2FC2
.................... 
.................... 
.................... 	}
.................... 
.................... 
.................... }
2FFC:  BRA    2FFC

Configuration Fuses:
   Word  1: 2800   INTRC_IO NOPLLEN PCLKEN NOFCMEN NOIESO
   Word  2: 0E19   NOPUT NOBROWNOUT BORV19 NOWDT WDT128
   Word  3: 0000   NOHFOFST NOMCLR
   Word  4: 0009   STVREN NOLVP BBSIZ2K NOXINST DEBUG
   Word  5: C003   NOPROTECT NOCPB NOCPD
   Word  6: E003   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 4003   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.

ROM data:
F00000: 00 00 40 00                                        ..@.
