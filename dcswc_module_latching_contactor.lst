CCS PCH C Compiler, Version 5.090, 49113               14-Jan-22 15:57

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\dcswc_module_latching_contactor\dcswc_module_latching_contactor.lst

               ROM used:   6424 bytes (41%)
                           Largest free fragment is 9128
               RAM used:   220 (43%) at main() level
                           259 (51%) worst case
               Stack used: 4 locations (2 in main + 2 for interrupts)
               Stack size: 30

0000:  GOTO   12A8
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   00D4
0060:  BTFSS  F9D.3
0062:  GOTO   006C
0066:  BTFSC  F9E.3
0068:  GOTO   0102
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include "dcswc_module_latching_contactor.h"
.................... #include <18F14K22.h>
.................... //////////// Standard Header file for the PIC18F14K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F14K22
00BA:  CLRF   FF7
00BC:  ADDLW  CA
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  RETURN 0
00CA:  DATA 31,34
00CC:  DATA 2D,4A
00CE:  DATA 61,6E
00D0:  DATA 2D,32
00D2:  DATA 32,00
*
01A8:  DATA 23,20
01AA:  DATA 64,63
01AC:  DATA 73,77
01AE:  DATA 63,5F
01B0:  DATA 6D,6F
01B2:  DATA 64,75
01B4:  DATA 6C,65
01B6:  DATA 5F,6C
01B8:  DATA 61,74
01BA:  DATA 63,68
01BC:  DATA 69,6E
01BE:  DATA 67,5F
01C0:  DATA 63,6F
01C2:  DATA 6E,74
01C4:  DATA 61,63
01C6:  DATA 74,6F
01C8:  DATA 72,20
01CA:  DATA 25,73
01CC:  DATA 0D,0A
01CE:  DATA 23,20
01D0:  DATA 00,00
01D2:  DATA 31,34
01D4:  DATA 2D,4A
01D6:  DATA 61,6E
01D8:  DATA 2D,32
01DA:  DATA 32,00
01DC:  DATA 57,44
01DE:  DATA 54,20
01E0:  DATA 54,49
01E2:  DATA 4D,45
01E4:  DATA 4F,55
01E6:  DATA 54,00
01E8:  DATA 4D,43
01EA:  DATA 4C,52
01EC:  DATA 20,46
01EE:  DATA 52,4F
01F0:  DATA 4D,20
01F2:  DATA 53,4C
01F4:  DATA 45,45
01F6:  DATA 50,00
01F8:  DATA 4D,43
01FA:  DATA 4C,52
01FC:  DATA 20,46
01FE:  DATA 52,4F
0200:  DATA 4D,20
0202:  DATA 52,55
0204:  DATA 4E,00
0206:  DATA 4E,4F
0208:  DATA 52,4D
020A:  DATA 41,4C
020C:  DATA 20,50
020E:  DATA 4F,57
0210:  DATA 45,52
0212:  DATA 20,55
0214:  DATA 50,00
0216:  DATA 42,52
0218:  DATA 4F,57
021A:  DATA 4E,4F
021C:  DATA 55,54
021E:  DATA 20,52
0220:  DATA 45,53
0222:  DATA 54,41
0224:  DATA 52,54
0226:  DATA 00,00
0228:  DATA 57,44
022A:  DATA 54,20
022C:  DATA 46,52
022E:  DATA 4F,4D
0230:  DATA 20,53
0232:  DATA 4C,45
0234:  DATA 45,50
0236:  DATA 00,00
0238:  DATA 52,45
023A:  DATA 53,45
023C:  DATA 54,20
023E:  DATA 49,4E
0240:  DATA 53,54
0242:  DATA 52,55
0244:  DATA 43,54
0246:  DATA 49,4F
0248:  DATA 4E,00
024A:  DATA 55,4E
024C:  DATA 4B,4E
024E:  DATA 4F,57
0250:  DATA 4E,21
0252:  DATA 00,00
0254:  DATA 23,20
0256:  DATA 72,65
0258:  DATA 61,64
025A:  DATA 5F,64
025C:  DATA 69,70
025E:  DATA 5F,73
0260:  DATA 77,69
0262:  DATA 74,63
0264:  DATA 68,28
0266:  DATA 29,3D
0268:  DATA 25,75
026A:  DATA 0D,0A
026C:  DATA 00,00
026E:  DATA 23,20
0270:  DATA 20,20
0272:  DATA 20,76
0274:  DATA 69,6E
0276:  DATA 20,61
0278:  DATA 64,63
027A:  DATA 3D,25
027C:  DATA 6C,75
027E:  DATA 0D,0A
0280:  DATA 00,00
0282:  DATA 23,20
0284:  DATA 20,20
0286:  DATA 74,65
0288:  DATA 6D,70
028A:  DATA 20,61
028C:  DATA 64,63
028E:  DATA 3D,25
0290:  DATA 6C,75
0292:  DATA 0D,0A
0294:  DATA 00,00
0296:  DATA 23,20
0298:  DATA 64,69
029A:  DATA 70,20
029C:  DATA 73,77
029E:  DATA 20,61
02A0:  DATA 64,63
02A2:  DATA 3D,25
02A4:  DATA 6C,75
02A6:  DATA 0D,0A
02A8:  DATA 00,00
02AA:  DATA 23,20
02AC:  DATA 63,68
02AE:  DATA 61,6E
02B0:  DATA 6E,65
02B2:  DATA 6C,5B
02B4:  DATA 25,75
02B6:  DATA 5D,0D
02B8:  DATA 0A,00
02BA:  DATA 23,20
02BC:  DATA 20,20
02BE:  DATA 20,20
02C0:  DATA 20,20
02C2:  DATA 20,20
02C4:  DATA 20,20
02C6:  DATA 20,20
02C8:  DATA 20,20
02CA:  DATA 20,20
02CC:  DATA 20,20
02CE:  DATA 20,20
02D0:  DATA 20,20
02D2:  DATA 20,73
02D4:  DATA 74,61
02D6:  DATA 74,65
02D8:  DATA 3D,30
02DA:  DATA 78,25
02DC:  DATA 30,32
02DE:  DATA 78,0D
02E0:  DATA 0A,00
02E2:  DATA 23,20
02E4:  DATA 20,20
02E6:  DATA 20,20
02E8:  DATA 20,20
02EA:  DATA 20,20
02EC:  DATA 20,20
02EE:  DATA 63,6F
02F0:  DATA 6D,6D
02F2:  DATA 61,6E
02F4:  DATA 64,5F
02F6:  DATA 6F,6E
02F8:  DATA 5F,73
02FA:  DATA 65,63
02FC:  DATA 6F,6E
02FE:  DATA 64,73
0300:  DATA 3D,25
0302:  DATA 6C,75
0304:  DATA 0D,0A
0306:  DATA 00,00
0308:  DATA 23,20
030A:  DATA 20,20
030C:  DATA 20,20
030E:  DATA 20,63
0310:  DATA 6F,6D
0312:  DATA 6D,61
0314:  DATA 6E,64
0316:  DATA 5F,6F
0318:  DATA 6E,5F
031A:  DATA 68,6F
031C:  DATA 6C,64
031E:  DATA 5F,73
0320:  DATA 65,63
0322:  DATA 6F,6E
0324:  DATA 64,73
0326:  DATA 3D,25
0328:  DATA 6C,75
032A:  DATA 0D,0A
032C:  DATA 00,00
032E:  DATA 23,20
0330:  DATA 20,20
0332:  DATA 20,20
0334:  DATA 20,20
0336:  DATA 20,20
0338:  DATA 20,63
033A:  DATA 6F,6D
033C:  DATA 6D,61
033E:  DATA 6E,64
0340:  DATA 5F,6F
0342:  DATA 66,66
0344:  DATA 5F,73
0346:  DATA 65,63
0348:  DATA 6F,6E
034A:  DATA 64,73
034C:  DATA 3D,25
034E:  DATA 6C,75
0350:  DATA 0D,0A
0352:  DATA 00,00
0354:  DATA 23,20
0356:  DATA 20,20
0358:  DATA 20,20
035A:  DATA 63,6F
035C:  DATA 6D,6D
035E:  DATA 61,6E
0360:  DATA 64,5F
0362:  DATA 6F,66
0364:  DATA 66,5F
0366:  DATA 68,6F
0368:  DATA 6C,64
036A:  DATA 5F,73
036C:  DATA 65,63
036E:  DATA 6F,6E
0370:  DATA 64,73
0372:  DATA 3D,25
0374:  DATA 6C,75
0376:  DATA 0D,0A
0378:  DATA 00,00
037A:  DATA 23,20
037C:  DATA 6C,76
037E:  DATA 64,5F
0380:  DATA 64,69
0382:  DATA 73,63
0384:  DATA 6F,6E
0386:  DATA 6E,65
0388:  DATA 63,74
038A:  DATA 5F,64
038C:  DATA 65,6C
038E:  DATA 61,79
0390:  DATA 5F,73
0392:  DATA 65,63
0394:  DATA 6F,6E
0396:  DATA 64,73
0398:  DATA 3D,25
039A:  DATA 6C,75
039C:  DATA 0D,0A
039E:  DATA 00,00
03A0:  DATA 23,20
03A2:  DATA 20,6C
03A4:  DATA 76,64
03A6:  DATA 5F,72
03A8:  DATA 65,63
03AA:  DATA 6F,6E
03AC:  DATA 6E,65
03AE:  DATA 63,74
03B0:  DATA 5F,64
03B2:  DATA 65,6C
03B4:  DATA 61,79
03B6:  DATA 5F,73
03B8:  DATA 65,63
03BA:  DATA 6F,6E
03BC:  DATA 64,73
03BE:  DATA 3D,25
03C0:  DATA 75,0D
03C2:  DATA 0A,00
03C4:  DATA 23,20
03C6:  DATA 68,76
03C8:  DATA 64,5F
03CA:  DATA 64,69
03CC:  DATA 73,63
03CE:  DATA 6F,6E
03D0:  DATA 6E,65
03D2:  DATA 63,74
03D4:  DATA 5F,64
03D6:  DATA 65,6C
03D8:  DATA 61,79
03DA:  DATA 5F,73
03DC:  DATA 65,63
03DE:  DATA 6F,6E
03E0:  DATA 64,73
03E2:  DATA 3D,25
03E4:  DATA 6C,75
03E6:  DATA 0D,0A
03E8:  DATA 00,00
03EA:  DATA 23,20
03EC:  DATA 20,68
03EE:  DATA 76,64
03F0:  DATA 5F,72
03F2:  DATA 65,63
03F4:  DATA 6F,6E
03F6:  DATA 6E,65
03F8:  DATA 63,74
03FA:  DATA 5F,64
03FC:  DATA 65,6C
03FE:  DATA 61,79
0400:  DATA 5F,73
0402:  DATA 65,63
0404:  DATA 6F,6E
0406:  DATA 64,73
0408:  DATA 3D,25
040A:  DATA 75,0D
040C:  DATA 0A,00
*
08A8:  TBLRD*+
08AA:  MOVFF  FF6,DD
08AE:  MOVFF  FF7,DE
08B2:  MOVF   FF5,W
08B4:  BTFSS  F9E.4
08B6:  BRA    08B4
08B8:  MOVWF  FAD
08BA:  MOVFF  DD,FF6
08BE:  MOVFF  DE,FF7
08C2:  DECFSZ xDC,F
08C4:  BRA    08A8
08C6:  RETURN 0
08C8:  TBLRD*+
08CA:  MOVF   FF5,F
08CC:  BZ    08E8
08CE:  MOVFF  FF6,D9
08D2:  MOVFF  FF7,DA
08D6:  MOVF   FF5,W
08D8:  BTFSS  F9E.4
08DA:  BRA    08D8
08DC:  MOVWF  FAD
08DE:  MOVFF  D9,FF6
08E2:  MOVFF  DA,FF7
08E6:  BRA    08C8
08E8:  RETURN 0
*
10E4:  MOVF   xDD,W
10E6:  CLRF   01
10E8:  SUBWF  xDC,W
10EA:  BC    10F2
10EC:  MOVFF  DC,00
10F0:  BRA    110A
10F2:  CLRF   00
10F4:  MOVLW  08
10F6:  MOVWF  xDE
10F8:  RLCF   xDC,F
10FA:  RLCF   00,F
10FC:  MOVF   xDD,W
10FE:  SUBWF  00,W
1100:  BTFSC  FD8.0
1102:  MOVWF  00
1104:  RLCF   01,F
1106:  DECFSZ xDE,F
1108:  BRA    10F8
110A:  RETURN 0
110C:  MOVF   01,W
110E:  MOVFF  DA,DC
1112:  MOVLW  64
1114:  MOVWF  xDD
1116:  RCALL  10E4
1118:  MOVFF  00,DA
111C:  MOVF   01,W
111E:  MOVLW  30
1120:  BNZ   1130
1122:  BTFSS  xDB.1
1124:  BRA    1140
1126:  BTFSC  xDB.3
1128:  BRA    1140
112A:  BTFSC  xDB.4
112C:  MOVLW  20
112E:  BRA    1136
1130:  BCF    xDB.3
1132:  BCF    xDB.4
1134:  BSF    xDB.0
1136:  ADDWF  01,F
1138:  MOVF   01,W
113A:  BTFSS  F9E.4
113C:  BRA    113A
113E:  MOVWF  FAD
1140:  MOVFF  DA,DC
1144:  MOVLW  0A
1146:  MOVWF  xDD
1148:  RCALL  10E4
114A:  MOVFF  00,DA
114E:  MOVF   01,W
1150:  MOVLW  30
1152:  BNZ   1160
1154:  BTFSC  xDB.3
1156:  BRA    116A
1158:  BTFSS  xDB.0
115A:  BRA    116A
115C:  BTFSC  xDB.4
115E:  MOVLW  20
1160:  ADDWF  01,F
1162:  MOVF   01,W
1164:  BTFSS  F9E.4
1166:  BRA    1164
1168:  MOVWF  FAD
116A:  MOVLW  30
116C:  ADDWF  xDA,F
116E:  MOVF   xDA,W
1170:  BTFSS  F9E.4
1172:  BRA    1170
1174:  MOVWF  FAD
1176:  RETURN 0
1178:  MOVFF  FEA,E3
117C:  MOVFF  FE9,E2
1180:  SWAPF  xDC,W
1182:  IORLW  F0
1184:  MOVWF  xDE
1186:  ADDWF  xDE,F
1188:  ADDLW  E2
118A:  MOVWF  xDF
118C:  ADDLW  32
118E:  MOVWF  xE1
1190:  MOVF   xDC,W
1192:  ANDLW  0F
1194:  ADDWF  xDF,F
1196:  ADDWF  xDF,F
1198:  ADDWF  xE1,F
119A:  ADDLW  E9
119C:  MOVWF  xE0
119E:  ADDWF  xE0,F
11A0:  ADDWF  xE0,F
11A2:  SWAPF  xDB,W
11A4:  ANDLW  0F
11A6:  ADDWF  xE0,F
11A8:  ADDWF  xE1,F
11AA:  RLCF   xE0,F
11AC:  RLCF   xE1,F
11AE:  COMF   xE1,F
11B0:  RLCF   xE1,F
11B2:  MOVF   xDB,W
11B4:  ANDLW  0F
11B6:  ADDWF  xE1,F
11B8:  RLCF   xDE,F
11BA:  MOVLW  07
11BC:  MOVWF  xDD
11BE:  MOVLW  0A
11C0:  DECF   xE0,F
11C2:  ADDWF  xE1,F
11C4:  BNC   11C0
11C6:  DECF   xDF,F
11C8:  ADDWF  xE0,F
11CA:  BNC   11C6
11CC:  DECF   xDE,F
11CE:  ADDWF  xDF,F
11D0:  BNC   11CC
11D2:  DECF   xDD,F
11D4:  ADDWF  xDE,F
11D6:  BNC   11D2
11D8:  CLRF   FEA
11DA:  MOVLW  DD
11DC:  MOVWF  FE9
11DE:  MOVLW  07
11E0:  ANDWF  xE2,W
11E2:  BCF    xE2.6
11E4:  ADDWF  FE9,F
11E6:  MOVLW  00
11E8:  ADDWFC FEA,F
11EA:  MOVF   FE9,W
11EC:  SUBLW  E1
11EE:  BNZ   11F6
11F0:  MOVF   FEA,F
11F2:  BNZ   11F6
11F4:  BSF    xE2.6
11F6:  MOVF   FEF,W
11F8:  MOVWF  00
11FA:  BNZ   120C
11FC:  BTFSC  xE2.6
11FE:  BRA    120C
1200:  BTFSC  xE2.4
1202:  BRA    121C
1204:  BTFSC  xE2.3
1206:  BRA    120C
1208:  MOVLW  20
120A:  BRA    1212
120C:  BSF    xE2.3
120E:  BCF    xE2.4
1210:  MOVLW  30
1212:  ADDWF  00,F
1214:  MOVF   00,W
1216:  BTFSS  F9E.4
1218:  BRA    1216
121A:  MOVWF  FAD
121C:  MOVF   FEE,W
121E:  BTFSS  xE2.6
1220:  BRA    11EA
1222:  RETURN 0
1224:  BTFSC  xDD.7
1226:  BRA    1248
1228:  MOVLW  0F
122A:  MOVWF  00
122C:  SWAPF  xDC,W
122E:  ANDWF  00,F
1230:  MOVLW  0A
1232:  SUBWF  00,W
1234:  BC    123C
1236:  MOVLW  30
1238:  ADDWF  00,F
123A:  BRA    1240
123C:  MOVF   xDD,W
123E:  ADDWF  00,F
1240:  MOVF   00,W
1242:  BTFSS  F9E.4
1244:  BRA    1242
1246:  MOVWF  FAD
1248:  MOVLW  0F
124A:  ANDWF  xDC,F
124C:  MOVLW  0A
124E:  SUBWF  xDC,W
1250:  BC    1256
1252:  MOVLW  30
1254:  BRA    125A
1256:  BCF    xDD.7
1258:  MOVF   xDD,W
125A:  ADDWF  xDC,F
125C:  MOVF   xDC,W
125E:  BTFSS  F9E.4
1260:  BRA    125E
1262:  MOVWF  FAD
1264:  GOTO   15DE (RETURN)
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #device *=16
.................... #use delay(clock=16MHz)
*
040E:  CLRF   FEA
0410:  MOVLW  FB
0412:  MOVWF  FE9
0414:  MOVF   FEF,W
0416:  BZ    0434
0418:  MOVLW  05
041A:  MOVWF  01
041C:  CLRF   00
041E:  DECFSZ 00,F
0420:  BRA    041E
0422:  DECFSZ 01,F
0424:  BRA    041C
0426:  MOVLW  2E
0428:  MOVWF  00
042A:  DECFSZ 00,F
042C:  BRA    042A
042E:  BRA    0430
0430:  DECFSZ FEF,F
0432:  BRA    0418
0434:  RETURN 0
.................... 
.................... /* hardware I2C port is slave and is connected to DCSWC bus */
.................... #use i2c(stream=STREAM_SLAVE,SLAVE, I2C1, FORCE_HW)
*
00EC:  MOVF   FC9,W
00EE:  MOVFF  FF,FC9
00F2:  BSF    FC6.4
00F4:  BCF    F9E.3
00F6:  BTFSC  FC7.0
00F8:  BRA    00F6
00FA:  CLRF   01
00FC:  BTFSS  FC5.6
00FE:  INCF   01,F
0100:  RETURN 0
.................... /* slave address set based on dip switch in init() */
.................... 
.................... 
.................... #fuses INTRC_IO
.................... #fuses NOPLLEN
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses PUT
.................... #fuses BROWNOUT
.................... #fuses WDT512
.................... #fuses NOHFOFST
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses NOLVP
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... #fuses NOPROTECT
.................... #fuses NOWRT
.................... #fuses NOWRTC 
.................... #fuses NOWRTB
.................... #fuses NOWRTD
.................... #fuses NOEBTR
.................... #fuses NOEBTRB
.................... 
.................... #use standard_io(ALL)
.................... 
.................... #use rs232(UART1,stream=STREAM_FTDI,baud=9600,errors)	
*
10CC:  BTFSS  F9E.5
10CE:  BRA    10CC
10D0:  MOVFF  FAB,19
10D4:  MOVFF  FAE,01
10D8:  BTFSS  19.1
10DA:  BRA    10E0
10DC:  BCF    FAB.4
10DE:  BSF    FAB.4
10E0:  GOTO   148A (RETURN)
.................... 
.................... /* program config CRC of 0 and a serial_prefix of 'A' ... that will trigger a write default on first boot */
.................... #ROM 0xF00000 = { 0x00, 0x00, 0x40, 0x00 }
.................... 
.................... 
.................... 
.................... 
.................... #define SW_OVERRIDE_A        PIN_A5
.................... #define SW_OVERRIDE_B        PIN_A4
.................... #define BRIDGE_B_A           PIN_C5
.................... #define BRIDGE_A_B           PIN_C4
.................... #define BRIDGE_A_A           PIN_C3
.................... #define BRIDGE_B_B           PIN_C6
.................... #define AN_DIP               PIN_C7
.................... #define SER_TO_PC            PIN_B7
.................... #define AN_VTEMP             PIN_A2
.................... #define AN_IN_VOLTS          PIN_C0
.................... #define LED_A                PIN_C1
.................... #define LED_B                PIN_C2
.................... #define I2C_SDA              PIN_B4
.................... #define SER_FROM_PC          PIN_B5
.................... #define I2C_SCL              PIN_B6
.................... 
.................... 
.................... /* 
.................... Parameters are stored in EEPROM
.................... */
.................... #define PARAM_CRC_ADDRESS  0x00
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2
.................... 
.................... 
.................... 
.................... /* bit positions for a channel state byte */
.................... #define CH_STATE_BIT_FUTURE   7  /* reserved for future use */
.................... #define CH_STATE_BIT_HTD      6  /* high temperature disconnect */
.................... #define CH_STATE_BIT_LTD      5  /* low temperature disconnect */
.................... #define CH_STATE_BIT_HVD      4  /* high voltage disconnect */
.................... #define CH_STATE_BIT_LVD      3  /* low voltage disconnect */
.................... #define CH_STATE_BIT_CMD_OFF  2  /* commanded off */
.................... #define CH_STATE_BIT_CMD_ON   1  /* commanded on (takes presedence over commanded off) */
.................... #define CH_STATE_BIT_OVERRIDE 0  /* override switch */
....................       
.................... 
.................... 
.................... #define CONTACTOR_POWER_SAVE_MS       200 /* milliseconds for contactor be on. Must be >0 and <= 255 */
.................... 
.................... 
.................... typedef struct {
.................... 	int16 lvd_disconnect_adc;
.................... 	int16 lvd_disconnect_delay;
.................... 	int16 lvd_reconnect_adc;
.................... 
.................... 	int16 hvd_disconnect_adc;
.................... 	int16 hvd_disconnect_delay;
.................... 	int16 hvd_reconnect_adc;
.................... } struct_config_channel;
.................... 
.................... typedef struct {
.................... 	int16 adc_sample_ticks;
.................... 
.................... 	int16 startup_power_on_delay;
.................... 	int8 reconnect_delay;
.................... 
.................... 	/* command_off in current */
.................... 	int16 command_off_hold_time;
.................... 	int16 command_on_hold_time;
.................... 
.................... 	struct_config_channel ch[2];
.................... } struct_config;
.................... 
.................... 
.................... typedef struct {
.................... 	int8 state;
.................... 
.................... 	int16 command_on_seconds;			/* counts down. Off at zero. */
.................... 	int16 command_on_hold_seconds;      /* counts down. Off at zero. */
.................... 
.................... 	int16 command_off_seconds;			/* counts down. Off at zero. */
.................... 	int16 command_off_hold_seconds;     /* counts down. Off at zero. */
.................... 
.................... 	int16 lvd_disconnect_delay_seconds;	/* counts down */
.................... 	int8  lvd_reconnect_delay_seconds;	/* counts down */
.................... 
.................... 	int16 hvd_disconnect_delay_seconds;	/* counts down */
.................... 	int8  hvd_reconnect_delay_seconds;	/* counts down */
.................... } struct_channel;
.................... 
.................... typedef struct {
.................... 	/* circular buffer for ADC readings */
.................... 	int16 adc_buffer[3][16];
.................... 	int8  adc_buffer_index;
.................... 
.................... 	int16 sequence_number;
.................... 	int16 uptime_minutes;
.................... 	int16 interval_milliseconds;
.................... 
.................... 	int8 factory_unlocked;
.................... 
.................... 
.................... 	int8 compile_year;
.................... 	int8 compile_month;
.................... 	int8 compile_day;
.................... 
.................... 
.................... 	int8 default_params_written;
.................... } struct_current;
.................... 
.................... typedef struct {
.................... 	/* action flags */
.................... 	int1 now_adc_sample;
.................... 	int1 now_adc_reset_count;
.................... 
.................... 	int1 now_millisecond;
.................... 
.................... 	int1 now_write_config;
.................... 	int1 now_reset_config;
.................... 
.................... 	/* timers */
.................... 	int8 led_on_a;
.................... 	int8 led_on_b;
.................... 
.................... 	int8  contactor_a_powersave;        /* counts down. Off at zero. */
.................... 	int8  contactor_b_powersave;        /* counts down. Off at zero. */
.................... 
.................... } struct_time_keep;
.................... 
.................... /* global structures */
.................... struct_config config={0};
.................... struct_current current={0};
.................... struct_time_keep timers={0};
.................... struct_channel channel[2]={0};
.................... 
.................... #include "adc_dcswc_module_latching_contactor.c"
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3};
.................... 
.................... int16 adc_get(int8 ch) {
.................... 	int16 sum;
.................... 	int8 i;
.................... 
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */
.................... 	int16 *p;
.................... 	p = current.adc_buffer[ch];
*
0980:  MOVF   xDC,W
0982:  MULLW  20
0984:  MOVF   FF3,W
0986:  CLRF   03
0988:  ADDLW  3B
098A:  MOVWF  01
098C:  MOVLW  00
098E:  ADDWFC 03,F
0990:  MOVFF  01,E0
0994:  MOVFF  03,E1
.................... 
.................... 	// Calculate the mean.  This is done by summing up the
.................... 	// values and dividing by the number of elements.
.................... 	sum = 0;
0998:  CLRF   xDE
099A:  CLRF   xDD
.................... 	for( i = 0; i < 16 ; i++ ) {
099C:  CLRF   xDF
099E:  MOVF   xDF,W
09A0:  SUBLW  0F
09A2:  BNC   09CE
.................... //		sum += current.adc_buffer[ch][i];
.................... 		sum += p[i];
09A4:  CLRF   03
09A6:  MOVFF  DF,02
09AA:  BCF    FD8.0
09AC:  RLCF   02,F
09AE:  RLCF   03,F
09B0:  MOVF   02,W
09B2:  ADDWF  xE0,W
09B4:  MOVWF  FE9
09B6:  MOVF   xE1,W
09B8:  ADDWFC 03,W
09BA:  MOVWF  FEA
09BC:  MOVFF  FEC,03
09C0:  MOVF   FED,F
09C2:  MOVF   FEF,W
09C4:  ADDWF  xDD,F
09C6:  MOVF   03,W
09C8:  ADDWFC xDE,F
09CA:  INCF   xDF,F
09CC:  BRA    099E
.................... 	}
.................... 
.................... 	/* divide sum by our 16 samples and round by adding 8 */
.................... 	return ( (sum+8) >> 4 );
09CE:  MOVLW  08
09D0:  ADDWF  xDD,W
09D2:  MOVWF  xE2
09D4:  MOVLW  00
09D6:  ADDWFC xDE,W
09D8:  MOVWF  xE3
09DA:  RRCF   xE3,W
09DC:  MOVWF  03
09DE:  RRCF   xE2,W
09E0:  MOVWF  02
09E2:  RRCF   03,F
09E4:  RRCF   02,F
09E6:  RRCF   03,F
09E8:  RRCF   02,F
09EA:  RRCF   03,F
09EC:  RRCF   02,F
09EE:  MOVLW  0F
09F0:  ANDWF  03,F
09F2:  MOVFF  02,01
09F6:  MOVFF  03,02
09FA:  RETURN 0
.................... }
.................... 
.................... 
.................... void adc_update(void) {
.................... 
.................... 	/* wrap buffer around */
.................... 	current.adc_buffer_index++;
*
08EA:  INCF   x9B,F
.................... 	if ( current.adc_buffer_index >= 16 )
08EC:  MOVF   x9B,W
08EE:  SUBLW  0F
08F0:  BC    08F4
.................... 		current.adc_buffer_index=0;
08F2:  CLRF   x9B
.................... 
.................... 	set_adc_channel(4);
08F4:  MOVLW  10
08F6:  MOVWF  01
08F8:  MOVF   FC2,W
08FA:  ANDLW  C3
08FC:  IORWF  01,W
08FE:  MOVWF  FC2
.................... 	current.adc_buffer[0][current.adc_buffer_index] = read_adc();
0900:  BCF    FD8.0
0902:  RLCF   x9B,W
0904:  CLRF   03
0906:  ADDLW  3B
0908:  MOVWF  FE9
090A:  MOVLW  00
090C:  ADDWFC 03,W
090E:  MOVWF  FEA
0910:  BSF    FC2.1
0912:  BTFSC  FC2.1
0914:  BRA    0912
0916:  MOVFF  FC3,FEF
091A:  MOVFF  FC4,FEC
.................... 
.................... 
.................... 	set_adc_channel(2);
091E:  MOVLW  08
0920:  MOVWF  01
0922:  MOVF   FC2,W
0924:  ANDLW  C3
0926:  IORWF  01,W
0928:  MOVWF  FC2
.................... 	delay_ms(1);
092A:  MOVLW  01
092C:  MOVWF  xFB
092E:  RCALL  040E
.................... 	current.adc_buffer[1][current.adc_buffer_index] = read_adc();
0930:  BCF    FD8.0
0932:  RLCF   x9B,W
0934:  CLRF   03
0936:  ADDLW  5B
0938:  MOVWF  FE9
093A:  MOVLW  00
093C:  ADDWFC 03,W
093E:  MOVWF  FEA
0940:  BSF    FC2.1
0942:  BTFSC  FC2.1
0944:  BRA    0942
0946:  MOVFF  FC3,FEF
094A:  MOVFF  FC4,FEC
.................... 
.................... 	set_adc_channel(9);
094E:  MOVLW  24
0950:  MOVWF  01
0952:  MOVF   FC2,W
0954:  ANDLW  C3
0956:  IORWF  01,W
0958:  MOVWF  FC2
.................... 	delay_ms(1);
095A:  MOVLW  01
095C:  MOVWF  xFB
095E:  RCALL  040E
.................... 	current.adc_buffer[2][current.adc_buffer_index] = read_adc();
0960:  BCF    FD8.0
0962:  RLCF   x9B,W
0964:  CLRF   03
0966:  ADDLW  7B
0968:  MOVWF  FE9
096A:  MOVLW  00
096C:  ADDWFC 03,W
096E:  MOVWF  FEA
0970:  BSF    FC2.1
0972:  BTFSC  FC2.1
0974:  BRA    0972
0976:  MOVFF  FC3,FEF
097A:  MOVFF  FC4,FEC
097E:  RETURN 0
.................... }
.................... 
.................... #include "param_dcswc_module_latching_contactor.c"
.................... #inline
.................... char xor_crc(char oldcrc, char data) {
.................... 	return oldcrc ^ data;
*
0630:  MOVF   xE6,W
0632:  XORWF  xE7,W
0634:  MOVWF  01
*
067A:  MOVF   xE6,W
067C:  XORWF  xE7,W
067E:  MOVWF  01
.................... }
.................... 
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) {
*
05CA:  CLRF   xE2
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
05CC:  MOVFF  E1,E4
05D0:  MOVF   xE0,W
05D2:  BTFSC  FD8.2
05D4:  DECF   xE1,F
05D6:  DECF   xE0,F
05D8:  MOVWF  xE3
05DA:  MOVF   xE3,F
05DC:  BNZ   05E2
05DE:  MOVF   xE4,F
05E0:  BZ    0642
.................... 		*data = read_eeprom( address++ );
05E2:  MOVFF  DF,03
05E6:  MOVF   xDE,W
05E8:  MOVWF  FE9
05EA:  MOVFF  03,FEA
05EE:  MOVF   xDD,W
05F0:  MOVWF  03
05F2:  MOVF   xDC,W
05F4:  INCF   xDC,F
05F6:  BTFSC  FD8.2
05F8:  INCF   xDD,F
05FA:  MOVWF  xE5
05FC:  MOVFF  03,E6
0600:  MOVFF  FF2,E7
0604:  BCF    FF2.7
0606:  MOVFF  E5,FA9
060A:  BCF    FA6.6
060C:  BCF    FA6.7
060E:  BSF    FA6.0
0610:  MOVF   FA8,W
0612:  BTFSC  xE7.7
0614:  BSF    FF2.7
0616:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data);
0618:  MOVFF  DF,03
061C:  MOVF   xDE,W
061E:  MOVWF  FE9
0620:  MOVFF  03,FEA
0624:  MOVFF  FEF,E3
0628:  MOVFF  E2,E6
062C:  MOVFF  E3,E7
*
0636:  MOVFF  01,E2
.................... 		data++;
063A:  INCF   xDE,F
063C:  BTFSC  FD8.2
063E:  INCF   xDF,F
0640:  BRA    05CC
.................... 	}
.................... 	return crc;
0642:  MOVFF  E2,01
0646:  GOTO   0886 (RETURN)
.................... }
.................... 
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) {
064A:  CLRF   xE4
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
064C:  MOVFF  E3,E6
0650:  MOVF   xE2,W
0652:  BTFSC  FD8.2
0654:  DECF   xE3,F
0656:  DECF   xE2,F
0658:  MOVWF  xE5
065A:  MOVF   xE5,F
065C:  BNZ   0662
065E:  MOVF   xE6,F
0660:  BZ    06DA
.................... 		/* restart_wdt() */
.................... 		crc = xor_crc(crc,*data);
0662:  MOVFF  E1,03
0666:  MOVF   xE0,W
0668:  MOVWF  FE9
066A:  MOVFF  03,FEA
066E:  MOVFF  FEF,E5
0672:  MOVFF  E4,E6
0676:  MOVFF  E5,E7
*
0680:  MOVFF  01,E4
.................... 		write_eeprom( address++, *data++ );
0684:  MOVF   xDF,W
0686:  MOVWF  03
0688:  MOVF   xDE,W
068A:  INCF   xDE,F
068C:  BTFSC  FD8.2
068E:  INCF   xDF,F
0690:  MOVWF  xE5
0692:  MOVFF  03,E6
0696:  MOVF   xE1,W
0698:  MOVWF  03
069A:  MOVF   xE0,W
069C:  INCF   xE0,F
069E:  BTFSC  FD8.2
06A0:  INCF   xE1,F
06A2:  MOVWF  FE9
06A4:  MOVFF  03,FEA
06A8:  MOVFF  FEF,E7
06AC:  MOVF   FF2,W
06AE:  MOVWF  00
06B0:  BCF    FF2.7
06B2:  MOVFF  E5,FA9
06B6:  MOVFF  E7,FA8
06BA:  BCF    FA6.6
06BC:  BCF    FA6.7
06BE:  BSF    FA6.2
06C0:  MOVLB  F
06C2:  MOVLW  55
06C4:  MOVWF  FA7
06C6:  MOVLW  AA
06C8:  MOVWF  FA7
06CA:  BSF    FA6.1
06CC:  BTFSC  FA6.1
06CE:  BRA    06CC
06D0:  BCF    FA6.2
06D2:  MOVF   00,W
06D4:  IORWF  FF2,F
06D6:  MOVLB  0
06D8:  BRA    064C
.................... 	}
.................... 
.................... 	return crc;
06DA:  MOVFF  E4,01
06DE:  GOTO   06FA (RETURN)
.................... }
.................... 
.................... void write_param_file() {
.................... 	int8 crc;
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config));
06E2:  MOVLW  1A
06E4:  MOVWF  xDC
06E6:  CLRF   xDF
06E8:  MOVLW  02
06EA:  MOVWF  xDE
06EC:  CLRF   xE1
06EE:  MOVFF  DC,E0
06F2:  CLRF   xE3
06F4:  MOVLW  21
06F6:  MOVWF  xE2
06F8:  BRA    064A
06FA:  MOVFF  01,DB
.................... 	/* write the CRC was calculated on the structure */
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc);
06FE:  MOVF   FF2,W
0700:  MOVWF  00
0702:  BCF    FF2.7
0704:  CLRF   FA9
0706:  MOVFF  DB,FA8
070A:  BCF    FA6.6
070C:  BCF    FA6.7
070E:  BSF    FA6.2
0710:  MOVLB  F
0712:  MOVLW  55
0714:  MOVWF  FA7
0716:  MOVLW  AA
0718:  MOVWF  FA7
071A:  BSF    FA6.1
071C:  BTFSC  FA6.1
071E:  BRA    071C
0720:  BCF    FA6.2
0722:  MOVF   00,W
0724:  IORWF  FF2,F
0726:  MOVLB  0
0728:  RETURN 0
.................... }
.................... 
.................... void write_default_param_file() {
.................... 	int8 i;
.................... 
.................... 	current.default_params_written=1;
072A:  MOVLW  01
072C:  MOVWF  xA6
.................... 
.................... 	/* both LEDs on */
.................... 	timers.led_on_a=150;
072E:  MOVLW  96
0730:  MOVWF  xA8
.................... 	timers.led_on_b=150;
0732:  MOVWF  xA9
.................... 
.................... 	config.adc_sample_ticks=20;
0734:  CLRF   1B
0736:  MOVLW  14
0738:  MOVWF  1A
.................... 
.................... 	config.startup_power_on_delay=5;
073A:  CLRF   1D
073C:  MOVLW  05
073E:  MOVWF  1C
.................... 	config.reconnect_delay=5;
0740:  MOVWF  1E
.................... 
.................... 	config.command_off_hold_time=2;
0742:  CLRF   20
0744:  MOVLW  02
0746:  MOVWF  1F
.................... 
.................... 	for ( i=0 ; i<2 ; i++ ) {
0748:  CLRF   xDA
074A:  MOVF   xDA,W
074C:  SUBLW  01
074E:  BTFSS  FD8.0
0750:  BRA    086A
.................... 		config.ch[i].lvd_disconnect_adc=190;
0752:  MOVF   xDA,W
0754:  MULLW  0C
0756:  MOVF   FF3,W
0758:  CLRF   03
075A:  ADDLW  23
075C:  MOVWF  FE9
075E:  MOVLW  00
0760:  ADDWFC 03,W
0762:  MOVWF  FEA
0764:  CLRF   FEC
0766:  MOVF   FED,F
0768:  MOVLW  BE
076A:  MOVWF  FEF
.................... 		config.ch[i].lvd_disconnect_delay=65535;
076C:  MOVF   xDA,W
076E:  MULLW  0C
0770:  MOVF   FF3,W
0772:  CLRF   03
0774:  ADDLW  09
0776:  MOVWF  xDB
0778:  MOVLW  00
077A:  ADDWFC 03,W
077C:  MOVWF  xDC
077E:  MOVLW  02
0780:  ADDWF  xDB,W
0782:  MOVWF  01
0784:  MOVLW  00
0786:  ADDWFC xDC,W
0788:  MOVWF  03
078A:  MOVF   01,W
078C:  ADDLW  1A
078E:  MOVWF  FE9
0790:  MOVLW  00
0792:  ADDWFC 03,W
0794:  MOVWF  FEA
0796:  SETF   FEC
0798:  MOVF   FED,F
079A:  SETF   FEF
.................... 		config.ch[i].lvd_reconnect_adc=200;
079C:  MOVF   xDA,W
079E:  MULLW  0C
07A0:  MOVF   FF3,W
07A2:  CLRF   03
07A4:  ADDLW  09
07A6:  MOVWF  xDB
07A8:  MOVLW  00
07AA:  ADDWFC 03,W
07AC:  MOVWF  xDC
07AE:  MOVLW  04
07B0:  ADDWF  xDB,W
07B2:  MOVWF  01
07B4:  MOVLW  00
07B6:  ADDWFC xDC,W
07B8:  MOVWF  03
07BA:  MOVF   01,W
07BC:  ADDLW  1A
07BE:  MOVWF  FE9
07C0:  MOVLW  00
07C2:  ADDWFC 03,W
07C4:  MOVWF  FEA
07C6:  CLRF   FEC
07C8:  MOVF   FED,F
07CA:  MOVLW  C8
07CC:  MOVWF  FEF
.................... 
.................... 		config.ch[i].hvd_disconnect_adc=1000;
07CE:  MOVF   xDA,W
07D0:  MULLW  0C
07D2:  MOVF   FF3,W
07D4:  CLRF   03
07D6:  ADDLW  09
07D8:  MOVWF  xDB
07DA:  MOVLW  00
07DC:  ADDWFC 03,W
07DE:  MOVWF  xDC
07E0:  MOVLW  06
07E2:  ADDWF  xDB,W
07E4:  MOVWF  01
07E6:  MOVLW  00
07E8:  ADDWFC xDC,W
07EA:  MOVWF  03
07EC:  MOVF   01,W
07EE:  ADDLW  1A
07F0:  MOVWF  FE9
07F2:  MOVLW  00
07F4:  ADDWFC 03,W
07F6:  MOVWF  FEA
07F8:  MOVLW  03
07FA:  MOVWF  FEC
07FC:  MOVF   FED,F
07FE:  MOVLW  E8
0800:  MOVWF  FEF
.................... 		config.ch[i].hvd_disconnect_delay=65535;
0802:  MOVF   xDA,W
0804:  MULLW  0C
0806:  MOVF   FF3,W
0808:  CLRF   03
080A:  ADDLW  09
080C:  MOVWF  xDB
080E:  MOVLW  00
0810:  ADDWFC 03,W
0812:  MOVWF  xDC
0814:  MOVLW  08
0816:  ADDWF  xDB,W
0818:  MOVWF  01
081A:  MOVLW  00
081C:  ADDWFC xDC,W
081E:  MOVWF  03
0820:  MOVF   01,W
0822:  ADDLW  1A
0824:  MOVWF  FE9
0826:  MOVLW  00
0828:  ADDWFC 03,W
082A:  MOVWF  FEA
082C:  SETF   FEC
082E:  MOVF   FED,F
0830:  SETF   FEF
.................... 		config.ch[i].hvd_reconnect_adc=900;
0832:  MOVF   xDA,W
0834:  MULLW  0C
0836:  MOVF   FF3,W
0838:  CLRF   03
083A:  ADDLW  09
083C:  MOVWF  xDB
083E:  MOVLW  00
0840:  ADDWFC 03,W
0842:  MOVWF  xDC
0844:  MOVLW  0A
0846:  ADDWF  xDB,W
0848:  MOVWF  01
084A:  MOVLW  00
084C:  ADDWFC xDC,W
084E:  MOVWF  03
0850:  MOVF   01,W
0852:  ADDLW  1A
0854:  MOVWF  FE9
0856:  MOVLW  00
0858:  ADDWFC 03,W
085A:  MOVWF  FEA
085C:  MOVLW  03
085E:  MOVWF  FEC
0860:  MOVF   FED,F
0862:  MOVLW  84
0864:  MOVWF  FEF
0866:  INCF   xDA,F
0868:  BRA    074A
.................... 	}
.................... 	
.................... 	/* write them so next time we use from EEPROM */
.................... 	write_param_file();
086A:  RCALL  06E2
086C:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void read_param_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config)); 
086E:  MOVLW  1A
0870:  MOVWF  xDA
0872:  CLRF   xDD
0874:  MOVLW  02
0876:  MOVWF  xDC
0878:  CLRF   xDF
087A:  MOVFF  DA,DE
087E:  CLRF   xE1
0880:  MOVLW  21
0882:  MOVWF  xE0
0884:  BRA    05CA
0886:  MOVFF  01,D9
.................... 		
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) {
088A:  MOVFF  FF2,DA
088E:  BCF    FF2.7
0890:  CLRF   FA9
0892:  BCF    FA6.6
0894:  BCF    FA6.7
0896:  BSF    FA6.0
0898:  MOVF   FA8,W
089A:  BTFSC  xDA.7
089C:  BSF    FF2.7
089E:  SUBWF  xD9,W
08A0:  BZ    08A4
.................... 		write_default_param_file();
08A2:  RCALL  072A
.................... 	}
08A4:  GOTO   1344 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... #include "i2c_handler_dcswc_module_latching_contactor.c"
.................... #include "registers_dcswc_module_latching_contactor.h"
.................... 
.................... /* first three registers will give enough information for telemetry */
.................... #define I2C_REG_VOLTAGE_INPUT_AVG             0  /* 10 bit input voltage ADC averaged value */
.................... #define I2C_REG_STATE_CONTACTORS              1  /* two 8 bit channel states (A is MSB / B is LSB) */
.................... #define I2C_REG_TEMPERATURE_BOARD_AVG         2  /* 10 bit NTC thermistor ADC averaged value */
.................... 
.................... #define I2C_REG_VOLTAGE_INPUT_NOW             3  /* 10 bit input voltage ADC latest value */
.................... #define I2C_REG_TEMPERATURE_BOARD_NOW         4  /* 10 bit NTC thermistor ADC latest value */
.................... 
.................... /* command can only come from I2C interface */
.................... #define I2C_REG_COMMAND_ON_A                  5  /* R/W seconds */
.................... #define I2C_REG_COMMAND_ON_B                  6
.................... 
.................... #define I2C_REG_COMMAND_OFF_A                 7  /* R/W seconds */
.................... #define I2C_REG_COMMAND_OFF_B                 8
.................... 
.................... /* low voltage disconnect */
.................... #define I2C_REG_LVD_DISCONNECT_A              9  /* R seconds */
.................... #define I2C_REG_LVD_DISCONNECT_B              10
.................... 
.................... /* high voltage disconnect */
.................... #define I2C_REG_HVD_DISCONNECT_A              11 /* R seconds */
.................... #define I2C_REG_HVD_DISCONNECT_B              12
.................... 
.................... /* low temperature disconnect */
.................... #define I2C_REG_LTD_DISCONNECT_A              9  /* R seconds */
.................... #define I2C_REG_LTD_DISCONNECT_B              10
.................... 
.................... /* high temperature disconnect */
.................... #define I2C_REG_HTD_DISCONNECT_A              11 /* R seconds */
.................... #define I2C_REG_HTD_DISCONNECT_B              12
.................... 
.................... /* reserved for future, unimplemented */
.................... #define I2C_REG_FUT_DISCONNECT_A              13 /* R seconds */
.................... #define I2C_REG_FUT_DISCONNECT_B              14
.................... 
.................... 
.................... #define I2C_REG_SEQUENCE_NUMBER               8  /* R */
.................... #define I2C_REG_TIME_INTERVAL_MILLISECONDS    9
.................... #define I2C_REG_TIME_UPTIME_MINUTES           10
.................... #define I2C_REG_DEFAULT_PARAMS_WRITTEN        13
.................... 
.................... 
.................... /* configuration */
.................... #define I2C_REG_CONFIG_HARDWARE_MODEL              128 /* R */
.................... #define I2C_REG_CONFIG_HARDWARE_VERSION            129
.................... #define I2C_REG_CONFIG_SOFTWARE_MODEL              130
.................... #define I2C_REG_CONFIG_SOFTWARE_VERSION            131
.................... #define I2C_REG_CONFIG_SOFTWARE_YEAR               132
.................... #define I2C_REG_CONFIG_SOFTWARE_MONTH              133
.................... #define I2C_REG_CONFIG_SOFTWARE_DAY                134
.................... 
.................... #define I2C_REG_CONFIG_PARAM_WRITE                 135 /* R / W */
.................... 
.................... #define I2C_REG_CONFIG_STARTUP_POWER_ON_DELAY      136
.................... #define I2C_REG_CONFIG_RECONNECT_DELAY             137
.................... 
.................... #define I2C_REG_CONFIG_COMMAND_OFF_HOLD_TIME        44
.................... #define I2C_REG_CONFIG_COMMAND_ON_HOLD_TIME         44
.................... 
.................... 
.................... #define I2C_REG_CONFIG_LVD_DISCONNECT_VOLTAGE       49
.................... #define I2C_REG_CONFIG_LVD_DISCONNECT_DELAY         50
.................... #define I2C_REG_CONFIG_LVD_RECONNECT_VOLTAGE        51
.................... #define I2C_REG_CONFIG_HVD_DISCONNECT_VOLTAGE       52
.................... #define I2C_REG_CONFIG_HVD_DISCONNECT_DELAY         53
.................... #define I2C_REG_CONFIG_HVD_RECONNECT_VOLTAGE        54
.................... 
.................... 
.................... void write_i2c(int8 address, int16 value) {
.................... 
.................... #if 0
*
0004:  GOTO   016E (RETURN)
.................... 		case I2C_REG_COMMAND_OFF:
.................... 			timers.command_off_seconds=value;
.................... 			break;
.................... 
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			if ( 1 == value ) {
.................... 				timers.now_write_config=1;
.................... 			} else if ( 2 == value ) {
.................... 				timers.now_reset_config=1;
.................... 			} else if ( 1802 == value ) {
.................... 				current.factory_unlocked =1;
.................... 			} else if ( 65535 == value ) {
.................... 				reset_cpu();
.................... 			}
.................... 			break;
.................... 		case I2C_REG_CONFIG_TICKS_ADC:
.................... 			config.adc_sample_ticks=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_STARTUP_POWER_ON_DELAY:
.................... 			config.startup_power_on_delay=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_COMMAND_OFF_HOLD_TIME:
.................... 			config.command_off_hold_time=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_LVD_DISCONNECT_VOLTAGE:
.................... 			config.lvd_disconnect_adc=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_LVD_DISCONNECT_DELAY:
.................... 			config.lvd_disconnect_delay=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_LVD_RECONNECT_VOLTAGE:
.................... 			config.lvd_reconnect_adc=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_HVD_DISCONNECT_VOLTAGE:
.................... 			config.hvd_disconnect_adc=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_HVD_DISCONNECT_DELAY:
.................... 			config.hvd_disconnect_delay=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_HVD_RECONNECT_VOLTAGE:
.................... 			config.hvd_reconnect_adc=value;
.................... 			break;
.................... 		default:
.................... 			/* do nothing */
.................... 	}
.................... #endif
.................... 
.................... }
.................... 
.................... 
.................... int16 map_i2c(int8 addr) {
.................... 
.................... 	timers.led_on_a=100;
*
00DC:  MOVLW  64
00DE:  MOVWF  xA8
.................... 
.................... 	switch ( addr ) {
00E0:  MOVF   xFF,W
.................... #if 0
.................... 
.................... 
.................... 		/* analog channels */
.................... 		/* input voltage */
.................... 		case I2C_REG_VOLTAGE_INPUT_NOW: 
.................... 			return (int16) current.adc_buffer[0][current.adc_buffer_index];
.................... 		case I2C_REG_VOLTAGE_INPUT_AVG: 
.................... 			return (int16) adc_get(0);
.................... 
.................... 		/* temperature sensor */
.................... 		case I2C_REG_TEMPERATURE_BOARD_NOW: 
.................... 			return (int16) current.adc_buffer[1][current.adc_buffer_index];
.................... 		case I2C_REG_TEMPERATURE_BOARD_AVG: 
.................... 			return (int16) adc_get(1);
.................... 		
.................... 		/* status */
.................... 		case I2C_REG_SEQUENCE_NUMBER: 
.................... 			return (int16) current.sequence_number++;
.................... 		case I2C_REG_TIME_INTERVAL_MILLISECONDS: 
.................... 			return (int16) current.interval_milliseconds; /* milliseconds since last query */
.................... 		case I2C_REG_TIME_UPTIME_MINUTES: 
.................... 			return (int16) current.uptime_minutes; 
.................... 		case I2C_REG_DEFAULT_PARAMS_WRITTEN:
.................... 			return (int16) current.default_params_written;
.................... 		case I2C_REG_COMMAND_OFF:
.................... 			return (int16) timers.command_off_seconds;
.................... 		case I2C_REG_POWER_OFF_FLAGS:
.................... 			return (int16) current.power_off_flags;
.................... 
.................... 
.................... 		/* configuration */
.................... 		case I2C_REG_CONFIG_HARDWARE_MODEL: 
.................... 			return (int16) 'P';
.................... 		case I2C_REG_CONFIG_HARDWARE_VERSION: 
.................... 			return (int16) 'Z';
.................... 		case I2C_REG_CONFIG_SOFTWARE_MODEL: 
.................... 			return (int16) 'P';
.................... 		case I2C_REG_CONFIG_SOFTWARE_VERSION: 
.................... 			return (int16) 3;
.................... 		case I2C_REG_CONFIG_SOFTWARE_YEAR:
.................... 			return (int16) current.compile_year;
.................... 		case I2C_REG_CONFIG_SOFTWARE_MONTH:
.................... 			return (int16) current.compile_month;
.................... 		case I2C_REG_CONFIG_SOFTWARE_DAY:
.................... 			return (int16) current.compile_day;
.................... 
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			/* 1 if factory unlocked */ 
.................... 			return (int16) current.factory_unlocked; 	
.................... 		case I2C_REG_CONFIG_TICKS_ADC: 
.................... 			return (int16) config.adc_sample_ticks;
.................... 		case I2C_REG_CONFIG_STARTUP_POWER_ON_DELAY: 
.................... 			return (int16) config.startup_power_on_delay;
.................... 		case I2C_REG_CONFIG_COMMAND_OFF_HOLD_TIME:
.................... 			return (int16) config.command_off_hold_time;
.................... 		case I2C_REG_CONFIG_LVD_DISCONNECT_VOLTAGE:
.................... 			return (int16) config.lvd_disconnect_adc;
.................... 		case I2C_REG_CONFIG_LVD_DISCONNECT_DELAY:
.................... 			return (int16) config.lvd_disconnect_delay;
.................... 		case I2C_REG_CONFIG_LVD_RECONNECT_VOLTAGE:
.................... 			return (int16) config.lvd_reconnect_adc;
.................... 		case I2C_REG_CONFIG_HVD_DISCONNECT_VOLTAGE:
.................... 			return (int16) config.hvd_disconnect_adc;
.................... 		case I2C_REG_CONFIG_HVD_DISCONNECT_DELAY:
.................... 			return (int16) config.hvd_disconnect_delay;
.................... 		case I2C_REG_CONFIG_HVD_RECONNECT_VOLTAGE:
.................... 			return (int16) config.hvd_reconnect_adc;
.................... 
.................... #endif
.................... 
.................... 		/* we should have range checked, and never gotten here ... or read unimplemented (future) register */
.................... 		default: return (int16) addr;
00E2:  MOVFF  FF,01
00E6:  CLRF   02
.................... 	}
00E8:  GOTO   0182 (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... 
.................... 
.................... #include "interrupt_dcswc_module_latching_contactor.c"
.................... #int_timer2
.................... void isr_timer2() {
.................... 	timers.now_millisecond=1;
*
00D4:  BSF    xA7.2
00D6:  BCF    F9E.1
00D8:  GOTO   006C
.................... }
.................... 
.................... 
.................... 
.................... unsigned int8 address;
.................... 
.................... #INT_SSP
.................... void ssp_interrupt () {
.................... 	unsigned int8 incoming, state;
.................... 	static int16 lastValue;
.................... 	static int8 lastMSB;
.................... 
.................... 
.................... 	state = i2c_isr_state();
*
0102:  BTFSC  FC7.5
0104:  BRA    010C
0106:  CLRF   xCE
0108:  BTFSC  FC7.2
010A:  BSF    xCE.7
010C:  MOVF   xCE,W
010E:  INCF   xCE,F
0110:  MOVWF  xFD
.................... 
.................... 	if(state <= 0x80) {                      
0112:  MOVF   xFD,W
0114:  SUBLW  80
0116:  BNC   016E
.................... 		// Master is sending data
.................... 		if ( state == 0x80 ) {
0118:  MOVF   xFD,W
011A:  SUBLW  80
011C:  BNZ   0124
.................... 			incoming = i2c_read(2); //Passing 2 as parameter, causes the function to read the SSPBUF without releasing the clock
011E:  MOVFF  FC9,FC
.................... 		} else {
0122:  BRA    0130
.................... 			incoming = i2c_read();
0124:  BCF    FC6.6
0126:  BTFSS  FC7.0
0128:  BRA    0126
012A:  MOVF   FC9,W
012C:  BSF    FC6.4
012E:  MOVWF  xFC
.................... 		}
.................... 
.................... 		if ( state == 1 ) {                      
0130:  DECFSZ xFD,W
0132:  BRA    013A
.................... 			// First received byte is address
.................... 			address = incoming;
0134:  MOVFF  FC,CA
.................... 		} else if ( state >= 2 && state != 0x80 ) {
0138:  BRA    016E
013A:  MOVF   xFD,W
013C:  SUBLW  01
013E:  BC    016E
0140:  MOVF   xFD,W
0142:  SUBLW  80
0144:  BZ    016E
.................... 			// Received byte is data
.................... 			// buffer[address++] = incoming;
.................... 		
.................... 			/* save MSB and we'll process it on next */
.................... 			if ( 2 == state ) {
0146:  MOVF   xFD,W
0148:  SUBLW  02
014A:  BNZ   0152
.................... 				lastMSB=incoming;
014C:  MOVFF  FC,CD
.................... 			} else if ( 3 == state ) {
0150:  BRA    016E
0152:  MOVF   xFD,W
0154:  SUBLW  03
0156:  BNZ   016E
.................... 				/* 16 bit value made of previous byte and this byte */
.................... 				write_i2c(address,make16(lastMSB,incoming));
0158:  MOVFF  CD,FF
015C:  MOVFF  FC,FE
0160:  MOVFF  CA,100
0164:  MOVFF  CD,102
0168:  MOVFF  FC,101
016C:  BRA    0004
.................... 			}
.................... 			
.................... 
.................... //			address++;
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	if ( state >= 0x80 ) {
016E:  MOVF   xFD,W
0170:  SUBLW  7F
0172:  BC    01A2
.................... 		//Master is requesting data
.................... 		
.................... 		if ( ! bit_test(address,0) ) {
0174:  BTFSC  xCA.0
0176:  BRA    0196
.................... 			/* read 16 bit register on even address */
.................... 			lastValue=map_i2c(address>>1);
0178:  BCF    FD8.0
017A:  RRCF   xCA,W
017C:  MOVWF  xFE
017E:  MOVWF  xFF
0180:  BRA    00DC
0182:  MOVFF  02,CC
0186:  MOVFF  01,CB
.................... 
.................... 			 i2c_write(make8(lastValue,1));
018A:  MOVFF  CC,FE
018E:  MOVFF  CC,FF
0192:  RCALL  00EC
.................... 		} else {
0194:  BRA    01A0
.................... 			/* send other byte of 16 bit register on odd address */
.................... 			i2c_write(make8(lastValue,0));
0196:  MOVFF  CB,FE
019A:  MOVFF  CB,FF
019E:  RCALL  00EC
.................... 		}
.................... 
.................... 		address++;
01A0:  INCF   xCA,F
.................... 	}
01A2:  BCF    F9E.3
01A4:  GOTO   006C
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... int8 read_dip_switch(void) {
.................... 	int16 adc;
.................... 
.................... 	set_adc_channel(9);
*
0436:  MOVLW  24
0438:  MOVWF  01
043A:  MOVF   FC2,W
043C:  ANDLW  C3
043E:  IORWF  01,W
0440:  MOVWF  FC2
.................... 	delay_ms(1);
0442:  MOVLW  01
0444:  MOVWF  xFB
0446:  RCALL  040E
.................... 	adc=read_adc();
0448:  BSF    FC2.1
044A:  BTFSC  FC2.1
044C:  BRA    044A
044E:  MOVFF  FC4,FA
0452:  MOVFF  FC3,F9
.................... 
.................... 	/* (note that table is sorted by vout reading 
.................... 	SW3.1 (LSB) SW3.2 (MSB) VALUE ADC
....................     OFF         OFF         0     1023
.................... 	OFF         ON          2     682
....................     ON          OFF         1     511
.................... 	ON          ON          3     409
.................... 	*/
.................... 
.................... //	return adc;
.................... 
.................... 	if ( adc > (1023-64) )
0456:  MOVF   xFA,W
0458:  SUBLW  02
045A:  BC    046C
045C:  XORLW  FF
045E:  BNZ   0466
0460:  MOVF   xF9,W
0462:  SUBLW  BF
0464:  BC    046C
.................... 		return 0;
0466:  MOVLW  00
0468:  MOVWF  01
046A:  BRA    049C
.................... 	if ( adc > (682-64) )
046C:  MOVF   xFA,W
046E:  SUBLW  01
0470:  BC    0482
0472:  XORLW  FF
0474:  BNZ   047C
0476:  MOVF   xF9,W
0478:  SUBLW  6A
047A:  BC    0482
.................... 		return 2;
047C:  MOVLW  02
047E:  MOVWF  01
0480:  BRA    049C
.................... 	if ( adc > (511-64) )
0482:  MOVF   xFA,W
0484:  SUBLW  00
0486:  BC    0498
0488:  XORLW  FF
048A:  BNZ   0492
048C:  MOVF   xF9,W
048E:  SUBLW  BF
0490:  BC    0498
.................... 		return 1;
0492:  MOVLW  01
0494:  MOVWF  01
0496:  BRA    049C
.................... 
.................... 	return 3;
0498:  MOVLW  03
049A:  MOVWF  01
049C:  RETURN 0
.................... }
.................... 
.................... void contactor_on_a(void) {
.................... 	timers.contactor_a_powersave=CONTACTOR_POWER_SAVE_MS;
*
1268:  MOVLW  C8
126A:  MOVWF  xAA
.................... 
.................... 	output_high(BRIDGE_A_A);
126C:  BCF    F94.3
126E:  BSF    F8B.3
.................... 	output_low(BRIDGE_A_B);
1270:  BCF    F94.4
1272:  BCF    F8B.4
1274:  GOTO   18CC (RETURN)
.................... }
.................... 
.................... void contactor_off_a(void) {
.................... 	timers.contactor_a_powersave=CONTACTOR_POWER_SAVE_MS;
1278:  MOVLW  C8
127A:  MOVWF  xAA
.................... 
.................... 	output_low(BRIDGE_A_A);
127C:  BCF    F94.3
127E:  BCF    F8B.3
.................... 	output_high(BRIDGE_A_B);
1280:  BCF    F94.4
1282:  BSF    F8B.4
1284:  GOTO   18D2 (RETURN)
.................... }
.................... 
.................... void contactor_on_b(void) {
.................... 	timers.contactor_b_powersave=CONTACTOR_POWER_SAVE_MS;
1288:  MOVLW  C8
128A:  MOVWF  xAB
.................... 
.................... 	output_high(BRIDGE_B_A);
128C:  BCF    F94.5
128E:  BSF    F8B.5
.................... 	output_low(BRIDGE_B_B);
1290:  BCF    F94.6
1292:  BCF    F8B.6
1294:  GOTO   18F0 (RETURN)
.................... }
.................... 
.................... void contactor_off_b(void) {
.................... 	timers.contactor_b_powersave=CONTACTOR_POWER_SAVE_MS;
1298:  MOVLW  C8
129A:  MOVWF  xAB
.................... 
.................... 	output_low(BRIDGE_B_A);
129C:  BCF    F94.5
129E:  BCF    F8B.5
.................... 	output_high(BRIDGE_B_B);
12A0:  BCF    F94.6
12A2:  BSF    F8B.6
12A4:  GOTO   18F6 (RETURN)
.................... }
.................... 
.................... void contactor_logic(int8 c) {
.................... 	int16 adc;
.................... 
.................... 	/* TODO: implement Command On.  */
.................... 
.................... 	/* command off. 65535 disables */
.................... 	if ( 65535 != channel[c].command_off_seconds ) {
*
09FC:  MOVF   xD9,W
09FE:  MULLW  0F
0A00:  MOVF   FF3,W
0A02:  CLRF   xDD
0A04:  MOVWF  xDC
0A06:  MOVLW  05
0A08:  ADDWF  xDC,W
0A0A:  MOVWF  01
0A0C:  MOVLW  00
0A0E:  ADDWFC xDD,W
0A10:  MOVWF  03
0A12:  MOVF   01,W
0A14:  ADDLW  AC
0A16:  MOVWF  FE9
0A18:  MOVLW  00
0A1A:  ADDWFC 03,W
0A1C:  MOVWF  FEA
0A1E:  MOVFF  FEC,03
0A22:  MOVF   FED,F
0A24:  MOVF   FEF,W
0A26:  SUBLW  FF
0A28:  BNZ   0A30
0A2A:  INCFSZ 03,W
0A2C:  BRA    0A30
0A2E:  BRA    0B9C
.................... 		if ( channel[c].command_off_seconds > 0 ) {
0A30:  MOVF   xD9,W
0A32:  MULLW  0F
0A34:  MOVF   FF3,W
0A36:  CLRF   xDD
0A38:  MOVWF  xDC
0A3A:  MOVLW  05
0A3C:  ADDWF  xDC,W
0A3E:  MOVWF  01
0A40:  MOVLW  00
0A42:  ADDWFC xDD,W
0A44:  MOVWF  03
0A46:  MOVF   01,W
0A48:  ADDLW  AC
0A4A:  MOVWF  FE9
0A4C:  MOVLW  00
0A4E:  ADDWFC 03,W
0A50:  MOVWF  FEA
0A52:  MOVFF  FEC,DD
0A56:  MOVF   FED,F
0A58:  MOVFF  FEF,DC
0A5C:  MOVF   xDC,F
0A5E:  BNZ   0A64
0A60:  MOVF   xDD,F
0A62:  BZ    0A92
.................... 			/* waiting to power off */
.................... 			channel[c].command_off_seconds--;
0A64:  MOVF   xD9,W
0A66:  MULLW  0F
0A68:  MOVF   FF3,W
0A6A:  CLRF   xDD
0A6C:  MOVWF  xDC
0A6E:  MOVLW  05
0A70:  ADDWF  xDC,W
0A72:  MOVWF  01
0A74:  MOVLW  00
0A76:  ADDWFC xDD,W
0A78:  MOVWF  03
0A7A:  MOVF   01,W
0A7C:  ADDLW  AC
0A7E:  MOVWF  FE9
0A80:  MOVLW  00
0A82:  ADDWFC 03,W
0A84:  MOVWF  FEA
0A86:  MOVLW  FF
0A88:  ADDWF  FEF,F
0A8A:  BC    0A90
0A8C:  MOVF   FEE,F
0A8E:  DECF   FED,F
.................... 		} else {
0A90:  BRA    0B9C
.................... 			/* timer at zero, ready to power off or already powered off */
.................... 			if ( ! bit_test(channel[c].state,CH_STATE_BIT_CMD_OFF) ) {
0A92:  MOVF   xD9,W
0A94:  MULLW  0F
0A96:  MOVF   FF3,W
0A98:  CLRF   xDD
0A9A:  MOVWF  xDC
0A9C:  MOVLW  AC
0A9E:  ADDWF  xDC,W
0AA0:  MOVWF  FE9
0AA2:  MOVLW  00
0AA4:  ADDWFC xDD,W
0AA6:  MOVWF  FEA
0AA8:  MOVFF  FEF,DE
0AAC:  BTFSC  xDE.2
0AAE:  BRA    0AFA
.................... 				/* not currently set, so we set it and start the countdown */
.................... 				bit_set(channel[c].state,CH_STATE_BIT_CMD_OFF);
0AB0:  MOVF   xD9,W
0AB2:  MULLW  0F
0AB4:  MOVF   FF3,W
0AB6:  CLRF   xDD
0AB8:  MOVWF  xDC
0ABA:  MOVLW  AC
0ABC:  ADDWF  xDC,W
0ABE:  MOVWF  01
0AC0:  MOVLW  00
0AC2:  ADDWFC xDD,W
0AC4:  MOVFF  01,FE9
0AC8:  MOVWF  FEA
0ACA:  BSF    FEF.2
.................... 				channel[c].command_off_hold_seconds=config.command_off_hold_time;
0ACC:  MOVF   xD9,W
0ACE:  MULLW  0F
0AD0:  MOVF   FF3,W
0AD2:  CLRF   xDD
0AD4:  MOVWF  xDC
0AD6:  MOVLW  07
0AD8:  ADDWF  xDC,W
0ADA:  MOVWF  01
0ADC:  MOVLW  00
0ADE:  ADDWFC xDD,W
0AE0:  MOVWF  03
0AE2:  MOVF   01,W
0AE4:  ADDLW  AC
0AE6:  MOVWF  FE9
0AE8:  MOVLW  00
0AEA:  ADDWFC 03,W
0AEC:  MOVWF  FEA
0AEE:  MOVFF  20,FEC
0AF2:  MOVF   FED,F
0AF4:  MOVFF  1F,FEF
.................... 			} else {
0AF8:  BRA    0B9C
.................... 				/* set, so we clear it once countdown has elapsed */
.................... 				if ( 0==channel[c].command_off_hold_seconds ) {
0AFA:  MOVF   xD9,W
0AFC:  MULLW  0F
0AFE:  MOVF   FF3,W
0B00:  CLRF   xDD
0B02:  MOVWF  xDC
0B04:  MOVLW  07
0B06:  ADDWF  xDC,W
0B08:  MOVWF  01
0B0A:  MOVLW  00
0B0C:  ADDWFC xDD,W
0B0E:  MOVWF  03
0B10:  MOVF   01,W
0B12:  ADDLW  AC
0B14:  MOVWF  FE9
0B16:  MOVLW  00
0B18:  ADDWFC 03,W
0B1A:  MOVWF  FEA
0B1C:  MOVFF  FEC,03
0B20:  MOVF   FED,F
0B22:  MOVF   FEF,W
0B24:  BNZ   0B70
0B26:  MOVF   03,F
0B28:  BNZ   0B70
.................... 					/* countdown elapsed, clear the flag and reset the timer */
.................... 					bit_clear(channel[c].state,CH_STATE_BIT_CMD_OFF);
0B2A:  MOVF   xD9,W
0B2C:  MULLW  0F
0B2E:  MOVF   FF3,W
0B30:  CLRF   xDD
0B32:  MOVWF  xDC
0B34:  MOVLW  AC
0B36:  ADDWF  xDC,W
0B38:  MOVWF  01
0B3A:  MOVLW  00
0B3C:  ADDWFC xDD,W
0B3E:  MOVFF  01,FE9
0B42:  MOVWF  FEA
0B44:  BCF    FEF.2
.................... 					channel[c].command_off_seconds=65535;
0B46:  MOVF   xD9,W
0B48:  MULLW  0F
0B4A:  MOVF   FF3,W
0B4C:  CLRF   xDD
0B4E:  MOVWF  xDC
0B50:  MOVLW  05
0B52:  ADDWF  xDC,W
0B54:  MOVWF  01
0B56:  MOVLW  00
0B58:  ADDWFC xDD,W
0B5A:  MOVWF  03
0B5C:  MOVF   01,W
0B5E:  ADDLW  AC
0B60:  MOVWF  FE9
0B62:  MOVLW  00
0B64:  ADDWFC 03,W
0B66:  MOVWF  FEA
0B68:  SETF   FEC
0B6A:  MOVF   FED,F
0B6C:  SETF   FEF
.................... 				} else {
0B6E:  BRA    0B9C
.................... 					channel[c].command_off_hold_seconds--;
0B70:  MOVF   xD9,W
0B72:  MULLW  0F
0B74:  MOVF   FF3,W
0B76:  CLRF   xDD
0B78:  MOVWF  xDC
0B7A:  MOVLW  07
0B7C:  ADDWF  xDC,W
0B7E:  MOVWF  01
0B80:  MOVLW  00
0B82:  ADDWFC xDD,W
0B84:  MOVWF  03
0B86:  MOVF   01,W
0B88:  ADDLW  AC
0B8A:  MOVWF  FE9
0B8C:  MOVLW  00
0B8E:  ADDWFC 03,W
0B90:  MOVWF  FEA
0B92:  MOVLW  FF
0B94:  ADDWF  FEF,F
0B96:  BC    0B9C
0B98:  MOVF   FEE,F
0B9A:  DECF   FED,F
.................... 				}
.................... 			}		
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	/* LVD. 65535 disables */
.................... 	if ( 65535 != config.ch[c].lvd_disconnect_delay ) {
0B9C:  MOVF   xD9,W
0B9E:  MULLW  0C
0BA0:  MOVF   FF3,W
0BA2:  CLRF   03
0BA4:  ADDLW  09
0BA6:  MOVWF  xDC
0BA8:  MOVLW  00
0BAA:  ADDWFC 03,W
0BAC:  MOVWF  xDD
0BAE:  MOVLW  02
0BB0:  ADDWF  xDC,W
0BB2:  MOVWF  01
0BB4:  MOVLW  00
0BB6:  ADDWFC xDD,W
0BB8:  MOVWF  03
0BBA:  MOVF   01,W
0BBC:  ADDLW  1A
0BBE:  MOVWF  FE9
0BC0:  MOVLW  00
0BC2:  ADDWFC 03,W
0BC4:  MOVWF  FEA
0BC6:  MOVFF  FEC,03
0BCA:  MOVF   FED,F
0BCC:  MOVF   FEF,W
0BCE:  SUBLW  FF
0BD0:  BNZ   0BD8
0BD2:  INCFSZ 03,W
0BD4:  BRA    0BD8
0BD6:  BRA    0DCE
.................... 		adc=adc_get(0);
0BD8:  CLRF   xDC
0BDA:  RCALL  0980
0BDC:  MOVFF  02,DB
0BE0:  MOVFF  01,DA
.................... 
.................... 		if ( adc > config.ch[c].lvd_reconnect_adc ) {
0BE4:  MOVF   xD9,W
0BE6:  MULLW  0C
0BE8:  MOVF   FF3,W
0BEA:  CLRF   03
0BEC:  ADDLW  09
0BEE:  MOVWF  xDC
0BF0:  MOVLW  00
0BF2:  ADDWFC 03,W
0BF4:  MOVWF  xDD
0BF6:  MOVLW  04
0BF8:  ADDWF  xDC,W
0BFA:  MOVWF  01
0BFC:  MOVLW  00
0BFE:  ADDWFC xDD,W
0C00:  MOVWF  03
0C02:  MOVF   01,W
0C04:  ADDLW  1A
0C06:  MOVWF  FE9
0C08:  MOVLW  00
0C0A:  ADDWFC 03,W
0C0C:  MOVWF  FEA
0C0E:  MOVFF  FEC,03
0C12:  MOVF   FED,F
0C14:  MOVFF  FEF,01
0C18:  MOVF   03,W
0C1A:  SUBWF  xDB,W
0C1C:  BNC   0C90
0C1E:  BNZ   0C26
0C20:  MOVF   xDA,W
0C22:  SUBWF  01,W
0C24:  BC    0C90
.................... 			if ( channel[c].lvd_reconnect_delay_seconds > 0 ) {
0C26:  MOVF   xD9,W
0C28:  MULLW  0F
0C2A:  MOVF   FF3,W
0C2C:  CLRF   xDD
0C2E:  MOVWF  xDC
0C30:  MOVLW  0B
0C32:  ADDWF  xDC,W
0C34:  MOVWF  01
0C36:  MOVLW  00
0C38:  ADDWFC xDD,W
0C3A:  MOVWF  03
0C3C:  MOVF   01,W
0C3E:  ADDLW  AC
0C40:  MOVWF  FE9
0C42:  MOVLW  00
0C44:  ADDWFC 03,W
0C46:  MOVWF  FEA
0C48:  MOVF   FEF,F
0C4A:  BZ    0C72
.................... 				channel[c].lvd_reconnect_delay_seconds--;
0C4C:  MOVF   xD9,W
0C4E:  MULLW  0F
0C50:  MOVF   FF3,W
0C52:  CLRF   xDD
0C54:  MOVWF  xDC
0C56:  MOVLW  0B
0C58:  ADDWF  xDC,W
0C5A:  MOVWF  01
0C5C:  MOVLW  00
0C5E:  ADDWFC xDD,W
0C60:  MOVWF  03
0C62:  MOVF   01,W
0C64:  ADDLW  AC
0C66:  MOVWF  FE9
0C68:  MOVLW  00
0C6A:  ADDWFC 03,W
0C6C:  MOVWF  FEA
0C6E:  DECF   FEF,F
.................... 			} else {
0C70:  BRA    0C8E
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_LVD);
0C72:  MOVF   xD9,W
0C74:  MULLW  0F
0C76:  MOVF   FF3,W
0C78:  CLRF   xDD
0C7A:  MOVWF  xDC
0C7C:  MOVLW  AC
0C7E:  ADDWF  xDC,W
0C80:  MOVWF  01
0C82:  MOVLW  00
0C84:  ADDWFC xDD,W
0C86:  MOVFF  01,FE9
0C8A:  MOVWF  FEA
0C8C:  BCF    FEF.3
.................... 			}
.................... 		} else {
0C8E:  BRA    0CB6
.................... 			channel[c].lvd_reconnect_delay_seconds=config.reconnect_delay; /* 5 seconds countdown before reconnecting */
0C90:  MOVF   xD9,W
0C92:  MULLW  0F
0C94:  MOVF   FF3,W
0C96:  CLRF   xDD
0C98:  MOVWF  xDC
0C9A:  MOVLW  0B
0C9C:  ADDWF  xDC,W
0C9E:  MOVWF  01
0CA0:  MOVLW  00
0CA2:  ADDWFC xDD,W
0CA4:  MOVWF  03
0CA6:  MOVF   01,W
0CA8:  ADDLW  AC
0CAA:  MOVWF  FE9
0CAC:  MOVLW  00
0CAE:  ADDWFC 03,W
0CB0:  MOVWF  FEA
0CB2:  MOVFF  1E,FEF
.................... 		}
.................... 
.................... 		if ( adc < config.ch[c].lvd_disconnect_adc ) {
0CB6:  MOVF   xD9,W
0CB8:  MULLW  0C
0CBA:  MOVF   FF3,W
0CBC:  CLRF   03
0CBE:  ADDLW  23
0CC0:  MOVWF  FE9
0CC2:  MOVLW  00
0CC4:  ADDWFC 03,W
0CC6:  MOVWF  FEA
0CC8:  MOVFF  FEC,03
0CCC:  MOVF   FED,F
0CCE:  MOVFF  FEF,01
0CD2:  MOVF   xDB,W
0CD4:  SUBWF  03,W
0CD6:  BNC   0D60
0CD8:  BNZ   0CE0
0CDA:  MOVF   01,W
0CDC:  SUBWF  xDA,W
0CDE:  BC    0D60
.................... 			if ( channel[c].lvd_disconnect_delay_seconds > 0 ) {
0CE0:  MOVF   xD9,W
0CE2:  MULLW  0F
0CE4:  MOVF   FF3,W
0CE6:  CLRF   xDD
0CE8:  MOVWF  xDC
0CEA:  MOVLW  09
0CEC:  ADDWF  xDC,W
0CEE:  MOVWF  01
0CF0:  MOVLW  00
0CF2:  ADDWFC xDD,W
0CF4:  MOVWF  03
0CF6:  MOVF   01,W
0CF8:  ADDLW  AC
0CFA:  MOVWF  FE9
0CFC:  MOVLW  00
0CFE:  ADDWFC 03,W
0D00:  MOVWF  FEA
0D02:  MOVFF  FEC,DD
0D06:  MOVF   FED,F
0D08:  MOVFF  FEF,DC
0D0C:  MOVF   xDC,F
0D0E:  BNZ   0D14
0D10:  MOVF   xDD,F
0D12:  BZ    0D42
.................... 				channel[c].lvd_disconnect_delay_seconds--;
0D14:  MOVF   xD9,W
0D16:  MULLW  0F
0D18:  MOVF   FF3,W
0D1A:  CLRF   xDD
0D1C:  MOVWF  xDC
0D1E:  MOVLW  09
0D20:  ADDWF  xDC,W
0D22:  MOVWF  01
0D24:  MOVLW  00
0D26:  ADDWFC xDD,W
0D28:  MOVWF  03
0D2A:  MOVF   01,W
0D2C:  ADDLW  AC
0D2E:  MOVWF  FE9
0D30:  MOVLW  00
0D32:  ADDWFC 03,W
0D34:  MOVWF  FEA
0D36:  MOVLW  FF
0D38:  ADDWF  FEF,F
0D3A:  BC    0D40
0D3C:  MOVF   FEE,F
0D3E:  DECF   FED,F
.................... 			} else {
0D40:  BRA    0D5E
.................... 				bit_set(channel[c].state,CH_STATE_BIT_LVD);
0D42:  MOVF   xD9,W
0D44:  MULLW  0F
0D46:  MOVF   FF3,W
0D48:  CLRF   xDD
0D4A:  MOVWF  xDC
0D4C:  MOVLW  AC
0D4E:  ADDWF  xDC,W
0D50:  MOVWF  01
0D52:  MOVLW  00
0D54:  ADDWFC xDD,W
0D56:  MOVFF  01,FE9
0D5A:  MOVWF  FEA
0D5C:  BSF    FEF.3
.................... 			}
.................... 		} else {
0D5E:  BRA    0DCE
.................... 			channel[c].lvd_disconnect_delay_seconds=config.ch[c].lvd_disconnect_delay;
0D60:  MOVF   xD9,W
0D62:  MULLW  0F
0D64:  MOVF   FF3,W
0D66:  CLRF   xDD
0D68:  MOVWF  xDC
0D6A:  MOVLW  09
0D6C:  ADDWF  xDC,W
0D6E:  MOVWF  01
0D70:  MOVLW  00
0D72:  ADDWFC xDD,W
0D74:  MOVWF  03
0D76:  MOVF   01,W
0D78:  ADDLW  AC
0D7A:  MOVWF  01
0D7C:  MOVLW  00
0D7E:  ADDWFC 03,F
0D80:  MOVFF  01,DC
0D84:  MOVFF  03,DD
0D88:  MOVF   xD9,W
0D8A:  MULLW  0C
0D8C:  MOVF   FF3,W
0D8E:  CLRF   03
0D90:  ADDLW  09
0D92:  MOVWF  xDE
0D94:  MOVLW  00
0D96:  ADDWFC 03,W
0D98:  MOVWF  xDF
0D9A:  MOVLW  02
0D9C:  ADDWF  xDE,W
0D9E:  MOVWF  01
0DA0:  MOVLW  00
0DA2:  ADDWFC xDF,W
0DA4:  MOVWF  03
0DA6:  MOVF   01,W
0DA8:  ADDLW  1A
0DAA:  MOVWF  FE9
0DAC:  MOVLW  00
0DAE:  ADDWFC 03,W
0DB0:  MOVWF  FEA
0DB2:  MOVFF  FEC,03
0DB6:  MOVF   FED,F
0DB8:  MOVFF  FEF,DE
0DBC:  MOVFF  DD,FEA
0DC0:  MOVFF  DC,FE9
0DC4:  MOVFF  03,FEC
0DC8:  MOVF   FED,F
0DCA:  MOVFF  DE,FEF
.................... 		}
.................... 	}
.................... 
.................... 	/* HVD. 65535 disables */
.................... 	if ( 65535 != config.ch[c].hvd_disconnect_delay ) {
0DCE:  MOVF   xD9,W
0DD0:  MULLW  0C
0DD2:  MOVF   FF3,W
0DD4:  CLRF   03
0DD6:  ADDLW  09
0DD8:  MOVWF  xDC
0DDA:  MOVLW  00
0DDC:  ADDWFC 03,W
0DDE:  MOVWF  xDD
0DE0:  MOVLW  08
0DE2:  ADDWF  xDC,W
0DE4:  MOVWF  01
0DE6:  MOVLW  00
0DE8:  ADDWFC xDD,W
0DEA:  MOVWF  03
0DEC:  MOVF   01,W
0DEE:  ADDLW  1A
0DF0:  MOVWF  FE9
0DF2:  MOVLW  00
0DF4:  ADDWFC 03,W
0DF6:  MOVWF  FEA
0DF8:  MOVFF  FEC,03
0DFC:  MOVF   FED,F
0DFE:  MOVF   FEF,W
0E00:  SUBLW  FF
0E02:  BNZ   0E0A
0E04:  INCFSZ 03,W
0E06:  BRA    0E0A
0E08:  BRA    1018
.................... 		adc=adc_get(0);
0E0A:  CLRF   xDC
0E0C:  RCALL  0980
0E0E:  MOVFF  02,DB
0E12:  MOVFF  01,DA
.................... 
.................... 		if ( adc < config.ch[c].hvd_reconnect_adc ) {
0E16:  MOVF   xD9,W
0E18:  MULLW  0C
0E1A:  MOVF   FF3,W
0E1C:  CLRF   03
0E1E:  ADDLW  09
0E20:  MOVWF  xDC
0E22:  MOVLW  00
0E24:  ADDWFC 03,W
0E26:  MOVWF  xDD
0E28:  MOVLW  0A
0E2A:  ADDWF  xDC,W
0E2C:  MOVWF  01
0E2E:  MOVLW  00
0E30:  ADDWFC xDD,W
0E32:  MOVWF  03
0E34:  MOVF   01,W
0E36:  ADDLW  1A
0E38:  MOVWF  FE9
0E3A:  MOVLW  00
0E3C:  ADDWFC 03,W
0E3E:  MOVWF  FEA
0E40:  MOVFF  FEC,03
0E44:  MOVF   FED,F
0E46:  MOVFF  FEF,01
0E4A:  MOVF   xDB,W
0E4C:  SUBWF  03,W
0E4E:  BNC   0EC2
0E50:  BNZ   0E58
0E52:  MOVF   01,W
0E54:  SUBWF  xDA,W
0E56:  BC    0EC2
.................... 			if ( channel[c].hvd_reconnect_delay_seconds > 0 ) {
0E58:  MOVF   xD9,W
0E5A:  MULLW  0F
0E5C:  MOVF   FF3,W
0E5E:  CLRF   xDD
0E60:  MOVWF  xDC
0E62:  MOVLW  0E
0E64:  ADDWF  xDC,W
0E66:  MOVWF  01
0E68:  MOVLW  00
0E6A:  ADDWFC xDD,W
0E6C:  MOVWF  03
0E6E:  MOVF   01,W
0E70:  ADDLW  AC
0E72:  MOVWF  FE9
0E74:  MOVLW  00
0E76:  ADDWFC 03,W
0E78:  MOVWF  FEA
0E7A:  MOVF   FEF,F
0E7C:  BZ    0EA4
.................... 				channel[c].hvd_reconnect_delay_seconds--;
0E7E:  MOVF   xD9,W
0E80:  MULLW  0F
0E82:  MOVF   FF3,W
0E84:  CLRF   xDD
0E86:  MOVWF  xDC
0E88:  MOVLW  0E
0E8A:  ADDWF  xDC,W
0E8C:  MOVWF  01
0E8E:  MOVLW  00
0E90:  ADDWFC xDD,W
0E92:  MOVWF  03
0E94:  MOVF   01,W
0E96:  ADDLW  AC
0E98:  MOVWF  FE9
0E9A:  MOVLW  00
0E9C:  ADDWFC 03,W
0E9E:  MOVWF  FEA
0EA0:  DECF   FEF,F
.................... 			} else {
0EA2:  BRA    0EC0
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_HVD);
0EA4:  MOVF   xD9,W
0EA6:  MULLW  0F
0EA8:  MOVF   FF3,W
0EAA:  CLRF   xDD
0EAC:  MOVWF  xDC
0EAE:  MOVLW  AC
0EB0:  ADDWF  xDC,W
0EB2:  MOVWF  01
0EB4:  MOVLW  00
0EB6:  ADDWFC xDD,W
0EB8:  MOVFF  01,FE9
0EBC:  MOVWF  FEA
0EBE:  BCF    FEF.4
.................... 			}
.................... 		} else {
0EC0:  BRA    0EE8
.................... 			channel[c].hvd_reconnect_delay_seconds=config.reconnect_delay; /* 5 seconds countdown before reconnecting */
0EC2:  MOVF   xD9,W
0EC4:  MULLW  0F
0EC6:  MOVF   FF3,W
0EC8:  CLRF   xDD
0ECA:  MOVWF  xDC
0ECC:  MOVLW  0E
0ECE:  ADDWF  xDC,W
0ED0:  MOVWF  01
0ED2:  MOVLW  00
0ED4:  ADDWFC xDD,W
0ED6:  MOVWF  03
0ED8:  MOVF   01,W
0EDA:  ADDLW  AC
0EDC:  MOVWF  FE9
0EDE:  MOVLW  00
0EE0:  ADDWFC 03,W
0EE2:  MOVWF  FEA
0EE4:  MOVFF  1E,FEF
.................... 		}
.................... 
.................... 		if ( adc > config.ch[c].hvd_disconnect_adc ) {
0EE8:  MOVF   xD9,W
0EEA:  MULLW  0C
0EEC:  MOVF   FF3,W
0EEE:  CLRF   03
0EF0:  ADDLW  09
0EF2:  MOVWF  xDC
0EF4:  MOVLW  00
0EF6:  ADDWFC 03,W
0EF8:  MOVWF  xDD
0EFA:  MOVLW  06
0EFC:  ADDWF  xDC,W
0EFE:  MOVWF  01
0F00:  MOVLW  00
0F02:  ADDWFC xDD,W
0F04:  MOVWF  03
0F06:  MOVF   01,W
0F08:  ADDLW  1A
0F0A:  MOVWF  FE9
0F0C:  MOVLW  00
0F0E:  ADDWFC 03,W
0F10:  MOVWF  FEA
0F12:  MOVFF  FEC,03
0F16:  MOVF   FED,F
0F18:  MOVFF  FEF,01
0F1C:  MOVF   03,W
0F1E:  SUBWF  xDB,W
0F20:  BNC   0FAA
0F22:  BNZ   0F2A
0F24:  MOVF   xDA,W
0F26:  SUBWF  01,W
0F28:  BC    0FAA
.................... 			if ( channel[c].hvd_disconnect_delay_seconds > 0 ) {
0F2A:  MOVF   xD9,W
0F2C:  MULLW  0F
0F2E:  MOVF   FF3,W
0F30:  CLRF   xDD
0F32:  MOVWF  xDC
0F34:  MOVLW  0C
0F36:  ADDWF  xDC,W
0F38:  MOVWF  01
0F3A:  MOVLW  00
0F3C:  ADDWFC xDD,W
0F3E:  MOVWF  03
0F40:  MOVF   01,W
0F42:  ADDLW  AC
0F44:  MOVWF  FE9
0F46:  MOVLW  00
0F48:  ADDWFC 03,W
0F4A:  MOVWF  FEA
0F4C:  MOVFF  FEC,DD
0F50:  MOVF   FED,F
0F52:  MOVFF  FEF,DC
0F56:  MOVF   xDC,F
0F58:  BNZ   0F5E
0F5A:  MOVF   xDD,F
0F5C:  BZ    0F8C
.................... 				channel[c].hvd_disconnect_delay_seconds--;
0F5E:  MOVF   xD9,W
0F60:  MULLW  0F
0F62:  MOVF   FF3,W
0F64:  CLRF   xDD
0F66:  MOVWF  xDC
0F68:  MOVLW  0C
0F6A:  ADDWF  xDC,W
0F6C:  MOVWF  01
0F6E:  MOVLW  00
0F70:  ADDWFC xDD,W
0F72:  MOVWF  03
0F74:  MOVF   01,W
0F76:  ADDLW  AC
0F78:  MOVWF  FE9
0F7A:  MOVLW  00
0F7C:  ADDWFC 03,W
0F7E:  MOVWF  FEA
0F80:  MOVLW  FF
0F82:  ADDWF  FEF,F
0F84:  BC    0F8A
0F86:  MOVF   FEE,F
0F88:  DECF   FED,F
.................... 			} else {
0F8A:  BRA    0FA8
.................... 				bit_set(channel[c].state,CH_STATE_BIT_HVD);
0F8C:  MOVF   xD9,W
0F8E:  MULLW  0F
0F90:  MOVF   FF3,W
0F92:  CLRF   xDD
0F94:  MOVWF  xDC
0F96:  MOVLW  AC
0F98:  ADDWF  xDC,W
0F9A:  MOVWF  01
0F9C:  MOVLW  00
0F9E:  ADDWFC xDD,W
0FA0:  MOVFF  01,FE9
0FA4:  MOVWF  FEA
0FA6:  BSF    FEF.4
.................... 			}
.................... 		} else {
0FA8:  BRA    1018
.................... 			channel[c].hvd_disconnect_delay_seconds=config.ch[c].hvd_disconnect_delay;
0FAA:  MOVF   xD9,W
0FAC:  MULLW  0F
0FAE:  MOVF   FF3,W
0FB0:  CLRF   xDD
0FB2:  MOVWF  xDC
0FB4:  MOVLW  0C
0FB6:  ADDWF  xDC,W
0FB8:  MOVWF  01
0FBA:  MOVLW  00
0FBC:  ADDWFC xDD,W
0FBE:  MOVWF  03
0FC0:  MOVF   01,W
0FC2:  ADDLW  AC
0FC4:  MOVWF  01
0FC6:  MOVLW  00
0FC8:  ADDWFC 03,F
0FCA:  MOVFF  01,DC
0FCE:  MOVFF  03,DD
0FD2:  MOVF   xD9,W
0FD4:  MULLW  0C
0FD6:  MOVF   FF3,W
0FD8:  CLRF   03
0FDA:  ADDLW  09
0FDC:  MOVWF  xDE
0FDE:  MOVLW  00
0FE0:  ADDWFC 03,W
0FE2:  MOVWF  xDF
0FE4:  MOVLW  08
0FE6:  ADDWF  xDE,W
0FE8:  MOVWF  01
0FEA:  MOVLW  00
0FEC:  ADDWFC xDF,W
0FEE:  MOVWF  03
0FF0:  MOVF   01,W
0FF2:  ADDLW  1A
0FF4:  MOVWF  FE9
0FF6:  MOVLW  00
0FF8:  ADDWFC 03,W
0FFA:  MOVWF  FEA
0FFC:  MOVFF  FEC,03
1000:  MOVF   FED,F
1002:  MOVFF  FEF,DE
1006:  MOVFF  DD,FEA
100A:  MOVFF  DC,FE9
100E:  MOVFF  03,FEC
1012:  MOVF   FED,F
1014:  MOVFF  DE,FEF
.................... 		}
.................... 	}
1018:  RETURN 0
.................... 
.................... 
.................... 	/* TODO: implement Low Temperature Disconnect (LTD) and High Temperature Disconnect (HTD) */
.................... }
.................... 
.................... 
.................... void periodic_millisecond(void) {
.................... 	static int8 uptimeticks=0;
.................... 	static int16 adcTicks=0;
.................... 	static int16 ticks=0;
.................... 
.................... 
.................... 	timers.now_millisecond=0;
101A:  BCF    xA7.2
.................... 
.................... 	/* LED control */
.................... 	if ( 0==timers.led_on_a ) {
101C:  MOVF   xA8,F
101E:  BNZ   1026
.................... 		output_low(LED_A);
1020:  BCF    F94.1
1022:  BCF    F8B.1
.................... 	} else {
1024:  BRA    102C
.................... 		output_high(LED_A);
1026:  BCF    F94.1
1028:  BSF    F8B.1
.................... 		timers.led_on_a--;
102A:  DECF   xA8,F
.................... 	}
.................... 	if ( 0==timers.led_on_b ) {
102C:  MOVF   xA9,F
102E:  BNZ   1036
.................... 		output_low(LED_B);
1030:  BCF    F94.2
1032:  BCF    F8B.2
.................... 	} else {
1034:  BRA    103C
.................... 		output_high(LED_B);
1036:  BCF    F94.2
1038:  BSF    F8B.2
.................... 		timers.led_on_b--;
103A:  DECF   xA9,F
.................... 	}
.................... 
.................... 	/* some other random stuff that we don't need to do every cycle in main */
.................... 	if ( current.interval_milliseconds < 65535 ) {
103C:  INCFSZ xA0,W
103E:  BRA    1046
1040:  INCFSZ xA1,W
1042:  BRA    1046
1044:  BRA    104C
.................... 		current.interval_milliseconds++;
1046:  INCF   xA0,F
1048:  BTFSC  FD8.2
104A:  INCF   xA1,F
.................... 	}
.................... 
.................... 	/* contactor timeout */
.................... 	if ( 0 == timers.contactor_a_powersave ) {
104C:  MOVF   xAA,F
104E:  BNZ   105A
.................... 		output_low(BRIDGE_A_A);
1050:  BCF    F94.3
1052:  BCF    F8B.3
.................... 		output_low(BRIDGE_A_B);
1054:  BCF    F94.4
1056:  BCF    F8B.4
.................... 	} else {
1058:  BRA    105C
.................... 		timers.contactor_a_powersave--;
105A:  DECF   xAA,F
.................... 	}
.................... 	if ( 0 == timers.contactor_b_powersave ) {
105C:  MOVF   xAB,F
105E:  BNZ   106A
.................... 		output_low(BRIDGE_B_A);
1060:  BCF    F94.5
1062:  BCF    F8B.5
.................... 		output_low(BRIDGE_B_B);
1064:  BCF    F94.6
1066:  BCF    F8B.6
.................... 	} else {
1068:  BRA    106C
.................... 		timers.contactor_b_powersave--;
106A:  DECF   xAB,F
.................... 	}
.................... 
.................... 
.................... 	/* seconds */
.................... 	ticks++;
106C:  INCF   xD2,F
106E:  BTFSC  FD8.2
1070:  INCF   xD3,F
.................... 	if ( 1000 == ticks ) {
1072:  MOVF   xD2,W
1074:  SUBLW  E8
1076:  BNZ   10A6
1078:  MOVF   xD3,W
107A:  SUBLW  03
107C:  BNZ   10A6
.................... 		ticks=0;
107E:  CLRF   xD3
1080:  CLRF   xD2
.................... 
.................... 		/* set channe[n].state based on logic */
.................... 		contactor_logic(0);
1082:  CLRF   xD9
1084:  RCALL  09FC
.................... 		contactor_logic(1);
1086:  MOVLW  01
1088:  MOVWF  xD9
108A:  RCALL  09FC
.................... 
.................... 		/* set contactor outputs */
.................... #if 0
.................... 		/* actually control the power switches */
.................... 		if ( current.power_off_flags ) {
.................... 			output_low(PI_POWER_EN);
.................... 			output_low(WIFI_POWER_EN);
.................... 		} else {
.................... 			output_high(PI_POWER_EN);
.................... 			output_high(WIFI_POWER_EN);
.................... 		}
.................... #endif
.................... 
.................... 
.................... 		
.................... 		/* uptime counter */
.................... 		uptimeTicks++;
108C:  INCF   xCF,F
.................... 		if ( 60 == uptimeTicks ) {
108E:  MOVF   xCF,W
1090:  SUBLW  3C
1092:  BNZ   10A6
.................... 			uptimeTicks=0;
1094:  CLRF   xCF
.................... 			if ( current.uptime_minutes < 65535 ) 
1096:  INCFSZ x9E,W
1098:  BRA    10A0
109A:  INCFSZ x9F,W
109C:  BRA    10A0
109E:  BRA    10A6
.................... 				current.uptime_minutes++;
10A0:  INCF   x9E,F
10A2:  BTFSC  FD8.2
10A4:  INCF   x9F,F
.................... 		}
.................... 	}
.................... 
.................... 	/* ADC sample counter */
.................... 	if ( timers.now_adc_reset_count ) {
10A6:  BTFSS  xA7.1
10A8:  BRA    10B0
.................... 		timers.now_adc_reset_count=0;
10AA:  BCF    xA7.1
.................... 		adcTicks=0;
10AC:  CLRF   xD1
10AE:  CLRF   xD0
.................... 	}
.................... 
.................... 	/* ADC sampling trigger */
.................... 	adcTicks++;
10B0:  INCF   xD0,F
10B2:  BTFSC  FD8.2
10B4:  INCF   xD1,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) {
10B6:  MOVF   1A,W
10B8:  SUBWF  xD0,W
10BA:  BNZ   10C8
10BC:  MOVF   1B,W
10BE:  SUBWF  xD1,W
10C0:  BNZ   10C8
.................... 		adcTicks=0;
10C2:  CLRF   xD1
10C4:  CLRF   xD0
.................... 		timers.now_adc_sample=1;
10C6:  BSF    xA7.0
.................... 	}
10C8:  GOTO   1484 (RETURN)
.................... 
.................... }
.................... 
.................... void init(void) {
.................... 	int8 buff[32];
.................... 	setup_oscillator(OSC_16MHZ);
*
049E:  MOVLW  70
04A0:  MOVWF  FD3
04A2:  BCF    F9B.6
04A4:  BCF    F9B.7
.................... 
.................... 	setup_adc(ADC_CLOCK_DIV_16);
04A6:  MOVF   FC0,W
04A8:  ANDLW  C0
04AA:  IORLW  05
04AC:  MOVWF  FC0
04AE:  BSF    FC0.7
04B0:  BSF    FC2.0
.................... 	/* NTC thermistor on sAN2, input voltage divider on sAN4, DIP switch analog on sAN9
.................... 	voltage spans between 0 and Vdd */
.................... 	setup_adc_ports(sAN2 | sAN4 | sAN9,VSS_VDD);
04B2:  MOVLW  14
04B4:  MOVWF  F7E
04B6:  BCF    FC1.0
04B8:  BCF    FC1.1
04BA:  BCF    FC1.2
04BC:  BCF    FC1.3
04BE:  MOVLW  02
04C0:  MOVWF  F7F
.................... 
.................... 	setup_wdt(WDT_512MS);
04C2:  BSF    FD1.0
.................... 
.................... 	set_tris_a(0b00111111);
04C4:  MOVLW  3F
04C6:  MOVWF  F92
.................... 	set_tris_b(0b01110000);
04C8:  MOVLW  70
04CA:  MOVWF  F93
.................... 	set_tris_c(0b10000001);
04CC:  MOVLW  81
04CE:  MOVWF  F94
.................... //               76543210
.................... 
.................... 	port_a_pullups(0b00110000);
04D0:  MOVLW  30
04D2:  MOVWF  F77
04D4:  BCF    FF1.7
.................... 	port_b_pullups(0b00000000);
04D6:  CLRF   F78
.................... //                   76543210
.................... 
.................... 	/* data structure initialization */
.................... 	/* all initialized to 0 on declaration. Just do this if need non-zero */
.................... 	channel[0].command_off_seconds=65535;
04D8:  SETF   xB2
04DA:  SETF   xB1
.................... 	channel[1].command_off_seconds=65535;
04DC:  SETF   xC1
04DE:  SETF   xC0
.................... 	channel[0].command_on_seconds =65535;
04E0:  SETF   xAE
04E2:  SETF   xAD
.................... 	channel[1].command_on_seconds =65535;
04E4:  SETF   xBD
04E6:  SETF   xBC
.................... 
.................... 
.................... 	/* get our compiled date from constant */
.................... 	strcpy(buff,__DATE__);
04E8:  CLRF   FEA
04EA:  MOVLW  D9
04EC:  MOVWF  FE9
04EE:  MOVLW  00
04F0:  RCALL  00BA
04F2:  TBLRD*-
04F4:  TBLRD*+
04F6:  MOVF   FF5,W
04F8:  MOVWF  FEE
04FA:  IORLW  00
04FC:  BNZ   04F4
.................... 	current.compile_day =(buff[0]-'0')*10;
04FE:  MOVLW  30
0500:  SUBWF  xD9,W
0502:  MULLW  0A
0504:  MOVFF  FF3,A5
.................... 	current.compile_day+=(buff[1]-'0');
0508:  MOVLW  30
050A:  SUBWF  xDA,W
050C:  ADDWF  xA5,F
.................... 	/* determine month ... how annoying */
.................... 	if ( 'J'==buff[3] ) {
050E:  MOVF   xDC,W
0510:  SUBLW  4A
0512:  BNZ   0532
.................... 		if ( 'A'==buff[4] )
0514:  MOVF   xDD,W
0516:  SUBLW  41
0518:  BNZ   0520
.................... 			current.compile_month=1;
051A:  MOVLW  01
051C:  MOVWF  xA4
051E:  BRA    0530
.................... 		else if ( 'N'==buff[5] )
0520:  MOVF   xDE,W
0522:  SUBLW  4E
0524:  BNZ   052C
.................... 			current.compile_month=6;
0526:  MOVLW  06
0528:  MOVWF  xA4
052A:  BRA    0530
.................... 		else
.................... 			current.compile_month=7;
052C:  MOVLW  07
052E:  MOVWF  xA4
.................... 	} else if ( 'A'==buff[3] ) {
0530:  BRA    05A0
0532:  MOVF   xDC,W
0534:  SUBLW  41
0536:  BNZ   054A
.................... 		if ( 'P'==buff[4] )
0538:  MOVF   xDD,W
053A:  SUBLW  50
053C:  BNZ   0544
.................... 			current.compile_month=4;
053E:  MOVLW  04
0540:  MOVWF  xA4
0542:  BRA    0548
.................... 		else
.................... 			current.compile_month=8;
0544:  MOVLW  08
0546:  MOVWF  xA4
.................... 	} else if ( 'M'==buff[3] ) {
0548:  BRA    05A0
054A:  MOVF   xDC,W
054C:  SUBLW  4D
054E:  BNZ   0562
.................... 		if ( 'R'==buff[5] )
0550:  MOVF   xDE,W
0552:  SUBLW  52
0554:  BNZ   055C
.................... 			current.compile_month=3;
0556:  MOVLW  03
0558:  MOVWF  xA4
055A:  BRA    0560
.................... 		else
.................... 			current.compile_month=5;
055C:  MOVLW  05
055E:  MOVWF  xA4
.................... 	} else if ( 'F'==buff[3] ) {
0560:  BRA    05A0
0562:  MOVF   xDC,W
0564:  SUBLW  46
0566:  BNZ   056E
.................... 		current.compile_month=2;
0568:  MOVLW  02
056A:  MOVWF  xA4
.................... 	} else if ( 'S'==buff[3] ) {
056C:  BRA    05A0
056E:  MOVF   xDC,W
0570:  SUBLW  53
0572:  BNZ   057A
.................... 		current.compile_month=9;
0574:  MOVLW  09
0576:  MOVWF  xA4
.................... 	} else if ( 'O'==buff[3] ) {
0578:  BRA    05A0
057A:  MOVF   xDC,W
057C:  SUBLW  4F
057E:  BNZ   0586
.................... 		current.compile_month=10;
0580:  MOVLW  0A
0582:  MOVWF  xA4
.................... 	} else if ( 'N'==buff[3] ) {
0584:  BRA    05A0
0586:  MOVF   xDC,W
0588:  SUBLW  4E
058A:  BNZ   0592
.................... 		current.compile_month=11;
058C:  MOVLW  0B
058E:  MOVWF  xA4
.................... 	} else if ( 'D'==buff[3] ) {
0590:  BRA    05A0
0592:  MOVF   xDC,W
0594:  SUBLW  44
0596:  BNZ   059E
.................... 		current.compile_month=12;
0598:  MOVLW  0C
059A:  MOVWF  xA4
.................... 	} else {
059C:  BRA    05A0
.................... 		/* error parsing, shouldn't happen */
.................... 		current.compile_month=255;
059E:  SETF   xA4
.................... 	}
.................... 	current.compile_year =(buff[7]-'0')*10;
05A0:  MOVLW  30
05A2:  SUBWF  xE0,W
05A4:  MULLW  0A
05A6:  MOVFF  FF3,A3
.................... 	current.compile_year+=(buff[8]-'0');
05AA:  MOVLW  30
05AC:  SUBWF  xE1,W
05AE:  ADDWF  xA3,F
.................... 
.................... 
.................... 	/* one periodic interrupt @ 1mS. Generated from system 16 MHz clock */
.................... 	/* prescale=16, match=249, postscale=1. Match is 249 because when match occurs, one cycle is lost */
.................... 	setup_timer_2(T2_DIV_BY_16,249,1);
05B0:  MOVLW  00
05B2:  IORLW  06
05B4:  MOVWF  FCA
05B6:  MOVLW  F9
05B8:  MOVWF  FCB
.................... 
.................... 	enable_interrupts(INT_TIMER2);
05BA:  BSF    F9D.1
.................... 
.................... 	/* set I2C slave address, which is always an even number */
.................... 	i2c_slaveaddr(0x3e + (read_dip_switch()<<1) );
05BC:  RCALL  0436
05BE:  BCF    FD8.0
05C0:  RLCF   01,W
05C2:  ADDLW  3E
05C4:  MOVWF  FC8
05C6:  GOTO   1340 (RETURN)
.................... }
.................... 
.................... 
.................... void main(void) {
*
12A8:  CLRF   FF8
12AA:  BCF    FD0.7
12AC:  BSF    07.7
12AE:  BSF    F93.6
12B0:  BSF    F93.4
12B2:  CLRF   FC8
12B4:  MOVLW  36
12B6:  MOVWF  FC6
12B8:  BSF    FC5.0
12BA:  BSF    FC5.7
12BC:  CLRF   19
12BE:  BSF    FB8.3
12C0:  MOVLW  A0
12C2:  MOVWF  FAF
12C4:  MOVLW  01
12C6:  MOVWF  FB0
12C8:  MOVLW  A6
12CA:  MOVWF  FAC
12CC:  MOVLW  90
12CE:  MOVWF  FAB
12D0:  MOVLW  03
12D2:  MOVWF  xCE
12D4:  CLRF   xD5
12D6:  CLRF   xD4
12D8:  MOVLW  00
12DA:  MOVWF  F7E
12DC:  BCF    FC1.0
12DE:  BCF    FC1.1
12E0:  BCF    FC1.2
12E2:  BCF    FC1.3
12E4:  MOVWF  F7F
12E6:  CLRF   F6C
12E8:  CLRF   F6B
12EA:  CLRF   F6D
12EC:  BRA    12FE
12EE:  DATA B0,40
12F0:  DATA 1A,00
12F2:  DATA 03,00
12F4:  DATA CB,00
12F6:  DATA 00,00
12F8:  DATA 05,40
12FA:  DATA CF,00
12FC:  DATA 00,00
12FE:  MOVLW  00
1300:  MOVWF  FF8
1302:  MOVLW  12
1304:  MOVWF  FF7
1306:  MOVLW  EE
1308:  MOVWF  FF6
130A:  TBLRD*+
130C:  MOVF   FF5,W
130E:  MOVWF  00
1310:  XORLW  00
1312:  BZ    133A
1314:  TBLRD*+
1316:  MOVF   FF5,W
1318:  MOVWF  01
131A:  BTFSC  FE8.7
131C:  BRA    1328
131E:  ANDLW  3F
1320:  MOVWF  FEA
1322:  TBLRD*+
1324:  MOVFF  FF5,FE9
1328:  BTFSC  01.6
132A:  TBLRD*+
132C:  BTFSS  01.6
132E:  TBLRD*+
1330:  MOVFF  FF5,FEE
1334:  DCFSNZ 00,F
1336:  BRA    130A
1338:  BRA    132C
133A:  CLRF   FF8
.................... 	int8 i;
.................... 	int8 last_a, last_b;
.................... 
.................... 	init();
133C:  GOTO   049E
.................... 
.................... 
.................... 	/* read parameters from EEPROM and write defaults if CRC doesn't match */
.................... 	read_param_file();
1340:  GOTO   086E
.................... 
.................... 	if ( config.startup_power_on_delay > 100 )
1344:  MOVF   1D,F
1346:  BNZ   134E
1348:  MOVF   1C,W
134A:  SUBLW  64
134C:  BC    1354
.................... 		config.startup_power_on_delay=100;
134E:  CLRF   1D
1350:  MOVLW  64
1352:  MOVWF  1C
.................... 
.................... 	/* flash on startup */
.................... 	for ( i=0 ; i<config.startup_power_on_delay ; i++ ) {
1354:  CLRF   xD6
1356:  MOVF   1D,F
1358:  BNZ   1360
135A:  MOVF   1C,W
135C:  SUBWF  xD6,W
135E:  BC    137E
.................... 		restart_wdt();
1360:  CLRWDT
.................... 		output_high(LED_A);
1362:  BCF    F94.1
1364:  BSF    F8B.1
.................... 		delay_ms(200);
1366:  MOVLW  C8
1368:  MOVWF  xFB
136A:  CALL   040E
.................... 		output_low(LED_A);
136E:  BCF    F94.1
1370:  BCF    F8B.1
.................... 		delay_ms(200);
1372:  MOVLW  C8
1374:  MOVWF  xFB
1376:  CALL   040E
137A:  INCF   xD6,F
137C:  BRA    1356
.................... 	}
.................... 
.................... 	fprintf(STREAM_FTDI,"# dcswc_module_latching_contactor %s\r\n# ",__DATE__);
137E:  MOVLW  A8
1380:  MOVWF  FF6
1382:  MOVLW  01
1384:  MOVWF  FF7
1386:  MOVLW  22
1388:  MOVWF  xDC
138A:  CALL   08A8
138E:  MOVLW  D2
1390:  MOVWF  FF6
1392:  MOVLW  01
1394:  MOVWF  FF7
1396:  CALL   08C8
139A:  MOVLW  CC
139C:  MOVWF  FF6
139E:  MOVLW  01
13A0:  MOVWF  FF7
13A2:  MOVLW  04
13A4:  MOVWF  xDC
13A6:  CALL   08A8
.................... 	switch ( restart_cause ) {
13AA:  MOVLW  07
13AC:  SUBWF  00,W
13AE:  BZ    13D4
13B0:  MOVLW  0B
13B2:  SUBWF  00,W
13B4:  BZ    13E2
13B6:  MOVLW  0F
13B8:  SUBWF  00,W
13BA:  BZ    13F0
13BC:  MOVLW  0C
13BE:  SUBWF  00,W
13C0:  BZ    13FE
13C2:  MOVLW  0E
13C4:  SUBWF  00,W
13C6:  BZ    140C
13C8:  MOVLW  03
13CA:  SUBWF  00,W
13CC:  BZ    141A
13CE:  MOVF   00,F
13D0:  BZ    1428
13D2:  BRA    1436
.................... 		case WDT_TIMEOUT:       fprintf(STREAM_FTDI,"WDT TIMEOUT"); break;
13D4:  MOVLW  DC
13D6:  MOVWF  FF6
13D8:  MOVLW  01
13DA:  MOVWF  FF7
13DC:  CALL   08C8
13E0:  BRA    1442
.................... 		case MCLR_FROM_SLEEP:   fprintf(STREAM_FTDI,"MCLR FROM SLEEP"); break;
13E2:  MOVLW  E8
13E4:  MOVWF  FF6
13E6:  MOVLW  01
13E8:  MOVWF  FF7
13EA:  CALL   08C8
13EE:  BRA    1442
.................... 		case MCLR_FROM_RUN:     fprintf(STREAM_FTDI,"MCLR FROM RUN"); break;
13F0:  MOVLW  F8
13F2:  MOVWF  FF6
13F4:  MOVLW  01
13F6:  MOVWF  FF7
13F8:  CALL   08C8
13FC:  BRA    1442
.................... 		case NORMAL_POWER_UP:   fprintf(STREAM_FTDI,"NORMAL POWER UP"); break;
13FE:  MOVLW  06
1400:  MOVWF  FF6
1402:  MOVLW  02
1404:  MOVWF  FF7
1406:  CALL   08C8
140A:  BRA    1442
.................... 		case BROWNOUT_RESTART:  fprintf(STREAM_FTDI,"BROWNOUT RESTART"); break;
140C:  MOVLW  16
140E:  MOVWF  FF6
1410:  MOVLW  02
1412:  MOVWF  FF7
1414:  CALL   08C8
1418:  BRA    1442
.................... 		case WDT_FROM_SLEEP:    fprintf(STREAM_FTDI,"WDT FROM SLEEP"); break;
141A:  MOVLW  28
141C:  MOVWF  FF6
141E:  MOVLW  02
1420:  MOVWF  FF7
1422:  CALL   08C8
1426:  BRA    1442
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_FTDI,"RESET INSTRUCTION"); break;
1428:  MOVLW  38
142A:  MOVWF  FF6
142C:  MOVLW  02
142E:  MOVWF  FF7
1430:  CALL   08C8
1434:  BRA    1442
.................... 		default:                fprintf(STREAM_FTDI,"UNKNOWN!");
1436:  MOVLW  4A
1438:  MOVWF  FF6
143A:  MOVLW  02
143C:  MOVWF  FF7
143E:  CALL   08C8
.................... 	}
.................... 	fprintf(STREAM_FTDI,"\r\n");
1442:  MOVLW  0D
1444:  BTFSS  F9E.4
1446:  BRA    1444
1448:  MOVWF  FAD
144A:  MOVLW  0A
144C:  BTFSS  F9E.4
144E:  BRA    144C
1450:  MOVWF  FAD
.................... 
.................... 	timers.led_on_a=500;
1452:  MOVLW  F4
1454:  MOVWF  xA8
.................... 
.................... 	enable_interrupts(GLOBAL);
1456:  MOVLW  C0
1458:  IORWF  FF2,F
.................... 
.................... 	/* Prime ADC filter */
.................... 	for ( i=0 ; i<30 ; i++ ) {
145A:  CLRF   xD6
145C:  MOVF   xD6,W
145E:  SUBLW  1D
1460:  BNC   146A
.................... 		adc_update();
1462:  CALL   08EA
1466:  INCF   xD6,F
1468:  BRA    145C
.................... 	}
.................... 
.................... 	last_a = ! input(SW_OVERRIDE_A);
146A:  BSF    F92.5
146C:  CLRF   xD7
146E:  BTFSS  F80.5
1470:  INCF   xD7,F
.................... 	last_b = ! input(SW_OVERRIDE_B);
1472:  BSF    F92.4
1474:  CLRF   xD8
1476:  BTFSS  F80.4
1478:  INCF   xD8,F
.................... 
.................... 
.................... 	/* enable I2C slave interrupt */
.................... 	enable_interrupts(INT_SSP);
147A:  BSF    F9D.3
.................... 
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
147C:  CLRWDT
.................... 
.................... 		if ( timers.now_millisecond ) {
147E:  BTFSS  xA7.2
1480:  BRA    1484
.................... 			periodic_millisecond();
1482:  BRA    101A
.................... 		}
.................... 
.................... 		if ( kbhit() ) {
1484:  BTFSS  F9E.5
1486:  BRA    18AE
.................... 			getc();
1488:  BRA    10CC
.................... 			fprintf(STREAM_FTDI,"# read_dip_switch()=%u\r\n",read_dip_switch());
148A:  CALL   0436
148E:  MOVFF  01,D9
1492:  MOVLW  54
1494:  MOVWF  FF6
1496:  MOVLW  02
1498:  MOVWF  FF7
149A:  MOVLW  14
149C:  MOVWF  xDC
149E:  CALL   08A8
14A2:  MOVFF  D9,DA
14A6:  MOVLW  1B
14A8:  MOVWF  xDB
14AA:  RCALL  110C
14AC:  MOVLW  0D
14AE:  BTFSS  F9E.4
14B0:  BRA    14AE
14B2:  MOVWF  FAD
14B4:  MOVLW  0A
14B6:  BTFSS  F9E.4
14B8:  BRA    14B6
14BA:  MOVWF  FAD
.................... 			fprintf(STREAM_FTDI,"#    vin adc=%lu\r\n",adc_get(0));
14BC:  CLRF   xDC
14BE:  CALL   0980
14C2:  MOVFF  02,DA
14C6:  MOVFF  01,D9
14CA:  MOVLW  6E
14CC:  MOVWF  FF6
14CE:  MOVLW  02
14D0:  MOVWF  FF7
14D2:  MOVLW  0D
14D4:  MOVWF  xDC
14D6:  CALL   08A8
14DA:  MOVLW  10
14DC:  MOVWF  FE9
14DE:  MOVFF  DA,DC
14E2:  MOVFF  D9,DB
14E6:  RCALL  1178
14E8:  MOVLW  0D
14EA:  BTFSS  F9E.4
14EC:  BRA    14EA
14EE:  MOVWF  FAD
14F0:  MOVLW  0A
14F2:  BTFSS  F9E.4
14F4:  BRA    14F2
14F6:  MOVWF  FAD
.................... 			fprintf(STREAM_FTDI,"#   temp adc=%lu\r\n",adc_get(1));
14F8:  MOVLW  01
14FA:  MOVWF  xDC
14FC:  CALL   0980
1500:  MOVFF  02,DA
1504:  MOVFF  01,D9
1508:  MOVLW  82
150A:  MOVWF  FF6
150C:  MOVLW  02
150E:  MOVWF  FF7
1510:  MOVLW  0D
1512:  MOVWF  xDC
1514:  CALL   08A8
1518:  MOVLW  10
151A:  MOVWF  FE9
151C:  MOVFF  DA,DC
1520:  MOVFF  D9,DB
1524:  RCALL  1178
1526:  MOVLW  0D
1528:  BTFSS  F9E.4
152A:  BRA    1528
152C:  MOVWF  FAD
152E:  MOVLW  0A
1530:  BTFSS  F9E.4
1532:  BRA    1530
1534:  MOVWF  FAD
.................... 			fprintf(STREAM_FTDI,"# dip sw adc=%lu\r\n",adc_get(2));
1536:  MOVLW  02
1538:  MOVWF  xDC
153A:  CALL   0980
153E:  MOVFF  02,DA
1542:  MOVFF  01,D9
1546:  MOVLW  96
1548:  MOVWF  FF6
154A:  MOVLW  02
154C:  MOVWF  FF7
154E:  MOVLW  0D
1550:  MOVWF  xDC
1552:  CALL   08A8
1556:  MOVLW  10
1558:  MOVWF  FE9
155A:  MOVFF  DA,DC
155E:  MOVFF  D9,DB
1562:  RCALL  1178
1564:  MOVLW  0D
1566:  BTFSS  F9E.4
1568:  BRA    1566
156A:  MOVWF  FAD
156C:  MOVLW  0A
156E:  BTFSS  F9E.4
1570:  BRA    156E
1572:  MOVWF  FAD
.................... 
.................... 			for ( i=0 ; i<2 ; i++ ) {
1574:  CLRF   xD6
1576:  MOVF   xD6,W
1578:  SUBLW  01
157A:  BTFSS  FD8.0
157C:  BRA    18AE
.................... 				restart_wdt();
157E:  CLRWDT
.................... 				fprintf(STREAM_FTDI,"# channel[%u]\r\n",i);
1580:  MOVLW  AA
1582:  MOVWF  FF6
1584:  MOVLW  02
1586:  MOVWF  FF7
1588:  MOVLW  0A
158A:  MOVWF  xDC
158C:  CALL   08A8
1590:  MOVFF  D6,DA
1594:  MOVLW  1B
1596:  MOVWF  xDB
1598:  RCALL  110C
159A:  MOVLW  B6
159C:  MOVWF  FF6
159E:  MOVLW  02
15A0:  MOVWF  FF7
15A2:  MOVLW  03
15A4:  MOVWF  xDC
15A6:  CALL   08A8
.................... 				fprintf(STREAM_FTDI,"#                        state=0x%02x\r\n",channel[i].state);
15AA:  MOVF   xD6,W
15AC:  MULLW  0F
15AE:  MOVF   FF3,W
15B0:  CLRF   xDA
15B2:  MOVWF  xD9
15B4:  MOVLW  AC
15B6:  ADDWF  xD9,W
15B8:  MOVWF  FE9
15BA:  MOVLW  00
15BC:  ADDWFC xDA,W
15BE:  MOVWF  FEA
15C0:  MOVFF  FEF,DB
15C4:  MOVLW  BA
15C6:  MOVWF  FF6
15C8:  MOVLW  02
15CA:  MOVWF  FF7
15CC:  MOVLW  21
15CE:  MOVWF  xDC
15D0:  CALL   08A8
15D4:  MOVFF  DB,DC
15D8:  MOVLW  57
15DA:  MOVWF  xDD
15DC:  BRA    1224
15DE:  MOVLW  0D
15E0:  BTFSS  F9E.4
15E2:  BRA    15E0
15E4:  MOVWF  FAD
15E6:  MOVLW  0A
15E8:  BTFSS  F9E.4
15EA:  BRA    15E8
15EC:  MOVWF  FAD
.................... 				fprintf(STREAM_FTDI,"#           command_on_seconds=%lu\r\n",channel[i].command_on_seconds);
15EE:  MOVF   xD6,W
15F0:  MULLW  0F
15F2:  MOVF   FF3,W
15F4:  CLRF   xDA
15F6:  MOVWF  xD9
15F8:  MOVLW  01
15FA:  ADDWF  xD9,W
15FC:  MOVWF  01
15FE:  MOVLW  00
1600:  ADDWFC xDA,W
1602:  MOVWF  03
1604:  MOVF   01,W
1606:  ADDLW  AC
1608:  MOVWF  FE9
160A:  MOVLW  00
160C:  ADDWFC 03,W
160E:  MOVWF  FEA
1610:  MOVFF  FEC,DA
1614:  MOVF   FED,F
1616:  MOVFF  FEF,D9
161A:  MOVLW  E2
161C:  MOVWF  FF6
161E:  MOVLW  02
1620:  MOVWF  FF7
1622:  MOVLW  1F
1624:  MOVWF  xDC
1626:  CALL   08A8
162A:  MOVLW  10
162C:  MOVWF  FE9
162E:  MOVFF  DA,DC
1632:  MOVFF  D9,DB
1636:  RCALL  1178
1638:  MOVLW  0D
163A:  BTFSS  F9E.4
163C:  BRA    163A
163E:  MOVWF  FAD
1640:  MOVLW  0A
1642:  BTFSS  F9E.4
1644:  BRA    1642
1646:  MOVWF  FAD
.................... 				fprintf(STREAM_FTDI,"#      command_on_hold_seconds=%lu\r\n",channel[i].command_on_hold_seconds);
1648:  MOVF   xD6,W
164A:  MULLW  0F
164C:  MOVF   FF3,W
164E:  CLRF   xDA
1650:  MOVWF  xD9
1652:  MOVLW  03
1654:  ADDWF  xD9,W
1656:  MOVWF  01
1658:  MOVLW  00
165A:  ADDWFC xDA,W
165C:  MOVWF  03
165E:  MOVF   01,W
1660:  ADDLW  AC
1662:  MOVWF  FE9
1664:  MOVLW  00
1666:  ADDWFC 03,W
1668:  MOVWF  FEA
166A:  MOVFF  FEC,DA
166E:  MOVF   FED,F
1670:  MOVFF  FEF,D9
1674:  MOVLW  08
1676:  MOVWF  FF6
1678:  MOVLW  03
167A:  MOVWF  FF7
167C:  MOVLW  1F
167E:  MOVWF  xDC
1680:  CALL   08A8
1684:  MOVLW  10
1686:  MOVWF  FE9
1688:  MOVFF  DA,DC
168C:  MOVFF  D9,DB
1690:  RCALL  1178
1692:  MOVLW  0D
1694:  BTFSS  F9E.4
1696:  BRA    1694
1698:  MOVWF  FAD
169A:  MOVLW  0A
169C:  BTFSS  F9E.4
169E:  BRA    169C
16A0:  MOVWF  FAD
.................... 
.................... 				fprintf(STREAM_FTDI,"#          command_off_seconds=%lu\r\n",channel[i].command_off_seconds);
16A2:  MOVF   xD6,W
16A4:  MULLW  0F
16A6:  MOVF   FF3,W
16A8:  CLRF   xDA
16AA:  MOVWF  xD9
16AC:  MOVLW  05
16AE:  ADDWF  xD9,W
16B0:  MOVWF  01
16B2:  MOVLW  00
16B4:  ADDWFC xDA,W
16B6:  MOVWF  03
16B8:  MOVF   01,W
16BA:  ADDLW  AC
16BC:  MOVWF  FE9
16BE:  MOVLW  00
16C0:  ADDWFC 03,W
16C2:  MOVWF  FEA
16C4:  MOVFF  FEC,DA
16C8:  MOVF   FED,F
16CA:  MOVFF  FEF,D9
16CE:  MOVLW  2E
16D0:  MOVWF  FF6
16D2:  MOVLW  03
16D4:  MOVWF  FF7
16D6:  MOVLW  1F
16D8:  MOVWF  xDC
16DA:  CALL   08A8
16DE:  MOVLW  10
16E0:  MOVWF  FE9
16E2:  MOVFF  DA,DC
16E6:  MOVFF  D9,DB
16EA:  RCALL  1178
16EC:  MOVLW  0D
16EE:  BTFSS  F9E.4
16F0:  BRA    16EE
16F2:  MOVWF  FAD
16F4:  MOVLW  0A
16F6:  BTFSS  F9E.4
16F8:  BRA    16F6
16FA:  MOVWF  FAD
.................... 				fprintf(STREAM_FTDI,"#     command_off_hold_seconds=%lu\r\n",channel[i].command_off_hold_seconds);
16FC:  MOVF   xD6,W
16FE:  MULLW  0F
1700:  MOVF   FF3,W
1702:  CLRF   xDA
1704:  MOVWF  xD9
1706:  MOVLW  07
1708:  ADDWF  xD9,W
170A:  MOVWF  01
170C:  MOVLW  00
170E:  ADDWFC xDA,W
1710:  MOVWF  03
1712:  MOVF   01,W
1714:  ADDLW  AC
1716:  MOVWF  FE9
1718:  MOVLW  00
171A:  ADDWFC 03,W
171C:  MOVWF  FEA
171E:  MOVFF  FEC,DA
1722:  MOVF   FED,F
1724:  MOVFF  FEF,D9
1728:  MOVLW  54
172A:  MOVWF  FF6
172C:  MOVLW  03
172E:  MOVWF  FF7
1730:  MOVLW  1F
1732:  MOVWF  xDC
1734:  CALL   08A8
1738:  MOVLW  10
173A:  MOVWF  FE9
173C:  MOVFF  DA,DC
1740:  MOVFF  D9,DB
1744:  RCALL  1178
1746:  MOVLW  0D
1748:  BTFSS  F9E.4
174A:  BRA    1748
174C:  MOVWF  FAD
174E:  MOVLW  0A
1750:  BTFSS  F9E.4
1752:  BRA    1750
1754:  MOVWF  FAD
.................... 
.................... 				fprintf(STREAM_FTDI,"# lvd_disconnect_delay_seconds=%lu\r\n",channel[i].lvd_disconnect_delay_seconds);
1756:  MOVF   xD6,W
1758:  MULLW  0F
175A:  MOVF   FF3,W
175C:  CLRF   xDA
175E:  MOVWF  xD9
1760:  MOVLW  09
1762:  ADDWF  xD9,W
1764:  MOVWF  01
1766:  MOVLW  00
1768:  ADDWFC xDA,W
176A:  MOVWF  03
176C:  MOVF   01,W
176E:  ADDLW  AC
1770:  MOVWF  FE9
1772:  MOVLW  00
1774:  ADDWFC 03,W
1776:  MOVWF  FEA
1778:  MOVFF  FEC,DA
177C:  MOVF   FED,F
177E:  MOVFF  FEF,D9
1782:  MOVLW  7A
1784:  MOVWF  FF6
1786:  MOVLW  03
1788:  MOVWF  FF7
178A:  MOVLW  1F
178C:  MOVWF  xDC
178E:  CALL   08A8
1792:  MOVLW  10
1794:  MOVWF  FE9
1796:  MOVFF  DA,DC
179A:  MOVFF  D9,DB
179E:  RCALL  1178
17A0:  MOVLW  0D
17A2:  BTFSS  F9E.4
17A4:  BRA    17A2
17A6:  MOVWF  FAD
17A8:  MOVLW  0A
17AA:  BTFSS  F9E.4
17AC:  BRA    17AA
17AE:  MOVWF  FAD
.................... 				fprintf(STREAM_FTDI,"#  lvd_reconnect_delay_seconds=%u\r\n",channel[i].lvd_reconnect_delay_seconds);
17B0:  MOVF   xD6,W
17B2:  MULLW  0F
17B4:  MOVF   FF3,W
17B6:  CLRF   xDA
17B8:  MOVWF  xD9
17BA:  MOVLW  0B
17BC:  ADDWF  xD9,W
17BE:  MOVWF  01
17C0:  MOVLW  00
17C2:  ADDWFC xDA,W
17C4:  MOVWF  03
17C6:  MOVF   01,W
17C8:  ADDLW  AC
17CA:  MOVWF  FE9
17CC:  MOVLW  00
17CE:  ADDWFC 03,W
17D0:  MOVWF  FEA
17D2:  MOVFF  FEF,D9
17D6:  MOVLW  A0
17D8:  MOVWF  FF6
17DA:  MOVLW  03
17DC:  MOVWF  FF7
17DE:  MOVLW  1F
17E0:  MOVWF  xDC
17E2:  CALL   08A8
17E6:  MOVFF  D9,DA
17EA:  MOVLW  1B
17EC:  MOVWF  xDB
17EE:  RCALL  110C
17F0:  MOVLW  0D
17F2:  BTFSS  F9E.4
17F4:  BRA    17F2
17F6:  MOVWF  FAD
17F8:  MOVLW  0A
17FA:  BTFSS  F9E.4
17FC:  BRA    17FA
17FE:  MOVWF  FAD
.................... 
.................... 				fprintf(STREAM_FTDI,"# hvd_disconnect_delay_seconds=%lu\r\n",channel[i].hvd_disconnect_delay_seconds);
1800:  MOVF   xD6,W
1802:  MULLW  0F
1804:  MOVF   FF3,W
1806:  CLRF   xDA
1808:  MOVWF  xD9
180A:  MOVLW  0C
180C:  ADDWF  xD9,W
180E:  MOVWF  01
1810:  MOVLW  00
1812:  ADDWFC xDA,W
1814:  MOVWF  03
1816:  MOVF   01,W
1818:  ADDLW  AC
181A:  MOVWF  FE9
181C:  MOVLW  00
181E:  ADDWFC 03,W
1820:  MOVWF  FEA
1822:  MOVFF  FEC,DA
1826:  MOVF   FED,F
1828:  MOVFF  FEF,D9
182C:  MOVLW  C4
182E:  MOVWF  FF6
1830:  MOVLW  03
1832:  MOVWF  FF7
1834:  MOVLW  1F
1836:  MOVWF  xDC
1838:  CALL   08A8
183C:  MOVLW  10
183E:  MOVWF  FE9
1840:  MOVFF  DA,DC
1844:  MOVFF  D9,DB
1848:  RCALL  1178
184A:  MOVLW  0D
184C:  BTFSS  F9E.4
184E:  BRA    184C
1850:  MOVWF  FAD
1852:  MOVLW  0A
1854:  BTFSS  F9E.4
1856:  BRA    1854
1858:  MOVWF  FAD
.................... 				fprintf(STREAM_FTDI,"#  hvd_reconnect_delay_seconds=%u\r\n",channel[i].hvd_reconnect_delay_seconds);
185A:  MOVF   xD6,W
185C:  MULLW  0F
185E:  MOVF   FF3,W
1860:  CLRF   xDA
1862:  MOVWF  xD9
1864:  MOVLW  0E
1866:  ADDWF  xD9,W
1868:  MOVWF  01
186A:  MOVLW  00
186C:  ADDWFC xDA,W
186E:  MOVWF  03
1870:  MOVF   01,W
1872:  ADDLW  AC
1874:  MOVWF  FE9
1876:  MOVLW  00
1878:  ADDWFC 03,W
187A:  MOVWF  FEA
187C:  MOVFF  FEF,D9
1880:  MOVLW  EA
1882:  MOVWF  FF6
1884:  MOVLW  03
1886:  MOVWF  FF7
1888:  MOVLW  1F
188A:  MOVWF  xDC
188C:  CALL   08A8
1890:  MOVFF  D9,DA
1894:  MOVLW  1B
1896:  MOVWF  xDB
1898:  RCALL  110C
189A:  MOVLW  0D
189C:  BTFSS  F9E.4
189E:  BRA    189C
18A0:  MOVWF  FAD
18A2:  MOVLW  0A
18A4:  BTFSS  F9E.4
18A6:  BRA    18A4
18A8:  MOVWF  FAD
.................... 			}
.................... 
.................... #if 0
18AA:  INCF   xD6,F
18AC:  BRA    1576
.................... 	int16 lvd_disconnect_delay_seconds;	/* counts down */
.................... 	int8  lvd_reconnect_delay_seconds;	/* counts down */
.................... 
.................... 	int16 hvd_disconnect_delay_seconds;	/* counts down */
.................... 	int8  hvd_reconnect_delay_seconds;	/* counts down */
.................... #endif
.................... 		}
.................... 
.................... 		if ( input(SW_OVERRIDE_A) != last_a ) {
18AE:  BSF    F92.5
18B0:  MOVLW  00
18B2:  BTFSC  F80.5
18B4:  MOVLW  01
18B6:  SUBWF  xD7,W
18B8:  BZ    18D2
.................... 			last_a=input(SW_OVERRIDE_A);
18BA:  BSF    F92.5
18BC:  CLRF   xD7
18BE:  BTFSC  F80.5
18C0:  INCF   xD7,F
.................... 
.................... 			if ( last_a ) {
18C2:  MOVF   xD7,F
18C4:  BZ    18CE
.................... 				timers.led_on_a=500;
18C6:  MOVLW  F4
18C8:  MOVWF  xA8
.................... 				contactor_on_a();
18CA:  BRA    1268
.................... 			} else {
18CC:  BRA    18D2
.................... 				timers.led_on_a=0;
18CE:  CLRF   xA8
.................... 				contactor_off_a();
18D0:  BRA    1278
.................... 			}
.................... 		}
.................... 
.................... 
.................... 		if ( input(SW_OVERRIDE_B) != last_b ) {
18D2:  BSF    F92.4
18D4:  MOVLW  00
18D6:  BTFSC  F80.4
18D8:  MOVLW  01
18DA:  SUBWF  xD8,W
18DC:  BZ    18F6
.................... 			last_B=input(SW_OVERRIDE_B);
18DE:  BSF    F92.4
18E0:  CLRF   xD8
18E2:  BTFSC  F80.4
18E4:  INCF   xD8,F
.................... 
.................... 			if ( last_b ) {
18E6:  MOVF   xD8,F
18E8:  BZ    18F2
.................... 				timers.led_on_b=500;
18EA:  MOVLW  F4
18EC:  MOVWF  xA9
.................... 				contactor_on_b();
18EE:  BRA    1288
.................... 			} else {
18F0:  BRA    18F6
.................... 				timers.led_on_b=0;
18F2:  CLRF   xA9
.................... 				contactor_off_b();
18F4:  BRA    1298
.................... 			}
.................... 		}
.................... 
.................... 
.................... 
.................... 		if ( timers.now_adc_sample ) {
18F6:  BTFSS  xA7.0
18F8:  BRA    1900
.................... 			timers.now_adc_sample=0;
18FA:  BCF    xA7.0
.................... 			adc_update();
18FC:  CALL   08EA
.................... 		}
.................... 
.................... 		if ( timers.now_write_config ) {
1900:  BTFSS  xA7.3
1902:  BRA    190A
.................... 			timers.now_write_config=0;
1904:  BCF    xA7.3
.................... 			write_param_file();
1906:  CALL   06E2
.................... 		}
.................... 		if ( timers.now_reset_config ) {
190A:  BTFSS  xA7.4
190C:  BRA    1914
.................... 			timers.now_reset_config=0;
190E:  BCF    xA7.4
.................... 			write_default_param_file();
1910:  CALL   072A
.................... 		}
1914:  BRA    147C
.................... 
.................... 
.................... 	}
.................... 
.................... 
.................... }
1916:  BRA    1916

Configuration Fuses:
   Word  1: 2800   INTRC_IO NOPLLEN PCLKEN NOFCMEN NOIESO
   Word  2: 0E19   NOPUT NOBROWNOUT BORV19 NOWDT WDT128
   Word  3: 0000   NOHFOFST NOMCLR
   Word  4: 0009   STVREN NOLVP BBSIZ2K NOXINST DEBUG
   Word  5: C003   NOPROTECT NOCPB NOCPD
   Word  6: E003   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 4003   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.

ROM data:
F00000: 00 00 40 00                                        ..@.
