CCS PCH C Compiler, Version 5.090, 49113               16-Aug-22 17:42

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\dcswc_module_latching_contactor\dcswc_module_latching_contactor.lst

               ROM used:   12186 bytes (74%)
                           Largest free fragment is 4194
               RAM used:   283 (55%) at main() level
                           311 (61%) worst case
               Stack used: 4 locations (2 in main + 2 for interrupts)
               Stack size: 31

0000:  GOTO   2D8C
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   00D4
0060:  BTFSS  F9D.3
0062:  GOTO   006C
0066:  BTFSC  F9E.3
0068:  GOTO   0E8A
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include "dcswc_module_latching_contactor.h"
.................... #include <18F14K22.h>
.................... //////////// Standard Header file for the PIC18F14K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F14K22
00BA:  CLRF   FF7
00BC:  ADDLW  CA
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  RETURN 0
00CA:  DATA 31,36
00CC:  DATA 2D,41
00CE:  DATA 75,67
00D0:  DATA 2D,32
00D2:  DATA 32,00
*
0F5C:  DATA 23,20
0F5E:  DATA 20,20
0F60:  DATA 20,20
0F62:  DATA 20,20
0F64:  DATA 76,69
0F66:  DATA 6E,20
0F68:  DATA 61,64
0F6A:  DATA 63,3D
0F6C:  DATA 25,6C
0F6E:  DATA 75,0D
0F70:  DATA 0A,00
0F72:  DATA 23,20
0F74:  DATA 20,20
0F76:  DATA 20,20
0F78:  DATA 20,74
0F7A:  DATA 65,6D
0F7C:  DATA 70,20
0F7E:  DATA 61,64
0F80:  DATA 63,3D
0F82:  DATA 25,6C
0F84:  DATA 75,0D
0F86:  DATA 0A,00
0F88:  DATA 23,20
0F8A:  DATA 20,20
0F8C:  DATA 63,68
0F8E:  DATA 5B,30
0F90:  DATA 5D,2E
0F92:  DATA 73,74
0F94:  DATA 61,74
0F96:  DATA 65,3D
0F98:  DATA 30,78
0F9A:  DATA 25,32
0F9C:  DATA 58,0D
0F9E:  DATA 0A,00
0FA0:  DATA 23,20
0FA2:  DATA 20,20
0FA4:  DATA 63,68
0FA6:  DATA 5B,31
0FA8:  DATA 5D,2E
0FAA:  DATA 73,74
0FAC:  DATA 61,74
0FAE:  DATA 65,3D
0FB0:  DATA 30,78
0FB2:  DATA 25,32
0FB4:  DATA 58,0D
0FB6:  DATA 0A,00
0FB8:  DATA 23,20
0FBA:  DATA 64,63
0FBC:  DATA 73,77
0FBE:  DATA 63,5F
0FC0:  DATA 6D,6F
0FC2:  DATA 64,75
0FC4:  DATA 6C,65
0FC6:  DATA 5F,6C
0FC8:  DATA 61,74
0FCA:  DATA 63,68
0FCC:  DATA 69,6E
0FCE:  DATA 67,5F
0FD0:  DATA 63,6F
0FD2:  DATA 6E,74
0FD4:  DATA 61,63
0FD6:  DATA 74,6F
0FD8:  DATA 72,20
0FDA:  DATA 25,73
0FDC:  DATA 0D,0A
0FDE:  DATA 23,20
0FE0:  DATA 00,00
0FE2:  DATA 31,36
0FE4:  DATA 2D,41
0FE6:  DATA 75,67
0FE8:  DATA 2D,32
0FEA:  DATA 32,00
0FEC:  DATA 57,44
0FEE:  DATA 54,20
0FF0:  DATA 54,49
0FF2:  DATA 4D,45
0FF4:  DATA 4F,55
0FF6:  DATA 54,00
0FF8:  DATA 4D,43
0FFA:  DATA 4C,52
0FFC:  DATA 20,46
0FFE:  DATA 52,4F
1000:  DATA 4D,20
1002:  DATA 53,4C
1004:  DATA 45,45
1006:  DATA 50,00
1008:  DATA 4D,43
100A:  DATA 4C,52
100C:  DATA 20,46
100E:  DATA 52,4F
1010:  DATA 4D,20
1012:  DATA 52,55
1014:  DATA 4E,00
1016:  DATA 4E,4F
1018:  DATA 52,4D
101A:  DATA 41,4C
101C:  DATA 20,50
101E:  DATA 4F,57
1020:  DATA 45,52
1022:  DATA 20,55
1024:  DATA 50,00
1026:  DATA 42,52
1028:  DATA 4F,57
102A:  DATA 4E,4F
102C:  DATA 55,54
102E:  DATA 20,52
1030:  DATA 45,53
1032:  DATA 54,41
1034:  DATA 52,54
1036:  DATA 00,00
1038:  DATA 57,44
103A:  DATA 54,20
103C:  DATA 46,52
103E:  DATA 4F,4D
1040:  DATA 20,53
1042:  DATA 4C,45
1044:  DATA 45,50
1046:  DATA 00,00
1048:  DATA 52,45
104A:  DATA 53,45
104C:  DATA 54,20
104E:  DATA 49,4E
1050:  DATA 53,54
1052:  DATA 52,55
1054:  DATA 43,54
1056:  DATA 49,4F
1058:  DATA 4E,00
105A:  DATA 55,4E
105C:  DATA 4B,4E
105E:  DATA 4F,57
1060:  DATA 4E,21
1062:  DATA 00,00
*
188C:  TBLRD*+
188E:  MOVFF  FF6,11E
1892:  MOVFF  FF7,11F
1896:  MOVF   FF5,W
1898:  BTFSS  F9E.4
189A:  BRA    1898
189C:  MOVWF  FAD
189E:  MOVFF  11E,FF6
18A2:  MOVFF  11F,FF7
18A6:  MOVLB  1
18A8:  DECFSZ x1D,F
18AA:  BRA    18AE
18AC:  BRA    18B2
18AE:  MOVLB  0
18B0:  BRA    188C
18B2:  MOVLB  0
18B4:  RETURN 0
18B6:  TBLRD*+
18B8:  MOVF   FF5,F
18BA:  BZ    18D6
18BC:  MOVFF  FF6,11B
18C0:  MOVFF  FF7,11C
18C4:  MOVF   FF5,W
18C6:  BTFSS  F9E.4
18C8:  BRA    18C6
18CA:  MOVWF  FAD
18CC:  MOVFF  11B,FF6
18D0:  MOVFF  11C,FF7
18D4:  BRA    18B6
18D6:  RETURN 0
*
2B88:  MOVFF  FEA,125
2B8C:  MOVFF  FE9,124
2B90:  MOVLB  1
2B92:  SWAPF  x1E,W
2B94:  IORLW  F0
2B96:  MOVWF  x20
2B98:  ADDWF  x20,F
2B9A:  ADDLW  E2
2B9C:  MOVWF  x21
2B9E:  ADDLW  32
2BA0:  MOVWF  x23
2BA2:  MOVF   x1E,W
2BA4:  ANDLW  0F
2BA6:  ADDWF  x21,F
2BA8:  ADDWF  x21,F
2BAA:  ADDWF  x23,F
2BAC:  ADDLW  E9
2BAE:  MOVWF  x22
2BB0:  ADDWF  x22,F
2BB2:  ADDWF  x22,F
2BB4:  SWAPF  x1D,W
2BB6:  ANDLW  0F
2BB8:  ADDWF  x22,F
2BBA:  ADDWF  x23,F
2BBC:  RLCF   x22,F
2BBE:  RLCF   x23,F
2BC0:  COMF   x23,F
2BC2:  RLCF   x23,F
2BC4:  MOVF   x1D,W
2BC6:  ANDLW  0F
2BC8:  ADDWF  x23,F
2BCA:  RLCF   x20,F
2BCC:  MOVLW  07
2BCE:  MOVWF  x1F
2BD0:  MOVLW  0A
2BD2:  DECF   x22,F
2BD4:  ADDWF  x23,F
2BD6:  BNC   2BD2
2BD8:  DECF   x21,F
2BDA:  ADDWF  x22,F
2BDC:  BNC   2BD8
2BDE:  DECF   x20,F
2BE0:  ADDWF  x21,F
2BE2:  BNC   2BDE
2BE4:  DECF   x1F,F
2BE6:  ADDWF  x20,F
2BE8:  BNC   2BE4
2BEA:  MOVLW  01
2BEC:  MOVWF  FEA
2BEE:  MOVLW  1F
2BF0:  MOVWF  FE9
2BF2:  MOVLW  07
2BF4:  ANDWF  x24,W
2BF6:  BCF    x24.6
2BF8:  ADDWF  FE9,F
2BFA:  MOVLW  00
2BFC:  ADDWFC FEA,F
2BFE:  MOVF   FE9,W
2C00:  SUBLW  23
2C02:  BNZ   2C0A
2C04:  DECFSZ FEA,W
2C06:  BRA    2C0A
2C08:  BSF    x24.6
2C0A:  MOVF   FEF,W
2C0C:  MOVWF  00
2C0E:  BNZ   2C20
2C10:  BTFSC  x24.6
2C12:  BRA    2C20
2C14:  BTFSC  x24.4
2C16:  BRA    2C30
2C18:  BTFSC  x24.3
2C1A:  BRA    2C20
2C1C:  MOVLW  20
2C1E:  BRA    2C26
2C20:  BSF    x24.3
2C22:  BCF    x24.4
2C24:  MOVLW  30
2C26:  ADDWF  00,F
2C28:  MOVF   00,W
2C2A:  BTFSS  F9E.4
2C2C:  BRA    2C2A
2C2E:  MOVWF  FAD
2C30:  MOVF   FEE,W
2C32:  BTFSS  x24.6
2C34:  BRA    2BFE
2C36:  MOVLB  0
2C38:  RETURN 0
2C3A:  MOVLB  1
2C3C:  BTFSC  x1C.7
2C3E:  BRA    2C60
2C40:  MOVLW  0F
2C42:  MOVWF  00
2C44:  SWAPF  x1B,W
2C46:  ANDWF  00,F
2C48:  MOVLW  0A
2C4A:  SUBWF  00,W
2C4C:  BC    2C54
2C4E:  MOVLW  30
2C50:  ADDWF  00,F
2C52:  BRA    2C58
2C54:  MOVF   x1C,W
2C56:  ADDWF  00,F
2C58:  MOVF   00,W
2C5A:  BTFSS  F9E.4
2C5C:  BRA    2C5A
2C5E:  MOVWF  FAD
2C60:  MOVLW  0F
2C62:  ANDWF  x1B,F
2C64:  MOVLW  0A
2C66:  SUBWF  x1B,W
2C68:  BC    2C6E
2C6A:  MOVLW  30
2C6C:  BRA    2C72
2C6E:  BCF    x1C.7
2C70:  MOVF   x1C,W
2C72:  ADDWF  x1B,F
2C74:  MOVF   x1B,W
2C76:  BTFSS  F9E.4
2C78:  BRA    2C76
2C7A:  MOVWF  FAD
2C7C:  MOVLB  0
2C7E:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #device *=16
.................... #use delay(clock=16MHz)
*
1064:  MOVLW  01
1066:  MOVWF  FEA
1068:  MOVLW  28
106A:  MOVWF  FE9
106C:  MOVF   FEF,W
106E:  BZ    108C
1070:  MOVLW  05
1072:  MOVWF  01
1074:  CLRF   00
1076:  DECFSZ 00,F
1078:  BRA    1076
107A:  DECFSZ 01,F
107C:  BRA    1074
107E:  MOVLW  2E
1080:  MOVWF  00
1082:  DECFSZ 00,F
1084:  BRA    1082
1086:  BRA    1088
1088:  DECFSZ FEF,F
108A:  BRA    1070
108C:  RETURN 0
.................... 
.................... /* hardware I2C port is slave and is connected to DCSWC bus */
.................... #use i2c(stream=STREAM_SLAVE,SLAVE, I2C1, FORCE_HW)
*
0E74:  MOVF   FC9,W
0E76:  MOVFF  12D,FC9
0E7A:  BSF    FC6.4
0E7C:  BCF    F9E.3
0E7E:  BTFSC  FC7.0
0E80:  BRA    0E7E
0E82:  CLRF   01
0E84:  BTFSS  FC5.6
0E86:  INCF   01,F
0E88:  RETURN 0
.................... /* slave address set based on dip switch in init() */
.................... 
.................... /* important FUSE notes! 
.................... MPLAB defaults to DEBUG mode and that will override fuses.
.................... make sure it is on "BUILD CONFIGURATION" of "RELEASE" under
.................... "PROJECT" menu.
.................... 
.................... CCS setup functions can override fuses. Check .LST file
.................... to see if anything has been overriden!
.................... */
.................... 
.................... #fuses NODEBUG 
.................... #fuses INTRC_IO
.................... #fuses NOPCLKEN
.................... #fuses NOPLLEN
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses BROWNOUT
.................... #fuses BORV30
.................... #fuses NOPUT
.................... #fuses WDT
.................... #fuses WDT128     /* this can be override by setup_wdt() */
.................... #fuses NOHFOFST
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses NOLVP
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... #fuses NOPROTECT
.................... #fuses NOWRT
.................... #fuses NOWRTC 
.................... #fuses NOWRTB
.................... #fuses NOWRTD
.................... #fuses NOEBTR
.................... #fuses NOEBTRB
.................... #fuses BBSIZ1K
.................... 
.................... 
.................... #use standard_io(ALL)
.................... 
.................... #use rs232(UART1,stream=STREAM_FTDI,baud=57600,errors)	
*
2B70:  BTFSS  F9E.5
2B72:  BRA    2B70
2B74:  MOVFF  FAB,1A
2B78:  MOVFF  FAE,01
2B7C:  BTFSS  1A.1
2B7E:  BRA    2B84
2B80:  BCF    FAB.4
2B82:  BSF    FAB.4
2B84:  GOTO   2F70 (RETURN)
.................... 
.................... /* program config CRC of 0 and a serial_prefix of 'A' ... that will trigger a write default on first boot */
.................... #ROM 0xF00000 = { 0x00, 0x00, 0x40, 0x00 }
.................... 
.................... 
.................... 
.................... 
.................... #define SW_OVERRIDE_A        PIN_A5
.................... #define SW_OVERRIDE_B        PIN_A4
.................... #define BRIDGE_B_A           PIN_C5
.................... #define BRIDGE_A_B           PIN_C4
.................... #define BRIDGE_A_A           PIN_C3
.................... #define BRIDGE_B_B           PIN_C6
.................... #define AN_DIP               PIN_C7
.................... #define SER_TO_PC            PIN_B7
.................... #define AN_VTEMP             PIN_A2
.................... #define AN_IN_VOLTS          PIN_C0
.................... #define LED_A                PIN_C1
.................... #define LED_B                PIN_C2
.................... #define I2C_SDA              PIN_B4
.................... #define SER_FROM_PC          PIN_B5
.................... #define I2C_SCL              PIN_B6
.................... 
.................... 
.................... /* 
.................... Parameters are stored in EEPROM
.................... */
.................... #define PARAM_CRC_ADDRESS  0x00
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2
.................... 
.................... 
.................... 
.................... /* bit positions for a channel state byte */
.................... #define CH_STATE_BIT_FUTURE   7  /* reserved for future use */
.................... #define CH_STATE_BIT_HTD      6  /* high temperature disconnect */
.................... #define CH_STATE_BIT_LTD      5  /* low temperature disconnect */
.................... #define CH_STATE_BIT_HVD      4  /* high voltage disconnect */
.................... #define CH_STATE_BIT_LVD      3  /* low voltage disconnect */
.................... #define CH_STATE_BIT_CMD_OFF  2  /* commanded off */
.................... #define CH_STATE_BIT_CMD_ON   1  /* commanded on (takes presedence over commanded off) */
.................... #define CH_STATE_BIT_OVERRIDE 0  /* override switch */
.................... 
.................... /* _OVERRIDE or _CMD_ON set means output on */
.................... #define CH_STATE_MASK_ON     0b00000011 
.................... /* _CMD_OFF, _LVD, _HVD, _LTD, _HTD means output off, unless override by on mask */
.................... #define CH_STATE_MASK_OFF    0b01111100 
.................... 
.................... #define ADC_SAMPLE_TICKS              20
.................... #define CONTACTOR_POWER_SAVE_MS       200 /* milliseconds for contactor be on. Must be >0 and <= 255 */
.................... #define CONTACTOR_REFRESH_CYCLES      10  /* re-appply contactor coil voltage every N cycles. 65525 disables */
.................... 
.................... #define BLINK_ON_TIME                 254
.................... #define BLINK_OFF_TIME                200
.................... 
.................... 
.................... typedef struct {
.................... 	/* command on hold time */
.................... 	int16 command_on_hold_time;
.................... 
.................... 	/* command off hold time */
.................... 	int16 command_off_hold_time;
.................... 
.................... 	/* low voltage disconnect */
.................... 	int16 lvd_disconnect_adc;
.................... 	int16 lvd_disconnect_delay;
.................... 	int16 lvd_reconnect_adc;
.................... 	int16 lvd_reconnect_delay;
.................... 
.................... 	/* high voltage disconnect */
.................... 	int16 hvd_disconnect_adc;
.................... 	int16 hvd_disconnect_delay;
.................... 	int16 hvd_reconnect_adc;
.................... 	int16 hvd_reconnect_delay;
.................... 
.................... 	/* low temperature disconnect */
.................... 	int16 ltd_disconnect_adc;
.................... 	int16 ltd_disconnect_delay;
.................... 	int16 ltd_reconnect_adc;
.................... 	int16 ltd_reconnect_delay;
.................... 
.................... 	/* high temperature disconnect */
.................... 	int16 htd_disconnect_adc;
.................... 	int16 htd_disconnect_delay;
.................... 	int16 htd_reconnect_adc;
.................... 	int16 htd_reconnect_delay;
.................... } struct_config_channel;
.................... 
.................... typedef struct {
.................... 	/* not much going on here */
.................... 	struct_config_channel ch[2];
.................... } struct_config;
.................... 
.................... 
.................... typedef struct {
.................... 	int8 state;
.................... 
.................... 	int16 command_on_seconds;			/* counts down. Off at zero. */
.................... 	int16 command_on_hold_seconds;      /* counts down. Off at zero. */
.................... 
.................... 	int16 command_off_seconds;			/* counts down. Off at zero. */
.................... 	int16 command_off_hold_seconds;     /* counts down. Off at zero. */
.................... 
.................... 	int16 lvd_disconnect_delay_seconds;	/* counts down */
.................... 	int16  lvd_reconnect_delay_seconds;	/* counts down */
.................... 
.................... 	int16 hvd_disconnect_delay_seconds;	/* counts down */
.................... 	int16  hvd_reconnect_delay_seconds;	/* counts down */
.................... 
.................... 	int16 ltd_disconnect_delay_seconds; /* counts down */
.................... 	int16 ltd_reconnect_delay_seconds;  /* counts down */
.................... 
.................... 	int16 htd_disconnect_delay_seconds; /* counts down */
.................... 	int16 htd_reconnect_delay_seconds;  /* counts down */
.................... } struct_channel;
.................... 
.................... typedef struct {
.................... 	/* circular buffer for ADC readings */
.................... 	int16 adc_buffer[3][16];
.................... 	int8  adc_buffer_index;
.................... 
.................... 	int16 sequence_number;
.................... 	int16 uptime_minutes;
.................... 	int16 interval_milliseconds;
.................... 
.................... 	int8 factory_unlocked;
.................... 
.................... 
.................... 	int8 compile_year;
.................... 	int8 compile_month;
.................... 	int8 compile_day;
.................... 
.................... 
.................... 	int8 default_params_written;
.................... } struct_current;
.................... 
.................... typedef struct {
.................... 	/* action flags */
.................... 	int1 now_adc_sample;
.................... 	int1 now_adc_reset_count;
.................... 
.................... 	int1 now_millisecond;
.................... 
.................... 	int1 now_write_config;
.................... 	int1 now_reset_config;
.................... 
.................... 	int1 now_debug_dump;
.................... 
.................... 
.................... 	/* timers */
.................... 	int8 led_blink[2];
.................... 	int8 led_on[2];
.................... 	int8 led_off[2];
.................... 
.................... 	/* contactors */
.................... 	int8 contactor[2]; 	         /* current state */
.................... 	int8 contactor_powersave[2]; /* countdown to shut off power to coil at 0 */
.................... } struct_time_keep;
.................... 
.................... /* global structures */
.................... struct_config config={0};
.................... struct_current current={0};
.................... struct_time_keep timers={0};
.................... struct_channel channel[2]={0};
.................... 
.................... #include "adc_dcswc_module_latching_contactor.c"
.................... int16 adc_get(int8 ch) {
.................... 	int16 sum;
.................... 	int8 i;
.................... 
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */
.................... 	int16 *p;
.................... 	p = current.adc_buffer[ch];
*
0594:  MOVLB  1
0596:  MOVF   x2F,W
0598:  MULLW  20
059A:  MOVF   FF3,W
059C:  CLRF   03
059E:  ADDLW  63
05A0:  MOVWF  01
05A2:  MOVLW  00
05A4:  ADDWFC 03,F
05A6:  MOVFF  01,133
05AA:  MOVFF  03,134
.................... 
.................... 	// Calculate the mean.  This is done by summing up the
.................... 	// values and dividing by the number of elements.
.................... 	sum = 0;
05AE:  CLRF   x31
05B0:  CLRF   x30
.................... 	for( i = 0; i < 16 ; i++ ) {
05B2:  CLRF   x32
05B4:  MOVF   x32,W
05B6:  SUBLW  0F
05B8:  BNC   05E4
.................... //		sum += current.adc_buffer[ch][i];
.................... 		sum += p[i];
05BA:  CLRF   03
05BC:  MOVFF  132,02
05C0:  BCF    FD8.0
05C2:  RLCF   02,F
05C4:  RLCF   03,F
05C6:  MOVF   02,W
05C8:  ADDWF  x33,W
05CA:  MOVWF  FE9
05CC:  MOVF   x34,W
05CE:  ADDWFC 03,W
05D0:  MOVWF  FEA
05D2:  MOVFF  FEC,03
05D6:  MOVF   FED,F
05D8:  MOVF   FEF,W
05DA:  ADDWF  x30,F
05DC:  MOVF   03,W
05DE:  ADDWFC x31,F
05E0:  INCF   x32,F
05E2:  BRA    05B4
.................... 	}
.................... 
.................... 	/* divide sum by our 16 samples and round by adding 8 */
.................... 	return ( (sum+8) >> 4 );
05E4:  MOVLW  08
05E6:  ADDWF  x30,W
05E8:  MOVWF  x35
05EA:  MOVLW  00
05EC:  ADDWFC x31,W
05EE:  MOVWF  x36
05F0:  RRCF   x36,W
05F2:  MOVWF  03
05F4:  RRCF   x35,W
05F6:  MOVWF  02
05F8:  RRCF   03,F
05FA:  RRCF   02,F
05FC:  RRCF   03,F
05FE:  RRCF   02,F
0600:  RRCF   03,F
0602:  RRCF   02,F
0604:  MOVLW  0F
0606:  ANDWF  03,F
0608:  MOVFF  02,01
060C:  MOVFF  03,02
0610:  MOVLB  0
0612:  RETURN 0
.................... }
.................... 
.................... 
.................... void adc_update(void) {
.................... 
.................... 	/* wrap buffer around */
.................... 	current.adc_buffer_index++;
*
18D8:  INCF   xC3,F
.................... 	if ( current.adc_buffer_index >= 16 )
18DA:  MOVF   xC3,W
18DC:  SUBLW  0F
18DE:  BC    18E2
.................... 		current.adc_buffer_index=0;
18E0:  CLRF   xC3
.................... 
.................... 	set_adc_channel(4);
18E2:  MOVLW  10
18E4:  MOVWF  01
18E6:  MOVF   FC2,W
18E8:  ANDLW  C3
18EA:  IORWF  01,W
18EC:  MOVWF  FC2
.................... 	current.adc_buffer[0][current.adc_buffer_index] = read_adc();
18EE:  BCF    FD8.0
18F0:  RLCF   xC3,W
18F2:  CLRF   03
18F4:  ADDLW  63
18F6:  MOVWF  FE9
18F8:  MOVLW  00
18FA:  ADDWFC 03,W
18FC:  MOVWF  FEA
18FE:  BSF    FC2.1
1900:  BTFSC  FC2.1
1902:  BRA    1900
1904:  MOVFF  FC3,FEF
1908:  MOVFF  FC4,FEC
.................... 
.................... 
.................... 	set_adc_channel(2);
190C:  MOVLW  08
190E:  MOVWF  01
1910:  MOVF   FC2,W
1912:  ANDLW  C3
1914:  IORWF  01,W
1916:  MOVWF  FC2
.................... 	delay_ms(1);
1918:  MOVLW  01
191A:  MOVLB  1
191C:  MOVWF  x28
191E:  MOVLB  0
1920:  CALL   1064
.................... 	current.adc_buffer[1][current.adc_buffer_index] = read_adc();
1924:  BCF    FD8.0
1926:  RLCF   xC3,W
1928:  CLRF   03
192A:  ADDLW  83
192C:  MOVWF  FE9
192E:  MOVLW  00
1930:  ADDWFC 03,W
1932:  MOVWF  FEA
1934:  BSF    FC2.1
1936:  BTFSC  FC2.1
1938:  BRA    1936
193A:  MOVFF  FC3,FEF
193E:  MOVFF  FC4,FEC
.................... 
.................... 	set_adc_channel(9);
1942:  MOVLW  24
1944:  MOVWF  01
1946:  MOVF   FC2,W
1948:  ANDLW  C3
194A:  IORWF  01,W
194C:  MOVWF  FC2
.................... 	delay_ms(1);
194E:  MOVLW  01
1950:  MOVLB  1
1952:  MOVWF  x28
1954:  MOVLB  0
1956:  CALL   1064
.................... 	current.adc_buffer[2][current.adc_buffer_index] = read_adc();
195A:  BCF    FD8.0
195C:  RLCF   xC3,W
195E:  CLRF   03
1960:  ADDLW  A3
1962:  MOVWF  FE9
1964:  MOVLW  00
1966:  ADDWFC 03,W
1968:  MOVWF  FEA
196A:  BSF    FC2.1
196C:  BTFSC  FC2.1
196E:  BRA    196C
1970:  MOVFF  FC3,FEF
1974:  MOVFF  FC4,FEC
1978:  RETURN 0
.................... }
.................... 
.................... int8 read_dip_switch(void) {
.................... 	int16 adc;
.................... 
.................... 	set_adc_channel(9);
*
108E:  MOVLW  24
1090:  MOVWF  01
1092:  MOVF   FC2,W
1094:  ANDLW  C3
1096:  IORWF  01,W
1098:  MOVWF  FC2
.................... 	delay_ms(1);
109A:  MOVLW  01
109C:  MOVLB  1
109E:  MOVWF  x28
10A0:  MOVLB  0
10A2:  RCALL  1064
.................... 	adc=read_adc();
10A4:  BSF    FC2.1
10A6:  BTFSC  FC2.1
10A8:  BRA    10A6
10AA:  MOVFF  FC4,127
10AE:  MOVFF  FC3,126
.................... 
.................... 	/* (note that table is sorted by vout reading 
.................... 	SW3.1 (LSB) SW3.2 (MSB) VALUE ADC
....................     OFF         OFF         0     1023
.................... 	OFF         ON          2     682
....................     ON          OFF         1     511
.................... 	ON          ON          3     409
.................... 	*/
.................... 
.................... 	if ( adc > (1023-64) )
10B2:  MOVLB  1
10B4:  MOVF   x27,W
10B6:  SUBLW  02
10B8:  BC    10CA
10BA:  XORLW  FF
10BC:  BNZ   10C4
10BE:  MOVF   x26,W
10C0:  SUBLW  BF
10C2:  BC    10CA
.................... 		return 0;
10C4:  MOVLW  00
10C6:  MOVWF  01
10C8:  BRA    10FA
.................... 	if ( adc > (682-64) )
10CA:  MOVF   x27,W
10CC:  SUBLW  01
10CE:  BC    10E0
10D0:  XORLW  FF
10D2:  BNZ   10DA
10D4:  MOVF   x26,W
10D6:  SUBLW  6A
10D8:  BC    10E0
.................... 		return 2;
10DA:  MOVLW  02
10DC:  MOVWF  01
10DE:  BRA    10FA
.................... 	if ( adc > (511-64) )
10E0:  MOVF   x27,W
10E2:  SUBLW  00
10E4:  BC    10F6
10E6:  XORLW  FF
10E8:  BNZ   10F0
10EA:  MOVF   x26,W
10EC:  SUBLW  BF
10EE:  BC    10F6
.................... 		return 1;
10F0:  MOVLW  01
10F2:  MOVWF  01
10F4:  BRA    10FA
.................... 
.................... 	return 3;
10F6:  MOVLW  03
10F8:  MOVWF  01
10FA:  MOVLB  0
10FC:  GOTO   13B2 (RETURN)
.................... }
.................... 
.................... #include "param_dcswc_module_latching_contactor.c"
.................... #inline
.................... char xor_crc(char oldcrc, char data) {
.................... 	return oldcrc ^ data;
*
147C:  MOVF   x28,W
147E:  XORWF  x29,W
1480:  MOVWF  01
*
14CA:  MOVF   x28,W
14CC:  XORWF  x29,W
14CE:  MOVWF  01
.................... }
.................... 
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) {
*
1414:  MOVLB  1
1416:  CLRF   x24
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
1418:  MOVFF  123,126
141C:  MOVF   x22,W
141E:  BTFSC  FD8.2
1420:  DECF   x23,F
1422:  DECF   x22,F
1424:  MOVWF  x25
1426:  MOVF   x25,F
1428:  BNZ   142E
142A:  MOVF   x26,F
142C:  BZ    148E
.................... 		*data = read_eeprom( address++ );
142E:  MOVFF  121,03
1432:  MOVF   x20,W
1434:  MOVWF  FE9
1436:  MOVFF  03,FEA
143A:  MOVF   x1F,W
143C:  MOVWF  03
143E:  MOVF   x1E,W
1440:  INCF   x1E,F
1442:  BTFSC  FD8.2
1444:  INCF   x1F,F
1446:  MOVWF  x27
1448:  MOVFF  03,128
144C:  MOVFF  FF2,129
1450:  BCF    FF2.7
1452:  MOVFF  127,FA9
1456:  BCF    FA6.6
1458:  BCF    FA6.7
145A:  BSF    FA6.0
145C:  MOVF   FA8,W
145E:  BTFSC  x29.7
1460:  BSF    FF2.7
1462:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data);
1464:  MOVFF  121,03
1468:  MOVF   x20,W
146A:  MOVWF  FE9
146C:  MOVFF  03,FEA
1470:  MOVFF  FEF,125
1474:  MOVFF  124,128
1478:  MOVFF  125,129
*
1482:  MOVFF  01,124
.................... 		data++;
1486:  INCF   x20,F
1488:  BTFSC  FD8.2
148A:  INCF   x21,F
148C:  BRA    1418
.................... 	}
.................... 	return crc;
148E:  MOVFF  124,01
1492:  MOVLB  0
1494:  GOTO   1862 (RETURN)
.................... }
.................... 
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) {
1498:  MOVLB  1
149A:  CLRF   x26
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
149C:  MOVFF  125,128
14A0:  MOVF   x24,W
14A2:  BTFSC  FD8.2
14A4:  DECF   x25,F
14A6:  DECF   x24,F
14A8:  MOVWF  x27
14AA:  MOVF   x27,F
14AC:  BNZ   14B2
14AE:  MOVF   x28,F
14B0:  BZ    152A
.................... 		/* restart_wdt() */
.................... 		crc = xor_crc(crc,*data);
14B2:  MOVFF  123,03
14B6:  MOVF   x22,W
14B8:  MOVWF  FE9
14BA:  MOVFF  03,FEA
14BE:  MOVFF  FEF,127
14C2:  MOVFF  126,128
14C6:  MOVFF  127,129
*
14D0:  MOVFF  01,126
.................... 		write_eeprom( address++, *data++ );
14D4:  MOVF   x21,W
14D6:  MOVWF  03
14D8:  MOVF   x20,W
14DA:  INCF   x20,F
14DC:  BTFSC  FD8.2
14DE:  INCF   x21,F
14E0:  MOVWF  x27
14E2:  MOVFF  03,128
14E6:  MOVF   x23,W
14E8:  MOVWF  03
14EA:  MOVF   x22,W
14EC:  INCF   x22,F
14EE:  BTFSC  FD8.2
14F0:  INCF   x23,F
14F2:  MOVWF  FE9
14F4:  MOVFF  03,FEA
14F8:  MOVFF  FEF,129
14FC:  MOVF   FF2,W
14FE:  MOVWF  00
1500:  BCF    FF2.7
1502:  MOVFF  127,FA9
1506:  MOVFF  129,FA8
150A:  BCF    FA6.6
150C:  BCF    FA6.7
150E:  BSF    FA6.2
1510:  MOVLB  F
1512:  MOVLW  55
1514:  MOVWF  FA7
1516:  MOVLW  AA
1518:  MOVWF  FA7
151A:  BSF    FA6.1
151C:  BTFSC  FA6.1
151E:  BRA    151C
1520:  BCF    FA6.2
1522:  MOVF   00,W
1524:  IORWF  FF2,F
1526:  MOVLB  1
1528:  BRA    149C
.................... 	}
.................... 
.................... 	return crc;
152A:  MOVFF  126,01
152E:  MOVLB  0
1530:  GOTO   1550 (RETURN)
.................... }
.................... 
.................... void write_param_file() {
.................... 	int8 crc;
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config));
1534:  MOVLB  1
1536:  MOVLW  1B
1538:  MOVWF  x1E
153A:  CLRF   x21
153C:  MOVLW  02
153E:  MOVWF  x20
1540:  CLRF   x23
1542:  MOVFF  11E,122
1546:  CLRF   x25
1548:  MOVLW  48
154A:  MOVWF  x24
154C:  MOVLB  0
154E:  BRA    1498
1550:  MOVFF  01,11D
.................... 	/* write the CRC was calculated on the structure */
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc);
1554:  MOVF   FF2,W
1556:  MOVWF  00
1558:  BCF    FF2.7
155A:  CLRF   FA9
155C:  MOVFF  11D,FA8
1560:  BCF    FA6.6
1562:  BCF    FA6.7
1564:  BSF    FA6.2
1566:  MOVLB  F
1568:  MOVLW  55
156A:  MOVWF  FA7
156C:  MOVLW  AA
156E:  MOVWF  FA7
1570:  BSF    FA6.1
1572:  BTFSC  FA6.1
1574:  BRA    1572
1576:  BCF    FA6.2
1578:  MOVF   00,W
157A:  IORWF  FF2,F
157C:  MOVLB  0
157E:  RETURN 0
.................... }
.................... 
.................... void write_default_param_file() {
.................... 	int8 i;
.................... 
.................... 	current.default_params_written=1;
1580:  MOVLW  01
1582:  MOVWF  xCE
.................... 
.................... 	/* both LEDs on */
.................... 	timers.led_blink[0]=255;
1584:  SETF   xD0
.................... 	timers.led_blink[1]=255;
1586:  SETF   xD1
.................... 
.................... 
.................... 	for ( i=0 ; i<2 ; i++ ) {
1588:  MOVLB  1
158A:  CLRF   x1C
158C:  MOVF   x1C,W
158E:  SUBLW  01
1590:  BTFSS  FD8.0
1592:  BRA    1840
.................... 			/* low voltage disconnect */
.................... 			config.ch[i].lvd_disconnect_adc=593;  /* 23.16 volts */
1594:  MOVF   x1C,W
1596:  MULLW  24
1598:  MOVF   FF3,W
159A:  CLRF   x1E
159C:  MOVWF  x1D
159E:  MOVLW  04
15A0:  ADDWF  x1D,W
15A2:  MOVWF  01
15A4:  MOVLW  00
15A6:  ADDWFC x1E,W
15A8:  MOVWF  03
15AA:  MOVF   01,W
15AC:  ADDLW  1B
15AE:  MOVWF  FE9
15B0:  MOVLW  00
15B2:  ADDWFC 03,W
15B4:  MOVWF  FEA
15B6:  MOVLW  02
15B8:  MOVWF  FEC
15BA:  MOVF   FED,F
15BC:  MOVLW  51
15BE:  MOVWF  FEF
.................... 			config.ch[i].lvd_disconnect_delay=20; /* 65535 disables LVD */
15C0:  MOVF   x1C,W
15C2:  MULLW  24
15C4:  MOVF   FF3,W
15C6:  CLRF   x1E
15C8:  MOVWF  x1D
15CA:  MOVLW  06
15CC:  ADDWF  x1D,W
15CE:  MOVWF  01
15D0:  MOVLW  00
15D2:  ADDWFC x1E,W
15D4:  MOVWF  03
15D6:  MOVF   01,W
15D8:  ADDLW  1B
15DA:  MOVWF  FE9
15DC:  MOVLW  00
15DE:  ADDWFC 03,W
15E0:  MOVWF  FEA
15E2:  CLRF   FEC
15E4:  MOVF   FED,F
15E6:  MOVLW  14
15E8:  MOVWF  FEF
.................... 			config.ch[i].lvd_reconnect_adc=602;   /* 23.51 volts */
15EA:  MOVF   x1C,W
15EC:  MULLW  24
15EE:  MOVF   FF3,W
15F0:  CLRF   x1E
15F2:  MOVWF  x1D
15F4:  MOVLW  08
15F6:  ADDWF  x1D,W
15F8:  MOVWF  01
15FA:  MOVLW  00
15FC:  ADDWFC x1E,W
15FE:  MOVWF  03
1600:  MOVF   01,W
1602:  ADDLW  1B
1604:  MOVWF  FE9
1606:  MOVLW  00
1608:  ADDWFC 03,W
160A:  MOVWF  FEA
160C:  MOVLW  02
160E:  MOVWF  FEC
1610:  MOVF   FED,F
1612:  MOVLW  5A
1614:  MOVWF  FEF
.................... 			config.ch[i].lvd_reconnect_delay=10;
1616:  MOVF   x1C,W
1618:  MULLW  24
161A:  MOVF   FF3,W
161C:  CLRF   x1E
161E:  MOVWF  x1D
1620:  MOVLW  0A
1622:  ADDWF  x1D,W
1624:  MOVWF  01
1626:  MOVLW  00
1628:  ADDWFC x1E,W
162A:  MOVWF  03
162C:  MOVF   01,W
162E:  ADDLW  1B
1630:  MOVWF  FE9
1632:  MOVLW  00
1634:  ADDWFC 03,W
1636:  MOVWF  FEA
1638:  CLRF   FEC
163A:  MOVF   FED,F
163C:  MOVLW  0A
163E:  MOVWF  FEF
.................... 		
.................... 		/* high voltage disconnect */
.................... 		config.ch[i].hvd_disconnect_adc=700; 
1640:  MOVF   x1C,W
1642:  MULLW  24
1644:  MOVF   FF3,W
1646:  CLRF   x1E
1648:  MOVWF  x1D
164A:  MOVLW  0C
164C:  ADDWF  x1D,W
164E:  MOVWF  01
1650:  MOVLW  00
1652:  ADDWFC x1E,W
1654:  MOVWF  03
1656:  MOVF   01,W
1658:  ADDLW  1B
165A:  MOVWF  FE9
165C:  MOVLW  00
165E:  ADDWFC 03,W
1660:  MOVWF  FEA
1662:  MOVLW  02
1664:  MOVWF  FEC
1666:  MOVF   FED,F
1668:  MOVLW  BC
166A:  MOVWF  FEF
.................... 		config.ch[i].hvd_disconnect_delay=65535; /* 65535 disables HVD */
166C:  MOVF   x1C,W
166E:  MULLW  24
1670:  MOVF   FF3,W
1672:  CLRF   x1E
1674:  MOVWF  x1D
1676:  MOVLW  0E
1678:  ADDWF  x1D,W
167A:  MOVWF  01
167C:  MOVLW  00
167E:  ADDWFC x1E,W
1680:  MOVWF  03
1682:  MOVF   01,W
1684:  ADDLW  1B
1686:  MOVWF  FE9
1688:  MOVLW  00
168A:  ADDWFC 03,W
168C:  MOVWF  FEA
168E:  SETF   FEC
1690:  MOVF   FED,F
1692:  SETF   FEF
.................... 		config.ch[i].hvd_reconnect_adc=650;
1694:  MOVF   x1C,W
1696:  MULLW  24
1698:  MOVF   FF3,W
169A:  CLRF   x1E
169C:  MOVWF  x1D
169E:  MOVLW  10
16A0:  ADDWF  x1D,W
16A2:  MOVWF  01
16A4:  MOVLW  00
16A6:  ADDWFC x1E,W
16A8:  MOVWF  03
16AA:  MOVF   01,W
16AC:  ADDLW  1B
16AE:  MOVWF  FE9
16B0:  MOVLW  00
16B2:  ADDWFC 03,W
16B4:  MOVWF  FEA
16B6:  MOVLW  02
16B8:  MOVWF  FEC
16BA:  MOVF   FED,F
16BC:  MOVLW  8A
16BE:  MOVWF  FEF
.................... 		config.ch[i].hvd_reconnect_delay=60;
16C0:  MOVF   x1C,W
16C2:  MULLW  24
16C4:  MOVF   FF3,W
16C6:  CLRF   x1E
16C8:  MOVWF  x1D
16CA:  MOVLW  12
16CC:  ADDWF  x1D,W
16CE:  MOVWF  01
16D0:  MOVLW  00
16D2:  ADDWFC x1E,W
16D4:  MOVWF  03
16D6:  MOVF   01,W
16D8:  ADDLW  1B
16DA:  MOVWF  FE9
16DC:  MOVLW  00
16DE:  ADDWFC 03,W
16E0:  MOVWF  FEA
16E2:  CLRF   FEC
16E4:  MOVF   FED,F
16E6:  MOVLW  3C
16E8:  MOVWF  FEF
.................... 
.................... 		/* low temperature disconnect */
.................... 		config.ch[i].ltd_disconnect_adc=786; // 0C / 32F
16EA:  MOVF   x1C,W
16EC:  MULLW  24
16EE:  MOVF   FF3,W
16F0:  CLRF   x1E
16F2:  MOVWF  x1D
16F4:  MOVLW  14
16F6:  ADDWF  x1D,W
16F8:  MOVWF  01
16FA:  MOVLW  00
16FC:  ADDWFC x1E,W
16FE:  MOVWF  03
1700:  MOVF   01,W
1702:  ADDLW  1B
1704:  MOVWF  FE9
1706:  MOVLW  00
1708:  ADDWFC 03,W
170A:  MOVWF  FEA
170C:  MOVLW  03
170E:  MOVWF  FEC
1710:  MOVF   FED,F
1712:  MOVLW  12
1714:  MOVWF  FEF
.................... 		config.ch[i].ltd_disconnect_delay=65535; /* 65535 disables LTD */
1716:  MOVF   x1C,W
1718:  MULLW  24
171A:  MOVF   FF3,W
171C:  CLRF   x1E
171E:  MOVWF  x1D
1720:  MOVLW  16
1722:  ADDWF  x1D,W
1724:  MOVWF  01
1726:  MOVLW  00
1728:  ADDWFC x1E,W
172A:  MOVWF  03
172C:  MOVF   01,W
172E:  ADDLW  1B
1730:  MOVWF  FE9
1732:  MOVLW  00
1734:  ADDWFC 03,W
1736:  MOVWF  FEA
1738:  SETF   FEC
173A:  MOVF   FED,F
173C:  SETF   FEF
.................... 		config.ch[i].ltd_reconnect_adc=683;  // 10C / 50F
173E:  MOVF   x1C,W
1740:  MULLW  24
1742:  MOVF   FF3,W
1744:  CLRF   x1E
1746:  MOVWF  x1D
1748:  MOVLW  18
174A:  ADDWF  x1D,W
174C:  MOVWF  01
174E:  MOVLW  00
1750:  ADDWFC x1E,W
1752:  MOVWF  03
1754:  MOVF   01,W
1756:  ADDLW  1B
1758:  MOVWF  FE9
175A:  MOVLW  00
175C:  ADDWFC 03,W
175E:  MOVWF  FEA
1760:  MOVLW  02
1762:  MOVWF  FEC
1764:  MOVF   FED,F
1766:  MOVLW  AB
1768:  MOVWF  FEF
.................... 		config.ch[i].ltd_reconnect_delay=4;
176A:  MOVF   x1C,W
176C:  MULLW  24
176E:  MOVF   FF3,W
1770:  CLRF   x1E
1772:  MOVWF  x1D
1774:  MOVLW  1A
1776:  ADDWF  x1D,W
1778:  MOVWF  01
177A:  MOVLW  00
177C:  ADDWFC x1E,W
177E:  MOVWF  03
1780:  MOVF   01,W
1782:  ADDLW  1B
1784:  MOVWF  FE9
1786:  MOVLW  00
1788:  ADDWFC 03,W
178A:  MOVWF  FEA
178C:  CLRF   FEC
178E:  MOVF   FED,F
1790:  MOVLW  04
1792:  MOVWF  FEF
.................... 
.................... 		/* high temperature disconnect */
.................... 		config.ch[i].htd_disconnect_adc=405; // 35C / 95F
1794:  MOVF   x1C,W
1796:  MULLW  24
1798:  MOVF   FF3,W
179A:  CLRF   x1E
179C:  MOVWF  x1D
179E:  MOVLW  1C
17A0:  ADDWF  x1D,W
17A2:  MOVWF  01
17A4:  MOVLW  00
17A6:  ADDWFC x1E,W
17A8:  MOVWF  03
17AA:  MOVF   01,W
17AC:  ADDLW  1B
17AE:  MOVWF  FE9
17B0:  MOVLW  00
17B2:  ADDWFC 03,W
17B4:  MOVWF  FEA
17B6:  MOVLW  01
17B8:  MOVWF  FEC
17BA:  MOVF   FED,F
17BC:  MOVLW  95
17BE:  MOVWF  FEF
.................... 		config.ch[i].htd_disconnect_delay=65535; /* 65535 disables LTD */
17C0:  MOVF   x1C,W
17C2:  MULLW  24
17C4:  MOVF   FF3,W
17C6:  CLRF   x1E
17C8:  MOVWF  x1D
17CA:  MOVLW  1E
17CC:  ADDWF  x1D,W
17CE:  MOVWF  01
17D0:  MOVLW  00
17D2:  ADDWFC x1E,W
17D4:  MOVWF  03
17D6:  MOVF   01,W
17D8:  ADDLW  1B
17DA:  MOVWF  FE9
17DC:  MOVLW  00
17DE:  ADDWFC 03,W
17E0:  MOVWF  FEA
17E2:  SETF   FEC
17E4:  MOVF   FED,F
17E6:  SETF   FEF
.................... 		config.ch[i].htd_reconnect_adc=512;  // 25C / 77F
17E8:  MOVF   x1C,W
17EA:  MULLW  24
17EC:  MOVF   FF3,W
17EE:  CLRF   x1E
17F0:  MOVWF  x1D
17F2:  MOVLW  20
17F4:  ADDWF  x1D,W
17F6:  MOVWF  01
17F8:  MOVLW  00
17FA:  ADDWFC x1E,W
17FC:  MOVWF  03
17FE:  MOVF   01,W
1800:  ADDLW  1B
1802:  MOVWF  FE9
1804:  MOVLW  00
1806:  ADDWFC 03,W
1808:  MOVWF  FEA
180A:  MOVLW  02
180C:  MOVWF  FEC
180E:  MOVF   FED,F
1810:  CLRF   FEF
.................... 		config.ch[i].htd_reconnect_delay=4;
1812:  MOVF   x1C,W
1814:  MULLW  24
1816:  MOVF   FF3,W
1818:  CLRF   x1E
181A:  MOVWF  x1D
181C:  MOVLW  22
181E:  ADDWF  x1D,W
1820:  MOVWF  01
1822:  MOVLW  00
1824:  ADDWFC x1E,W
1826:  MOVWF  03
1828:  MOVF   01,W
182A:  ADDLW  1B
182C:  MOVWF  FE9
182E:  MOVLW  00
1830:  ADDWFC 03,W
1832:  MOVWF  FEA
1834:  CLRF   FEC
1836:  MOVF   FED,F
1838:  MOVLW  04
183A:  MOVWF  FEF
.................... 	}
.................... 	
.................... 
.................... #if 0
183C:  INCF   x1C,F
183E:  BRA    158C
.................... 	/* set the two channels differently */
.................... 	/* LVD 1 bus (modem, etc) @ Fairway */
.................... 	config.ch[0].lvd_disconnect_adc=602; /* 23.5 */
.................... 	config.ch[0].lvd_reconnect_adc=627;  /* 24.5 */
....................  	/* LVD 2 bus (CODAR) @ Fairway */
.................... 	config.ch[1].lvd_disconnect_adc=614; /* 24.0 */
.................... 	config.ch[1].lvd_reconnect_adc=640;  /* 25.0 */		
.................... #endif
.................... 
.................... 
.................... 	/* write them so next time we use from EEPROM */
.................... 	write_param_file();
1840:  MOVLB  0
1842:  RCALL  1534
1844:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void read_param_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config)); 
1846:  MOVLB  1
1848:  MOVLW  1B
184A:  MOVWF  x1C
184C:  CLRF   x1F
184E:  MOVLW  02
1850:  MOVWF  x1E
1852:  CLRF   x21
1854:  MOVFF  11C,120
1858:  CLRF   x23
185A:  MOVLW  48
185C:  MOVWF  x22
185E:  MOVLB  0
1860:  BRA    1414
1862:  MOVFF  01,11B
.................... 		
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) {
1866:  MOVFF  FF2,11C
186A:  BCF    FF2.7
186C:  CLRF   FA9
186E:  BCF    FA6.6
1870:  BCF    FA6.7
1872:  BSF    FA6.0
1874:  MOVF   FA8,W
1876:  MOVLB  1
1878:  BTFSC  x1C.7
187A:  BSF    FF2.7
187C:  SUBWF  x1B,W
187E:  BZ    1886
.................... 		write_default_param_file();
1880:  MOVLB  0
1882:  RCALL  1580
1884:  MOVLB  1
.................... 	}
1886:  MOVLB  0
1888:  GOTO   2E3A (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... #include "i2c_handler_dcswc_module_latching_contactor.c"
.................... #include "registers_dcswc_module_latching_contactor.h"
.................... 
.................... /* first two or three registers will give enough information for telemetry */
.................... /* 10 bit input voltage ADC averaged value */
.................... #define I2C_REG_VOLTAGE_INPUT_AVG             0  
.................... /* two 8 bit channel states (A is MSB / B is LSB) */
.................... #define I2C_REG_STATE_CONTACTORS              1 
.................... /* 10 bit NTC thermistor ADC averaged value */
.................... #define I2C_REG_TEMPERATURE_BOARD_AVG         2
.................... 
....................   
.................... /* channel 0 / A */
.................... /* command can only come from I2C interface */
.................... #define I2C_REG_CH0_COMMAND_ON                3 /* R/W seconds */
.................... #define I2C_REG_CH0_COMMAND_ON_HOLD           4
.................... 
.................... #define I2C_REG_CH0_COMMAND_OFF               5 /* R/W seconds */
.................... #define I2C_REG_CH0_COMMAND_OFF_HOLD          6
.................... 
.................... /* low voltage disconnect */
.................... #define I2C_REG_CH0_LVD_DISCONNECT            7  /* R seconds */
.................... #define I2C_REG_CH0_LVD_RECONNECT             8 
.................... 
.................... /* high voltage disconnect */
.................... #define I2C_REG_CH0_HVD_DISCONNECT            9 /* R seconds */
.................... #define I2C_REG_CH0_HVD_RECONNECT             10
.................... 
.................... /* low temperature disconnect */
.................... #define I2C_REG_CH0_LTD_DISCONNECT            11  /* R seconds */
.................... #define I2C_REG_CH0_LTD_RECONNECT             12
.................... 
.................... /* high temperature disconnect */
.................... #define I2C_REG_CH0_HTD_DISCONNECT            13 /* R seconds */
.................... #define I2C_REG_CH0_HTD_RECONNECT             14
.................... 
.................... /* reserved for future, unimplemented */
.................... #define I2C_REG_CH0_FUT_DISCONNECT            15 /* R seconds */
.................... #define I2C_REG_CH0_FUT_RECONNECT             16
.................... 
.................... /* channel 1 / B */
.................... /* command can only come from I2C interface */
.................... #define I2C_REG_CH1_COMMAND_ON                17 /* R/W seconds */
.................... #define I2C_REG_CH1_COMMAND_ON_HOLD           18
.................... 
.................... #define I2C_REG_CH1_COMMAND_OFF               19 /* R/W seconds */
.................... #define I2C_REG_CH1_COMMAND_OFF_HOLD          20
.................... 
.................... /* low voltage disconnect */
.................... #define I2C_REG_CH1_LVD_DISCONNECT            21 /* R seconds */
.................... #define I2C_REG_CH1_LVD_RECONNECT             22 
.................... 
.................... /* high voltage disconnect */
.................... #define I2C_REG_CH1_HVD_DISCONNECT            23 /* R seconds */
.................... #define I2C_REG_CH1_HVD_RECONNECT             24
.................... 
.................... /* low temperature disconnect */
.................... #define I2C_REG_CH1_LTD_DISCONNECT            25  /* R seconds */
.................... #define I2C_REG_CH1_LTD_RECONNECT             26
.................... 
.................... /* high temperature disconnect */
.................... #define I2C_REG_CH1_HTD_DISCONNECT            27 /* R seconds */
.................... #define I2C_REG_CH1_HTD_RECONNECT             28
.................... 
.................... /* reserved for future, unimplemented */
.................... #define I2C_REG_CH1_FUT_DISCONNECT            29 /* R seconds */
.................... #define I2C_REG_CH1_FUT_RECONNECT             30
.................... 
.................... /* meta */
.................... #define I2C_REG_SEQUENCE_NUMBER               31 /* R */
.................... #define I2C_REG_TIME_INTERVAL_MILLISECONDS    32
.................... #define I2C_REG_TIME_UPTIME_MINUTES           33
.................... #define I2C_REG_DEFAULT_PARAMS_WRITTEN        34
.................... 
.................... /* channel configuration */
.................... /* channel 0 / A */
.................... #define I2C_REG_CH0_COMMAND_ON_HOLD_INITIAL   64
.................... 
.................... #define I2C_REG_CH0_COMMAND_OFF_HOLD_INITIAL  65
.................... 
.................... #define I2C_REG_CH0_LVD_DISCONNECT_ADC        66
.................... #define I2C_REG_CH0_LVD_DISCONNECT_DELAY      67
.................... #define I2C_REG_CH0_LVD_RECONNECT_ADC         68
.................... #define I2C_REG_CH0_LVD_RECONNECT_DELAY       69
.................... 
.................... #define I2C_REG_CH0_HVD_DISCONNECT_ADC        70
.................... #define I2C_REG_CH0_HVD_DISCONNECT_DELAY      71
.................... #define I2C_REG_CH0_HVD_RECONNECT_ADC         72
.................... #define I2C_REG_CH0_HVD_RECONNECT_DELAY       73
.................... 
.................... #define I2C_REG_CH0_LTD_DISCONNECT_ADC        74
.................... #define I2C_REG_CH0_LTD_DISCONNECT_DELAY      75
.................... #define I2C_REG_CH0_LTD_RECONNECT_ADC         76
.................... #define I2C_REG_CH0_LTD_RECONNECT_DELAY       77
.................... 
.................... #define I2C_REG_CH0_HTD_DISCONNECT_ADC        78
.................... #define I2C_REG_CH0_HTD_DISCONNECT_DELAY      79
.................... #define I2C_REG_CH0_HTD_RECONNECT_ADC         80
.................... #define I2C_REG_CH0_HTD_RECONNECT_DELAY       81
.................... 
.................... #define I2C_REG_CH0_FUT_DISCONNECT_VALUE      82
.................... #define I2C_REG_CH0_FUT_DISCONNECT_DELAY      83
.................... #define I2C_REG_CH0_FUT_RECONNECT_VALUE       84
.................... #define I2C_REG_CH0_FUT_RECONNECT_DELAY       85
.................... 
.................... /* channel 1 / B */
.................... #define I2C_REG_CH1_COMMAND_ON_HOLD_INITIAL   86
.................... 
.................... #define I2C_REG_CH1_COMMAND_OFF_HOLD_INITIAL  87
.................... 
.................... #define I2C_REG_CH1_LVD_DISCONNECT_ADC        88
.................... #define I2C_REG_CH1_LVD_DISCONNECT_DELAY      89
.................... #define I2C_REG_CH1_LVD_RECONNECT_ADC         90
.................... #define I2C_REG_CH1_LVD_RECONNECT_DELAY       91
.................... 
.................... #define I2C_REG_CH1_HVD_DISCONNECT_ADC        92
.................... #define I2C_REG_CH1_HVD_DISCONNECT_DELAY      93
.................... #define I2C_REG_CH1_HVD_RECONNECT_ADC         94
.................... #define I2C_REG_CH1_HVD_RECONNECT_DELAY       95
.................... 
.................... #define I2C_REG_CH1_LTD_DISCONNECT_ADC        96
.................... #define I2C_REG_CH1_LTD_DISCONNECT_DELAY      97
.................... #define I2C_REG_CH1_LTD_RECONNECT_ADC         98
.................... #define I2C_REG_CH1_LTD_RECONNECT_DELAY       99
.................... 
.................... #define I2C_REG_CH1_HTD_DISCONNECT_ADC        100
.................... #define I2C_REG_CH1_HTD_DISCONNECT_DELAY      101
.................... #define I2C_REG_CH1_HTD_RECONNECT_ADC         102
.................... #define I2C_REG_CH1_HTD_RECONNECT_DELAY       103
.................... 
.................... #define I2C_REG_CH1_FUT_DISCONNECT_VALUE      104
.................... #define I2C_REG_CH1_FUT_DISCONNECT_DELAY      105
.................... #define I2C_REG_CH1_FUT_RECONNECT_VALUE       106
.................... #define I2C_REG_CH1_FUT_RECONNECT_DELAY       107
.................... 
.................... 
.................... /* configuration */
.................... #define I2C_REG_CONFIG_HARDWARE_MODEL              128 /* R */
.................... #define I2C_REG_CONFIG_HARDWARE_VERSION            129
.................... #define I2C_REG_CONFIG_SOFTWARE_MODEL              130
.................... #define I2C_REG_CONFIG_SOFTWARE_VERSION            131
.................... #define I2C_REG_CONFIG_SOFTWARE_YEAR               132
.................... #define I2C_REG_CONFIG_SOFTWARE_MONTH              133
.................... #define I2C_REG_CONFIG_SOFTWARE_DAY                134
.................... 
.................... #define I2C_REG_CONFIG_PARAM_WRITE                 135 /* R / W */
.................... 
.................... 
.................... 
.................... void write_i2c(int8 addr, int16 value) {
.................... 	int8 c;
.................... 
.................... 	/* c is the channel we are accessing based on register range */
.................... 	if ( addr >= I2C_REG_CH1_COMMAND_ON && addr <= I2C_REG_CH1_FUT_RECONNECT ) {
*
00DC:  MOVLB  1
00DE:  MOVF   x2F,W
00E0:  SUBLW  10
00E2:  BC    00F4
00E4:  MOVF   x2F,W
00E6:  SUBLW  1E
00E8:  BNC   00F4
.................... 		/* channel 1 status region */
.................... 		c=1;
00EA:  MOVLW  01
00EC:  MOVWF  x32
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON - I2C_REG_CH0_COMMAND_ON);
00EE:  MOVLW  0E
00F0:  SUBWF  x2F,F
.................... 	} else if ( addr >= I2C_REG_CH1_COMMAND_ON_HOLD && addr <= I2C_REG_CH1_FUT_RECONNECT_DELAY ) {
00F2:  BRA    010C
00F4:  MOVF   x2F,W
00F6:  SUBLW  11
00F8:  BC    010A
00FA:  MOVF   x2F,W
00FC:  SUBLW  6B
00FE:  BNC   010A
.................... 		/* channel 1 configuration region */
.................... 		c=1;
0100:  MOVLW  01
0102:  MOVWF  x32
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON_HOLD - I2C_REG_CH0_COMMAND_ON_HOLD );
0104:  MOVLW  0E
0106:  SUBWF  x2F,F
.................... 	} else {
0108:  BRA    010C
.................... 		c=0;
010A:  CLRF   x32
.................... 	}
.................... 
.................... 	switch ( addr ) {
010C:  MOVF   x2F,W
010E:  XORLW  03
0110:  MOVLB  0
0112:  BZ    018A
0114:  XORLW  07
0116:  BZ    01BA
0118:  XORLW  01
011A:  BZ    01EA
011C:  XORLW  03
011E:  BTFSC  FD8.2
0120:  BRA    021A
0122:  XORLW  44
0124:  BTFSC  FD8.2
0126:  BRA    024A
0128:  XORLW  01
012A:  BTFSC  FD8.2
012C:  BRA    027A
012E:  XORLW  07
0130:  BTFSC  FD8.2
0132:  BRA    02AA
0134:  XORLW  01
0136:  BTFSC  FD8.2
0138:  BRA    02DA
013A:  XORLW  03
013C:  BTFSC  FD8.2
013E:  BRA    030A
0140:  XORLW  01
0142:  BTFSC  FD8.2
0144:  BRA    033A
0146:  XORLW  0F
0148:  BTFSC  FD8.2
014A:  BRA    036A
014C:  XORLW  01
014E:  BTFSC  FD8.2
0150:  BRA    039A
0152:  XORLW  03
0154:  BTFSC  FD8.2
0156:  BRA    03CA
0158:  XORLW  01
015A:  BTFSC  FD8.2
015C:  BRA    03FA
015E:  XORLW  07
0160:  BTFSC  FD8.2
0162:  BRA    042A
0164:  XORLW  01
0166:  BTFSC  FD8.2
0168:  BRA    045A
016A:  XORLW  03
016C:  BTFSC  FD8.2
016E:  BRA    048A
0170:  XORLW  01
0172:  BTFSC  FD8.2
0174:  BRA    04BA
0176:  XORLW  1F
0178:  BTFSC  FD8.2
017A:  BRA    04EA
017C:  XORLW  01
017E:  BTFSC  FD8.2
0180:  BRA    051A
0182:  XORLW  D6
0184:  BTFSC  FD8.2
0186:  BRA    054A
0188:  BRA    0590
.................... 		case I2C_REG_CH0_COMMAND_ON:
.................... 			channel[c].command_on_seconds=value;
018A:  MOVLB  1
018C:  MOVF   x32,W
018E:  MULLW  19
0190:  MOVF   FF3,W
0192:  CLRF   x34
0194:  MOVWF  x33
0196:  MOVLW  01
0198:  ADDWF  x33,W
019A:  MOVWF  01
019C:  MOVLW  00
019E:  ADDWFC x34,W
01A0:  MOVWF  03
01A2:  MOVF   01,W
01A4:  ADDLW  DA
01A6:  MOVWF  FE9
01A8:  MOVLW  00
01AA:  ADDWFC 03,W
01AC:  MOVWF  FEA
01AE:  MOVFF  131,FEC
01B2:  MOVF   FED,F
01B4:  MOVFF  130,FEF
01B8:  MOVLB  0
.................... 		case I2C_REG_CH0_COMMAND_ON_HOLD:
.................... 			channel[c].command_on_hold_seconds=value;
01BA:  MOVLB  1
01BC:  MOVF   x32,W
01BE:  MULLW  19
01C0:  MOVF   FF3,W
01C2:  CLRF   x34
01C4:  MOVWF  x33
01C6:  MOVLW  03
01C8:  ADDWF  x33,W
01CA:  MOVWF  01
01CC:  MOVLW  00
01CE:  ADDWFC x34,W
01D0:  MOVWF  03
01D2:  MOVF   01,W
01D4:  ADDLW  DA
01D6:  MOVWF  FE9
01D8:  MOVLW  00
01DA:  ADDWFC 03,W
01DC:  MOVWF  FEA
01DE:  MOVFF  131,FEC
01E2:  MOVF   FED,F
01E4:  MOVFF  130,FEF
01E8:  MOVLB  0
.................... 	
.................... 		case I2C_REG_CH0_COMMAND_OFF:
.................... 			channel[c].command_off_seconds=value;
01EA:  MOVLB  1
01EC:  MOVF   x32,W
01EE:  MULLW  19
01F0:  MOVF   FF3,W
01F2:  CLRF   x34
01F4:  MOVWF  x33
01F6:  MOVLW  05
01F8:  ADDWF  x33,W
01FA:  MOVWF  01
01FC:  MOVLW  00
01FE:  ADDWFC x34,W
0200:  MOVWF  03
0202:  MOVF   01,W
0204:  ADDLW  DA
0206:  MOVWF  FE9
0208:  MOVLW  00
020A:  ADDWFC 03,W
020C:  MOVWF  FEA
020E:  MOVFF  131,FEC
0212:  MOVF   FED,F
0214:  MOVFF  130,FEF
0218:  MOVLB  0
.................... 		case I2C_REG_CH0_COMMAND_OFF_HOLD:
.................... 			channel[c].command_off_hold_seconds=value;
021A:  MOVLB  1
021C:  MOVF   x32,W
021E:  MULLW  19
0220:  MOVF   FF3,W
0222:  CLRF   x34
0224:  MOVWF  x33
0226:  MOVLW  07
0228:  ADDWF  x33,W
022A:  MOVWF  01
022C:  MOVLW  00
022E:  ADDWFC x34,W
0230:  MOVWF  03
0232:  MOVF   01,W
0234:  ADDLW  DA
0236:  MOVWF  FE9
0238:  MOVLW  00
023A:  ADDWFC 03,W
023C:  MOVWF  FEA
023E:  MOVFF  131,FEC
0242:  MOVF   FED,F
0244:  MOVFF  130,FEF
0248:  MOVLB  0
.................... 
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_ADC:
.................... 			config.ch[c].lvd_disconnect_adc=value;
024A:  MOVLB  1
024C:  MOVF   x32,W
024E:  MULLW  24
0250:  MOVF   FF3,W
0252:  CLRF   x34
0254:  MOVWF  x33
0256:  MOVLW  04
0258:  ADDWF  x33,W
025A:  MOVWF  01
025C:  MOVLW  00
025E:  ADDWFC x34,W
0260:  MOVWF  03
0262:  MOVF   01,W
0264:  ADDLW  1B
0266:  MOVWF  FE9
0268:  MOVLW  00
026A:  ADDWFC 03,W
026C:  MOVWF  FEA
026E:  MOVFF  131,FEC
0272:  MOVF   FED,F
0274:  MOVFF  130,FEF
0278:  MOVLB  0
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_DELAY:
.................... 			config.ch[c].lvd_disconnect_delay=value;
027A:  MOVLB  1
027C:  MOVF   x32,W
027E:  MULLW  24
0280:  MOVF   FF3,W
0282:  CLRF   x34
0284:  MOVWF  x33
0286:  MOVLW  06
0288:  ADDWF  x33,W
028A:  MOVWF  01
028C:  MOVLW  00
028E:  ADDWFC x34,W
0290:  MOVWF  03
0292:  MOVF   01,W
0294:  ADDLW  1B
0296:  MOVWF  FE9
0298:  MOVLW  00
029A:  ADDWFC 03,W
029C:  MOVWF  FEA
029E:  MOVFF  131,FEC
02A2:  MOVF   FED,F
02A4:  MOVFF  130,FEF
02A8:  MOVLB  0
.................... 		case I2C_REG_CH0_LVD_RECONNECT_ADC:
.................... 			config.ch[c].lvd_reconnect_adc=value;
02AA:  MOVLB  1
02AC:  MOVF   x32,W
02AE:  MULLW  24
02B0:  MOVF   FF3,W
02B2:  CLRF   x34
02B4:  MOVWF  x33
02B6:  MOVLW  08
02B8:  ADDWF  x33,W
02BA:  MOVWF  01
02BC:  MOVLW  00
02BE:  ADDWFC x34,W
02C0:  MOVWF  03
02C2:  MOVF   01,W
02C4:  ADDLW  1B
02C6:  MOVWF  FE9
02C8:  MOVLW  00
02CA:  ADDWFC 03,W
02CC:  MOVWF  FEA
02CE:  MOVFF  131,FEC
02D2:  MOVF   FED,F
02D4:  MOVFF  130,FEF
02D8:  MOVLB  0
.................... 		case I2C_REG_CH0_LVD_RECONNECT_DELAY:
.................... 			config.ch[c].lvd_reconnect_delay=value;
02DA:  MOVLB  1
02DC:  MOVF   x32,W
02DE:  MULLW  24
02E0:  MOVF   FF3,W
02E2:  CLRF   x34
02E4:  MOVWF  x33
02E6:  MOVLW  0A
02E8:  ADDWF  x33,W
02EA:  MOVWF  01
02EC:  MOVLW  00
02EE:  ADDWFC x34,W
02F0:  MOVWF  03
02F2:  MOVF   01,W
02F4:  ADDLW  1B
02F6:  MOVWF  FE9
02F8:  MOVLW  00
02FA:  ADDWFC 03,W
02FC:  MOVWF  FEA
02FE:  MOVFF  131,FEC
0302:  MOVF   FED,F
0304:  MOVFF  130,FEF
0308:  MOVLB  0
.................... 
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_ADC:
.................... 			config.ch[c].hvd_disconnect_adc=value;
030A:  MOVLB  1
030C:  MOVF   x32,W
030E:  MULLW  24
0310:  MOVF   FF3,W
0312:  CLRF   x34
0314:  MOVWF  x33
0316:  MOVLW  0C
0318:  ADDWF  x33,W
031A:  MOVWF  01
031C:  MOVLW  00
031E:  ADDWFC x34,W
0320:  MOVWF  03
0322:  MOVF   01,W
0324:  ADDLW  1B
0326:  MOVWF  FE9
0328:  MOVLW  00
032A:  ADDWFC 03,W
032C:  MOVWF  FEA
032E:  MOVFF  131,FEC
0332:  MOVF   FED,F
0334:  MOVFF  130,FEF
0338:  MOVLB  0
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_DELAY:
.................... 			config.ch[c].hvd_disconnect_delay=value;
033A:  MOVLB  1
033C:  MOVF   x32,W
033E:  MULLW  24
0340:  MOVF   FF3,W
0342:  CLRF   x34
0344:  MOVWF  x33
0346:  MOVLW  0E
0348:  ADDWF  x33,W
034A:  MOVWF  01
034C:  MOVLW  00
034E:  ADDWFC x34,W
0350:  MOVWF  03
0352:  MOVF   01,W
0354:  ADDLW  1B
0356:  MOVWF  FE9
0358:  MOVLW  00
035A:  ADDWFC 03,W
035C:  MOVWF  FEA
035E:  MOVFF  131,FEC
0362:  MOVF   FED,F
0364:  MOVFF  130,FEF
0368:  MOVLB  0
.................... 		case I2C_REG_CH0_HVD_RECONNECT_ADC:
.................... 			config.ch[c].hvd_reconnect_adc=value;
036A:  MOVLB  1
036C:  MOVF   x32,W
036E:  MULLW  24
0370:  MOVF   FF3,W
0372:  CLRF   x34
0374:  MOVWF  x33
0376:  MOVLW  10
0378:  ADDWF  x33,W
037A:  MOVWF  01
037C:  MOVLW  00
037E:  ADDWFC x34,W
0380:  MOVWF  03
0382:  MOVF   01,W
0384:  ADDLW  1B
0386:  MOVWF  FE9
0388:  MOVLW  00
038A:  ADDWFC 03,W
038C:  MOVWF  FEA
038E:  MOVFF  131,FEC
0392:  MOVF   FED,F
0394:  MOVFF  130,FEF
0398:  MOVLB  0
.................... 		case I2C_REG_CH0_HVD_RECONNECT_DELAY:
.................... 			config.ch[c].hvd_reconnect_delay=value;
039A:  MOVLB  1
039C:  MOVF   x32,W
039E:  MULLW  24
03A0:  MOVF   FF3,W
03A2:  CLRF   x34
03A4:  MOVWF  x33
03A6:  MOVLW  12
03A8:  ADDWF  x33,W
03AA:  MOVWF  01
03AC:  MOVLW  00
03AE:  ADDWFC x34,W
03B0:  MOVWF  03
03B2:  MOVF   01,W
03B4:  ADDLW  1B
03B6:  MOVWF  FE9
03B8:  MOVLW  00
03BA:  ADDWFC 03,W
03BC:  MOVWF  FEA
03BE:  MOVFF  131,FEC
03C2:  MOVF   FED,F
03C4:  MOVFF  130,FEF
03C8:  MOVLB  0
.................... 
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_ADC:
.................... 			config.ch[c].ltd_disconnect_adc=value;
03CA:  MOVLB  1
03CC:  MOVF   x32,W
03CE:  MULLW  24
03D0:  MOVF   FF3,W
03D2:  CLRF   x34
03D4:  MOVWF  x33
03D6:  MOVLW  14
03D8:  ADDWF  x33,W
03DA:  MOVWF  01
03DC:  MOVLW  00
03DE:  ADDWFC x34,W
03E0:  MOVWF  03
03E2:  MOVF   01,W
03E4:  ADDLW  1B
03E6:  MOVWF  FE9
03E8:  MOVLW  00
03EA:  ADDWFC 03,W
03EC:  MOVWF  FEA
03EE:  MOVFF  131,FEC
03F2:  MOVF   FED,F
03F4:  MOVFF  130,FEF
03F8:  MOVLB  0
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_DELAY:
.................... 			config.ch[c].ltd_disconnect_delay=value;
03FA:  MOVLB  1
03FC:  MOVF   x32,W
03FE:  MULLW  24
0400:  MOVF   FF3,W
0402:  CLRF   x34
0404:  MOVWF  x33
0406:  MOVLW  16
0408:  ADDWF  x33,W
040A:  MOVWF  01
040C:  MOVLW  00
040E:  ADDWFC x34,W
0410:  MOVWF  03
0412:  MOVF   01,W
0414:  ADDLW  1B
0416:  MOVWF  FE9
0418:  MOVLW  00
041A:  ADDWFC 03,W
041C:  MOVWF  FEA
041E:  MOVFF  131,FEC
0422:  MOVF   FED,F
0424:  MOVFF  130,FEF
0428:  MOVLB  0
.................... 		case I2C_REG_CH0_LTD_RECONNECT_ADC:
.................... 			config.ch[c].ltd_reconnect_adc=value;
042A:  MOVLB  1
042C:  MOVF   x32,W
042E:  MULLW  24
0430:  MOVF   FF3,W
0432:  CLRF   x34
0434:  MOVWF  x33
0436:  MOVLW  18
0438:  ADDWF  x33,W
043A:  MOVWF  01
043C:  MOVLW  00
043E:  ADDWFC x34,W
0440:  MOVWF  03
0442:  MOVF   01,W
0444:  ADDLW  1B
0446:  MOVWF  FE9
0448:  MOVLW  00
044A:  ADDWFC 03,W
044C:  MOVWF  FEA
044E:  MOVFF  131,FEC
0452:  MOVF   FED,F
0454:  MOVFF  130,FEF
0458:  MOVLB  0
.................... 		case I2C_REG_CH0_LTD_RECONNECT_DELAY:
.................... 			config.ch[c].ltd_reconnect_delay=value;
045A:  MOVLB  1
045C:  MOVF   x32,W
045E:  MULLW  24
0460:  MOVF   FF3,W
0462:  CLRF   x34
0464:  MOVWF  x33
0466:  MOVLW  1A
0468:  ADDWF  x33,W
046A:  MOVWF  01
046C:  MOVLW  00
046E:  ADDWFC x34,W
0470:  MOVWF  03
0472:  MOVF   01,W
0474:  ADDLW  1B
0476:  MOVWF  FE9
0478:  MOVLW  00
047A:  ADDWFC 03,W
047C:  MOVWF  FEA
047E:  MOVFF  131,FEC
0482:  MOVF   FED,F
0484:  MOVFF  130,FEF
0488:  MOVLB  0
.................... 
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_ADC:
.................... 			config.ch[c].htd_disconnect_adc=value;
048A:  MOVLB  1
048C:  MOVF   x32,W
048E:  MULLW  24
0490:  MOVF   FF3,W
0492:  CLRF   x34
0494:  MOVWF  x33
0496:  MOVLW  1C
0498:  ADDWF  x33,W
049A:  MOVWF  01
049C:  MOVLW  00
049E:  ADDWFC x34,W
04A0:  MOVWF  03
04A2:  MOVF   01,W
04A4:  ADDLW  1B
04A6:  MOVWF  FE9
04A8:  MOVLW  00
04AA:  ADDWFC 03,W
04AC:  MOVWF  FEA
04AE:  MOVFF  131,FEC
04B2:  MOVF   FED,F
04B4:  MOVFF  130,FEF
04B8:  MOVLB  0
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_DELAY:
.................... 			config.ch[c].htd_disconnect_delay=value;
04BA:  MOVLB  1
04BC:  MOVF   x32,W
04BE:  MULLW  24
04C0:  MOVF   FF3,W
04C2:  CLRF   x34
04C4:  MOVWF  x33
04C6:  MOVLW  1E
04C8:  ADDWF  x33,W
04CA:  MOVWF  01
04CC:  MOVLW  00
04CE:  ADDWFC x34,W
04D0:  MOVWF  03
04D2:  MOVF   01,W
04D4:  ADDLW  1B
04D6:  MOVWF  FE9
04D8:  MOVLW  00
04DA:  ADDWFC 03,W
04DC:  MOVWF  FEA
04DE:  MOVFF  131,FEC
04E2:  MOVF   FED,F
04E4:  MOVFF  130,FEF
04E8:  MOVLB  0
.................... 		case I2C_REG_CH0_HTD_RECONNECT_ADC:
.................... 			config.ch[c].htd_reconnect_adc=value;
04EA:  MOVLB  1
04EC:  MOVF   x32,W
04EE:  MULLW  24
04F0:  MOVF   FF3,W
04F2:  CLRF   x34
04F4:  MOVWF  x33
04F6:  MOVLW  20
04F8:  ADDWF  x33,W
04FA:  MOVWF  01
04FC:  MOVLW  00
04FE:  ADDWFC x34,W
0500:  MOVWF  03
0502:  MOVF   01,W
0504:  ADDLW  1B
0506:  MOVWF  FE9
0508:  MOVLW  00
050A:  ADDWFC 03,W
050C:  MOVWF  FEA
050E:  MOVFF  131,FEC
0512:  MOVF   FED,F
0514:  MOVFF  130,FEF
0518:  MOVLB  0
.................... 		case I2C_REG_CH0_HTD_RECONNECT_DELAY:
.................... 			config.ch[c].htd_reconnect_delay=value;
051A:  MOVLB  1
051C:  MOVF   x32,W
051E:  MULLW  24
0520:  MOVF   FF3,W
0522:  CLRF   x34
0524:  MOVWF  x33
0526:  MOVLW  22
0528:  ADDWF  x33,W
052A:  MOVWF  01
052C:  MOVLW  00
052E:  ADDWFC x34,W
0530:  MOVWF  03
0532:  MOVF   01,W
0534:  ADDLW  1B
0536:  MOVWF  FE9
0538:  MOVLW  00
053A:  ADDWFC 03,W
053C:  MOVWF  FEA
053E:  MOVFF  131,FEC
0542:  MOVF   FED,F
0544:  MOVFF  130,FEF
0548:  MOVLB  0
.................... 
.................... 		/* don't need to implement FUT ... there is nowhere for it to go anyhow */
.................... 
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			if ( 1 == value ) {
054A:  MOVLB  1
054C:  DECFSZ x30,W
054E:  BRA    055C
0550:  MOVF   x31,F
0552:  BNZ   055C
.................... 				timers.now_write_config=1;
0554:  MOVLB  0
0556:  BSF    xCF.3
.................... 			} else if ( 2 == value ) {
0558:  BRA    0590
055A:  MOVLB  1
055C:  MOVF   x30,W
055E:  SUBLW  02
0560:  BNZ   056E
0562:  MOVF   x31,F
0564:  BNZ   056E
.................... 				timers.now_reset_config=1;
0566:  MOVLB  0
0568:  BSF    xCF.4
.................... 			} else if ( 1802 == value ) {
056A:  BRA    0590
056C:  MOVLB  1
056E:  MOVF   x30,W
0570:  SUBLW  0A
0572:  BNZ   0584
0574:  MOVF   x31,W
0576:  SUBLW  07
0578:  BNZ   0584
.................... 				current.factory_unlocked =1;
057A:  MOVLW  01
057C:  MOVLB  0
057E:  MOVWF  xCA
.................... 			} else if ( 65535 == value ) {
0580:  BRA    0590
0582:  MOVLB  1
0584:  INCFSZ x30,W
0586:  BRA    058E
0588:  INCFSZ x31,W
058A:  BRA    058E
.................... 				reset_cpu();
058C:  RESET
058E:  MOVLB  0
.................... 			}
.................... 			break;
.................... 		default:
.................... 			/* do nothing */
.................... 	}
0590:  GOTO   0F14 (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... int16 map_i2c(int8 addr) {
.................... 	int8 c;
.................... 
.................... 	/* c is the channel we are accessing based on register range */
.................... 	if ( addr >= I2C_REG_CH1_COMMAND_ON && addr <= I2C_REG_CH1_FUT_RECONNECT ) {
*
0614:  MOVLB  1
0616:  MOVF   x2D,W
0618:  SUBLW  10
061A:  BC    062C
061C:  MOVF   x2D,W
061E:  SUBLW  1E
0620:  BNC   062C
.................... 		/* channel 1 status region */
.................... 		c=1;
0622:  MOVLW  01
0624:  MOVWF  x2E
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON - I2C_REG_CH0_COMMAND_ON);
0626:  MOVLW  0E
0628:  SUBWF  x2D,F
.................... 	} else if ( addr >= I2C_REG_CH1_COMMAND_ON_HOLD && addr <= I2C_REG_CH1_FUT_RECONNECT_DELAY ) {
062A:  BRA    0644
062C:  MOVF   x2D,W
062E:  SUBLW  11
0630:  BC    0642
0632:  MOVF   x2D,W
0634:  SUBLW  6B
0636:  BNC   0642
.................... 		/* channel 1 configuration region */
.................... 		c=1;
0638:  MOVLW  01
063A:  MOVWF  x2E
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON_HOLD - I2C_REG_CH0_COMMAND_ON_HOLD );
063C:  MOVLW  0E
063E:  SUBWF  x2D,F
.................... 	} else {
0640:  BRA    0644
.................... 		c=0;
0642:  CLRF   x2E
.................... 	}
.................... 
.................... 	switch ( addr ) {
0644:  MOVF   x2D,W
0646:  XORLW  00
0648:  MOVLB  0
064A:  BTFSC  FD8.2
064C:  BRA    077C
064E:  XORLW  01
0650:  BTFSC  FD8.2
0652:  BRA    0788
0654:  XORLW  03
0656:  BTFSC  FD8.2
0658:  BRA    0796
065A:  XORLW  01
065C:  BTFSC  FD8.2
065E:  BRA    07A4
0660:  XORLW  07
0662:  BTFSC  FD8.2
0664:  BRA    07DA
0666:  XORLW  01
0668:  BTFSC  FD8.2
066A:  BRA    0810
066C:  XORLW  03
066E:  BTFSC  FD8.2
0670:  BRA    0846
0672:  XORLW  01
0674:  BTFSC  FD8.2
0676:  BRA    087C
0678:  XORLW  0F
067A:  BTFSC  FD8.2
067C:  BRA    08B2
067E:  XORLW  01
0680:  BTFSC  FD8.2
0682:  BRA    08E8
0684:  XORLW  03
0686:  BTFSC  FD8.2
0688:  BRA    091E
068A:  XORLW  01
068C:  BTFSC  FD8.2
068E:  BRA    0954
0690:  XORLW  07
0692:  BTFSC  FD8.2
0694:  BRA    098A
0696:  XORLW  01
0698:  BTFSC  FD8.2
069A:  BRA    09C0
069C:  XORLW  03
069E:  BTFSC  FD8.2
06A0:  BRA    09F6
06A2:  XORLW  01
06A4:  BTFSC  FD8.2
06A6:  BRA    0A2C
06A8:  XORLW  1F
06AA:  BTFSC  FD8.2
06AC:  BRA    0A2C
06AE:  XORLW  0F
06B0:  BTFSC  FD8.2
06B2:  BRA    0A34
06B4:  XORLW  3F
06B6:  BTFSC  FD8.2
06B8:  BRA    0A3E
06BA:  XORLW  01
06BC:  BTFSC  FD8.2
06BE:  BRA    0A48
06C0:  XORLW  03
06C2:  BTFSC  FD8.2
06C4:  BRA    0A52
06C6:  XORLW  62
06C8:  BTFSC  FD8.2
06CA:  BRA    0A5A
06CC:  XORLW  01
06CE:  BTFSC  FD8.2
06D0:  BRA    0A84
06D2:  XORLW  03
06D4:  BTFSC  FD8.2
06D6:  BRA    0ABA
06D8:  XORLW  01
06DA:  BTFSC  FD8.2
06DC:  BRA    0AF0
06DE:  XORLW  07
06E0:  BTFSC  FD8.2
06E2:  BRA    0B26
06E4:  XORLW  01
06E6:  BTFSC  FD8.2
06E8:  BRA    0B5C
06EA:  XORLW  03
06EC:  BTFSC  FD8.2
06EE:  BRA    0B92
06F0:  XORLW  01
06F2:  BTFSC  FD8.2
06F4:  BRA    0BC8
06F6:  XORLW  0F
06F8:  BTFSC  FD8.2
06FA:  BRA    0BFE
06FC:  XORLW  01
06FE:  BTFSC  FD8.2
0700:  BRA    0C34
0702:  XORLW  03
0704:  BTFSC  FD8.2
0706:  BRA    0C6A
0708:  XORLW  01
070A:  BTFSC  FD8.2
070C:  BRA    0CA0
070E:  XORLW  07
0710:  BTFSC  FD8.2
0712:  BRA    0CD6
0714:  XORLW  01
0716:  BTFSC  FD8.2
0718:  BRA    0D0C
071A:  XORLW  03
071C:  BTFSC  FD8.2
071E:  BRA    0D42
0720:  XORLW  01
0722:  BTFSC  FD8.2
0724:  BRA    0D78
0726:  XORLW  1F
0728:  BTFSC  FD8.2
072A:  BRA    0DAE
072C:  XORLW  01
072E:  BTFSC  FD8.2
0730:  BRA    0DE4
0732:  XORLW  03
0734:  BTFSC  FD8.2
0736:  BRA    0E1A
0738:  XORLW  01
073A:  BTFSC  FD8.2
073C:  BRA    0E1A
073E:  XORLW  07
0740:  BTFSC  FD8.2
0742:  BRA    0E1A
0744:  XORLW  01
0746:  BTFSC  FD8.2
0748:  BRA    0E1A
074A:  XORLW  D5
074C:  BTFSC  FD8.2
074E:  BRA    0E22
0750:  XORLW  01
0752:  BTFSC  FD8.2
0754:  BRA    0E2C
0756:  XORLW  03
0758:  BTFSC  FD8.2
075A:  BRA    0E36
075C:  XORLW  01
075E:  BTFSC  FD8.2
0760:  BRA    0E40
0762:  XORLW  07
0764:  BTFSC  FD8.2
0766:  BRA    0E4A
0768:  XORLW  01
076A:  BTFSC  FD8.2
076C:  BRA    0E52
076E:  XORLW  03
0770:  BTFSC  FD8.2
0772:  BRA    0E5A
0774:  XORLW  01
0776:  BTFSC  FD8.2
0778:  BRA    0E62
077A:  BRA    0E6A
.................... 		/* not channel based */
.................... 		case I2C_REG_VOLTAGE_INPUT_AVG: 
.................... 			return (int16) adc_get(0);
077C:  MOVLB  1
077E:  CLRF   x2F
0780:  MOVLB  0
0782:  RCALL  0594
0784:  MOVF   02,W
0786:  BRA    0E70
.................... 		case I2C_REG_STATE_CONTACTORS:
.................... 			return (int16) make16(channel[0].state,channel[1].state);
0788:  MOVFF  DA,03
078C:  MOVFF  F3,01
0790:  MOVFF  DA,02
0794:  BRA    0E70
.................... 		case I2C_REG_TEMPERATURE_BOARD_AVG: 
.................... 			return (int16) adc_get(1);
0796:  MOVLW  01
0798:  MOVLB  1
079A:  MOVWF  x2F
079C:  MOVLB  0
079E:  RCALL  0594
07A0:  MOVF   02,W
07A2:  BRA    0E70
.................... 
.................... 		/* status based on channel value c */
.................... 		case I2C_REG_CH0_COMMAND_ON :
.................... 			return (int16) channel[c].command_on_seconds;
07A4:  MOVLB  1
07A6:  MOVF   x2E,W
07A8:  MULLW  19
07AA:  MOVF   FF3,W
07AC:  CLRF   x30
07AE:  MOVWF  x2F
07B0:  MOVLW  01
07B2:  ADDWF  x2F,W
07B4:  MOVWF  01
07B6:  MOVLW  00
07B8:  ADDWFC x30,W
07BA:  MOVWF  03
07BC:  MOVF   01,W
07BE:  ADDLW  DA
07C0:  MOVWF  FE9
07C2:  MOVLW  00
07C4:  ADDWFC 03,W
07C6:  MOVWF  FEA
07C8:  MOVFF  FEC,03
07CC:  MOVF   FED,F
07CE:  MOVFF  FEF,01
07D2:  MOVFF  03,02
07D6:  MOVLB  0
07D8:  BRA    0E70
.................... 		case I2C_REG_CH0_COMMAND_ON_HOLD:
.................... 			return (int16) channel[c].command_on_hold_seconds;
07DA:  MOVLB  1
07DC:  MOVF   x2E,W
07DE:  MULLW  19
07E0:  MOVF   FF3,W
07E2:  CLRF   x30
07E4:  MOVWF  x2F
07E6:  MOVLW  03
07E8:  ADDWF  x2F,W
07EA:  MOVWF  01
07EC:  MOVLW  00
07EE:  ADDWFC x30,W
07F0:  MOVWF  03
07F2:  MOVF   01,W
07F4:  ADDLW  DA
07F6:  MOVWF  FE9
07F8:  MOVLW  00
07FA:  ADDWFC 03,W
07FC:  MOVWF  FEA
07FE:  MOVFF  FEC,03
0802:  MOVF   FED,F
0804:  MOVFF  FEF,01
0808:  MOVFF  03,02
080C:  MOVLB  0
080E:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_COMMAND_OFF:
.................... 			return (int16) channel[c].command_off_seconds;
0810:  MOVLB  1
0812:  MOVF   x2E,W
0814:  MULLW  19
0816:  MOVF   FF3,W
0818:  CLRF   x30
081A:  MOVWF  x2F
081C:  MOVLW  05
081E:  ADDWF  x2F,W
0820:  MOVWF  01
0822:  MOVLW  00
0824:  ADDWFC x30,W
0826:  MOVWF  03
0828:  MOVF   01,W
082A:  ADDLW  DA
082C:  MOVWF  FE9
082E:  MOVLW  00
0830:  ADDWFC 03,W
0832:  MOVWF  FEA
0834:  MOVFF  FEC,03
0838:  MOVF   FED,F
083A:  MOVFF  FEF,01
083E:  MOVFF  03,02
0842:  MOVLB  0
0844:  BRA    0E70
.................... 		case I2C_REG_CH0_COMMAND_OFF_HOLD:
.................... 			return (int16) channel[c].command_off_hold_seconds;
0846:  MOVLB  1
0848:  MOVF   x2E,W
084A:  MULLW  19
084C:  MOVF   FF3,W
084E:  CLRF   x30
0850:  MOVWF  x2F
0852:  MOVLW  07
0854:  ADDWF  x2F,W
0856:  MOVWF  01
0858:  MOVLW  00
085A:  ADDWFC x30,W
085C:  MOVWF  03
085E:  MOVF   01,W
0860:  ADDLW  DA
0862:  MOVWF  FE9
0864:  MOVLW  00
0866:  ADDWFC 03,W
0868:  MOVWF  FEA
086A:  MOVFF  FEC,03
086E:  MOVF   FED,F
0870:  MOVFF  FEF,01
0874:  MOVFF  03,02
0878:  MOVLB  0
087A:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_LVD_DISCONNECT:
.................... 			return (int16) channel[c].lvd_disconnect_delay_seconds;
087C:  MOVLB  1
087E:  MOVF   x2E,W
0880:  MULLW  19
0882:  MOVF   FF3,W
0884:  CLRF   x30
0886:  MOVWF  x2F
0888:  MOVLW  09
088A:  ADDWF  x2F,W
088C:  MOVWF  01
088E:  MOVLW  00
0890:  ADDWFC x30,W
0892:  MOVWF  03
0894:  MOVF   01,W
0896:  ADDLW  DA
0898:  MOVWF  FE9
089A:  MOVLW  00
089C:  ADDWFC 03,W
089E:  MOVWF  FEA
08A0:  MOVFF  FEC,03
08A4:  MOVF   FED,F
08A6:  MOVFF  FEF,01
08AA:  MOVFF  03,02
08AE:  MOVLB  0
08B0:  BRA    0E70
.................... 		case I2C_REG_CH0_LVD_RECONNECT:
.................... 			return (int16) channel[c].lvd_reconnect_delay_seconds;
08B2:  MOVLB  1
08B4:  MOVF   x2E,W
08B6:  MULLW  19
08B8:  MOVF   FF3,W
08BA:  CLRF   x30
08BC:  MOVWF  x2F
08BE:  MOVLW  0B
08C0:  ADDWF  x2F,W
08C2:  MOVWF  01
08C4:  MOVLW  00
08C6:  ADDWFC x30,W
08C8:  MOVWF  03
08CA:  MOVF   01,W
08CC:  ADDLW  DA
08CE:  MOVWF  FE9
08D0:  MOVLW  00
08D2:  ADDWFC 03,W
08D4:  MOVWF  FEA
08D6:  MOVFF  FEC,03
08DA:  MOVF   FED,F
08DC:  MOVFF  FEF,01
08E0:  MOVFF  03,02
08E4:  MOVLB  0
08E6:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_HVD_DISCONNECT:
.................... 			return (int16) channel[c].hvd_disconnect_delay_seconds;
08E8:  MOVLB  1
08EA:  MOVF   x2E,W
08EC:  MULLW  19
08EE:  MOVF   FF3,W
08F0:  CLRF   x30
08F2:  MOVWF  x2F
08F4:  MOVLW  0D
08F6:  ADDWF  x2F,W
08F8:  MOVWF  01
08FA:  MOVLW  00
08FC:  ADDWFC x30,W
08FE:  MOVWF  03
0900:  MOVF   01,W
0902:  ADDLW  DA
0904:  MOVWF  FE9
0906:  MOVLW  00
0908:  ADDWFC 03,W
090A:  MOVWF  FEA
090C:  MOVFF  FEC,03
0910:  MOVF   FED,F
0912:  MOVFF  FEF,01
0916:  MOVFF  03,02
091A:  MOVLB  0
091C:  BRA    0E70
.................... 		case I2C_REG_CH0_HVD_RECONNECT:
.................... 			return (int16) channel[c].hvd_reconnect_delay_seconds;
091E:  MOVLB  1
0920:  MOVF   x2E,W
0922:  MULLW  19
0924:  MOVF   FF3,W
0926:  CLRF   x30
0928:  MOVWF  x2F
092A:  MOVLW  0F
092C:  ADDWF  x2F,W
092E:  MOVWF  01
0930:  MOVLW  00
0932:  ADDWFC x30,W
0934:  MOVWF  03
0936:  MOVF   01,W
0938:  ADDLW  DA
093A:  MOVWF  FE9
093C:  MOVLW  00
093E:  ADDWFC 03,W
0940:  MOVWF  FEA
0942:  MOVFF  FEC,03
0946:  MOVF   FED,F
0948:  MOVFF  FEF,01
094C:  MOVFF  03,02
0950:  MOVLB  0
0952:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_LTD_DISCONNECT:
.................... 			return (int16) channel[c].ltd_disconnect_delay_seconds;
0954:  MOVLB  1
0956:  MOVF   x2E,W
0958:  MULLW  19
095A:  MOVF   FF3,W
095C:  CLRF   x30
095E:  MOVWF  x2F
0960:  MOVLW  11
0962:  ADDWF  x2F,W
0964:  MOVWF  01
0966:  MOVLW  00
0968:  ADDWFC x30,W
096A:  MOVWF  03
096C:  MOVF   01,W
096E:  ADDLW  DA
0970:  MOVWF  FE9
0972:  MOVLW  00
0974:  ADDWFC 03,W
0976:  MOVWF  FEA
0978:  MOVFF  FEC,03
097C:  MOVF   FED,F
097E:  MOVFF  FEF,01
0982:  MOVFF  03,02
0986:  MOVLB  0
0988:  BRA    0E70
.................... 		case I2C_REG_CH0_LTD_RECONNECT:
.................... 			return (int16) channel[c].ltd_reconnect_delay_seconds;
098A:  MOVLB  1
098C:  MOVF   x2E,W
098E:  MULLW  19
0990:  MOVF   FF3,W
0992:  CLRF   x30
0994:  MOVWF  x2F
0996:  MOVLW  13
0998:  ADDWF  x2F,W
099A:  MOVWF  01
099C:  MOVLW  00
099E:  ADDWFC x30,W
09A0:  MOVWF  03
09A2:  MOVF   01,W
09A4:  ADDLW  DA
09A6:  MOVWF  FE9
09A8:  MOVLW  00
09AA:  ADDWFC 03,W
09AC:  MOVWF  FEA
09AE:  MOVFF  FEC,03
09B2:  MOVF   FED,F
09B4:  MOVFF  FEF,01
09B8:  MOVFF  03,02
09BC:  MOVLB  0
09BE:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_HTD_DISCONNECT:
.................... 			return (int16) channel[c].htd_disconnect_delay_seconds;
09C0:  MOVLB  1
09C2:  MOVF   x2E,W
09C4:  MULLW  19
09C6:  MOVF   FF3,W
09C8:  CLRF   x30
09CA:  MOVWF  x2F
09CC:  MOVLW  15
09CE:  ADDWF  x2F,W
09D0:  MOVWF  01
09D2:  MOVLW  00
09D4:  ADDWFC x30,W
09D6:  MOVWF  03
09D8:  MOVF   01,W
09DA:  ADDLW  DA
09DC:  MOVWF  FE9
09DE:  MOVLW  00
09E0:  ADDWFC 03,W
09E2:  MOVWF  FEA
09E4:  MOVFF  FEC,03
09E8:  MOVF   FED,F
09EA:  MOVFF  FEF,01
09EE:  MOVFF  03,02
09F2:  MOVLB  0
09F4:  BRA    0E70
.................... 		case I2C_REG_CH0_HTD_RECONNECT:
.................... 			return (int16) channel[c].htd_reconnect_delay_seconds;
09F6:  MOVLB  1
09F8:  MOVF   x2E,W
09FA:  MULLW  19
09FC:  MOVF   FF3,W
09FE:  CLRF   x30
0A00:  MOVWF  x2F
0A02:  MOVLW  17
0A04:  ADDWF  x2F,W
0A06:  MOVWF  01
0A08:  MOVLW  00
0A0A:  ADDWFC x30,W
0A0C:  MOVWF  03
0A0E:  MOVF   01,W
0A10:  ADDLW  DA
0A12:  MOVWF  FE9
0A14:  MOVLW  00
0A16:  ADDWFC 03,W
0A18:  MOVWF  FEA
0A1A:  MOVFF  FEC,03
0A1E:  MOVF   FED,F
0A20:  MOVFF  FEF,01
0A24:  MOVFF  03,02
0A28:  MOVLB  0
0A2A:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_FUT_DISCONNECT:
.................... 		case I2C_REG_CH0_FUT_RECONNECT:
.................... 			return (int16) 0xffff; /* not yet implemented */
0A2C:  MOVLW  FF
0A2E:  MOVWF  01
0A30:  MOVWF  02
0A32:  BRA    0E70
.................... 
.................... 
.................... 		/* non-channel based meta */
.................... 		case I2C_REG_SEQUENCE_NUMBER:
.................... 			return (int16) current.sequence_number;
0A34:  MOVFF  C4,01
0A38:  MOVFF  C5,02
0A3C:  BRA    0E70
.................... 		case I2C_REG_TIME_INTERVAL_MILLISECONDS:
.................... 			return (int16) current.interval_milliseconds;
0A3E:  MOVFF  C8,01
0A42:  MOVFF  C9,02
0A46:  BRA    0E70
.................... 		case I2C_REG_TIME_UPTIME_MINUTES:
.................... 			return (int16) current.uptime_minutes;
0A48:  MOVFF  C6,01
0A4C:  MOVFF  C7,02
0A50:  BRA    0E70
.................... 		case I2C_REG_DEFAULT_PARAMS_WRITTEN:
.................... 			return (int16) current.default_params_written;
0A52:  MOVFF  CE,01
0A56:  CLRF   02
0A58:  BRA    0E70
.................... 
.................... 		/* channel based configuration */
.................... 		case I2C_REG_CH0_COMMAND_ON_HOLD_INITIAL:
.................... 			return (int16) config.ch[c].command_on_hold_time;
0A5A:  MOVLB  1
0A5C:  MOVF   x2E,W
0A5E:  MULLW  24
0A60:  MOVF   FF3,W
0A62:  CLRF   x30
0A64:  MOVWF  x2F
0A66:  MOVLW  1B
0A68:  ADDWF  x2F,W
0A6A:  MOVWF  FE9
0A6C:  MOVLW  00
0A6E:  ADDWFC x30,W
0A70:  MOVWF  FEA
0A72:  MOVFF  FEC,03
0A76:  MOVF   FED,F
0A78:  MOVFF  FEF,01
0A7C:  MOVFF  03,02
0A80:  MOVLB  0
0A82:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_COMMAND_OFF_HOLD_INITIAL:
.................... 			return (int16) config.ch[c].command_off_hold_time;
0A84:  MOVLB  1
0A86:  MOVF   x2E,W
0A88:  MULLW  24
0A8A:  MOVF   FF3,W
0A8C:  CLRF   x30
0A8E:  MOVWF  x2F
0A90:  MOVLW  02
0A92:  ADDWF  x2F,W
0A94:  MOVWF  01
0A96:  MOVLW  00
0A98:  ADDWFC x30,W
0A9A:  MOVWF  03
0A9C:  MOVF   01,W
0A9E:  ADDLW  1B
0AA0:  MOVWF  FE9
0AA2:  MOVLW  00
0AA4:  ADDWFC 03,W
0AA6:  MOVWF  FEA
0AA8:  MOVFF  FEC,03
0AAC:  MOVF   FED,F
0AAE:  MOVFF  FEF,01
0AB2:  MOVFF  03,02
0AB6:  MOVLB  0
0AB8:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].lvd_disconnect_adc;
0ABA:  MOVLB  1
0ABC:  MOVF   x2E,W
0ABE:  MULLW  24
0AC0:  MOVF   FF3,W
0AC2:  CLRF   x30
0AC4:  MOVWF  x2F
0AC6:  MOVLW  04
0AC8:  ADDWF  x2F,W
0ACA:  MOVWF  01
0ACC:  MOVLW  00
0ACE:  ADDWFC x30,W
0AD0:  MOVWF  03
0AD2:  MOVF   01,W
0AD4:  ADDLW  1B
0AD6:  MOVWF  FE9
0AD8:  MOVLW  00
0ADA:  ADDWFC 03,W
0ADC:  MOVWF  FEA
0ADE:  MOVFF  FEC,03
0AE2:  MOVF   FED,F
0AE4:  MOVFF  FEF,01
0AE8:  MOVFF  03,02
0AEC:  MOVLB  0
0AEE:  BRA    0E70
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].lvd_disconnect_delay;
0AF0:  MOVLB  1
0AF2:  MOVF   x2E,W
0AF4:  MULLW  24
0AF6:  MOVF   FF3,W
0AF8:  CLRF   x30
0AFA:  MOVWF  x2F
0AFC:  MOVLW  06
0AFE:  ADDWF  x2F,W
0B00:  MOVWF  01
0B02:  MOVLW  00
0B04:  ADDWFC x30,W
0B06:  MOVWF  03
0B08:  MOVF   01,W
0B0A:  ADDLW  1B
0B0C:  MOVWF  FE9
0B0E:  MOVLW  00
0B10:  ADDWFC 03,W
0B12:  MOVWF  FEA
0B14:  MOVFF  FEC,03
0B18:  MOVF   FED,F
0B1A:  MOVFF  FEF,01
0B1E:  MOVFF  03,02
0B22:  MOVLB  0
0B24:  BRA    0E70
.................... 		case I2C_REG_CH0_LVD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].lvd_reconnect_adc;
0B26:  MOVLB  1
0B28:  MOVF   x2E,W
0B2A:  MULLW  24
0B2C:  MOVF   FF3,W
0B2E:  CLRF   x30
0B30:  MOVWF  x2F
0B32:  MOVLW  08
0B34:  ADDWF  x2F,W
0B36:  MOVWF  01
0B38:  MOVLW  00
0B3A:  ADDWFC x30,W
0B3C:  MOVWF  03
0B3E:  MOVF   01,W
0B40:  ADDLW  1B
0B42:  MOVWF  FE9
0B44:  MOVLW  00
0B46:  ADDWFC 03,W
0B48:  MOVWF  FEA
0B4A:  MOVFF  FEC,03
0B4E:  MOVF   FED,F
0B50:  MOVFF  FEF,01
0B54:  MOVFF  03,02
0B58:  MOVLB  0
0B5A:  BRA    0E70
.................... 		case I2C_REG_CH0_LVD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].lvd_reconnect_delay;
0B5C:  MOVLB  1
0B5E:  MOVF   x2E,W
0B60:  MULLW  24
0B62:  MOVF   FF3,W
0B64:  CLRF   x30
0B66:  MOVWF  x2F
0B68:  MOVLW  0A
0B6A:  ADDWF  x2F,W
0B6C:  MOVWF  01
0B6E:  MOVLW  00
0B70:  ADDWFC x30,W
0B72:  MOVWF  03
0B74:  MOVF   01,W
0B76:  ADDLW  1B
0B78:  MOVWF  FE9
0B7A:  MOVLW  00
0B7C:  ADDWFC 03,W
0B7E:  MOVWF  FEA
0B80:  MOVFF  FEC,03
0B84:  MOVF   FED,F
0B86:  MOVFF  FEF,01
0B8A:  MOVFF  03,02
0B8E:  MOVLB  0
0B90:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].hvd_disconnect_adc;
0B92:  MOVLB  1
0B94:  MOVF   x2E,W
0B96:  MULLW  24
0B98:  MOVF   FF3,W
0B9A:  CLRF   x30
0B9C:  MOVWF  x2F
0B9E:  MOVLW  0C
0BA0:  ADDWF  x2F,W
0BA2:  MOVWF  01
0BA4:  MOVLW  00
0BA6:  ADDWFC x30,W
0BA8:  MOVWF  03
0BAA:  MOVF   01,W
0BAC:  ADDLW  1B
0BAE:  MOVWF  FE9
0BB0:  MOVLW  00
0BB2:  ADDWFC 03,W
0BB4:  MOVWF  FEA
0BB6:  MOVFF  FEC,03
0BBA:  MOVF   FED,F
0BBC:  MOVFF  FEF,01
0BC0:  MOVFF  03,02
0BC4:  MOVLB  0
0BC6:  BRA    0E70
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].hvd_disconnect_delay;
0BC8:  MOVLB  1
0BCA:  MOVF   x2E,W
0BCC:  MULLW  24
0BCE:  MOVF   FF3,W
0BD0:  CLRF   x30
0BD2:  MOVWF  x2F
0BD4:  MOVLW  0E
0BD6:  ADDWF  x2F,W
0BD8:  MOVWF  01
0BDA:  MOVLW  00
0BDC:  ADDWFC x30,W
0BDE:  MOVWF  03
0BE0:  MOVF   01,W
0BE2:  ADDLW  1B
0BE4:  MOVWF  FE9
0BE6:  MOVLW  00
0BE8:  ADDWFC 03,W
0BEA:  MOVWF  FEA
0BEC:  MOVFF  FEC,03
0BF0:  MOVF   FED,F
0BF2:  MOVFF  FEF,01
0BF6:  MOVFF  03,02
0BFA:  MOVLB  0
0BFC:  BRA    0E70
.................... 		case I2C_REG_CH0_HVD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].hvd_reconnect_adc;
0BFE:  MOVLB  1
0C00:  MOVF   x2E,W
0C02:  MULLW  24
0C04:  MOVF   FF3,W
0C06:  CLRF   x30
0C08:  MOVWF  x2F
0C0A:  MOVLW  10
0C0C:  ADDWF  x2F,W
0C0E:  MOVWF  01
0C10:  MOVLW  00
0C12:  ADDWFC x30,W
0C14:  MOVWF  03
0C16:  MOVF   01,W
0C18:  ADDLW  1B
0C1A:  MOVWF  FE9
0C1C:  MOVLW  00
0C1E:  ADDWFC 03,W
0C20:  MOVWF  FEA
0C22:  MOVFF  FEC,03
0C26:  MOVF   FED,F
0C28:  MOVFF  FEF,01
0C2C:  MOVFF  03,02
0C30:  MOVLB  0
0C32:  BRA    0E70
.................... 		case I2C_REG_CH0_HVD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].hvd_reconnect_delay;
0C34:  MOVLB  1
0C36:  MOVF   x2E,W
0C38:  MULLW  24
0C3A:  MOVF   FF3,W
0C3C:  CLRF   x30
0C3E:  MOVWF  x2F
0C40:  MOVLW  12
0C42:  ADDWF  x2F,W
0C44:  MOVWF  01
0C46:  MOVLW  00
0C48:  ADDWFC x30,W
0C4A:  MOVWF  03
0C4C:  MOVF   01,W
0C4E:  ADDLW  1B
0C50:  MOVWF  FE9
0C52:  MOVLW  00
0C54:  ADDWFC 03,W
0C56:  MOVWF  FEA
0C58:  MOVFF  FEC,03
0C5C:  MOVF   FED,F
0C5E:  MOVFF  FEF,01
0C62:  MOVFF  03,02
0C66:  MOVLB  0
0C68:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_disconnect_adc;
0C6A:  MOVLB  1
0C6C:  MOVF   x2E,W
0C6E:  MULLW  24
0C70:  MOVF   FF3,W
0C72:  CLRF   x30
0C74:  MOVWF  x2F
0C76:  MOVLW  14
0C78:  ADDWF  x2F,W
0C7A:  MOVWF  01
0C7C:  MOVLW  00
0C7E:  ADDWFC x30,W
0C80:  MOVWF  03
0C82:  MOVF   01,W
0C84:  ADDLW  1B
0C86:  MOVWF  FE9
0C88:  MOVLW  00
0C8A:  ADDWFC 03,W
0C8C:  MOVWF  FEA
0C8E:  MOVFF  FEC,03
0C92:  MOVF   FED,F
0C94:  MOVFF  FEF,01
0C98:  MOVFF  03,02
0C9C:  MOVLB  0
0C9E:  BRA    0E70
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_disconnect_delay;
0CA0:  MOVLB  1
0CA2:  MOVF   x2E,W
0CA4:  MULLW  24
0CA6:  MOVF   FF3,W
0CA8:  CLRF   x30
0CAA:  MOVWF  x2F
0CAC:  MOVLW  16
0CAE:  ADDWF  x2F,W
0CB0:  MOVWF  01
0CB2:  MOVLW  00
0CB4:  ADDWFC x30,W
0CB6:  MOVWF  03
0CB8:  MOVF   01,W
0CBA:  ADDLW  1B
0CBC:  MOVWF  FE9
0CBE:  MOVLW  00
0CC0:  ADDWFC 03,W
0CC2:  MOVWF  FEA
0CC4:  MOVFF  FEC,03
0CC8:  MOVF   FED,F
0CCA:  MOVFF  FEF,01
0CCE:  MOVFF  03,02
0CD2:  MOVLB  0
0CD4:  BRA    0E70
.................... 		case I2C_REG_CH0_LTD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_reconnect_adc;
0CD6:  MOVLB  1
0CD8:  MOVF   x2E,W
0CDA:  MULLW  24
0CDC:  MOVF   FF3,W
0CDE:  CLRF   x30
0CE0:  MOVWF  x2F
0CE2:  MOVLW  18
0CE4:  ADDWF  x2F,W
0CE6:  MOVWF  01
0CE8:  MOVLW  00
0CEA:  ADDWFC x30,W
0CEC:  MOVWF  03
0CEE:  MOVF   01,W
0CF0:  ADDLW  1B
0CF2:  MOVWF  FE9
0CF4:  MOVLW  00
0CF6:  ADDWFC 03,W
0CF8:  MOVWF  FEA
0CFA:  MOVFF  FEC,03
0CFE:  MOVF   FED,F
0D00:  MOVFF  FEF,01
0D04:  MOVFF  03,02
0D08:  MOVLB  0
0D0A:  BRA    0E70
.................... 		case I2C_REG_CH0_LTD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_reconnect_delay;
0D0C:  MOVLB  1
0D0E:  MOVF   x2E,W
0D10:  MULLW  24
0D12:  MOVF   FF3,W
0D14:  CLRF   x30
0D16:  MOVWF  x2F
0D18:  MOVLW  1A
0D1A:  ADDWF  x2F,W
0D1C:  MOVWF  01
0D1E:  MOVLW  00
0D20:  ADDWFC x30,W
0D22:  MOVWF  03
0D24:  MOVF   01,W
0D26:  ADDLW  1B
0D28:  MOVWF  FE9
0D2A:  MOVLW  00
0D2C:  ADDWFC 03,W
0D2E:  MOVWF  FEA
0D30:  MOVFF  FEC,03
0D34:  MOVF   FED,F
0D36:  MOVFF  FEF,01
0D3A:  MOVFF  03,02
0D3E:  MOVLB  0
0D40:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_disconnect_adc;
0D42:  MOVLB  1
0D44:  MOVF   x2E,W
0D46:  MULLW  24
0D48:  MOVF   FF3,W
0D4A:  CLRF   x30
0D4C:  MOVWF  x2F
0D4E:  MOVLW  14
0D50:  ADDWF  x2F,W
0D52:  MOVWF  01
0D54:  MOVLW  00
0D56:  ADDWFC x30,W
0D58:  MOVWF  03
0D5A:  MOVF   01,W
0D5C:  ADDLW  1B
0D5E:  MOVWF  FE9
0D60:  MOVLW  00
0D62:  ADDWFC 03,W
0D64:  MOVWF  FEA
0D66:  MOVFF  FEC,03
0D6A:  MOVF   FED,F
0D6C:  MOVFF  FEF,01
0D70:  MOVFF  03,02
0D74:  MOVLB  0
0D76:  BRA    0E70
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_disconnect_delay;
0D78:  MOVLB  1
0D7A:  MOVF   x2E,W
0D7C:  MULLW  24
0D7E:  MOVF   FF3,W
0D80:  CLRF   x30
0D82:  MOVWF  x2F
0D84:  MOVLW  16
0D86:  ADDWF  x2F,W
0D88:  MOVWF  01
0D8A:  MOVLW  00
0D8C:  ADDWFC x30,W
0D8E:  MOVWF  03
0D90:  MOVF   01,W
0D92:  ADDLW  1B
0D94:  MOVWF  FE9
0D96:  MOVLW  00
0D98:  ADDWFC 03,W
0D9A:  MOVWF  FEA
0D9C:  MOVFF  FEC,03
0DA0:  MOVF   FED,F
0DA2:  MOVFF  FEF,01
0DA6:  MOVFF  03,02
0DAA:  MOVLB  0
0DAC:  BRA    0E70
.................... 		case I2C_REG_CH0_HTD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_reconnect_adc;
0DAE:  MOVLB  1
0DB0:  MOVF   x2E,W
0DB2:  MULLW  24
0DB4:  MOVF   FF3,W
0DB6:  CLRF   x30
0DB8:  MOVWF  x2F
0DBA:  MOVLW  18
0DBC:  ADDWF  x2F,W
0DBE:  MOVWF  01
0DC0:  MOVLW  00
0DC2:  ADDWFC x30,W
0DC4:  MOVWF  03
0DC6:  MOVF   01,W
0DC8:  ADDLW  1B
0DCA:  MOVWF  FE9
0DCC:  MOVLW  00
0DCE:  ADDWFC 03,W
0DD0:  MOVWF  FEA
0DD2:  MOVFF  FEC,03
0DD6:  MOVF   FED,F
0DD8:  MOVFF  FEF,01
0DDC:  MOVFF  03,02
0DE0:  MOVLB  0
0DE2:  BRA    0E70
.................... 		case I2C_REG_CH0_HTD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_reconnect_delay;	
0DE4:  MOVLB  1
0DE6:  MOVF   x2E,W
0DE8:  MULLW  24
0DEA:  MOVF   FF3,W
0DEC:  CLRF   x30
0DEE:  MOVWF  x2F
0DF0:  MOVLW  1A
0DF2:  ADDWF  x2F,W
0DF4:  MOVWF  01
0DF6:  MOVLW  00
0DF8:  ADDWFC x30,W
0DFA:  MOVWF  03
0DFC:  MOVF   01,W
0DFE:  ADDLW  1B
0E00:  MOVWF  FE9
0E02:  MOVLW  00
0E04:  ADDWFC 03,W
0E06:  MOVWF  FEA
0E08:  MOVFF  FEC,03
0E0C:  MOVF   FED,F
0E0E:  MOVFF  FEF,01
0E12:  MOVFF  03,02
0E16:  MOVLB  0
0E18:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_FUT_DISCONNECT_VALUE:
.................... 		case I2C_REG_CH0_FUT_DISCONNECT_DELAY:
.................... 		case I2C_REG_CH0_FUT_RECONNECT_VALUE:
.................... 		case I2C_REG_CH0_FUT_RECONNECT_DELAY:
.................... 			return (int16) 0xffff; /* not yet implemented */
0E1A:  MOVLW  FF
0E1C:  MOVWF  01
0E1E:  MOVWF  02
0E20:  BRA    0E70
.................... 		
.................... 		/* configuration */
.................... 		case I2C_REG_CONFIG_HARDWARE_MODEL: 
.................... 			return (int16) 'D';
0E22:  MOVLW  44
0E24:  MOVWF  01
0E26:  MOVLW  00
0E28:  MOVWF  02
0E2A:  BRA    0E70
.................... 		case I2C_REG_CONFIG_HARDWARE_VERSION: 
.................... 			return (int16) '2';
0E2C:  MOVLW  32
0E2E:  MOVWF  01
0E30:  MOVLW  00
0E32:  MOVWF  02
0E34:  BRA    0E70
.................... 		case I2C_REG_CONFIG_SOFTWARE_MODEL: 
.................... 			return (int16) 'L';
0E36:  MOVLW  4C
0E38:  MOVWF  01
0E3A:  MOVLW  00
0E3C:  MOVWF  02
0E3E:  BRA    0E70
.................... 		case I2C_REG_CONFIG_SOFTWARE_VERSION: 
.................... 			return (int16) '0';
0E40:  MOVLW  30
0E42:  MOVWF  01
0E44:  MOVLW  00
0E46:  MOVWF  02
0E48:  BRA    0E70
.................... 		case I2C_REG_CONFIG_SOFTWARE_YEAR:
.................... 			return (int16) current.compile_year;
0E4A:  MOVFF  CB,01
0E4E:  CLRF   02
0E50:  BRA    0E70
.................... 		case I2C_REG_CONFIG_SOFTWARE_MONTH:
.................... 			return (int16) current.compile_month;
0E52:  MOVFF  CC,01
0E56:  CLRF   02
0E58:  BRA    0E70
.................... 		case I2C_REG_CONFIG_SOFTWARE_DAY:
.................... 			return (int16) current.compile_day;
0E5A:  MOVFF  CD,01
0E5E:  CLRF   02
0E60:  BRA    0E70
.................... 
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			/* 1 if factory unlocked */ 
.................... 			return (int16) current.factory_unlocked; 	
0E62:  MOVFF  CA,01
0E66:  CLRF   02
0E68:  BRA    0E70
.................... 
.................... 		/* we should have range checked, and never gotten here ... or read unimplemented (future) register */
.................... 		default: return (int16) 0xffff;
0E6A:  MOVLW  FF
0E6C:  MOVWF  01
0E6E:  MOVWF  02
.................... 	}
0E70:  GOTO   0F2E (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... 
.................... 
.................... #include "interrupt_dcswc_module_latching_contactor.c"
.................... #int_timer2
.................... void isr_timer2() {
.................... 	timers.now_millisecond=1;
*
00D4:  BSF    xCF.2
.................... }
.................... 
.................... 
.................... 
.................... /* I2C slave interrupt */
00D6:  BCF    F9E.1
00D8:  GOTO   006C
.................... #byte SSPSTAT=GETENV("SFR:SSPSTAT")
.................... #INT_SSP
.................... void ssp_interrupt () {
.................... 	static int8 sstate;
.................... 	int8 state;
.................... 	int8 incoming;
.................... 	static int16 lastValue;
.................... 	static int8 lastMSB;
.................... 
.................... 	static int8 address; 
.................... 
.................... 	/* 
.................... 	our implementation of i2c_isr_state() that won't overflow and switch states
.................... 	but it will quit counting at 127 bytes. 
.................... 	If more bytes are needed, external counting variables can be used or the size of state can be made larger
.................... 	*/
.................... 
.................... 
.................... 	if ( ! bit_test(SSPSTAT,5) ) {
*
0E8A:  BTFSC  FC7.5
0E8C:  BRA    0E9A
.................... 		/* address */
.................... 		sstate=0;
0E8E:  MOVLB  1
0E90:  CLRF   x0C
.................... 
.................... 		if ( bit_test(SSPSTAT,2) ) {
0E92:  BTFSS  FC7.2
0E94:  BRA    0E98
.................... 			/* set high bit if read */
.................... 			bit_set(sstate,7);
0E96:  BSF    x0C.7
.................... 		}
.................... 	} else {
0E98:  MOVLB  0
.................... 		/* data */
.................... 	}
.................... 
.................... 	/* state variable used below is not incremented */
.................... 	state=sstate;
0E9A:  MOVFF  10C,12A
.................... 
.................... 	/* increment the state counter for next pass through unless it will overflow us into another state */
.................... 	if ( sstate != 0x7f && sstate != 0xff) {
0E9E:  MOVLB  1
0EA0:  MOVF   x0C,W
0EA2:  SUBLW  7F
0EA4:  BZ    0EAE
0EA6:  INCFSZ x0C,W
0EA8:  BRA    0EAC
0EAA:  BRA    0EAE
.................... 		sstate++;
0EAC:  INCF   x0C,F
.................... 	}
.................... 
.................... 	
.................... 	/* i2c_isr_state() return an 8 bit int
.................... 		0 - Address match received with R/W bit clear, perform i2c_read( ) to read the I2C address.
.................... 		1-0x7F - Master has written data; i2c_read() will immediately return the data
.................... 		0x80 - Address match received with R/W bit set; perform i2c_read( ) to read the I2C address,
.................... 		and use i2c_write( ) to pre-load the transmit buffer for the next transaction (next I2C read
.................... 		performed by master will read this byte).
.................... 		0x81-0xFF - Transmission completed and acknowledged; respond with i2c_write() to pre-load
.................... 		the transmit buffer for the next transition (the next I2C read performed by master will read this
.................... 		byte).
.................... 		Function:
.................... 		Returns the state of I2C communications in I2C slave mode after an SSP interrupt. The return
.................... 		value increments with each byte received or sent.
.................... 		If 0x00 or 0x80 is returned, an i2C_read( ) needs to be performed to read the I2C address that
.................... 		was sent (it will match the address configured by #USE I2C so this value can be ignored)
.................... 	*/
.................... 
.................... 	if ( state <= 0x80 ) {                      
0EAE:  MOVF   x2A,W
0EB0:  SUBLW  80
0EB2:  BNC   0F16
.................... 		/* I2C master is sending us data */
.................... 		if ( 0x80 == state ) {
0EB4:  MOVF   x2A,W
0EB6:  SUBLW  80
0EB8:  BNZ   0EC0
.................... 			/* i2c_read(2) casues the function to read the SSPBUF without releasing the clock */
.................... 			incoming = i2c_read(STREAM_SLAVE,2);
0EBA:  MOVFF  FC9,12B
.................... 		} else {
0EBE:  BRA    0ECC
.................... 			incoming = i2c_read(STREAM_SLAVE);
0EC0:  BCF    FC6.6
0EC2:  BTFSS  FC7.0
0EC4:  BRA    0EC2
0EC6:  MOVF   FC9,W
0EC8:  BSF    FC6.4
0ECA:  MOVWF  x2B
.................... 		}
.................... 
.................... 		if ( 1 == state ) {             
0ECC:  DECFSZ x2A,W
0ECE:  BRA    0ED8
.................... 			address = incoming<<1;
0ED0:  BCF    FD8.0
0ED2:  RLCF   x2B,W
0ED4:  MOVWF  x10
.................... 		} else if ( state >= 2 && 0x80 != state ) {
0ED6:  BRA    0F16
0ED8:  MOVF   x2A,W
0EDA:  SUBLW  01
0EDC:  BC    0F16
0EDE:  MOVF   x2A,W
0EE0:  SUBLW  80
0EE2:  BZ    0F16
.................... 			/* received byte is data */
.................... 		
.................... 			/* save MSB and we'll process it on next */
.................... 			if ( 2 == state ) {
0EE4:  MOVF   x2A,W
0EE6:  SUBLW  02
0EE8:  BNZ   0EF0
.................... 				lastMSB=incoming;
0EEA:  MOVFF  12B,10F
.................... 			} else if ( 3 == state ) {
0EEE:  BRA    0F16
0EF0:  MOVF   x2A,W
0EF2:  SUBLW  03
0EF4:  BNZ   0F16
.................... 				/* 16 bit value made of previous byte and this byte */
.................... 				write_i2c(address>>1,make16(lastMSB,incoming));
0EF6:  BCF    FD8.0
0EF8:  RRCF   x10,W
0EFA:  MOVWF  x2C
0EFC:  MOVFF  10F,12E
0F00:  MOVFF  12B,12D
0F04:  MOVWF  x2F
0F06:  MOVFF  10F,131
0F0A:  MOVFF  12B,130
0F0E:  MOVLB  0
0F10:  GOTO   00DC
0F14:  MOVLB  1
.................... 
.................... 				/* this write only works for a single register per I2C transaction */
.................... 				/* this is not a BUG, but it would need to be implemented if this functionality is needed */
.................... 			}
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	if ( state >= 0x80 ) {
0F16:  MOVF   x2A,W
0F18:  SUBLW  7F
0F1A:  BC    0F54
.................... 		/* I2C master is requesting data from us */
.................... 
.................... 		if ( ! bit_test(address,0) ) {
0F1C:  BTFSC  x10.0
0F1E:  BRA    0F44
.................... 			/* read 16 bit register (register address half of I2C address) on even address */
.................... 			lastValue=map_i2c(address>>1);
0F20:  BCF    FD8.0
0F22:  RRCF   x10,W
0F24:  MOVWF  x2C
0F26:  MOVWF  x2D
0F28:  MOVLB  0
0F2A:  GOTO   0614
0F2E:  MOVFF  02,10E
0F32:  MOVFF  01,10D
.................... 
.................... 			/* send the MSB */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,1));
0F36:  MOVFF  10E,12C
0F3A:  MOVFF  10E,12D
0F3E:  RCALL  0E74
.................... 		} else {
0F40:  BRA    0F50
0F42:  MOVLB  1
.................... 			/* send LSB of 16 bit register on odd address */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,0));
0F44:  MOVFF  10D,12C
0F48:  MOVFF  10D,12D
0F4C:  MOVLB  0
0F4E:  RCALL  0E74
.................... 		}
.................... 		address++;
0F50:  MOVLB  1
0F52:  INCF   x10,F
.................... 	}
.................... }
.................... 
.................... 
.................... 
.................... 
0F54:  BCF    F9E.3
0F56:  MOVLB  0
0F58:  GOTO   006C
.................... #include "debug_dcswc_module_latching_contactor.c"
.................... void debug_dump(void) {
.................... 
.................... //	int8 i;
.................... 
.................... 	
.................... 	restart_wdt();
*
2C80:  CLRWDT
2C82:  CLRF   19
2C84:  BTFSC  FF2.7
2C86:  BSF    19.7
2C88:  BCF    FF2.7
.................... #if 0
.................... 	fprintf(STREAM_FTDI,"# '%s'\r\n",__DATE__);
.................... 	fprintf(STREAM_FTDI,"#  compile_year=%u\r\n",current.compile_year);
.................... 	fprintf(STREAM_FTDI,"# compile_month=%u\r\n",current.compile_month);
.................... 	fprintf(STREAM_FTDI,"#   compile_day=%u\r\n",current.compile_day);
.................... #endif
.................... 	fprintf(STREAM_FTDI,"#       vin adc=%lu\r\n",adc_get(0));
2C8A:  MOVLB  1
2C8C:  CLRF   x2F
2C8E:  MOVLB  0
2C90:  CALL   0594
2C94:  BTFSC  19.7
2C96:  BSF    FF2.7
2C98:  MOVFF  02,11C
2C9C:  MOVFF  01,11B
2CA0:  MOVLW  5C
2CA2:  MOVWF  FF6
2CA4:  MOVLW  0F
2CA6:  MOVWF  FF7
2CA8:  MOVLW  10
2CAA:  MOVLB  1
2CAC:  MOVWF  x1D
2CAE:  MOVLB  0
2CB0:  CALL   188C
2CB4:  MOVLW  10
2CB6:  MOVWF  FE9
2CB8:  MOVFF  11C,11E
2CBC:  MOVFF  11B,11D
2CC0:  RCALL  2B88
2CC2:  MOVLW  0D
2CC4:  BTFSS  F9E.4
2CC6:  BRA    2CC4
2CC8:  MOVWF  FAD
2CCA:  MOVLW  0A
2CCC:  BTFSS  F9E.4
2CCE:  BRA    2CCC
2CD0:  MOVWF  FAD
2CD2:  CLRF   19
2CD4:  BTFSC  FF2.7
2CD6:  BSF    19.7
2CD8:  BCF    FF2.7
.................... 	fprintf(STREAM_FTDI,"#      temp adc=%lu\r\n",adc_get(1));
2CDA:  MOVLW  01
2CDC:  MOVLB  1
2CDE:  MOVWF  x2F
2CE0:  MOVLB  0
2CE2:  CALL   0594
2CE6:  BTFSC  19.7
2CE8:  BSF    FF2.7
2CEA:  MOVFF  02,11C
2CEE:  MOVFF  01,11B
2CF2:  MOVLW  72
2CF4:  MOVWF  FF6
2CF6:  MOVLW  0F
2CF8:  MOVWF  FF7
2CFA:  MOVLW  10
2CFC:  MOVLB  1
2CFE:  MOVWF  x1D
2D00:  MOVLB  0
2D02:  CALL   188C
2D06:  MOVLW  10
2D08:  MOVWF  FE9
2D0A:  MOVFF  11C,11E
2D0E:  MOVFF  11B,11D
2D12:  RCALL  2B88
2D14:  MOVLW  0D
2D16:  BTFSS  F9E.4
2D18:  BRA    2D16
2D1A:  MOVWF  FAD
2D1C:  MOVLW  0A
2D1E:  BTFSS  F9E.4
2D20:  BRA    2D1E
2D22:  MOVWF  FAD
.................... 	fprintf(STREAM_FTDI,"#   ch[0].state=0x%2X\r\n",channel[0].state);
2D24:  MOVLW  88
2D26:  MOVWF  FF6
2D28:  MOVLW  0F
2D2A:  MOVWF  FF7
2D2C:  MOVLW  12
2D2E:  MOVLB  1
2D30:  MOVWF  x1D
2D32:  MOVLB  0
2D34:  CALL   188C
2D38:  MOVFF  DA,11B
2D3C:  MOVLW  37
2D3E:  MOVLB  1
2D40:  MOVWF  x1C
2D42:  MOVLB  0
2D44:  RCALL  2C3A
2D46:  MOVLW  0D
2D48:  BTFSS  F9E.4
2D4A:  BRA    2D48
2D4C:  MOVWF  FAD
2D4E:  MOVLW  0A
2D50:  BTFSS  F9E.4
2D52:  BRA    2D50
2D54:  MOVWF  FAD
.................... 	fprintf(STREAM_FTDI,"#   ch[1].state=0x%2X\r\n",channel[1].state);
2D56:  MOVLW  A0
2D58:  MOVWF  FF6
2D5A:  MOVLW  0F
2D5C:  MOVWF  FF7
2D5E:  MOVLW  12
2D60:  MOVLB  1
2D62:  MOVWF  x1D
2D64:  MOVLB  0
2D66:  CALL   188C
2D6A:  MOVFF  F3,11B
2D6E:  MOVLW  37
2D70:  MOVLB  1
2D72:  MOVWF  x1C
2D74:  MOVLB  0
2D76:  RCALL  2C3A
2D78:  MOVLW  0D
2D7A:  BTFSS  F9E.4
2D7C:  BRA    2D7A
2D7E:  MOVWF  FAD
2D80:  MOVLW  0A
2D82:  BTFSS  F9E.4
2D84:  BRA    2D82
2D86:  MOVWF  FAD
.................... //	fprintf(STREAM_FTDI,"# read_dip_sw()=%u\r\n",read_dip_switch());
.................... //	fprintf(STREAM_FTDI,"#    dip sw adc=%lu\r\n",adc_get(2));
.................... 
.................... #if 0
2D88:  GOTO   2F7A (RETURN)
.................... 	for ( i=0 ; i<2 ; i++ ) {
.................... 		restart_wdt();
.................... 		fprintf(STREAM_FTDI,"#-------\r\n");
.................... 		fprintf(STREAM_FTDI,"# config.ch[%u]\r\n",i);
.................... 		fprintf(STREAM_FTDI,"# command_off_hold_time=%lu\r\n",config.ch[i].command_off_hold_time);
.................... 
.................... 		fprintf(STREAM_FTDI,"#    lvd_disconnect_adc=%lu\r\n",config.ch[i].lvd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  lvd_disconnect_delay=%lu\r\n",config.ch[i].lvd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     lvd_reconnect_adc=%lu\r\n",config.ch[i].lvd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   lvd_reconnect_delay=%lu\r\n",config.ch[i].lvd_reconnect_delay);
.................... 
.................... 		fprintf(STREAM_FTDI,"#    hvd_disconnect_adc=%lu\r\n",config.ch[i].hvd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  hvd_disconnect_delay=%lu\r\n",config.ch[i].hvd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     hvd_reconnect_adc=%lu\r\n",config.ch[i].hvd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   hvd_reconnect_delay=%lu\r\n",config.ch[i].hvd_reconnect_delay);
.................... 
.................... 		restart_wdt();
.................... 		fprintf(STREAM_FTDI,"#    ltd_disconnect_adc=%lu\r\n",config.ch[i].ltd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  ltd_disconnect_delay=%lu\r\n",config.ch[i].ltd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     ltd_reconnect_adc=%lu\r\n",config.ch[i].ltd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   ltd_reconnect_delay=%lu\r\n",config.ch[i].ltd_reconnect_delay);
.................... 
.................... 		fprintf(STREAM_FTDI,"#    htd_disconnect_adc=%lu\r\n",config.ch[i].htd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  htd_disconnect_delay=%lu\r\n",config.ch[i].htd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     htd_reconnect_adc=%lu\r\n",config.ch[i].htd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   htd_reconnect_delay=%lu\r\n",config.ch[i].htd_reconnect_delay);
.................... 
.................... 
.................... 		restart_wdt();
.................... 		fprintf(STREAM_FTDI,"#\r\n");
.................... 		fprintf(STREAM_FTDI,"# channel[%u]\r\n",i);
.................... 		fprintf(STREAM_FTDI,"#                        state=0x%02x\r\n",channel[i].state);
.................... 		fprintf(STREAM_FTDI,"#           command_on_seconds=%lu\r\n",channel[i].command_on_seconds);
.................... 		fprintf(STREAM_FTDI,"#      command_on_hold_seconds=%lu\r\n",channel[i].command_on_hold_seconds);
.................... 
.................... 		fprintf(STREAM_FTDI,"#          command_off_seconds=%lu\r\n",channel[i].command_off_seconds);
.................... 		fprintf(STREAM_FTDI,"#     command_off_hold_seconds=%lu\r\n",channel[i].command_off_hold_seconds);
.................... 
.................... 		fprintf(STREAM_FTDI,"# lvd_disconnect_delay_seconds=%lu\r\n",channel[i].lvd_disconnect_delay_seconds);
.................... 		fprintf(STREAM_FTDI,"#  lvd_reconnect_delay_seconds=%lu\r\n",channel[i].lvd_reconnect_delay_seconds);
.................... 
.................... 		fprintf(STREAM_FTDI,"# hvd_disconnect_delay_seconds=%lu\r\n",channel[i].hvd_disconnect_delay_seconds);
.................... 		fprintf(STREAM_FTDI,"#  hvd_reconnect_delay_seconds=%lu\r\n",channel[i].hvd_reconnect_delay_seconds);
.................... 
.................... 		restart_wdt();
.................... 		fprintf(STREAM_FTDI,"# ltd_disconnect_delay_seconds=%lu\r\n",channel[i].ltd_disconnect_delay_seconds);
.................... 		fprintf(STREAM_FTDI,"#  ltd_reconnect_delay_seconds=%lu\r\n",channel[i].ltd_reconnect_delay_seconds);
.................... 
.................... 		fprintf(STREAM_FTDI,"# htd_disconnect_delay_seconds=%lu\r\n",channel[i].htd_disconnect_delay_seconds);
.................... 		fprintf(STREAM_FTDI,"#  htd_reconnect_delay_seconds=%lu\r\n",channel[i].htd_reconnect_delay_seconds);
.................... 	}
.................... 	#endif
.................... }
.................... 
.................... 
.................... 
.................... void contactor_on(int8 c) {
.................... 	/* only turn on contactor if it isn't on or needs a refresh */
.................... 	if ( 1 == timers.contactor[c] ) {
*
27E6:  CLRF   03
27E8:  MOVLB  1
27EA:  MOVF   x1E,W
27EC:  ADDLW  D6
27EE:  MOVWF  FE9
27F0:  MOVLW  00
27F2:  ADDWFC 03,W
27F4:  MOVWF  FEA
27F6:  MOVF   FEF,W
27F8:  SUBLW  01
27FA:  BNZ   27FE
.................... 		return;
27FC:  BRA    2838
.................... 	}
.................... 
.................... 	/* we start the powersave count down */
.................... 	timers.contactor_powersave[c]=CONTACTOR_POWER_SAVE_MS;
27FE:  CLRF   03
2800:  MOVF   x1E,W
2802:  ADDLW  D8
2804:  MOVWF  FE9
2806:  MOVLW  00
2808:  ADDWFC 03,W
280A:  MOVWF  FEA
280C:  MOVLW  C8
280E:  MOVWF  FEF
.................... 
.................... 	/* control the actual coil depending on what channel we are on */
.................... 	if ( 0==c ) {
2810:  MOVF   x1E,F
2812:  BNZ   281E
.................... 		/* contactor A pins */
.................... 		output_low(BRIDGE_A_A);
2814:  BCF    F94.3
2816:  BCF    F8B.3
.................... 		output_high(BRIDGE_A_B);
2818:  BCF    F94.4
281A:  BSF    F8B.4
.................... 	} else {
281C:  BRA    2826
.................... 		/* contactor B pins */
.................... 		output_low(BRIDGE_B_A);
281E:  BCF    F94.5
2820:  BCF    F8B.5
.................... 		output_high(BRIDGE_B_B);
2822:  BCF    F94.6
2824:  BSF    F8B.6
.................... 	}
.................... 
.................... 	/* save state for next time */
.................... 	timers.contactor[c]=1;
2826:  CLRF   03
2828:  MOVF   x1E,W
282A:  ADDLW  D6
282C:  MOVWF  FE9
282E:  MOVLW  00
2830:  ADDWFC 03,W
2832:  MOVWF  FEA
2834:  MOVLW  01
2836:  MOVWF  FEF
2838:  MOVLB  0
283A:  GOTO   28A0 (RETURN)
.................... }
.................... 
.................... void contactor_off(int8 c) {
.................... 	/* only turn off contactor if it isn't on or needs a refresh */
.................... 	if ( 0 == timers.contactor[c] ) {
*
13C2:  CLRF   03
13C4:  MOVLB  1
13C6:  MOVF   x1E,W
13C8:  ADDLW  D6
13CA:  MOVWF  FE9
13CC:  MOVLW  00
13CE:  ADDWFC 03,W
13D0:  MOVWF  FEA
13D2:  MOVF   FEF,W
13D4:  BNZ   13D8
.................... 		return;
13D6:  BRA    1410
.................... 	}
.................... 
.................... 	/* we start the powersave count down */
.................... 	timers.contactor_powersave[c]=CONTACTOR_POWER_SAVE_MS;
13D8:  CLRF   03
13DA:  MOVF   x1E,W
13DC:  ADDLW  D8
13DE:  MOVWF  FE9
13E0:  MOVLW  00
13E2:  ADDWFC 03,W
13E4:  MOVWF  FEA
13E6:  MOVLW  C8
13E8:  MOVWF  FEF
.................... 
.................... 	/* control the actual coil depending on what channel we are on */
.................... 	if ( 0==c ) {
13EA:  MOVF   x1E,F
13EC:  BNZ   13F8
.................... 		output_high(BRIDGE_A_A);
13EE:  BCF    F94.3
13F0:  BSF    F8B.3
.................... 		output_low(BRIDGE_A_B);
13F2:  BCF    F94.4
13F4:  BCF    F8B.4
.................... 	} else {
13F6:  BRA    1400
.................... 		output_high(BRIDGE_B_A);
13F8:  BCF    F94.5
13FA:  BSF    F8B.5
.................... 		output_low(BRIDGE_B_B);
13FC:  BCF    F94.6
13FE:  BCF    F8B.6
.................... 	}
.................... 
.................... 	/* save state for next time */
.................... 	timers.contactor[c]=0;
1400:  CLRF   03
1402:  MOVF   x1E,W
1404:  ADDLW  D6
1406:  MOVWF  FE9
1408:  MOVLW  00
140A:  ADDWFC 03,W
140C:  MOVWF  FEA
140E:  CLRF   FEF
1410:  MOVLB  0
1412:  RETURN 0
.................... }
.................... 
.................... void contactor_set(int8 c) {
*
283E:  MOVLW  01
2840:  MOVLB  1
2842:  MOVWF  x1D
.................... 	int8 state=1;
.................... 
.................... 	/* if nothing is set in channel[c].state, contactor is on */
.................... 	state=1; 
2844:  MOVWF  x1D
.................... 
.................... 	if ( channel[c].state & CH_STATE_MASK_ON ) {
2846:  MOVF   x1C,W
2848:  MULLW  19
284A:  MOVF   FF3,W
284C:  CLRF   x1F
284E:  MOVWF  x1E
2850:  MOVLW  DA
2852:  ADDWF  x1E,W
2854:  MOVWF  FE9
2856:  MOVLW  00
2858:  ADDWFC x1F,W
285A:  MOVWF  FEA
285C:  MOVF   FEF,W
285E:  ANDLW  03
2860:  BZ    2868
.................... 		/* if override button (switch) is set or we are commanded on, then we will be on */
.................... 		state=1;
2862:  MOVLW  01
2864:  MOVWF  x1D
.................... 	} else if ( channel[c].state & CH_STATE_MASK_OFF ) {
2866:  BRA    2886
2868:  MOVF   x1C,W
286A:  MULLW  19
286C:  MOVF   FF3,W
286E:  CLRF   x1F
2870:  MOVWF  x1E
2872:  MOVLW  DA
2874:  ADDWF  x1E,W
2876:  MOVWF  FE9
2878:  MOVLW  00
287A:  ADDWFC x1F,W
287C:  MOVWF  FEA
287E:  MOVF   FEF,W
2880:  ANDLW  7C
2882:  BZ    2886
.................... 		/* if one of the disconnect bits is set, we will be off */
.................... 		state=0;
2884:  CLRF   x1D
.................... 	}
.................... 
.................... 	if ( 0==state ) {
2886:  MOVF   x1D,F
2888:  BNZ   2898
.................... 		contactor_off(c);
288A:  MOVFF  11C,11E
288E:  MOVLB  0
2890:  CALL   13C2
.................... 	} else {
2894:  BRA    28A0
2896:  MOVLB  1
.................... 		contactor_on(c);
2898:  MOVFF  11C,11E
289C:  MOVLB  0
289E:  BRA    27E6
.................... 	}
28A0:  RETURN 0
.................... 
.................... }
.................... 
.................... void contactor_logic(int8 c) {
.................... 	int16 adc;
.................... 
.................... 	/* override button / switch */
.................... 	if ( (0==c && 0==input(SW_OVERRIDE_A)) || (1==c && 0==input(SW_OVERRIDE_B)) ) {
*
19A2:  MOVLB  1
19A4:  MOVF   x1C,F
19A6:  BNZ   19AE
19A8:  BSF    F92.5
19AA:  BTFSS  F80.5
19AC:  BRA    19B8
19AE:  DECFSZ x1C,W
19B0:  BRA    19D6
19B2:  BSF    F92.4
19B4:  BTFSC  F80.4
19B6:  BRA    19D6
.................... 		bit_set(channel[c].state,CH_STATE_BIT_OVERRIDE);
19B8:  MOVF   x1C,W
19BA:  MULLW  19
19BC:  MOVF   FF3,W
19BE:  CLRF   x20
19C0:  MOVWF  x1F
19C2:  MOVLW  DA
19C4:  ADDWF  x1F,W
19C6:  MOVWF  01
19C8:  MOVLW  00
19CA:  ADDWFC x20,W
19CC:  MOVFF  01,FE9
19D0:  MOVWF  FEA
19D2:  BSF    FEF.0
.................... 	} else {
19D4:  BRA    19F2
.................... 		bit_clear(channel[c].state,CH_STATE_BIT_OVERRIDE);
19D6:  MOVF   x1C,W
19D8:  MULLW  19
19DA:  MOVF   FF3,W
19DC:  CLRF   x20
19DE:  MOVWF  x1F
19E0:  MOVLW  DA
19E2:  ADDWF  x1F,W
19E4:  MOVWF  01
19E6:  MOVLW  00
19E8:  ADDWFC x20,W
19EA:  MOVFF  01,FE9
19EE:  MOVWF  FEA
19F0:  BCF    FEF.0
.................... 	}
.................... 
.................... 	/* command on. 65535 disables */
.................... 	if ( 65535 != channel[c].command_on_seconds ) {
19F2:  MOVF   x1C,W
19F4:  MULLW  19
19F6:  MOVF   FF3,W
19F8:  CLRF   x20
19FA:  MOVWF  x1F
19FC:  MOVLW  01
19FE:  ADDWF  x1F,W
1A00:  MOVWF  01
1A02:  MOVLW  00
1A04:  ADDWFC x20,W
1A06:  MOVWF  03
1A08:  MOVF   01,W
1A0A:  ADDLW  DA
1A0C:  MOVWF  FE9
1A0E:  MOVLW  00
1A10:  ADDWFC 03,W
1A12:  MOVWF  FEA
1A14:  MOVFF  FEC,03
1A18:  MOVF   FED,F
1A1A:  MOVF   FEF,W
1A1C:  SUBLW  FF
1A1E:  BNZ   1A26
1A20:  INCFSZ 03,W
1A22:  BRA    1A26
1A24:  BRA    1BBC
.................... 		if ( channel[c].command_on_seconds > 0 ) {
1A26:  MOVF   x1C,W
1A28:  MULLW  19
1A2A:  MOVF   FF3,W
1A2C:  CLRF   x20
1A2E:  MOVWF  x1F
1A30:  MOVLW  01
1A32:  ADDWF  x1F,W
1A34:  MOVWF  01
1A36:  MOVLW  00
1A38:  ADDWFC x20,W
1A3A:  MOVWF  03
1A3C:  MOVF   01,W
1A3E:  ADDLW  DA
1A40:  MOVWF  FE9
1A42:  MOVLW  00
1A44:  ADDWFC 03,W
1A46:  MOVWF  FEA
1A48:  MOVFF  FEC,120
1A4C:  MOVF   FED,F
1A4E:  MOVFF  FEF,11F
1A52:  MOVF   x1F,F
1A54:  BNZ   1A5A
1A56:  MOVF   x20,F
1A58:  BZ    1A88
.................... 			/* waiting to power on */
.................... 			channel[c].command_on_seconds--;
1A5A:  MOVF   x1C,W
1A5C:  MULLW  19
1A5E:  MOVF   FF3,W
1A60:  CLRF   x20
1A62:  MOVWF  x1F
1A64:  MOVLW  01
1A66:  ADDWF  x1F,W
1A68:  MOVWF  01
1A6A:  MOVLW  00
1A6C:  ADDWFC x20,W
1A6E:  MOVWF  03
1A70:  MOVF   01,W
1A72:  ADDLW  DA
1A74:  MOVWF  FE9
1A76:  MOVLW  00
1A78:  ADDWFC 03,W
1A7A:  MOVWF  FEA
1A7C:  MOVLW  FF
1A7E:  ADDWF  FEF,F
1A80:  BC    1A86
1A82:  MOVF   FEE,F
1A84:  DECF   FED,F
.................... 		} else {
1A86:  BRA    1BBC
.................... 			/* timer at zero, ready to power on or already powered on */
.................... 			if ( ! bit_test(channel[c].state,CH_STATE_BIT_CMD_ON) ) {
1A88:  MOVF   x1C,W
1A8A:  MULLW  19
1A8C:  MOVF   FF3,W
1A8E:  CLRF   x20
1A90:  MOVWF  x1F
1A92:  MOVLW  DA
1A94:  ADDWF  x1F,W
1A96:  MOVWF  FE9
1A98:  MOVLW  00
1A9A:  ADDWFC x20,W
1A9C:  MOVWF  FEA
1A9E:  MOVFF  FEF,121
1AA2:  BTFSC  x21.1
1AA4:  BRA    1B1A
.................... 				/* not currently set, so we set it and start the countdown */
.................... 				bit_set(channel[c].state,CH_STATE_BIT_CMD_ON);
1AA6:  MOVF   x1C,W
1AA8:  MULLW  19
1AAA:  MOVF   FF3,W
1AAC:  CLRF   x20
1AAE:  MOVWF  x1F
1AB0:  MOVLW  DA
1AB2:  ADDWF  x1F,W
1AB4:  MOVWF  01
1AB6:  MOVLW  00
1AB8:  ADDWFC x20,W
1ABA:  MOVFF  01,FE9
1ABE:  MOVWF  FEA
1AC0:  BSF    FEF.1
.................... 				channel[c].command_on_hold_seconds=config.ch[c].command_on_hold_time;
1AC2:  MOVF   x1C,W
1AC4:  MULLW  19
1AC6:  MOVF   FF3,W
1AC8:  CLRF   x20
1ACA:  MOVWF  x1F
1ACC:  MOVLW  03
1ACE:  ADDWF  x1F,W
1AD0:  MOVWF  01
1AD2:  MOVLW  00
1AD4:  ADDWFC x20,W
1AD6:  MOVWF  03
1AD8:  MOVF   01,W
1ADA:  ADDLW  DA
1ADC:  MOVWF  01
1ADE:  MOVLW  00
1AE0:  ADDWFC 03,F
1AE2:  MOVFF  03,120
1AE6:  MOVF   x1C,W
1AE8:  MULLW  24
1AEA:  MOVF   FF3,W
1AEC:  CLRF   x22
1AEE:  MOVWF  x21
1AF0:  MOVLW  1B
1AF2:  ADDWF  x21,W
1AF4:  MOVWF  FE9
1AF6:  MOVLW  00
1AF8:  ADDWFC x22,W
1AFA:  MOVWF  FEA
1AFC:  MOVFF  FEC,03
1B00:  MOVF   FED,F
1B02:  MOVFF  FEF,123
1B06:  MOVFF  120,FEA
1B0A:  MOVFF  01,FE9
1B0E:  MOVFF  03,FEC
1B12:  MOVF   FED,F
1B14:  MOVFF  123,FEF
.................... 			} else {
1B18:  BRA    1BBC
.................... 				/* set, so we clear it once countdown has elapsed */
.................... 				if ( 0==channel[c].command_on_hold_seconds ) {
1B1A:  MOVF   x1C,W
1B1C:  MULLW  19
1B1E:  MOVF   FF3,W
1B20:  CLRF   x20
1B22:  MOVWF  x1F
1B24:  MOVLW  03
1B26:  ADDWF  x1F,W
1B28:  MOVWF  01
1B2A:  MOVLW  00
1B2C:  ADDWFC x20,W
1B2E:  MOVWF  03
1B30:  MOVF   01,W
1B32:  ADDLW  DA
1B34:  MOVWF  FE9
1B36:  MOVLW  00
1B38:  ADDWFC 03,W
1B3A:  MOVWF  FEA
1B3C:  MOVFF  FEC,03
1B40:  MOVF   FED,F
1B42:  MOVF   FEF,W
1B44:  BNZ   1B90
1B46:  MOVF   03,F
1B48:  BNZ   1B90
.................... 					/* countdown elapsed, clear the flag and reset the timer */
.................... 					bit_clear(channel[c].state,CH_STATE_BIT_CMD_ON);
1B4A:  MOVF   x1C,W
1B4C:  MULLW  19
1B4E:  MOVF   FF3,W
1B50:  CLRF   x20
1B52:  MOVWF  x1F
1B54:  MOVLW  DA
1B56:  ADDWF  x1F,W
1B58:  MOVWF  01
1B5A:  MOVLW  00
1B5C:  ADDWFC x20,W
1B5E:  MOVFF  01,FE9
1B62:  MOVWF  FEA
1B64:  BCF    FEF.1
.................... 					channel[c].command_on_seconds=65535;
1B66:  MOVF   x1C,W
1B68:  MULLW  19
1B6A:  MOVF   FF3,W
1B6C:  CLRF   x20
1B6E:  MOVWF  x1F
1B70:  MOVLW  01
1B72:  ADDWF  x1F,W
1B74:  MOVWF  01
1B76:  MOVLW  00
1B78:  ADDWFC x20,W
1B7A:  MOVWF  03
1B7C:  MOVF   01,W
1B7E:  ADDLW  DA
1B80:  MOVWF  FE9
1B82:  MOVLW  00
1B84:  ADDWFC 03,W
1B86:  MOVWF  FEA
1B88:  SETF   FEC
1B8A:  MOVF   FED,F
1B8C:  SETF   FEF
.................... 				} else {
1B8E:  BRA    1BBC
.................... 					channel[c].command_on_hold_seconds--;
1B90:  MOVF   x1C,W
1B92:  MULLW  19
1B94:  MOVF   FF3,W
1B96:  CLRF   x20
1B98:  MOVWF  x1F
1B9A:  MOVLW  03
1B9C:  ADDWF  x1F,W
1B9E:  MOVWF  01
1BA0:  MOVLW  00
1BA2:  ADDWFC x20,W
1BA4:  MOVWF  03
1BA6:  MOVF   01,W
1BA8:  ADDLW  DA
1BAA:  MOVWF  FE9
1BAC:  MOVLW  00
1BAE:  ADDWFC 03,W
1BB0:  MOVWF  FEA
1BB2:  MOVLW  FF
1BB4:  ADDWF  FEF,F
1BB6:  BC    1BBC
1BB8:  MOVF   FEE,F
1BBA:  DECF   FED,F
.................... 				}
.................... 			}		
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	/* command off. 65535 disables */
.................... 	if ( 65535 != channel[c].command_off_seconds ) {
1BBC:  MOVF   x1C,W
1BBE:  MULLW  19
1BC0:  MOVF   FF3,W
1BC2:  CLRF   x20
1BC4:  MOVWF  x1F
1BC6:  MOVLW  05
1BC8:  ADDWF  x1F,W
1BCA:  MOVWF  01
1BCC:  MOVLW  00
1BCE:  ADDWFC x20,W
1BD0:  MOVWF  03
1BD2:  MOVF   01,W
1BD4:  ADDLW  DA
1BD6:  MOVWF  FE9
1BD8:  MOVLW  00
1BDA:  ADDWFC 03,W
1BDC:  MOVWF  FEA
1BDE:  MOVFF  FEC,03
1BE2:  MOVF   FED,F
1BE4:  MOVF   FEF,W
1BE6:  SUBLW  FF
1BE8:  BNZ   1BF0
1BEA:  INCFSZ 03,W
1BEC:  BRA    1BF0
1BEE:  BRA    1D96
.................... 		if ( channel[c].command_off_seconds > 0 ) {
1BF0:  MOVF   x1C,W
1BF2:  MULLW  19
1BF4:  MOVF   FF3,W
1BF6:  CLRF   x20
1BF8:  MOVWF  x1F
1BFA:  MOVLW  05
1BFC:  ADDWF  x1F,W
1BFE:  MOVWF  01
1C00:  MOVLW  00
1C02:  ADDWFC x20,W
1C04:  MOVWF  03
1C06:  MOVF   01,W
1C08:  ADDLW  DA
1C0A:  MOVWF  FE9
1C0C:  MOVLW  00
1C0E:  ADDWFC 03,W
1C10:  MOVWF  FEA
1C12:  MOVFF  FEC,120
1C16:  MOVF   FED,F
1C18:  MOVFF  FEF,11F
1C1C:  MOVF   x1F,F
1C1E:  BNZ   1C24
1C20:  MOVF   x20,F
1C22:  BZ    1C52
.................... 			/* waiting to power off */
.................... 			channel[c].command_off_seconds--;
1C24:  MOVF   x1C,W
1C26:  MULLW  19
1C28:  MOVF   FF3,W
1C2A:  CLRF   x20
1C2C:  MOVWF  x1F
1C2E:  MOVLW  05
1C30:  ADDWF  x1F,W
1C32:  MOVWF  01
1C34:  MOVLW  00
1C36:  ADDWFC x20,W
1C38:  MOVWF  03
1C3A:  MOVF   01,W
1C3C:  ADDLW  DA
1C3E:  MOVWF  FE9
1C40:  MOVLW  00
1C42:  ADDWFC 03,W
1C44:  MOVWF  FEA
1C46:  MOVLW  FF
1C48:  ADDWF  FEF,F
1C4A:  BC    1C50
1C4C:  MOVF   FEE,F
1C4E:  DECF   FED,F
.................... 		} else {
1C50:  BRA    1D96
.................... 			/* timer at zero, ready to power off or already powered off */
.................... 			if ( ! bit_test(channel[c].state,CH_STATE_BIT_CMD_OFF) ) {
1C52:  MOVF   x1C,W
1C54:  MULLW  19
1C56:  MOVF   FF3,W
1C58:  CLRF   x20
1C5A:  MOVWF  x1F
1C5C:  MOVLW  DA
1C5E:  ADDWF  x1F,W
1C60:  MOVWF  FE9
1C62:  MOVLW  00
1C64:  ADDWFC x20,W
1C66:  MOVWF  FEA
1C68:  MOVFF  FEF,121
1C6C:  BTFSC  x21.2
1C6E:  BRA    1CF4
.................... 				/* not currently set, so we set it and start the countdown */
.................... 				bit_set(channel[c].state,CH_STATE_BIT_CMD_OFF);
1C70:  MOVF   x1C,W
1C72:  MULLW  19
1C74:  MOVF   FF3,W
1C76:  CLRF   x20
1C78:  MOVWF  x1F
1C7A:  MOVLW  DA
1C7C:  ADDWF  x1F,W
1C7E:  MOVWF  01
1C80:  MOVLW  00
1C82:  ADDWFC x20,W
1C84:  MOVFF  01,FE9
1C88:  MOVWF  FEA
1C8A:  BSF    FEF.2
.................... 				channel[c].command_off_hold_seconds=config.ch[c].command_off_hold_time;
1C8C:  MOVF   x1C,W
1C8E:  MULLW  19
1C90:  MOVF   FF3,W
1C92:  CLRF   x20
1C94:  MOVWF  x1F
1C96:  MOVLW  07
1C98:  ADDWF  x1F,W
1C9A:  MOVWF  01
1C9C:  MOVLW  00
1C9E:  ADDWFC x20,W
1CA0:  MOVWF  03
1CA2:  MOVF   01,W
1CA4:  ADDLW  DA
1CA6:  MOVWF  01
1CA8:  MOVLW  00
1CAA:  ADDWFC 03,F
1CAC:  MOVFF  01,11F
1CB0:  MOVFF  03,120
1CB4:  MOVF   x1C,W
1CB6:  MULLW  24
1CB8:  MOVF   FF3,W
1CBA:  CLRF   x22
1CBC:  MOVWF  x21
1CBE:  MOVLW  02
1CC0:  ADDWF  x21,W
1CC2:  MOVWF  01
1CC4:  MOVLW  00
1CC6:  ADDWFC x22,W
1CC8:  MOVWF  03
1CCA:  MOVF   01,W
1CCC:  ADDLW  1B
1CCE:  MOVWF  FE9
1CD0:  MOVLW  00
1CD2:  ADDWFC 03,W
1CD4:  MOVWF  FEA
1CD6:  MOVFF  FEC,03
1CDA:  MOVF   FED,F
1CDC:  MOVFF  FEF,121
1CE0:  MOVFF  120,FEA
1CE4:  MOVFF  11F,FE9
1CE8:  MOVFF  03,FEC
1CEC:  MOVF   FED,F
1CEE:  MOVFF  121,FEF
.................... 			} else {
1CF2:  BRA    1D96
.................... 				/* set, so we clear it once countdown has elapsed */
.................... 				if ( 0==channel[c].command_off_hold_seconds ) {
1CF4:  MOVF   x1C,W
1CF6:  MULLW  19
1CF8:  MOVF   FF3,W
1CFA:  CLRF   x20
1CFC:  MOVWF  x1F
1CFE:  MOVLW  07
1D00:  ADDWF  x1F,W
1D02:  MOVWF  01
1D04:  MOVLW  00
1D06:  ADDWFC x20,W
1D08:  MOVWF  03
1D0A:  MOVF   01,W
1D0C:  ADDLW  DA
1D0E:  MOVWF  FE9
1D10:  MOVLW  00
1D12:  ADDWFC 03,W
1D14:  MOVWF  FEA
1D16:  MOVFF  FEC,03
1D1A:  MOVF   FED,F
1D1C:  MOVF   FEF,W
1D1E:  BNZ   1D6A
1D20:  MOVF   03,F
1D22:  BNZ   1D6A
.................... 					/* countdown elapsed, clear the flag and reset the timer */
.................... 					bit_clear(channel[c].state,CH_STATE_BIT_CMD_OFF);
1D24:  MOVF   x1C,W
1D26:  MULLW  19
1D28:  MOVF   FF3,W
1D2A:  CLRF   x20
1D2C:  MOVWF  x1F
1D2E:  MOVLW  DA
1D30:  ADDWF  x1F,W
1D32:  MOVWF  01
1D34:  MOVLW  00
1D36:  ADDWFC x20,W
1D38:  MOVFF  01,FE9
1D3C:  MOVWF  FEA
1D3E:  BCF    FEF.2
.................... 					channel[c].command_off_seconds=65535;
1D40:  MOVF   x1C,W
1D42:  MULLW  19
1D44:  MOVF   FF3,W
1D46:  CLRF   x20
1D48:  MOVWF  x1F
1D4A:  MOVLW  05
1D4C:  ADDWF  x1F,W
1D4E:  MOVWF  01
1D50:  MOVLW  00
1D52:  ADDWFC x20,W
1D54:  MOVWF  03
1D56:  MOVF   01,W
1D58:  ADDLW  DA
1D5A:  MOVWF  FE9
1D5C:  MOVLW  00
1D5E:  ADDWFC 03,W
1D60:  MOVWF  FEA
1D62:  SETF   FEC
1D64:  MOVF   FED,F
1D66:  SETF   FEF
.................... 				} else {
1D68:  BRA    1D96
.................... 					channel[c].command_off_hold_seconds--;
1D6A:  MOVF   x1C,W
1D6C:  MULLW  19
1D6E:  MOVF   FF3,W
1D70:  CLRF   x20
1D72:  MOVWF  x1F
1D74:  MOVLW  07
1D76:  ADDWF  x1F,W
1D78:  MOVWF  01
1D7A:  MOVLW  00
1D7C:  ADDWFC x20,W
1D7E:  MOVWF  03
1D80:  MOVF   01,W
1D82:  ADDLW  DA
1D84:  MOVWF  FE9
1D86:  MOVLW  00
1D88:  ADDWFC 03,W
1D8A:  MOVWF  FEA
1D8C:  MOVLW  FF
1D8E:  ADDWF  FEF,F
1D90:  BC    1D96
1D92:  MOVF   FEE,F
1D94:  DECF   FED,F
.................... 				}
.................... 			}		
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	/* Low Voltage Disconnect. 65535 disables */
.................... 	if ( 65535 != config.ch[c].lvd_disconnect_delay ) {
1D96:  MOVF   x1C,W
1D98:  MULLW  24
1D9A:  MOVF   FF3,W
1D9C:  CLRF   x20
1D9E:  MOVWF  x1F
1DA0:  MOVLW  06
1DA2:  ADDWF  x1F,W
1DA4:  MOVWF  01
1DA6:  MOVLW  00
1DA8:  ADDWFC x20,W
1DAA:  MOVWF  03
1DAC:  MOVF   01,W
1DAE:  ADDLW  1B
1DB0:  MOVWF  FE9
1DB2:  MOVLW  00
1DB4:  ADDWFC 03,W
1DB6:  MOVWF  FEA
1DB8:  MOVFF  FEC,03
1DBC:  MOVF   FED,F
1DBE:  MOVF   FEF,W
1DC0:  SUBLW  FF
1DC2:  BNZ   1DCA
1DC4:  INCFSZ 03,W
1DC6:  BRA    1DCA
1DC8:  BRA    2028
1DCA:  CLRF   19
1DCC:  BTFSC  FF2.7
1DCE:  BSF    19.7
1DD0:  BCF    FF2.7
.................... 		adc=adc_get(0);
1DD2:  CLRF   x2F
1DD4:  MOVLB  0
1DD6:  CALL   0594
1DDA:  BTFSC  19.7
1DDC:  BSF    FF2.7
1DDE:  MOVFF  02,11E
1DE2:  MOVFF  01,11D
.................... 
.................... 		if ( adc > config.ch[c].lvd_reconnect_adc ) {
1DE6:  MOVLB  1
1DE8:  MOVF   x1C,W
1DEA:  MULLW  24
1DEC:  MOVF   FF3,W
1DEE:  CLRF   x20
1DF0:  MOVWF  x1F
1DF2:  MOVLW  08
1DF4:  ADDWF  x1F,W
1DF6:  MOVWF  01
1DF8:  MOVLW  00
1DFA:  ADDWFC x20,W
1DFC:  MOVWF  03
1DFE:  MOVF   01,W
1E00:  ADDLW  1B
1E02:  MOVWF  FE9
1E04:  MOVLW  00
1E06:  ADDWFC 03,W
1E08:  MOVWF  FEA
1E0A:  MOVFF  FEC,03
1E0E:  MOVF   FED,F
1E10:  MOVFF  FEF,01
1E14:  MOVF   03,W
1E16:  SUBWF  x1E,W
1E18:  BNC   1EA2
1E1A:  BNZ   1E22
1E1C:  MOVF   x1D,W
1E1E:  SUBWF  01,W
1E20:  BC    1EA2
.................... 			if ( channel[c].lvd_reconnect_delay_seconds > 0 ) {
1E22:  MOVF   x1C,W
1E24:  MULLW  19
1E26:  MOVF   FF3,W
1E28:  CLRF   x20
1E2A:  MOVWF  x1F
1E2C:  MOVLW  0B
1E2E:  ADDWF  x1F,W
1E30:  MOVWF  01
1E32:  MOVLW  00
1E34:  ADDWFC x20,W
1E36:  MOVWF  03
1E38:  MOVF   01,W
1E3A:  ADDLW  DA
1E3C:  MOVWF  FE9
1E3E:  MOVLW  00
1E40:  ADDWFC 03,W
1E42:  MOVWF  FEA
1E44:  MOVFF  FEC,120
1E48:  MOVF   FED,F
1E4A:  MOVFF  FEF,11F
1E4E:  MOVF   x1F,F
1E50:  BNZ   1E56
1E52:  MOVF   x20,F
1E54:  BZ    1E84
.................... 				channel[c].lvd_reconnect_delay_seconds--;
1E56:  MOVF   x1C,W
1E58:  MULLW  19
1E5A:  MOVF   FF3,W
1E5C:  CLRF   x20
1E5E:  MOVWF  x1F
1E60:  MOVLW  0B
1E62:  ADDWF  x1F,W
1E64:  MOVWF  01
1E66:  MOVLW  00
1E68:  ADDWFC x20,W
1E6A:  MOVWF  03
1E6C:  MOVF   01,W
1E6E:  ADDLW  DA
1E70:  MOVWF  FE9
1E72:  MOVLW  00
1E74:  ADDWFC 03,W
1E76:  MOVWF  FEA
1E78:  MOVLW  FF
1E7A:  ADDWF  FEF,F
1E7C:  BC    1E82
1E7E:  MOVF   FEE,F
1E80:  DECF   FED,F
.................... 			} else {
1E82:  BRA    1EA0
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_LVD);
1E84:  MOVF   x1C,W
1E86:  MULLW  19
1E88:  MOVF   FF3,W
1E8A:  CLRF   x20
1E8C:  MOVWF  x1F
1E8E:  MOVLW  DA
1E90:  ADDWF  x1F,W
1E92:  MOVWF  01
1E94:  MOVLW  00
1E96:  ADDWFC x20,W
1E98:  MOVFF  01,FE9
1E9C:  MOVWF  FEA
1E9E:  BCF    FEF.3
.................... 			}
.................... 		} else {
1EA0:  BRA    1F08
.................... 			channel[c].lvd_reconnect_delay_seconds=config.ch[c].lvd_reconnect_delay;
1EA2:  MOVF   x1C,W
1EA4:  MULLW  19
1EA6:  MOVF   FF3,W
1EA8:  CLRF   x20
1EAA:  MOVWF  x1F
1EAC:  MOVLW  0B
1EAE:  ADDWF  x1F,W
1EB0:  MOVWF  01
1EB2:  MOVLW  00
1EB4:  ADDWFC x20,W
1EB6:  MOVWF  03
1EB8:  MOVF   01,W
1EBA:  ADDLW  DA
1EBC:  MOVWF  01
1EBE:  MOVLW  00
1EC0:  ADDWFC 03,F
1EC2:  MOVFF  01,11F
1EC6:  MOVFF  03,120
1ECA:  MOVF   x1C,W
1ECC:  MULLW  24
1ECE:  MOVF   FF3,W
1ED0:  CLRF   x22
1ED2:  MOVWF  x21
1ED4:  MOVLW  0A
1ED6:  ADDWF  x21,W
1ED8:  MOVWF  01
1EDA:  MOVLW  00
1EDC:  ADDWFC x22,W
1EDE:  MOVWF  03
1EE0:  MOVF   01,W
1EE2:  ADDLW  1B
1EE4:  MOVWF  FE9
1EE6:  MOVLW  00
1EE8:  ADDWFC 03,W
1EEA:  MOVWF  FEA
1EEC:  MOVFF  FEC,03
1EF0:  MOVF   FED,F
1EF2:  MOVFF  FEF,121
1EF6:  MOVFF  120,FEA
1EFA:  MOVFF  11F,FE9
1EFE:  MOVFF  03,FEC
1F02:  MOVF   FED,F
1F04:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc < config.ch[c].lvd_disconnect_adc ) {
1F08:  MOVF   x1C,W
1F0A:  MULLW  24
1F0C:  MOVF   FF3,W
1F0E:  CLRF   x20
1F10:  MOVWF  x1F
1F12:  MOVLW  04
1F14:  ADDWF  x1F,W
1F16:  MOVWF  01
1F18:  MOVLW  00
1F1A:  ADDWFC x20,W
1F1C:  MOVWF  03
1F1E:  MOVF   01,W
1F20:  ADDLW  1B
1F22:  MOVWF  FE9
1F24:  MOVLW  00
1F26:  ADDWFC 03,W
1F28:  MOVWF  FEA
1F2A:  MOVFF  FEC,03
1F2E:  MOVF   FED,F
1F30:  MOVFF  FEF,01
1F34:  MOVF   x1E,W
1F36:  SUBWF  03,W
1F38:  BNC   1FC2
1F3A:  BNZ   1F42
1F3C:  MOVF   01,W
1F3E:  SUBWF  x1D,W
1F40:  BC    1FC2
.................... 			if ( channel[c].lvd_disconnect_delay_seconds > 0 ) {
1F42:  MOVF   x1C,W
1F44:  MULLW  19
1F46:  MOVF   FF3,W
1F48:  CLRF   x20
1F4A:  MOVWF  x1F
1F4C:  MOVLW  09
1F4E:  ADDWF  x1F,W
1F50:  MOVWF  01
1F52:  MOVLW  00
1F54:  ADDWFC x20,W
1F56:  MOVWF  03
1F58:  MOVF   01,W
1F5A:  ADDLW  DA
1F5C:  MOVWF  FE9
1F5E:  MOVLW  00
1F60:  ADDWFC 03,W
1F62:  MOVWF  FEA
1F64:  MOVFF  FEC,120
1F68:  MOVF   FED,F
1F6A:  MOVFF  FEF,11F
1F6E:  MOVF   x1F,F
1F70:  BNZ   1F76
1F72:  MOVF   x20,F
1F74:  BZ    1FA4
.................... 				channel[c].lvd_disconnect_delay_seconds--;
1F76:  MOVF   x1C,W
1F78:  MULLW  19
1F7A:  MOVF   FF3,W
1F7C:  CLRF   x20
1F7E:  MOVWF  x1F
1F80:  MOVLW  09
1F82:  ADDWF  x1F,W
1F84:  MOVWF  01
1F86:  MOVLW  00
1F88:  ADDWFC x20,W
1F8A:  MOVWF  03
1F8C:  MOVF   01,W
1F8E:  ADDLW  DA
1F90:  MOVWF  FE9
1F92:  MOVLW  00
1F94:  ADDWFC 03,W
1F96:  MOVWF  FEA
1F98:  MOVLW  FF
1F9A:  ADDWF  FEF,F
1F9C:  BC    1FA2
1F9E:  MOVF   FEE,F
1FA0:  DECF   FED,F
.................... 			} else {
1FA2:  BRA    1FC0
.................... 				bit_set(channel[c].state,CH_STATE_BIT_LVD);
1FA4:  MOVF   x1C,W
1FA6:  MULLW  19
1FA8:  MOVF   FF3,W
1FAA:  CLRF   x20
1FAC:  MOVWF  x1F
1FAE:  MOVLW  DA
1FB0:  ADDWF  x1F,W
1FB2:  MOVWF  01
1FB4:  MOVLW  00
1FB6:  ADDWFC x20,W
1FB8:  MOVFF  01,FE9
1FBC:  MOVWF  FEA
1FBE:  BSF    FEF.3
.................... 			}
.................... 		} else {
1FC0:  BRA    2028
.................... 			channel[c].lvd_disconnect_delay_seconds=config.ch[c].lvd_disconnect_delay;
1FC2:  MOVF   x1C,W
1FC4:  MULLW  19
1FC6:  MOVF   FF3,W
1FC8:  CLRF   x20
1FCA:  MOVWF  x1F
1FCC:  MOVLW  09
1FCE:  ADDWF  x1F,W
1FD0:  MOVWF  01
1FD2:  MOVLW  00
1FD4:  ADDWFC x20,W
1FD6:  MOVWF  03
1FD8:  MOVF   01,W
1FDA:  ADDLW  DA
1FDC:  MOVWF  01
1FDE:  MOVLW  00
1FE0:  ADDWFC 03,F
1FE2:  MOVFF  01,11F
1FE6:  MOVFF  03,120
1FEA:  MOVF   x1C,W
1FEC:  MULLW  24
1FEE:  MOVF   FF3,W
1FF0:  CLRF   x22
1FF2:  MOVWF  x21
1FF4:  MOVLW  06
1FF6:  ADDWF  x21,W
1FF8:  MOVWF  01
1FFA:  MOVLW  00
1FFC:  ADDWFC x22,W
1FFE:  MOVWF  03
2000:  MOVF   01,W
2002:  ADDLW  1B
2004:  MOVWF  FE9
2006:  MOVLW  00
2008:  ADDWFC 03,W
200A:  MOVWF  FEA
200C:  MOVFF  FEC,03
2010:  MOVF   FED,F
2012:  MOVFF  FEF,121
2016:  MOVFF  120,FEA
201A:  MOVFF  11F,FE9
201E:  MOVFF  03,FEC
2022:  MOVF   FED,F
2024:  MOVFF  121,FEF
.................... 		}
.................... 	}
.................... 
.................... 	/* High Voltage Disconnect. 65535 disables */
.................... 	if ( 65535 != config.ch[c].hvd_disconnect_delay ) {
2028:  MOVF   x1C,W
202A:  MULLW  24
202C:  MOVF   FF3,W
202E:  CLRF   x20
2030:  MOVWF  x1F
2032:  MOVLW  0E
2034:  ADDWF  x1F,W
2036:  MOVWF  01
2038:  MOVLW  00
203A:  ADDWFC x20,W
203C:  MOVWF  03
203E:  MOVF   01,W
2040:  ADDLW  1B
2042:  MOVWF  FE9
2044:  MOVLW  00
2046:  ADDWFC 03,W
2048:  MOVWF  FEA
204A:  MOVFF  FEC,03
204E:  MOVF   FED,F
2050:  MOVF   FEF,W
2052:  SUBLW  FF
2054:  BNZ   205C
2056:  INCFSZ 03,W
2058:  BRA    205C
205A:  BRA    22BA
205C:  CLRF   19
205E:  BTFSC  FF2.7
2060:  BSF    19.7
2062:  BCF    FF2.7
.................... 		adc=adc_get(0);
2064:  CLRF   x2F
2066:  MOVLB  0
2068:  CALL   0594
206C:  BTFSC  19.7
206E:  BSF    FF2.7
2070:  MOVFF  02,11E
2074:  MOVFF  01,11D
.................... 
.................... 		if ( adc < config.ch[c].hvd_reconnect_adc ) {
2078:  MOVLB  1
207A:  MOVF   x1C,W
207C:  MULLW  24
207E:  MOVF   FF3,W
2080:  CLRF   x20
2082:  MOVWF  x1F
2084:  MOVLW  10
2086:  ADDWF  x1F,W
2088:  MOVWF  01
208A:  MOVLW  00
208C:  ADDWFC x20,W
208E:  MOVWF  03
2090:  MOVF   01,W
2092:  ADDLW  1B
2094:  MOVWF  FE9
2096:  MOVLW  00
2098:  ADDWFC 03,W
209A:  MOVWF  FEA
209C:  MOVFF  FEC,03
20A0:  MOVF   FED,F
20A2:  MOVFF  FEF,01
20A6:  MOVF   x1E,W
20A8:  SUBWF  03,W
20AA:  BNC   2134
20AC:  BNZ   20B4
20AE:  MOVF   01,W
20B0:  SUBWF  x1D,W
20B2:  BC    2134
.................... 			if ( channel[c].hvd_reconnect_delay_seconds > 0 ) {
20B4:  MOVF   x1C,W
20B6:  MULLW  19
20B8:  MOVF   FF3,W
20BA:  CLRF   x20
20BC:  MOVWF  x1F
20BE:  MOVLW  0F
20C0:  ADDWF  x1F,W
20C2:  MOVWF  01
20C4:  MOVLW  00
20C6:  ADDWFC x20,W
20C8:  MOVWF  03
20CA:  MOVF   01,W
20CC:  ADDLW  DA
20CE:  MOVWF  FE9
20D0:  MOVLW  00
20D2:  ADDWFC 03,W
20D4:  MOVWF  FEA
20D6:  MOVFF  FEC,120
20DA:  MOVF   FED,F
20DC:  MOVFF  FEF,11F
20E0:  MOVF   x1F,F
20E2:  BNZ   20E8
20E4:  MOVF   x20,F
20E6:  BZ    2116
.................... 				channel[c].hvd_reconnect_delay_seconds--;
20E8:  MOVF   x1C,W
20EA:  MULLW  19
20EC:  MOVF   FF3,W
20EE:  CLRF   x20
20F0:  MOVWF  x1F
20F2:  MOVLW  0F
20F4:  ADDWF  x1F,W
20F6:  MOVWF  01
20F8:  MOVLW  00
20FA:  ADDWFC x20,W
20FC:  MOVWF  03
20FE:  MOVF   01,W
2100:  ADDLW  DA
2102:  MOVWF  FE9
2104:  MOVLW  00
2106:  ADDWFC 03,W
2108:  MOVWF  FEA
210A:  MOVLW  FF
210C:  ADDWF  FEF,F
210E:  BC    2114
2110:  MOVF   FEE,F
2112:  DECF   FED,F
.................... 			} else {
2114:  BRA    2132
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_HVD);
2116:  MOVF   x1C,W
2118:  MULLW  19
211A:  MOVF   FF3,W
211C:  CLRF   x20
211E:  MOVWF  x1F
2120:  MOVLW  DA
2122:  ADDWF  x1F,W
2124:  MOVWF  01
2126:  MOVLW  00
2128:  ADDWFC x20,W
212A:  MOVFF  01,FE9
212E:  MOVWF  FEA
2130:  BCF    FEF.4
.................... 			}
.................... 		} else {
2132:  BRA    219A
.................... 			channel[c].hvd_reconnect_delay_seconds=config.ch[c].hvd_reconnect_delay;
2134:  MOVF   x1C,W
2136:  MULLW  19
2138:  MOVF   FF3,W
213A:  CLRF   x20
213C:  MOVWF  x1F
213E:  MOVLW  0F
2140:  ADDWF  x1F,W
2142:  MOVWF  01
2144:  MOVLW  00
2146:  ADDWFC x20,W
2148:  MOVWF  03
214A:  MOVF   01,W
214C:  ADDLW  DA
214E:  MOVWF  01
2150:  MOVLW  00
2152:  ADDWFC 03,F
2154:  MOVFF  01,11F
2158:  MOVFF  03,120
215C:  MOVF   x1C,W
215E:  MULLW  24
2160:  MOVF   FF3,W
2162:  CLRF   x22
2164:  MOVWF  x21
2166:  MOVLW  12
2168:  ADDWF  x21,W
216A:  MOVWF  01
216C:  MOVLW  00
216E:  ADDWFC x22,W
2170:  MOVWF  03
2172:  MOVF   01,W
2174:  ADDLW  1B
2176:  MOVWF  FE9
2178:  MOVLW  00
217A:  ADDWFC 03,W
217C:  MOVWF  FEA
217E:  MOVFF  FEC,03
2182:  MOVF   FED,F
2184:  MOVFF  FEF,121
2188:  MOVFF  120,FEA
218C:  MOVFF  11F,FE9
2190:  MOVFF  03,FEC
2194:  MOVF   FED,F
2196:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc > config.ch[c].hvd_disconnect_adc ) {
219A:  MOVF   x1C,W
219C:  MULLW  24
219E:  MOVF   FF3,W
21A0:  CLRF   x20
21A2:  MOVWF  x1F
21A4:  MOVLW  0C
21A6:  ADDWF  x1F,W
21A8:  MOVWF  01
21AA:  MOVLW  00
21AC:  ADDWFC x20,W
21AE:  MOVWF  03
21B0:  MOVF   01,W
21B2:  ADDLW  1B
21B4:  MOVWF  FE9
21B6:  MOVLW  00
21B8:  ADDWFC 03,W
21BA:  MOVWF  FEA
21BC:  MOVFF  FEC,03
21C0:  MOVF   FED,F
21C2:  MOVFF  FEF,01
21C6:  MOVF   03,W
21C8:  SUBWF  x1E,W
21CA:  BNC   2254
21CC:  BNZ   21D4
21CE:  MOVF   x1D,W
21D0:  SUBWF  01,W
21D2:  BC    2254
.................... 			if ( channel[c].hvd_disconnect_delay_seconds > 0 ) {
21D4:  MOVF   x1C,W
21D6:  MULLW  19
21D8:  MOVF   FF3,W
21DA:  CLRF   x20
21DC:  MOVWF  x1F
21DE:  MOVLW  0D
21E0:  ADDWF  x1F,W
21E2:  MOVWF  01
21E4:  MOVLW  00
21E6:  ADDWFC x20,W
21E8:  MOVWF  03
21EA:  MOVF   01,W
21EC:  ADDLW  DA
21EE:  MOVWF  FE9
21F0:  MOVLW  00
21F2:  ADDWFC 03,W
21F4:  MOVWF  FEA
21F6:  MOVFF  FEC,120
21FA:  MOVF   FED,F
21FC:  MOVFF  FEF,11F
2200:  MOVF   x1F,F
2202:  BNZ   2208
2204:  MOVF   x20,F
2206:  BZ    2236
.................... 				channel[c].hvd_disconnect_delay_seconds--;
2208:  MOVF   x1C,W
220A:  MULLW  19
220C:  MOVF   FF3,W
220E:  CLRF   x20
2210:  MOVWF  x1F
2212:  MOVLW  0D
2214:  ADDWF  x1F,W
2216:  MOVWF  01
2218:  MOVLW  00
221A:  ADDWFC x20,W
221C:  MOVWF  03
221E:  MOVF   01,W
2220:  ADDLW  DA
2222:  MOVWF  FE9
2224:  MOVLW  00
2226:  ADDWFC 03,W
2228:  MOVWF  FEA
222A:  MOVLW  FF
222C:  ADDWF  FEF,F
222E:  BC    2234
2230:  MOVF   FEE,F
2232:  DECF   FED,F
.................... 			} else {
2234:  BRA    2252
.................... 				bit_set(channel[c].state,CH_STATE_BIT_HVD);
2236:  MOVF   x1C,W
2238:  MULLW  19
223A:  MOVF   FF3,W
223C:  CLRF   x20
223E:  MOVWF  x1F
2240:  MOVLW  DA
2242:  ADDWF  x1F,W
2244:  MOVWF  01
2246:  MOVLW  00
2248:  ADDWFC x20,W
224A:  MOVFF  01,FE9
224E:  MOVWF  FEA
2250:  BSF    FEF.4
.................... 			}
.................... 		} else {
2252:  BRA    22BA
.................... 			channel[c].hvd_disconnect_delay_seconds=config.ch[c].hvd_disconnect_delay;
2254:  MOVF   x1C,W
2256:  MULLW  19
2258:  MOVF   FF3,W
225A:  CLRF   x20
225C:  MOVWF  x1F
225E:  MOVLW  0D
2260:  ADDWF  x1F,W
2262:  MOVWF  01
2264:  MOVLW  00
2266:  ADDWFC x20,W
2268:  MOVWF  03
226A:  MOVF   01,W
226C:  ADDLW  DA
226E:  MOVWF  01
2270:  MOVLW  00
2272:  ADDWFC 03,F
2274:  MOVFF  01,11F
2278:  MOVFF  03,120
227C:  MOVF   x1C,W
227E:  MULLW  24
2280:  MOVF   FF3,W
2282:  CLRF   x22
2284:  MOVWF  x21
2286:  MOVLW  0E
2288:  ADDWF  x21,W
228A:  MOVWF  01
228C:  MOVLW  00
228E:  ADDWFC x22,W
2290:  MOVWF  03
2292:  MOVF   01,W
2294:  ADDLW  1B
2296:  MOVWF  FE9
2298:  MOVLW  00
229A:  ADDWFC 03,W
229C:  MOVWF  FEA
229E:  MOVFF  FEC,03
22A2:  MOVF   FED,F
22A4:  MOVFF  FEF,121
22A8:  MOVFF  120,FEA
22AC:  MOVFF  11F,FE9
22B0:  MOVFF  03,FEC
22B4:  MOVF   FED,F
22B6:  MOVFF  121,FEF
.................... 		}
.................... 	}
.................... 
.................... 	/* Low Temperature Disconnect. 65535 disables */
.................... 	if ( 65535 != config.ch[c].ltd_disconnect_delay ) {
22BA:  MOVF   x1C,W
22BC:  MULLW  24
22BE:  MOVF   FF3,W
22C0:  CLRF   x20
22C2:  MOVWF  x1F
22C4:  MOVLW  16
22C6:  ADDWF  x1F,W
22C8:  MOVWF  01
22CA:  MOVLW  00
22CC:  ADDWFC x20,W
22CE:  MOVWF  03
22D0:  MOVF   01,W
22D2:  ADDLW  1B
22D4:  MOVWF  FE9
22D6:  MOVLW  00
22D8:  ADDWFC 03,W
22DA:  MOVWF  FEA
22DC:  MOVFF  FEC,03
22E0:  MOVF   FED,F
22E2:  MOVF   FEF,W
22E4:  SUBLW  FF
22E6:  BNZ   22EE
22E8:  INCFSZ 03,W
22EA:  BRA    22EE
22EC:  BRA    254E
22EE:  CLRF   19
22F0:  BTFSC  FF2.7
22F2:  BSF    19.7
22F4:  BCF    FF2.7
.................... 		adc=adc_get(1);
22F6:  MOVLW  01
22F8:  MOVWF  x2F
22FA:  MOVLB  0
22FC:  CALL   0594
2300:  BTFSC  19.7
2302:  BSF    FF2.7
2304:  MOVFF  02,11E
2308:  MOVFF  01,11D
.................... 
.................... 		if ( adc < config.ch[c].ltd_reconnect_adc ) {
230C:  MOVLB  1
230E:  MOVF   x1C,W
2310:  MULLW  24
2312:  MOVF   FF3,W
2314:  CLRF   x20
2316:  MOVWF  x1F
2318:  MOVLW  18
231A:  ADDWF  x1F,W
231C:  MOVWF  01
231E:  MOVLW  00
2320:  ADDWFC x20,W
2322:  MOVWF  03
2324:  MOVF   01,W
2326:  ADDLW  1B
2328:  MOVWF  FE9
232A:  MOVLW  00
232C:  ADDWFC 03,W
232E:  MOVWF  FEA
2330:  MOVFF  FEC,03
2334:  MOVF   FED,F
2336:  MOVFF  FEF,01
233A:  MOVF   x1E,W
233C:  SUBWF  03,W
233E:  BNC   23C8
2340:  BNZ   2348
2342:  MOVF   01,W
2344:  SUBWF  x1D,W
2346:  BC    23C8
.................... 			/* above reconnect temperature */
.................... 			if ( channel[c].ltd_reconnect_delay_seconds > 0 ) {
2348:  MOVF   x1C,W
234A:  MULLW  19
234C:  MOVF   FF3,W
234E:  CLRF   x20
2350:  MOVWF  x1F
2352:  MOVLW  13
2354:  ADDWF  x1F,W
2356:  MOVWF  01
2358:  MOVLW  00
235A:  ADDWFC x20,W
235C:  MOVWF  03
235E:  MOVF   01,W
2360:  ADDLW  DA
2362:  MOVWF  FE9
2364:  MOVLW  00
2366:  ADDWFC 03,W
2368:  MOVWF  FEA
236A:  MOVFF  FEC,120
236E:  MOVF   FED,F
2370:  MOVFF  FEF,11F
2374:  MOVF   x1F,F
2376:  BNZ   237C
2378:  MOVF   x20,F
237A:  BZ    23AA
.................... 				channel[c].ltd_reconnect_delay_seconds--;
237C:  MOVF   x1C,W
237E:  MULLW  19
2380:  MOVF   FF3,W
2382:  CLRF   x20
2384:  MOVWF  x1F
2386:  MOVLW  13
2388:  ADDWF  x1F,W
238A:  MOVWF  01
238C:  MOVLW  00
238E:  ADDWFC x20,W
2390:  MOVWF  03
2392:  MOVF   01,W
2394:  ADDLW  DA
2396:  MOVWF  FE9
2398:  MOVLW  00
239A:  ADDWFC 03,W
239C:  MOVWF  FEA
239E:  MOVLW  FF
23A0:  ADDWF  FEF,F
23A2:  BC    23A8
23A4:  MOVF   FEE,F
23A6:  DECF   FED,F
.................... 			} else {
23A8:  BRA    23C6
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_LTD);
23AA:  MOVF   x1C,W
23AC:  MULLW  19
23AE:  MOVF   FF3,W
23B0:  CLRF   x20
23B2:  MOVWF  x1F
23B4:  MOVLW  DA
23B6:  ADDWF  x1F,W
23B8:  MOVWF  01
23BA:  MOVLW  00
23BC:  ADDWFC x20,W
23BE:  MOVFF  01,FE9
23C2:  MOVWF  FEA
23C4:  BCF    FEF.5
.................... 			}
.................... 		} else {
23C6:  BRA    242E
.................... 			channel[c].ltd_reconnect_delay_seconds=config.ch[c].ltd_reconnect_delay;
23C8:  MOVF   x1C,W
23CA:  MULLW  19
23CC:  MOVF   FF3,W
23CE:  CLRF   x20
23D0:  MOVWF  x1F
23D2:  MOVLW  13
23D4:  ADDWF  x1F,W
23D6:  MOVWF  01
23D8:  MOVLW  00
23DA:  ADDWFC x20,W
23DC:  MOVWF  03
23DE:  MOVF   01,W
23E0:  ADDLW  DA
23E2:  MOVWF  01
23E4:  MOVLW  00
23E6:  ADDWFC 03,F
23E8:  MOVFF  01,11F
23EC:  MOVFF  03,120
23F0:  MOVF   x1C,W
23F2:  MULLW  24
23F4:  MOVF   FF3,W
23F6:  CLRF   x22
23F8:  MOVWF  x21
23FA:  MOVLW  1A
23FC:  ADDWF  x21,W
23FE:  MOVWF  01
2400:  MOVLW  00
2402:  ADDWFC x22,W
2404:  MOVWF  03
2406:  MOVF   01,W
2408:  ADDLW  1B
240A:  MOVWF  FE9
240C:  MOVLW  00
240E:  ADDWFC 03,W
2410:  MOVWF  FEA
2412:  MOVFF  FEC,03
2416:  MOVF   FED,F
2418:  MOVFF  FEF,121
241C:  MOVFF  120,FEA
2420:  MOVFF  11F,FE9
2424:  MOVFF  03,FEC
2428:  MOVF   FED,F
242A:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc > config.ch[c].ltd_disconnect_adc ) {
242E:  MOVF   x1C,W
2430:  MULLW  24
2432:  MOVF   FF3,W
2434:  CLRF   x20
2436:  MOVWF  x1F
2438:  MOVLW  14
243A:  ADDWF  x1F,W
243C:  MOVWF  01
243E:  MOVLW  00
2440:  ADDWFC x20,W
2442:  MOVWF  03
2444:  MOVF   01,W
2446:  ADDLW  1B
2448:  MOVWF  FE9
244A:  MOVLW  00
244C:  ADDWFC 03,W
244E:  MOVWF  FEA
2450:  MOVFF  FEC,03
2454:  MOVF   FED,F
2456:  MOVFF  FEF,01
245A:  MOVF   03,W
245C:  SUBWF  x1E,W
245E:  BNC   24E8
2460:  BNZ   2468
2462:  MOVF   x1D,W
2464:  SUBWF  01,W
2466:  BC    24E8
.................... 			/* below disconnect temperature */
.................... 			if ( channel[c].ltd_disconnect_delay_seconds > 0 ) {
2468:  MOVF   x1C,W
246A:  MULLW  19
246C:  MOVF   FF3,W
246E:  CLRF   x20
2470:  MOVWF  x1F
2472:  MOVLW  11
2474:  ADDWF  x1F,W
2476:  MOVWF  01
2478:  MOVLW  00
247A:  ADDWFC x20,W
247C:  MOVWF  03
247E:  MOVF   01,W
2480:  ADDLW  DA
2482:  MOVWF  FE9
2484:  MOVLW  00
2486:  ADDWFC 03,W
2488:  MOVWF  FEA
248A:  MOVFF  FEC,120
248E:  MOVF   FED,F
2490:  MOVFF  FEF,11F
2494:  MOVF   x1F,F
2496:  BNZ   249C
2498:  MOVF   x20,F
249A:  BZ    24CA
.................... 				channel[c].ltd_disconnect_delay_seconds--;
249C:  MOVF   x1C,W
249E:  MULLW  19
24A0:  MOVF   FF3,W
24A2:  CLRF   x20
24A4:  MOVWF  x1F
24A6:  MOVLW  11
24A8:  ADDWF  x1F,W
24AA:  MOVWF  01
24AC:  MOVLW  00
24AE:  ADDWFC x20,W
24B0:  MOVWF  03
24B2:  MOVF   01,W
24B4:  ADDLW  DA
24B6:  MOVWF  FE9
24B8:  MOVLW  00
24BA:  ADDWFC 03,W
24BC:  MOVWF  FEA
24BE:  MOVLW  FF
24C0:  ADDWF  FEF,F
24C2:  BC    24C8
24C4:  MOVF   FEE,F
24C6:  DECF   FED,F
.................... 			} else {
24C8:  BRA    24E6
.................... 				bit_set(channel[c].state,CH_STATE_BIT_LTD);
24CA:  MOVF   x1C,W
24CC:  MULLW  19
24CE:  MOVF   FF3,W
24D0:  CLRF   x20
24D2:  MOVWF  x1F
24D4:  MOVLW  DA
24D6:  ADDWF  x1F,W
24D8:  MOVWF  01
24DA:  MOVLW  00
24DC:  ADDWFC x20,W
24DE:  MOVFF  01,FE9
24E2:  MOVWF  FEA
24E4:  BSF    FEF.5
.................... 			}
.................... 		} else {
24E6:  BRA    254E
.................... 			channel[c].ltd_disconnect_delay_seconds=config.ch[c].ltd_disconnect_delay;
24E8:  MOVF   x1C,W
24EA:  MULLW  19
24EC:  MOVF   FF3,W
24EE:  CLRF   x20
24F0:  MOVWF  x1F
24F2:  MOVLW  11
24F4:  ADDWF  x1F,W
24F6:  MOVWF  01
24F8:  MOVLW  00
24FA:  ADDWFC x20,W
24FC:  MOVWF  03
24FE:  MOVF   01,W
2500:  ADDLW  DA
2502:  MOVWF  01
2504:  MOVLW  00
2506:  ADDWFC 03,F
2508:  MOVFF  01,11F
250C:  MOVFF  03,120
2510:  MOVF   x1C,W
2512:  MULLW  24
2514:  MOVF   FF3,W
2516:  CLRF   x22
2518:  MOVWF  x21
251A:  MOVLW  16
251C:  ADDWF  x21,W
251E:  MOVWF  01
2520:  MOVLW  00
2522:  ADDWFC x22,W
2524:  MOVWF  03
2526:  MOVF   01,W
2528:  ADDLW  1B
252A:  MOVWF  FE9
252C:  MOVLW  00
252E:  ADDWFC 03,W
2530:  MOVWF  FEA
2532:  MOVFF  FEC,03
2536:  MOVF   FED,F
2538:  MOVFF  FEF,121
253C:  MOVFF  120,FEA
2540:  MOVFF  11F,FE9
2544:  MOVFF  03,FEC
2548:  MOVF   FED,F
254A:  MOVFF  121,FEF
.................... 		}
.................... 	}
.................... 
.................... 	/* High Temperature Disconnect. 65535 disables */
.................... 	if ( 65535 != config.ch[c].htd_disconnect_delay ) {
254E:  MOVF   x1C,W
2550:  MULLW  24
2552:  MOVF   FF3,W
2554:  CLRF   x20
2556:  MOVWF  x1F
2558:  MOVLW  1E
255A:  ADDWF  x1F,W
255C:  MOVWF  01
255E:  MOVLW  00
2560:  ADDWFC x20,W
2562:  MOVWF  03
2564:  MOVF   01,W
2566:  ADDLW  1B
2568:  MOVWF  FE9
256A:  MOVLW  00
256C:  ADDWFC 03,W
256E:  MOVWF  FEA
2570:  MOVFF  FEC,03
2574:  MOVF   FED,F
2576:  MOVF   FEF,W
2578:  SUBLW  FF
257A:  BNZ   2582
257C:  INCFSZ 03,W
257E:  BRA    2582
2580:  BRA    27E2
2582:  CLRF   19
2584:  BTFSC  FF2.7
2586:  BSF    19.7
2588:  BCF    FF2.7
.................... 		adc=adc_get(1);
258A:  MOVLW  01
258C:  MOVWF  x2F
258E:  MOVLB  0
2590:  CALL   0594
2594:  BTFSC  19.7
2596:  BSF    FF2.7
2598:  MOVFF  02,11E
259C:  MOVFF  01,11D
.................... 
.................... 		if ( adc > config.ch[c].htd_reconnect_adc ) {
25A0:  MOVLB  1
25A2:  MOVF   x1C,W
25A4:  MULLW  24
25A6:  MOVF   FF3,W
25A8:  CLRF   x20
25AA:  MOVWF  x1F
25AC:  MOVLW  20
25AE:  ADDWF  x1F,W
25B0:  MOVWF  01
25B2:  MOVLW  00
25B4:  ADDWFC x20,W
25B6:  MOVWF  03
25B8:  MOVF   01,W
25BA:  ADDLW  1B
25BC:  MOVWF  FE9
25BE:  MOVLW  00
25C0:  ADDWFC 03,W
25C2:  MOVWF  FEA
25C4:  MOVFF  FEC,03
25C8:  MOVF   FED,F
25CA:  MOVFF  FEF,01
25CE:  MOVF   03,W
25D0:  SUBWF  x1E,W
25D2:  BNC   265C
25D4:  BNZ   25DC
25D6:  MOVF   x1D,W
25D8:  SUBWF  01,W
25DA:  BC    265C
.................... 			if ( channel[c].htd_reconnect_delay_seconds > 0 ) {
25DC:  MOVF   x1C,W
25DE:  MULLW  19
25E0:  MOVF   FF3,W
25E2:  CLRF   x20
25E4:  MOVWF  x1F
25E6:  MOVLW  17
25E8:  ADDWF  x1F,W
25EA:  MOVWF  01
25EC:  MOVLW  00
25EE:  ADDWFC x20,W
25F0:  MOVWF  03
25F2:  MOVF   01,W
25F4:  ADDLW  DA
25F6:  MOVWF  FE9
25F8:  MOVLW  00
25FA:  ADDWFC 03,W
25FC:  MOVWF  FEA
25FE:  MOVFF  FEC,120
2602:  MOVF   FED,F
2604:  MOVFF  FEF,11F
2608:  MOVF   x1F,F
260A:  BNZ   2610
260C:  MOVF   x20,F
260E:  BZ    263E
.................... 				channel[c].htd_reconnect_delay_seconds--;
2610:  MOVF   x1C,W
2612:  MULLW  19
2614:  MOVF   FF3,W
2616:  CLRF   x20
2618:  MOVWF  x1F
261A:  MOVLW  17
261C:  ADDWF  x1F,W
261E:  MOVWF  01
2620:  MOVLW  00
2622:  ADDWFC x20,W
2624:  MOVWF  03
2626:  MOVF   01,W
2628:  ADDLW  DA
262A:  MOVWF  FE9
262C:  MOVLW  00
262E:  ADDWFC 03,W
2630:  MOVWF  FEA
2632:  MOVLW  FF
2634:  ADDWF  FEF,F
2636:  BC    263C
2638:  MOVF   FEE,F
263A:  DECF   FED,F
.................... 			} else {
263C:  BRA    265A
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_HTD);
263E:  MOVF   x1C,W
2640:  MULLW  19
2642:  MOVF   FF3,W
2644:  CLRF   x20
2646:  MOVWF  x1F
2648:  MOVLW  DA
264A:  ADDWF  x1F,W
264C:  MOVWF  01
264E:  MOVLW  00
2650:  ADDWFC x20,W
2652:  MOVFF  01,FE9
2656:  MOVWF  FEA
2658:  BCF    FEF.6
.................... 			}
.................... 		} else {
265A:  BRA    26C2
.................... 			channel[c].htd_reconnect_delay_seconds=config.ch[c].htd_reconnect_delay;
265C:  MOVF   x1C,W
265E:  MULLW  19
2660:  MOVF   FF3,W
2662:  CLRF   x20
2664:  MOVWF  x1F
2666:  MOVLW  17
2668:  ADDWF  x1F,W
266A:  MOVWF  01
266C:  MOVLW  00
266E:  ADDWFC x20,W
2670:  MOVWF  03
2672:  MOVF   01,W
2674:  ADDLW  DA
2676:  MOVWF  01
2678:  MOVLW  00
267A:  ADDWFC 03,F
267C:  MOVFF  01,11F
2680:  MOVFF  03,120
2684:  MOVF   x1C,W
2686:  MULLW  24
2688:  MOVF   FF3,W
268A:  CLRF   x22
268C:  MOVWF  x21
268E:  MOVLW  22
2690:  ADDWF  x21,W
2692:  MOVWF  01
2694:  MOVLW  00
2696:  ADDWFC x22,W
2698:  MOVWF  03
269A:  MOVF   01,W
269C:  ADDLW  1B
269E:  MOVWF  FE9
26A0:  MOVLW  00
26A2:  ADDWFC 03,W
26A4:  MOVWF  FEA
26A6:  MOVFF  FEC,03
26AA:  MOVF   FED,F
26AC:  MOVFF  FEF,121
26B0:  MOVFF  120,FEA
26B4:  MOVFF  11F,FE9
26B8:  MOVFF  03,FEC
26BC:  MOVF   FED,F
26BE:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc < config.ch[c].htd_disconnect_adc ) {
26C2:  MOVF   x1C,W
26C4:  MULLW  24
26C6:  MOVF   FF3,W
26C8:  CLRF   x20
26CA:  MOVWF  x1F
26CC:  MOVLW  1C
26CE:  ADDWF  x1F,W
26D0:  MOVWF  01
26D2:  MOVLW  00
26D4:  ADDWFC x20,W
26D6:  MOVWF  03
26D8:  MOVF   01,W
26DA:  ADDLW  1B
26DC:  MOVWF  FE9
26DE:  MOVLW  00
26E0:  ADDWFC 03,W
26E2:  MOVWF  FEA
26E4:  MOVFF  FEC,03
26E8:  MOVF   FED,F
26EA:  MOVFF  FEF,01
26EE:  MOVF   x1E,W
26F0:  SUBWF  03,W
26F2:  BNC   277C
26F4:  BNZ   26FC
26F6:  MOVF   01,W
26F8:  SUBWF  x1D,W
26FA:  BC    277C
.................... 			if ( channel[c].htd_disconnect_delay_seconds > 0 ) {
26FC:  MOVF   x1C,W
26FE:  MULLW  19
2700:  MOVF   FF3,W
2702:  CLRF   x20
2704:  MOVWF  x1F
2706:  MOVLW  15
2708:  ADDWF  x1F,W
270A:  MOVWF  01
270C:  MOVLW  00
270E:  ADDWFC x20,W
2710:  MOVWF  03
2712:  MOVF   01,W
2714:  ADDLW  DA
2716:  MOVWF  FE9
2718:  MOVLW  00
271A:  ADDWFC 03,W
271C:  MOVWF  FEA
271E:  MOVFF  FEC,120
2722:  MOVF   FED,F
2724:  MOVFF  FEF,11F
2728:  MOVF   x1F,F
272A:  BNZ   2730
272C:  MOVF   x20,F
272E:  BZ    275E
.................... 				channel[c].htd_disconnect_delay_seconds--;
2730:  MOVF   x1C,W
2732:  MULLW  19
2734:  MOVF   FF3,W
2736:  CLRF   x20
2738:  MOVWF  x1F
273A:  MOVLW  15
273C:  ADDWF  x1F,W
273E:  MOVWF  01
2740:  MOVLW  00
2742:  ADDWFC x20,W
2744:  MOVWF  03
2746:  MOVF   01,W
2748:  ADDLW  DA
274A:  MOVWF  FE9
274C:  MOVLW  00
274E:  ADDWFC 03,W
2750:  MOVWF  FEA
2752:  MOVLW  FF
2754:  ADDWF  FEF,F
2756:  BC    275C
2758:  MOVF   FEE,F
275A:  DECF   FED,F
.................... 			} else {
275C:  BRA    277A
.................... 				bit_set(channel[c].state,CH_STATE_BIT_HTD);
275E:  MOVF   x1C,W
2760:  MULLW  19
2762:  MOVF   FF3,W
2764:  CLRF   x20
2766:  MOVWF  x1F
2768:  MOVLW  DA
276A:  ADDWF  x1F,W
276C:  MOVWF  01
276E:  MOVLW  00
2770:  ADDWFC x20,W
2772:  MOVFF  01,FE9
2776:  MOVWF  FEA
2778:  BSF    FEF.6
.................... 			}
.................... 		} else {
277A:  BRA    27E2
.................... 			channel[c].htd_disconnect_delay_seconds=config.ch[c].htd_disconnect_delay;
277C:  MOVF   x1C,W
277E:  MULLW  19
2780:  MOVF   FF3,W
2782:  CLRF   x20
2784:  MOVWF  x1F
2786:  MOVLW  15
2788:  ADDWF  x1F,W
278A:  MOVWF  01
278C:  MOVLW  00
278E:  ADDWFC x20,W
2790:  MOVWF  03
2792:  MOVF   01,W
2794:  ADDLW  DA
2796:  MOVWF  01
2798:  MOVLW  00
279A:  ADDWFC 03,F
279C:  MOVFF  01,11F
27A0:  MOVFF  03,120
27A4:  MOVF   x1C,W
27A6:  MULLW  24
27A8:  MOVF   FF3,W
27AA:  CLRF   x22
27AC:  MOVWF  x21
27AE:  MOVLW  1E
27B0:  ADDWF  x21,W
27B2:  MOVWF  01
27B4:  MOVLW  00
27B6:  ADDWFC x22,W
27B8:  MOVWF  03
27BA:  MOVF   01,W
27BC:  ADDLW  1B
27BE:  MOVWF  FE9
27C0:  MOVLW  00
27C2:  ADDWFC 03,W
27C4:  MOVWF  FEA
27C6:  MOVFF  FEC,03
27CA:  MOVF   FED,F
27CC:  MOVFF  FEF,121
27D0:  MOVFF  120,FEA
27D4:  MOVFF  11F,FE9
27D8:  MOVFF  03,FEC
27DC:  MOVF   FED,F
27DE:  MOVFF  121,FEF
.................... 		}
.................... 	}
27E2:  MOVLB  0
27E4:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void led_status_update(void) {
.................... 	static int8 cycle=0;
.................... 	int8 led;
.................... 
.................... 	for ( led=0 ; led<2 ; led++ ) {
*
28A2:  MOVLB  1
28A4:  CLRF   x1C
28A6:  MOVF   x1C,W
28A8:  SUBLW  01
28AA:  BNC   2980
.................... 		if ( cycle < 8 ) {
28AC:  MOVF   x11,W
28AE:  SUBLW  07
28B0:  BNC   2918
.................... 			/* first 8 cycles are 8 bits of state bit field */
.................... 
.................... 			/* if bit is set, then we blink the number of times+1 of the bit we are in. So bit 1 set means we blink 2 times */
.................... 			if ( bit_test(channel[led].state,cycle) ) {
28B2:  MOVF   x1C,W
28B4:  MULLW  19
28B6:  MOVF   FF3,W
28B8:  CLRF   x1E
28BA:  MOVWF  x1D
28BC:  MOVLW  DA
28BE:  ADDWF  x1D,W
28C0:  MOVWF  FE9
28C2:  MOVLW  00
28C4:  ADDWFC x1E,W
28C6:  MOVWF  FEA
28C8:  MOVFF  FEF,00
28CC:  MOVF   x11,W
28CE:  MOVWF  01
28D0:  BZ    28DA
28D2:  BCF    FD8.0
28D4:  RRCF   00,F
28D6:  DECFSZ 01,F
28D8:  BRA    28D2
28DA:  BTFSS  00.0
28DC:  BRA    2906
.................... 				timers.led_blink[led]=cycle+1;      /* number of blinks */
28DE:  CLRF   03
28E0:  MOVF   x1C,W
28E2:  ADDLW  D0
28E4:  MOVWF  FE9
28E6:  MOVLW  00
28E8:  ADDWFC 03,W
28EA:  MOVWF  FEA
28EC:  MOVLW  01
28EE:  ADDWF  x11,W
28F0:  MOVWF  FEF
.................... 				timers.led_on[led]=BLINK_ON_TIME;   /* how long to be on */
28F2:  CLRF   03
28F4:  MOVF   x1C,W
28F6:  ADDLW  D2
28F8:  MOVWF  FE9
28FA:  MOVLW  00
28FC:  ADDWFC 03,W
28FE:  MOVWF  FEA
2900:  MOVLW  FE
2902:  MOVWF  FEF
.................... 			} else {
2904:  BRA    2916
.................... 				timers.led_blink[led]=0;
2906:  CLRF   03
2908:  MOVF   x1C,W
290A:  ADDLW  D0
290C:  MOVWF  FE9
290E:  MOVLW  00
2910:  ADDWFC 03,W
2912:  MOVWF  FEA
2914:  CLRF   FEF
.................... 			}
.................... 		} else if ( 8 == cycle ) {
2916:  BRA    297C
2918:  MOVF   x11,W
291A:  SUBLW  08
291C:  BNZ   2930
.................... 			/* solid light to mark start of next cycle */
.................... 			timers.led_blink[led]=255;
291E:  CLRF   03
2920:  MOVF   x1C,W
2922:  ADDLW  D0
2924:  MOVWF  FE9
2926:  MOVLW  00
2928:  ADDWFC 03,W
292A:  MOVWF  FEA
292C:  SETF   FEF
.................... 		} else if ( 9 == cycle ) {
292E:  BRA    297C
2930:  MOVF   x11,W
2932:  SUBLW  09
2934:  BNZ   296C
.................... 			/* solid on if contactor state is on, otherwise off */
.................... 			if ( timers.contactor[led] ) {
2936:  CLRF   03
2938:  MOVF   x1C,W
293A:  ADDLW  D6
293C:  MOVWF  FE9
293E:  MOVLW  00
2940:  ADDWFC 03,W
2942:  MOVWF  FEA
2944:  MOVF   FEF,F
2946:  BZ    295A
.................... 				timers.led_blink[led]=255;
2948:  CLRF   03
294A:  MOVF   x1C,W
294C:  ADDLW  D0
294E:  MOVWF  FE9
2950:  MOVLW  00
2952:  ADDWFC 03,W
2954:  MOVWF  FEA
2956:  SETF   FEF
.................... 			} else {
2958:  BRA    296A
.................... 				timers.led_blink[led]=0;
295A:  CLRF   03
295C:  MOVF   x1C,W
295E:  ADDLW  D0
2960:  MOVWF  FE9
2962:  MOVLW  00
2964:  ADDWFC 03,W
2966:  MOVWF  FEA
2968:  CLRF   FEF
.................... 			}
.................... 		} else {
296A:  BRA    297C
.................... 			/* blank period before starting the bit field */
.................... 			timers.led_blink[led]=0;
296C:  CLRF   03
296E:  MOVF   x1C,W
2970:  ADDLW  D0
2972:  MOVWF  FE9
2974:  MOVLW  00
2976:  ADDWFC 03,W
2978:  MOVWF  FEA
297A:  CLRF   FEF
.................... 		}
297C:  INCF   x1C,F
297E:  BRA    28A6
.................... 	}
.................... 
.................... //	fprintf(STREAM_FTDI,"# LED %u A=%03u (0x%02X) B=%03u (0x%02X)\r\n",cycle,timers.led_blink[0],channel[0].state,timers.led_blink[1],channel[1].state);
.................... 
.................... 	if ( 10 == cycle ) {
2980:  MOVF   x11,W
2982:  SUBLW  0A
2984:  BNZ   298A
.................... 		cycle=0; 
2986:  CLRF   x11
.................... 	} else {
2988:  BRA    298C
.................... 		cycle++;
298A:  INCF   x11,F
.................... 	}
298C:  MOVLB  0
298E:  GOTO   2B3C (RETURN)
.................... }
.................... 
.................... void led_on(int8 c) {
.................... 	if ( 0==c ) 
*
197A:  MOVLB  1
197C:  MOVF   x1C,F
197E:  BNZ   1986
.................... 		output_high(LED_A);
1980:  BCF    F94.1
1982:  BSF    F8B.1
1984:  BRA    198A
.................... 	else
.................... 		output_high(LED_B);
1986:  BCF    F94.2
1988:  BSF    F8B.2
198A:  MOVLB  0
198C:  RETURN 0
.................... }
.................... 
.................... void led_off(int8 c) {
.................... 	if ( 0==c ) 
198E:  MOVLB  1
1990:  MOVF   x1C,F
1992:  BNZ   199A
.................... 		output_low(LED_A);
1994:  BCF    F94.1
1996:  BCF    F8B.1
1998:  BRA    199E
.................... 	else
.................... 		output_low(LED_B);
199A:  BCF    F94.2
199C:  BCF    F8B.2
199E:  MOVLB  0
19A0:  RETURN 0
.................... }
.................... 
.................... void periodic_millisecond(void) {
.................... 	static int8  uptimeTicks=0;
.................... 	static int8  statusTicks=0;
.................... 	static int16 adcTicks=0;
.................... 	static int16 ticks=0;
.................... 
.................... 	int8 i;
.................... 
.................... 
.................... 	timers.now_millisecond=0;
*
2992:  BCF    xCF.2
.................... 
.................... 	/* set LED output */
.................... 	for ( i=0 ; i<2 ; i++ ) {
2994:  MOVLB  1
2996:  CLRF   x1B
2998:  MOVF   x1B,W
299A:  SUBLW  01
299C:  BTFSS  FD8.0
299E:  BRA    2A9E
.................... 		if ( 255 == timers.led_blink[i] ) {
29A0:  CLRF   03
29A2:  MOVF   x1B,W
29A4:  ADDLW  D0
29A6:  MOVWF  FE9
29A8:  MOVLW  00
29AA:  ADDWFC 03,W
29AC:  MOVWF  FEA
29AE:  MOVF   FEF,W
29B0:  SUBLW  FF
29B2:  BNZ   29C2
.................... 			led_on(i);
29B4:  MOVFF  11B,11C
29B8:  MOVLB  0
29BA:  CALL   197A
.................... 		} else if ( 0 == timers.led_blink[i] ) {
29BE:  BRA    2A98
29C0:  MOVLB  1
29C2:  CLRF   03
29C4:  MOVF   x1B,W
29C6:  ADDLW  D0
29C8:  MOVWF  FE9
29CA:  MOVLW  00
29CC:  ADDWFC 03,W
29CE:  MOVWF  FEA
29D0:  MOVF   FEF,W
29D2:  BNZ   29E2
.................... 			led_off(i);
29D4:  MOVFF  11B,11C
29D8:  MOVLB  0
29DA:  CALL   198E
.................... 		} else {
29DE:  BRA    2A98
29E0:  MOVLB  1
.................... 			/* led_blink[i] is somewhere between 1 and 254 */
.................... 			if ( timers.led_on[i] > 0 ) {
29E2:  CLRF   03
29E4:  MOVF   x1B,W
29E6:  ADDLW  D2
29E8:  MOVWF  FE9
29EA:  MOVLW  00
29EC:  ADDWFC 03,W
29EE:  MOVWF  FEA
29F0:  MOVF   FEF,F
29F2:  BZ    2A34
.................... 				led_on(i);
29F4:  MOVFF  11B,11C
29F8:  MOVLB  0
29FA:  CALL   197A
.................... 				timers.led_on[i]--;
29FE:  CLRF   03
2A00:  MOVLB  1
2A02:  MOVF   x1B,W
2A04:  ADDLW  D2
2A06:  MOVWF  FE9
2A08:  MOVLW  00
2A0A:  ADDWFC 03,W
2A0C:  MOVWF  FEA
2A0E:  DECF   FEF,F
.................... 
.................... 				if ( 0==timers.led_on[i] ) {
2A10:  CLRF   03
2A12:  MOVF   x1B,W
2A14:  ADDLW  D2
2A16:  MOVWF  FE9
2A18:  MOVLW  00
2A1A:  ADDWFC 03,W
2A1C:  MOVWF  FEA
2A1E:  MOVF   FEF,W
2A20:  BNZ   2A34
.................... 					/* hit zero, switch to our off timer */
.................... 					timers.led_off[i]=BLINK_OFF_TIME;
2A22:  CLRF   03
2A24:  MOVF   x1B,W
2A26:  ADDLW  D4
2A28:  MOVWF  FE9
2A2A:  MOVLW  00
2A2C:  ADDWFC 03,W
2A2E:  MOVWF  FEA
2A30:  MOVLW  C8
2A32:  MOVWF  FEF
.................... 				}
.................... 			}
.................... 
.................... 			if ( timers.led_off[i] > 0 ) {
2A34:  CLRF   03
2A36:  MOVF   x1B,W
2A38:  ADDLW  D4
2A3A:  MOVWF  FE9
2A3C:  MOVLW  00
2A3E:  ADDWFC 03,W
2A40:  MOVWF  FEA
2A42:  MOVF   FEF,F
2A44:  BZ    2A96
.................... 				led_off(i);
2A46:  MOVFF  11B,11C
2A4A:  MOVLB  0
2A4C:  CALL   198E
.................... 				timers.led_off[i]--;
2A50:  CLRF   03
2A52:  MOVLB  1
2A54:  MOVF   x1B,W
2A56:  ADDLW  D4
2A58:  MOVWF  FE9
2A5A:  MOVLW  00
2A5C:  ADDWFC 03,W
2A5E:  MOVWF  FEA
2A60:  DECF   FEF,F
.................... 
.................... 				if ( 0==timers.led_off[i] ) {
2A62:  CLRF   03
2A64:  MOVF   x1B,W
2A66:  ADDLW  D4
2A68:  MOVWF  FE9
2A6A:  MOVLW  00
2A6C:  ADDWFC 03,W
2A6E:  MOVWF  FEA
2A70:  MOVF   FEF,W
2A72:  BNZ   2A96
.................... 					/* hit zero, preload for next */
.................... 					timers.led_on[i]=BLINK_ON_TIME;
2A74:  CLRF   03
2A76:  MOVF   x1B,W
2A78:  ADDLW  D2
2A7A:  MOVWF  FE9
2A7C:  MOVLW  00
2A7E:  ADDWFC 03,W
2A80:  MOVWF  FEA
2A82:  MOVLW  FE
2A84:  MOVWF  FEF
.................... 					/* done with this blink cycle */	
.................... 					timers.led_blink[i]--;
2A86:  CLRF   03
2A88:  MOVF   x1B,W
2A8A:  ADDLW  D0
2A8C:  MOVWF  FE9
2A8E:  MOVLW  00
2A90:  ADDWFC 03,W
2A92:  MOVWF  FEA
2A94:  DECF   FEF,F
2A96:  MOVLB  0
.................... 				}
.................... 			}
.................... 		}
2A98:  MOVLB  1
2A9A:  INCF   x1B,F
2A9C:  BRA    2998
.................... 	}
.................... 
.................... 
.................... 	/* some other random stuff that we don't need to do every cycle in main */
.................... 	if ( current.interval_milliseconds < 65535 ) {
2A9E:  MOVLB  0
2AA0:  INCFSZ xC8,W
2AA2:  BRA    2AAA
2AA4:  INCFSZ xC9,W
2AA6:  BRA    2AAA
2AA8:  BRA    2AB0
.................... 		current.interval_milliseconds++;
2AAA:  INCF   xC8,F
2AAC:  BTFSC  FD8.2
2AAE:  INCF   xC9,F
.................... 	}
.................... 
.................... 
.................... 	/* contactor timeout */
.................... 	if ( 0 == timers.contactor_powersave[0] ) {
2AB0:  MOVF   xD8,F
2AB2:  BNZ   2ABE
.................... 		output_low(BRIDGE_A_A);
2AB4:  BCF    F94.3
2AB6:  BCF    F8B.3
.................... 		output_low(BRIDGE_A_B);
2AB8:  BCF    F94.4
2ABA:  BCF    F8B.4
.................... 	} else {
2ABC:  BRA    2AC0
.................... 		timers.contactor_powersave[0]--;
2ABE:  DECF   xD8,F
.................... 	}
.................... 	if ( 0 == timers.contactor_powersave[1] ) {
2AC0:  MOVF   xD9,F
2AC2:  BNZ   2ACE
.................... 		output_low(BRIDGE_B_A);
2AC4:  BCF    F94.5
2AC6:  BCF    F8B.5
.................... 		output_low(BRIDGE_B_B);
2AC8:  BCF    F94.6
2ACA:  BCF    F8B.6
.................... 	} else {
2ACC:  BRA    2AD0
.................... 		timers.contactor_powersave[1]--;
2ACE:  DECF   xD9,F
.................... 	}
.................... 
.................... 
.................... 
.................... 
.................... 	/* seconds */
.................... 	ticks++;
2AD0:  MOVLB  1
2AD2:  INCF   x16,F
2AD4:  BTFSC  FD8.2
2AD6:  INCF   x17,F
.................... 	if ( 1000 == ticks ) {
2AD8:  MOVF   x16,W
2ADA:  SUBLW  E8
2ADC:  BNZ   2B3E
2ADE:  MOVF   x17,W
2AE0:  SUBLW  03
2AE2:  BNZ   2B3E
.................... 		ticks=0;
2AE4:  CLRF   x17
2AE6:  CLRF   x16
.................... 
.................... 		/* set channe[n].state based on logic */
.................... 		contactor_logic(0);
2AE8:  CLRF   x1C
2AEA:  MOVLB  0
2AEC:  CALL   19A2
.................... 		contactor_logic(1);
2AF0:  MOVLW  01
2AF2:  MOVLB  1
2AF4:  MOVWF  x1C
2AF6:  MOVLB  0
2AF8:  CALL   19A2
.................... 
.................... 		/* set contactor outputs based on their state bit field */
.................... 		contactor_set(0);
2AFC:  MOVLB  1
2AFE:  CLRF   x1C
2B00:  MOVLB  0
2B02:  RCALL  283E
.................... 		contactor_set(1);		
2B04:  MOVLW  01
2B06:  MOVLB  1
2B08:  MOVWF  x1C
2B0A:  MOVLB  0
2B0C:  RCALL  283E
.................... 
.................... 		/* uptime counter */
.................... 		uptimeTicks++;
2B0E:  MOVLB  1
2B10:  INCF   x12,F
.................... 		if ( 60 == uptimeTicks ) {
2B12:  MOVF   x12,W
2B14:  SUBLW  3C
2B16:  BNZ   2B2E
.................... 			uptimeTicks=0;
2B18:  CLRF   x12
.................... 			if ( current.uptime_minutes < 65535 ) 
2B1A:  MOVLB  0
2B1C:  INCFSZ xC6,W
2B1E:  BRA    2B26
2B20:  INCFSZ xC7,W
2B22:  BRA    2B26
2B24:  BRA    2B2C
.................... 				current.uptime_minutes++;
2B26:  INCF   xC6,F
2B28:  BTFSC  FD8.2
2B2A:  INCF   xC7,F
2B2C:  MOVLB  1
.................... 		}
.................... 
.................... 		/* LED status update every 4 seconds */
.................... 		statusTicks++;
2B2E:  INCF   x13,F
.................... 		if ( 4 == statusTicks ) {
2B30:  MOVF   x13,W
2B32:  SUBLW  04
2B34:  BNZ   2B3E
.................... 			/* LED state display update */
.................... 			statusTicks=0;
2B36:  CLRF   x13
.................... 			led_status_update();
2B38:  MOVLB  0
2B3A:  BRA    28A2
2B3C:  MOVLB  1
.................... 		}
.................... 
.................... 
.................... 	}
.................... 
.................... 	/* ADC sample counter */
.................... 	if ( timers.now_adc_reset_count ) {
2B3E:  MOVLB  0
2B40:  BTFSS  xCF.1
2B42:  BRA    2B4E
.................... 		timers.now_adc_reset_count=0;
2B44:  BCF    xCF.1
.................... 		adcTicks=0;
2B46:  MOVLB  1
2B48:  CLRF   x15
2B4A:  CLRF   x14
2B4C:  MOVLB  0
.................... 	}
.................... 
.................... 	/* ADC sampling trigger */
.................... 	adcTicks++;
2B4E:  MOVLB  1
2B50:  INCF   x14,F
2B52:  BTFSC  FD8.2
2B54:  INCF   x15,F
.................... 	if ( ADC_SAMPLE_TICKS == adcTicks ) {
2B56:  MOVF   x14,W
2B58:  SUBLW  14
2B5A:  BNZ   2B6A
2B5C:  MOVF   x15,F
2B5E:  BNZ   2B6A
.................... 		adcTicks=0;
2B60:  CLRF   x15
2B62:  CLRF   x14
.................... 		timers.now_adc_sample=1;
2B64:  MOVLB  0
2B66:  BSF    xCF.0
2B68:  MOVLB  1
.................... 	}
2B6A:  MOVLB  0
2B6C:  GOTO   2F6A (RETURN)
.................... 
.................... }
.................... 
.................... void init(void) {
.................... 	int8 i;
.................... 	int8 buff[10];
.................... 	setup_oscillator(OSC_16MHZ);
*
1100:  MOVLW  70
1102:  MOVWF  FD3
1104:  BCF    F9B.6
1106:  BCF    F9B.7
.................... 
.................... 	setup_adc(ADC_CLOCK_DIV_16);
1108:  MOVF   FC0,W
110A:  ANDLW  C0
110C:  IORLW  05
110E:  MOVWF  FC0
1110:  BSF    FC0.7
1112:  BSF    FC2.0
.................... 	/* NTC thermistor on sAN2, input voltage divider on sAN4, DIP switch analog on sAN9
.................... 	voltage spans between 0 and Vdd */
.................... 	setup_adc_ports(sAN2 | sAN4 | sAN9,VSS_VDD);
1114:  MOVLW  14
1116:  MOVWF  F7E
1118:  BCF    FC1.0
111A:  BCF    FC1.1
111C:  BCF    FC1.2
111E:  BCF    FC1.3
1120:  MOVLW  02
1122:  MOVWF  F7F
.................... 
.................... 	setup_wdt(WDT_512MS); /* forces the fuse to WDT128 */
1124:  BSF    FD1.0
.................... 
.................... 	set_tris_a(0b00111111);
1126:  MOVLW  3F
1128:  MOVWF  F92
.................... 	set_tris_b(0b01110000);
112A:  MOVLW  70
112C:  MOVWF  F93
.................... 	set_tris_c(0b10000001);
112E:  MOVLW  81
1130:  MOVWF  F94
.................... //               76543210
.................... 
.................... 	port_a_pullups(0b00110000);
1132:  MOVLW  30
1134:  MOVWF  F77
1136:  BCF    FF1.7
.................... 	port_b_pullups(0b00000000);
1138:  CLRF   F78
.................... //                   76543210
.................... 
.................... 	/* data structure initialization */
.................... 	/* all initialized to 0 on declaration. Just do this if need non-zero */
.................... 	for ( i=0 ; i<=1 ; i++ ) {
113A:  MOVLB  1
113C:  CLRF   x1B
113E:  MOVF   x1B,W
1140:  SUBLW  01
1142:  BNC   1198
.................... 		channel[i].command_off_seconds=65535;
1144:  MOVF   x1B,W
1146:  MULLW  19
1148:  MOVF   FF3,W
114A:  CLRF   x27
114C:  MOVWF  x26
114E:  MOVLW  05
1150:  ADDWF  x26,W
1152:  MOVWF  01
1154:  MOVLW  00
1156:  ADDWFC x27,W
1158:  MOVWF  03
115A:  MOVF   01,W
115C:  ADDLW  DA
115E:  MOVWF  FE9
1160:  MOVLW  00
1162:  ADDWFC 03,W
1164:  MOVWF  FEA
1166:  SETF   FEC
1168:  MOVF   FED,F
116A:  SETF   FEF
.................... 		channel[i].command_on_seconds =65535;
116C:  MOVF   x1B,W
116E:  MULLW  19
1170:  MOVF   FF3,W
1172:  CLRF   x27
1174:  MOVWF  x26
1176:  MOVLW  01
1178:  ADDWF  x26,W
117A:  MOVWF  01
117C:  MOVLW  00
117E:  ADDWFC x27,W
1180:  MOVWF  03
1182:  MOVF   01,W
1184:  ADDLW  DA
1186:  MOVWF  FE9
1188:  MOVLW  00
118A:  ADDWFC 03,W
118C:  MOVWF  FEA
118E:  SETF   FEC
1190:  MOVF   FED,F
1192:  SETF   FEF
1194:  INCF   x1B,F
1196:  BRA    113E
.................... 	}
.................... 
.................... 	/* get our compiled date from constant  
.................... 	'5-Feb-22'
.................... 	 01234567
.................... 
.................... 	'25-Feb-22'
.................... 	 012345678
.................... 	*/
.................... 	strcpy(buff,__DATE__);
1198:  MOVLW  01
119A:  MOVWF  FEA
119C:  MOVLW  1C
119E:  MOVWF  FE9
11A0:  MOVLW  00
11A2:  MOVLB  0
11A4:  CALL   00BA
11A8:  TBLRD*-
11AA:  TBLRD*+
11AC:  MOVF   FF5,W
11AE:  MOVWF  FEE
11B0:  IORLW  00
11B2:  BNZ   11AA
.................... 	i=0;
11B4:  MOVLB  1
11B6:  CLRF   x1B
.................... 	if ( '-' != buff[1] ) {
11B8:  MOVF   x1D,W
11BA:  SUBLW  2D
11BC:  BZ    11DC
.................... 		/* day can be one or two digits */
.................... 		current.compile_day =(buff[i]-'0')*10;
11BE:  CLRF   03
11C0:  MOVF   x1B,W
11C2:  ADDLW  1C
11C4:  MOVWF  FE9
11C6:  MOVLW  01
11C8:  ADDWFC 03,W
11CA:  MOVWF  FEA
11CC:  MOVLW  30
11CE:  SUBWF  FEF,W
11D0:  MULLW  0A
11D2:  MOVFF  FF3,CD
11D6:  MOVLB  0
.................... 		i++;
11D8:  MOVLB  1
11DA:  INCF   x1B,F
.................... 	}
.................... 	current.compile_day+=(buff[i]-'0');
11DC:  CLRF   03
11DE:  MOVF   x1B,W
11E0:  ADDLW  1C
11E2:  MOVWF  FE9
11E4:  MOVLW  01
11E6:  ADDWFC 03,W
11E8:  MOVWF  FEA
11EA:  MOVLW  30
11EC:  SUBWF  FEF,W
11EE:  MOVLB  0
11F0:  ADDWF  xCD,F
.................... 	i+=2; /* now points to month */
11F2:  MOVLW  02
11F4:  MOVLB  1
11F6:  ADDWF  x1B,F
.................... 
.................... 	/* determine month ... how annoying */
.................... 	if ( 'J'==buff[i+0] ) {
11F8:  CLRF   03
11FA:  MOVF   x1B,W
11FC:  ADDLW  1C
11FE:  MOVWF  FE9
1200:  MOVLW  01
1202:  ADDWFC 03,W
1204:  MOVWF  FEA
1206:  MOVF   FEF,W
1208:  SUBLW  4A
120A:  BNZ   1256
.................... 		if ( 'A'==buff[i+1] )
120C:  MOVLW  01
120E:  ADDWF  x1B,W
1210:  CLRF   03
1212:  ADDLW  1C
1214:  MOVWF  FE9
1216:  MOVLW  01
1218:  ADDWFC 03,W
121A:  MOVWF  FEA
121C:  MOVF   FEF,W
121E:  SUBLW  41
1220:  BNZ   122C
.................... 			current.compile_month=1;
1222:  MOVLW  01
1224:  MOVLB  0
1226:  MOVWF  xCC
1228:  BRA    1252
122A:  MOVLB  1
.................... 		else if ( 'N'==buff[i+2] )
122C:  MOVLW  02
122E:  ADDWF  x1B,W
1230:  CLRF   03
1232:  ADDLW  1C
1234:  MOVWF  FE9
1236:  MOVLW  01
1238:  ADDWFC 03,W
123A:  MOVWF  FEA
123C:  MOVF   FEF,W
123E:  SUBLW  4E
1240:  BNZ   124C
.................... 			current.compile_month=6;
1242:  MOVLW  06
1244:  MOVLB  0
1246:  MOVWF  xCC
1248:  BRA    1252
124A:  MOVLB  1
.................... 		else
.................... 			current.compile_month=7;
124C:  MOVLW  07
124E:  MOVLB  0
1250:  MOVWF  xCC
.................... 	} else if ( 'A'==buff[i+0] ) {
1252:  BRA    136C
1254:  MOVLB  1
1256:  CLRF   03
1258:  MOVF   x1B,W
125A:  ADDLW  1C
125C:  MOVWF  FE9
125E:  MOVLW  01
1260:  ADDWFC 03,W
1262:  MOVWF  FEA
1264:  MOVF   FEF,W
1266:  SUBLW  41
1268:  BNZ   1294
.................... 		if ( 'P'==buff[i+1] )
126A:  MOVLW  01
126C:  ADDWF  x1B,W
126E:  CLRF   03
1270:  ADDLW  1C
1272:  MOVWF  FE9
1274:  MOVLW  01
1276:  ADDWFC 03,W
1278:  MOVWF  FEA
127A:  MOVF   FEF,W
127C:  SUBLW  50
127E:  BNZ   128A
.................... 			current.compile_month=4;
1280:  MOVLW  04
1282:  MOVLB  0
1284:  MOVWF  xCC
1286:  BRA    1290
1288:  MOVLB  1
.................... 		else
.................... 			current.compile_month=8;
128A:  MOVLW  08
128C:  MOVLB  0
128E:  MOVWF  xCC
.................... 	} else if ( 'M'==buff[i+0] ) {
1290:  BRA    136C
1292:  MOVLB  1
1294:  CLRF   03
1296:  MOVF   x1B,W
1298:  ADDLW  1C
129A:  MOVWF  FE9
129C:  MOVLW  01
129E:  ADDWFC 03,W
12A0:  MOVWF  FEA
12A2:  MOVF   FEF,W
12A4:  SUBLW  4D
12A6:  BNZ   12D2
.................... 		if ( 'R'==buff[i+2] )
12A8:  MOVLW  02
12AA:  ADDWF  x1B,W
12AC:  CLRF   03
12AE:  ADDLW  1C
12B0:  MOVWF  FE9
12B2:  MOVLW  01
12B4:  ADDWFC 03,W
12B6:  MOVWF  FEA
12B8:  MOVF   FEF,W
12BA:  SUBLW  52
12BC:  BNZ   12C8
.................... 			current.compile_month=3;
12BE:  MOVLW  03
12C0:  MOVLB  0
12C2:  MOVWF  xCC
12C4:  BRA    12CE
12C6:  MOVLB  1
.................... 		else
.................... 			current.compile_month=5;
12C8:  MOVLW  05
12CA:  MOVLB  0
12CC:  MOVWF  xCC
.................... 	} else if ( 'F'==buff[i+0] ) {
12CE:  BRA    136C
12D0:  MOVLB  1
12D2:  CLRF   03
12D4:  MOVF   x1B,W
12D6:  ADDLW  1C
12D8:  MOVWF  FE9
12DA:  MOVLW  01
12DC:  ADDWFC 03,W
12DE:  MOVWF  FEA
12E0:  MOVF   FEF,W
12E2:  SUBLW  46
12E4:  BNZ   12F0
.................... 		current.compile_month=2;
12E6:  MOVLW  02
12E8:  MOVLB  0
12EA:  MOVWF  xCC
.................... 	} else if ( 'S'==buff[i+0] ) {
12EC:  BRA    136C
12EE:  MOVLB  1
12F0:  CLRF   03
12F2:  MOVF   x1B,W
12F4:  ADDLW  1C
12F6:  MOVWF  FE9
12F8:  MOVLW  01
12FA:  ADDWFC 03,W
12FC:  MOVWF  FEA
12FE:  MOVF   FEF,W
1300:  SUBLW  53
1302:  BNZ   130E
.................... 		current.compile_month=9;
1304:  MOVLW  09
1306:  MOVLB  0
1308:  MOVWF  xCC
.................... 	} else if ( 'O'==buff[i+0] ) {
130A:  BRA    136C
130C:  MOVLB  1
130E:  CLRF   03
1310:  MOVF   x1B,W
1312:  ADDLW  1C
1314:  MOVWF  FE9
1316:  MOVLW  01
1318:  ADDWFC 03,W
131A:  MOVWF  FEA
131C:  MOVF   FEF,W
131E:  SUBLW  4F
1320:  BNZ   132C
.................... 		current.compile_month=10;
1322:  MOVLW  0A
1324:  MOVLB  0
1326:  MOVWF  xCC
.................... 	} else if ( 'N'==buff[i+0] ) {
1328:  BRA    136C
132A:  MOVLB  1
132C:  CLRF   03
132E:  MOVF   x1B,W
1330:  ADDLW  1C
1332:  MOVWF  FE9
1334:  MOVLW  01
1336:  ADDWFC 03,W
1338:  MOVWF  FEA
133A:  MOVF   FEF,W
133C:  SUBLW  4E
133E:  BNZ   134A
.................... 		current.compile_month=11;
1340:  MOVLW  0B
1342:  MOVLB  0
1344:  MOVWF  xCC
.................... 	} else if ( 'D'==buff[i+0] ) {
1346:  BRA    136C
1348:  MOVLB  1
134A:  CLRF   03
134C:  MOVF   x1B,W
134E:  ADDLW  1C
1350:  MOVWF  FE9
1352:  MOVLW  01
1354:  ADDWFC 03,W
1356:  MOVWF  FEA
1358:  MOVF   FEF,W
135A:  SUBLW  44
135C:  BNZ   1368
.................... 		current.compile_month=12;
135E:  MOVLW  0C
1360:  MOVLB  0
1362:  MOVWF  xCC
.................... 	} else {
1364:  BRA    136C
1366:  MOVLB  1
.................... 		/* error parsing, shouldn't happen */
.................... 		current.compile_month=255;
1368:  MOVLB  0
136A:  SETF   xCC
.................... 	}
.................... 	current.compile_year =(buff[i+4]-'0')*10;
136C:  MOVLW  04
136E:  MOVLB  1
1370:  ADDWF  x1B,W
1372:  CLRF   03
1374:  ADDLW  1C
1376:  MOVWF  FE9
1378:  MOVLW  01
137A:  ADDWFC 03,W
137C:  MOVWF  FEA
137E:  MOVLW  30
1380:  SUBWF  FEF,W
1382:  MULLW  0A
1384:  MOVFF  FF3,CB
1388:  MOVLB  0
.................... 	current.compile_year+=(buff[i+5]-'0');
138A:  MOVLW  05
138C:  MOVLB  1
138E:  ADDWF  x1B,W
1390:  CLRF   03
1392:  ADDLW  1C
1394:  MOVWF  FE9
1396:  MOVLW  01
1398:  ADDWFC 03,W
139A:  MOVWF  FEA
139C:  MOVLW  30
139E:  SUBWF  FEF,W
13A0:  MOVLB  0
13A2:  ADDWF  xCB,F
.................... 
.................... 
.................... 	/* one periodic interrupt @ 1mS. Generated from system 16 MHz clock */
.................... 	/* prescale=16, match=249, postscale=1. Match is 249 because when match occurs, one cycle is lost */
.................... 	setup_timer_2(T2_DIV_BY_16,249,1);
13A4:  MOVLW  00
13A6:  IORLW  06
13A8:  MOVWF  FCA
13AA:  MOVLW  F9
13AC:  MOVWF  FCB
.................... 
.................... 	enable_interrupts(INT_TIMER2);
13AE:  BSF    F9D.1
.................... 
.................... 	/* set I2C slave address, which is always an even number */
.................... 	i2c_slaveaddr(STREAM_SLAVE,0x3e + (read_dip_switch()<<1) );
13B0:  BRA    108E
13B2:  BCF    FD8.0
13B4:  RLCF   01,W
13B6:  ADDLW  3E
13B8:  MOVLB  1
13BA:  MOVWF  FC8
13BC:  MOVLB  0
13BE:  GOTO   2E1A (RETURN)
.................... }
.................... 
.................... 
.................... void main(void) {
*
2D8C:  CLRF   FF8
2D8E:  BCF    FD0.7
2D90:  BSF    07.7
2D92:  BSF    F93.6
2D94:  BSF    F93.4
2D96:  CLRF   FC8
2D98:  MOVLW  36
2D9A:  MOVWF  FC6
2D9C:  BSF    FC5.0
2D9E:  BSF    FC5.7
2DA0:  CLRF   1A
2DA2:  BSF    FB8.3
2DA4:  MOVLW  44
2DA6:  MOVWF  FAF
2DA8:  MOVLW  00
2DAA:  MOVWF  FB0
2DAC:  MOVLW  A6
2DAE:  MOVWF  FAC
2DB0:  MOVLW  90
2DB2:  MOVWF  FAB
2DB4:  MOVLB  1
2DB6:  CLRF   x19
2DB8:  CLRF   x18
2DBA:  MOVLW  00
2DBC:  MOVWF  F7E
2DBE:  BCF    FC1.0
2DC0:  BCF    FC1.1
2DC2:  BCF    FC1.2
2DC4:  BCF    FC1.3
2DC6:  MOVWF  F7F
2DC8:  CLRF   F6C
2DCA:  CLRF   F6B
2DCC:  CLRF   F6D
2DCE:  BRA    2DD6
2DD0:  DATA FD,40
2DD2:  DATA 1B,00
2DD4:  DATA 00,00
2DD6:  MOVLW  00
2DD8:  MOVWF  FF8
2DDA:  MOVLW  2D
2DDC:  MOVWF  FF7
2DDE:  MOVLW  D0
2DE0:  MOVWF  FF6
2DE2:  TBLRD*+
2DE4:  MOVF   FF5,W
2DE6:  MOVWF  00
2DE8:  XORLW  00
2DEA:  BZ    2E12
2DEC:  TBLRD*+
2DEE:  MOVF   FF5,W
2DF0:  MOVWF  01
2DF2:  BTFSC  FE8.7
2DF4:  BRA    2E00
2DF6:  ANDLW  3F
2DF8:  MOVWF  FEA
2DFA:  TBLRD*+
2DFC:  MOVFF  FF5,FE9
2E00:  BTFSC  01.6
2E02:  TBLRD*+
2E04:  BTFSS  01.6
2E06:  TBLRD*+
2E08:  MOVFF  FF5,FEE
2E0C:  DCFSNZ 00,F
2E0E:  BRA    2DE2
2E10:  BRA    2E04
2E12:  CLRF   FF8
.................... 	int8 i;
.................... 
.................... 	init();
2E14:  MOVLB  0
2E16:  GOTO   1100
.................... 
.................... 	/* force off both contactors */
.................... 	timers.contactor[0]=1;
2E1A:  MOVLW  01
2E1C:  MOVWF  xD6
.................... 	timers.contactor[1]=1;
2E1E:  MOVWF  xD7
.................... 	contactor_off(0);
2E20:  MOVLB  1
2E22:  CLRF   x1E
2E24:  MOVLB  0
2E26:  CALL   13C2
.................... 	contactor_off(1);
2E2A:  MOVLW  01
2E2C:  MOVLB  1
2E2E:  MOVWF  x1E
2E30:  MOVLB  0
2E32:  CALL   13C2
.................... 
.................... 
.................... 	/* read parameters from EEPROM and write defaults if CRC doesn't match */
.................... 	read_param_file();
2E36:  GOTO   1846
.................... 
.................... 
.................... 	/* flash on startup */
.................... 	for ( i=0 ; i<5 ; i++ ) {
2E3A:  MOVLB  1
2E3C:  CLRF   x1A
2E3E:  MOVF   x1A,W
2E40:  SUBLW  04
2E42:  BNC   2E6A
.................... 		restart_wdt();
2E44:  CLRWDT
.................... 		output_high(LED_A);
2E46:  BCF    F94.1
2E48:  BSF    F8B.1
.................... 		delay_ms(200);
2E4A:  MOVLW  C8
2E4C:  MOVWF  x28
2E4E:  MOVLB  0
2E50:  CALL   1064
.................... 		output_low(LED_A);
2E54:  BCF    F94.1
2E56:  BCF    F8B.1
.................... 		delay_ms(200);
2E58:  MOVLW  C8
2E5A:  MOVLB  1
2E5C:  MOVWF  x28
2E5E:  MOVLB  0
2E60:  CALL   1064
2E64:  MOVLB  1
2E66:  INCF   x1A,F
2E68:  BRA    2E3E
.................... 	}
.................... 
.................... 	fprintf(STREAM_FTDI,"# dcswc_module_latching_contactor %s\r\n# ",__DATE__);
2E6A:  MOVLW  B8
2E6C:  MOVWF  FF6
2E6E:  MOVLW  0F
2E70:  MOVWF  FF7
2E72:  MOVLW  22
2E74:  MOVWF  x1D
2E76:  MOVLB  0
2E78:  CALL   188C
2E7C:  MOVLW  E2
2E7E:  MOVWF  FF6
2E80:  MOVLW  0F
2E82:  MOVWF  FF7
2E84:  CALL   18B6
2E88:  MOVLW  DC
2E8A:  MOVWF  FF6
2E8C:  MOVLW  0F
2E8E:  MOVWF  FF7
2E90:  MOVLW  04
2E92:  MOVLB  1
2E94:  MOVWF  x1D
2E96:  MOVLB  0
2E98:  CALL   188C
.................... 	switch ( restart_cause ) {
2E9C:  MOVLW  07
2E9E:  SUBWF  00,W
2EA0:  BZ    2EC6
2EA2:  MOVLW  0B
2EA4:  SUBWF  00,W
2EA6:  BZ    2ED4
2EA8:  MOVLW  0F
2EAA:  SUBWF  00,W
2EAC:  BZ    2EE2
2EAE:  MOVLW  0C
2EB0:  SUBWF  00,W
2EB2:  BZ    2EF0
2EB4:  MOVLW  0E
2EB6:  SUBWF  00,W
2EB8:  BZ    2EFE
2EBA:  MOVLW  03
2EBC:  SUBWF  00,W
2EBE:  BZ    2F0C
2EC0:  MOVF   00,F
2EC2:  BZ    2F1A
2EC4:  BRA    2F28
.................... 		case WDT_TIMEOUT:       fprintf(STREAM_FTDI,"WDT TIMEOUT"); break;
2EC6:  MOVLW  EC
2EC8:  MOVWF  FF6
2ECA:  MOVLW  0F
2ECC:  MOVWF  FF7
2ECE:  CALL   18B6
2ED2:  BRA    2F34
.................... 		case MCLR_FROM_SLEEP:   fprintf(STREAM_FTDI,"MCLR FROM SLEEP"); break;
2ED4:  MOVLW  F8
2ED6:  MOVWF  FF6
2ED8:  MOVLW  0F
2EDA:  MOVWF  FF7
2EDC:  CALL   18B6
2EE0:  BRA    2F34
.................... 		case MCLR_FROM_RUN:     fprintf(STREAM_FTDI,"MCLR FROM RUN"); break;
2EE2:  MOVLW  08
2EE4:  MOVWF  FF6
2EE6:  MOVLW  10
2EE8:  MOVWF  FF7
2EEA:  CALL   18B6
2EEE:  BRA    2F34
.................... 		case NORMAL_POWER_UP:   fprintf(STREAM_FTDI,"NORMAL POWER UP"); break;
2EF0:  MOVLW  16
2EF2:  MOVWF  FF6
2EF4:  MOVLW  10
2EF6:  MOVWF  FF7
2EF8:  CALL   18B6
2EFC:  BRA    2F34
.................... 		case BROWNOUT_RESTART:  fprintf(STREAM_FTDI,"BROWNOUT RESTART"); break;
2EFE:  MOVLW  26
2F00:  MOVWF  FF6
2F02:  MOVLW  10
2F04:  MOVWF  FF7
2F06:  CALL   18B6
2F0A:  BRA    2F34
.................... 		case WDT_FROM_SLEEP:    fprintf(STREAM_FTDI,"WDT FROM SLEEP"); break;
2F0C:  MOVLW  38
2F0E:  MOVWF  FF6
2F10:  MOVLW  10
2F12:  MOVWF  FF7
2F14:  CALL   18B6
2F18:  BRA    2F34
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_FTDI,"RESET INSTRUCTION"); break;
2F1A:  MOVLW  48
2F1C:  MOVWF  FF6
2F1E:  MOVLW  10
2F20:  MOVWF  FF7
2F22:  CALL   18B6
2F26:  BRA    2F34
.................... 		default:                fprintf(STREAM_FTDI,"UNKNOWN!");
2F28:  MOVLW  5A
2F2A:  MOVWF  FF6
2F2C:  MOVLW  10
2F2E:  MOVWF  FF7
2F30:  CALL   18B6
.................... 	}
.................... 	fprintf(STREAM_FTDI,"\r\n");
2F34:  MOVLW  0D
2F36:  BTFSS  F9E.4
2F38:  BRA    2F36
2F3A:  MOVWF  FAD
2F3C:  MOVLW  0A
2F3E:  BTFSS  F9E.4
2F40:  BRA    2F3E
2F42:  MOVWF  FAD
.................... 
.................... 	enable_interrupts(GLOBAL);
2F44:  MOVLW  C0
2F46:  IORWF  FF2,F
.................... 
.................... 	/* Prime ADC filter */
.................... 	for ( i=0 ; i<30 ; i++ ) {
2F48:  MOVLB  1
2F4A:  CLRF   x1A
2F4C:  MOVF   x1A,W
2F4E:  SUBLW  1D
2F50:  BNC   2F5E
.................... 		adc_update();
2F52:  MOVLB  0
2F54:  CALL   18D8
2F58:  MOVLB  1
2F5A:  INCF   x1A,F
2F5C:  BRA    2F4C
.................... 	}
.................... 
.................... 
.................... 	/* enable I2C slave interrupt */
.................... 	enable_interrupts(INT_SSP);
2F5E:  BSF    F9D.3
.................... 
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
2F60:  CLRWDT
.................... 
.................... 		if ( timers.now_millisecond ) {
2F62:  MOVLB  0
2F64:  BTFSS  xCF.2
2F66:  BRA    2F6A
.................... 			periodic_millisecond();
2F68:  BRA    2992
.................... 		}
.................... 
.................... 		if ( kbhit() ) {
2F6A:  BTFSS  F9E.5
2F6C:  BRA    2F72
.................... 			getc();
2F6E:  BRA    2B70
.................... 			timers.now_debug_dump=1;
2F70:  BSF    xCF.5
.................... 		}
.................... 
.................... 		if ( timers.now_debug_dump ) {
2F72:  BTFSS  xCF.5
2F74:  BRA    2F7A
.................... 			timers.now_debug_dump=0;
2F76:  BCF    xCF.5
.................... 
.................... 			debug_dump();
2F78:  BRA    2C80
.................... 		}
.................... 
.................... 		if ( timers.now_adc_sample ) {
2F7A:  BTFSS  xCF.0
2F7C:  BRA    2F84
.................... 			timers.now_adc_sample=0;
2F7E:  BCF    xCF.0
.................... 			adc_update();
2F80:  CALL   18D8
.................... 		}
.................... 
.................... 		if ( timers.now_write_config ) {
2F84:  BTFSS  xCF.3
2F86:  BRA    2F8E
.................... 			timers.now_write_config=0;
2F88:  BCF    xCF.3
.................... 			write_param_file();
2F8A:  CALL   1534
.................... 		}
.................... 		if ( timers.now_reset_config ) {
2F8E:  BTFSS  xCF.4
2F90:  BRA    2F98
.................... 			timers.now_reset_config=0;
2F92:  BCF    xCF.4
.................... 			write_default_param_file();
2F94:  CALL   1580
.................... 		}
2F98:  MOVLB  1
2F9A:  BRA    2F60
.................... 
.................... 
.................... 	}
.................... 
.................... 
.................... }
2F9C:  SLEEP 

Configuration Fuses:
   Word  1: 0800   INTRC_IO NOPLLEN NOPCLKEN NOFCMEN NOIESO
   Word  2: 0F07   NOPUT BROWNOUT BORV30 WDT WDT128
   Word  3: 0000   NOHFOFST NOMCLR
   Word  4: 0081   STVREN NOLVP BBSIZ1K NOXINST NODEBUG
   Word  5: C003   NOPROTECT NOCPB NOCPD
   Word  6: E003   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 4003   NOEBTR NOEBTRB

ROM data:
F00000: 00 00 40 00                                        ..@.
