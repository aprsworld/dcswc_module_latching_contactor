CCS PCH C Compiler, Version 5.090, 49113               05-Feb-22 11:24

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\dcswc_module_latching_contactor\dcswc_module_latching_contactor.lst

               ROM used:   7326 bytes (47%)
                           Largest free fragment is 8226
               RAM used:   277 (54%) at main() level
                           321 (63%) worst case
               Stack used: 4 locations (2 in main + 2 for interrupts)
               Stack size: 30

0000:  GOTO   1584
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   00D4
0060:  BTFSS  F9D.3
0062:  GOTO   006C
0066:  BTFSC  F9E.3
0068:  GOTO   031E
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include "dcswc_module_latching_contactor.h"
.................... #include <18F14K22.h>
.................... //////////// Standard Header file for the PIC18F14K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F14K22
00BA:  CLRF   FF7
00BC:  ADDLW  CA
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  RETURN 0
00CA:  DATA 35,2D
00CC:  DATA 46,65
00CE:  DATA 62,2D
00D0:  DATA 32,32
00D2:  DATA 00,00
*
03EC:  DATA 23,20
03EE:  DATA 64,63
03F0:  DATA 73,77
03F2:  DATA 63,5F
03F4:  DATA 6D,6F
03F6:  DATA 64,75
03F8:  DATA 6C,65
03FA:  DATA 5F,6C
03FC:  DATA 61,74
03FE:  DATA 63,68
0400:  DATA 69,6E
0402:  DATA 67,5F
0404:  DATA 63,6F
0406:  DATA 6E,74
0408:  DATA 61,63
040A:  DATA 74,6F
040C:  DATA 72,20
040E:  DATA 25,73
0410:  DATA 0D,0A
0412:  DATA 23,20
0414:  DATA 00,00
0416:  DATA 35,2D
0418:  DATA 46,65
041A:  DATA 62,2D
041C:  DATA 32,32
041E:  DATA 00,00
0420:  DATA 57,44
0422:  DATA 54,20
0424:  DATA 54,49
0426:  DATA 4D,45
0428:  DATA 4F,55
042A:  DATA 54,00
042C:  DATA 4D,43
042E:  DATA 4C,52
0430:  DATA 20,46
0432:  DATA 52,4F
0434:  DATA 4D,20
0436:  DATA 53,4C
0438:  DATA 45,45
043A:  DATA 50,00
043C:  DATA 4D,43
043E:  DATA 4C,52
0440:  DATA 20,46
0442:  DATA 52,4F
0444:  DATA 4D,20
0446:  DATA 52,55
0448:  DATA 4E,00
044A:  DATA 4E,4F
044C:  DATA 52,4D
044E:  DATA 41,4C
0450:  DATA 20,50
0452:  DATA 4F,57
0454:  DATA 45,52
0456:  DATA 20,55
0458:  DATA 50,00
045A:  DATA 42,52
045C:  DATA 4F,57
045E:  DATA 4E,4F
0460:  DATA 55,54
0462:  DATA 20,52
0464:  DATA 45,53
0466:  DATA 54,41
0468:  DATA 52,54
046A:  DATA 00,00
046C:  DATA 57,44
046E:  DATA 54,20
0470:  DATA 46,52
0472:  DATA 4F,4D
0474:  DATA 20,53
0476:  DATA 4C,45
0478:  DATA 45,50
047A:  DATA 00,00
047C:  DATA 52,45
047E:  DATA 53,45
0480:  DATA 54,20
0482:  DATA 49,4E
0484:  DATA 53,54
0486:  DATA 52,55
0488:  DATA 43,54
048A:  DATA 49,4F
048C:  DATA 4E,00
048E:  DATA 55,4E
0490:  DATA 4B,4E
0492:  DATA 4F,57
0494:  DATA 4E,21
0496:  DATA 00,00
0498:  DATA 23,20
049A:  DATA 72,65
049C:  DATA 61,64
049E:  DATA 5F,64
04A0:  DATA 69,70
04A2:  DATA 5F,73
04A4:  DATA 77,69
04A6:  DATA 74,63
04A8:  DATA 68,28
04AA:  DATA 29,3D
04AC:  DATA 25,75
04AE:  DATA 0D,0A
04B0:  DATA 00,00
04B2:  DATA 23,20
04B4:  DATA 20,20
04B6:  DATA 20,76
04B8:  DATA 69,6E
04BA:  DATA 20,61
04BC:  DATA 64,63
04BE:  DATA 3D,25
04C0:  DATA 6C,75
04C2:  DATA 0D,0A
04C4:  DATA 00,00
04C6:  DATA 23,20
04C8:  DATA 20,20
04CA:  DATA 74,65
04CC:  DATA 6D,70
04CE:  DATA 20,61
04D0:  DATA 64,63
04D2:  DATA 3D,25
04D4:  DATA 6C,75
04D6:  DATA 0D,0A
04D8:  DATA 00,00
04DA:  DATA 23,20
04DC:  DATA 64,69
04DE:  DATA 70,20
04E0:  DATA 73,77
04E2:  DATA 20,61
04E4:  DATA 64,63
04E6:  DATA 3D,25
04E8:  DATA 6C,75
04EA:  DATA 0D,0A
04EC:  DATA 00,00
04EE:  DATA 23,20
04F0:  DATA 63,68
04F2:  DATA 61,6E
04F4:  DATA 6E,65
04F6:  DATA 6C,5B
04F8:  DATA 25,75
04FA:  DATA 5D,0D
04FC:  DATA 0A,00
04FE:  DATA 23,20
0500:  DATA 20,20
0502:  DATA 20,20
0504:  DATA 20,20
0506:  DATA 20,20
0508:  DATA 20,20
050A:  DATA 20,20
050C:  DATA 20,20
050E:  DATA 20,20
0510:  DATA 20,20
0512:  DATA 20,20
0514:  DATA 20,20
0516:  DATA 20,73
0518:  DATA 74,61
051A:  DATA 74,65
051C:  DATA 3D,30
051E:  DATA 78,25
0520:  DATA 30,32
0522:  DATA 78,0D
0524:  DATA 0A,00
0526:  DATA 23,20
0528:  DATA 20,20
052A:  DATA 20,20
052C:  DATA 20,20
052E:  DATA 20,20
0530:  DATA 20,20
0532:  DATA 63,6F
0534:  DATA 6D,6D
0536:  DATA 61,6E
0538:  DATA 64,5F
053A:  DATA 6F,6E
053C:  DATA 5F,73
053E:  DATA 65,63
0540:  DATA 6F,6E
0542:  DATA 64,73
0544:  DATA 3D,25
0546:  DATA 6C,75
0548:  DATA 0D,0A
054A:  DATA 00,00
054C:  DATA 23,20
054E:  DATA 20,20
0550:  DATA 20,20
0552:  DATA 20,63
0554:  DATA 6F,6D
0556:  DATA 6D,61
0558:  DATA 6E,64
055A:  DATA 5F,6F
055C:  DATA 6E,5F
055E:  DATA 68,6F
0560:  DATA 6C,64
0562:  DATA 5F,73
0564:  DATA 65,63
0566:  DATA 6F,6E
0568:  DATA 64,73
056A:  DATA 3D,25
056C:  DATA 6C,75
056E:  DATA 0D,0A
0570:  DATA 00,00
0572:  DATA 23,20
0574:  DATA 20,20
0576:  DATA 20,20
0578:  DATA 20,20
057A:  DATA 20,20
057C:  DATA 20,63
057E:  DATA 6F,6D
0580:  DATA 6D,61
0582:  DATA 6E,64
0584:  DATA 5F,6F
0586:  DATA 66,66
0588:  DATA 5F,73
058A:  DATA 65,63
058C:  DATA 6F,6E
058E:  DATA 64,73
0590:  DATA 3D,25
0592:  DATA 6C,75
0594:  DATA 0D,0A
0596:  DATA 00,00
0598:  DATA 23,20
059A:  DATA 20,20
059C:  DATA 20,20
059E:  DATA 63,6F
05A0:  DATA 6D,6D
05A2:  DATA 61,6E
05A4:  DATA 64,5F
05A6:  DATA 6F,66
05A8:  DATA 66,5F
05AA:  DATA 68,6F
05AC:  DATA 6C,64
05AE:  DATA 5F,73
05B0:  DATA 65,63
05B2:  DATA 6F,6E
05B4:  DATA 64,73
05B6:  DATA 3D,25
05B8:  DATA 6C,75
05BA:  DATA 0D,0A
05BC:  DATA 00,00
05BE:  DATA 23,20
05C0:  DATA 6C,76
05C2:  DATA 64,5F
05C4:  DATA 64,69
05C6:  DATA 73,63
05C8:  DATA 6F,6E
05CA:  DATA 6E,65
05CC:  DATA 63,74
05CE:  DATA 5F,64
05D0:  DATA 65,6C
05D2:  DATA 61,79
05D4:  DATA 5F,73
05D6:  DATA 65,63
05D8:  DATA 6F,6E
05DA:  DATA 64,73
05DC:  DATA 3D,25
05DE:  DATA 6C,75
05E0:  DATA 0D,0A
05E2:  DATA 00,00
05E4:  DATA 23,20
05E6:  DATA 20,6C
05E8:  DATA 76,64
05EA:  DATA 5F,72
05EC:  DATA 65,63
05EE:  DATA 6F,6E
05F0:  DATA 6E,65
05F2:  DATA 63,74
05F4:  DATA 5F,64
05F6:  DATA 65,6C
05F8:  DATA 61,79
05FA:  DATA 5F,73
05FC:  DATA 65,63
05FE:  DATA 6F,6E
0600:  DATA 64,73
0602:  DATA 3D,25
0604:  DATA 75,0D
0606:  DATA 0A,00
0608:  DATA 23,20
060A:  DATA 68,76
060C:  DATA 64,5F
060E:  DATA 64,69
0610:  DATA 73,63
0612:  DATA 6F,6E
0614:  DATA 6E,65
0616:  DATA 63,74
0618:  DATA 5F,64
061A:  DATA 65,6C
061C:  DATA 61,79
061E:  DATA 5F,73
0620:  DATA 65,63
0622:  DATA 6F,6E
0624:  DATA 64,73
0626:  DATA 3D,25
0628:  DATA 6C,75
062A:  DATA 0D,0A
062C:  DATA 00,00
062E:  DATA 23,20
0630:  DATA 20,68
0632:  DATA 76,64
0634:  DATA 5F,72
0636:  DATA 65,63
0638:  DATA 6F,6E
063A:  DATA 6E,65
063C:  DATA 63,74
063E:  DATA 5F,64
0640:  DATA 65,6C
0642:  DATA 61,79
0644:  DATA 5F,73
0646:  DATA 65,63
0648:  DATA 6F,6E
064A:  DATA 64,73
064C:  DATA 3D,25
064E:  DATA 75,0D
0650:  DATA 0A,00
*
0B64:  TBLRD*+
0B66:  MOVFF  FF6,116
0B6A:  MOVFF  FF7,117
0B6E:  MOVF   FF5,W
0B70:  BTFSS  F9E.4
0B72:  BRA    0B70
0B74:  MOVWF  FAD
0B76:  MOVFF  116,FF6
0B7A:  MOVFF  117,FF7
0B7E:  MOVLB  1
0B80:  DECFSZ x15,F
0B82:  BRA    0B86
0B84:  BRA    0B8A
0B86:  MOVLB  0
0B88:  BRA    0B64
0B8A:  MOVLB  0
0B8C:  RETURN 0
0B8E:  TBLRD*+
0B90:  MOVF   FF5,F
0B92:  BZ    0BAE
0B94:  MOVFF  FF6,112
0B98:  MOVFF  FF7,113
0B9C:  MOVF   FF5,W
0B9E:  BTFSS  F9E.4
0BA0:  BRA    0B9E
0BA2:  MOVWF  FAD
0BA4:  MOVFF  112,FF6
0BA8:  MOVFF  113,FF7
0BAC:  BRA    0B8E
0BAE:  RETURN 0
*
1380:  MOVLB  1
1382:  MOVF   x16,W
1384:  CLRF   01
1386:  SUBWF  x15,W
1388:  BC    1390
138A:  MOVFF  115,00
138E:  BRA    13A8
1390:  CLRF   00
1392:  MOVLW  08
1394:  MOVWF  x17
1396:  RLCF   x15,F
1398:  RLCF   00,F
139A:  MOVF   x16,W
139C:  SUBWF  00,W
139E:  BTFSC  FD8.0
13A0:  MOVWF  00
13A2:  RLCF   01,F
13A4:  DECFSZ x17,F
13A6:  BRA    1396
13A8:  MOVLB  0
13AA:  RETURN 0
13AC:  MOVF   01,W
13AE:  MOVFF  113,115
13B2:  MOVLW  64
13B4:  MOVLB  1
13B6:  MOVWF  x16
13B8:  MOVLB  0
13BA:  RCALL  1380
13BC:  MOVFF  00,113
13C0:  MOVF   01,W
13C2:  MOVLW  30
13C4:  BNZ   13D6
13C6:  MOVLB  1
13C8:  BTFSS  x14.1
13CA:  BRA    13E8
13CC:  BTFSC  x14.3
13CE:  BRA    13E8
13D0:  BTFSC  x14.4
13D2:  MOVLW  20
13D4:  BRA    13DE
13D6:  MOVLB  1
13D8:  BCF    x14.3
13DA:  BCF    x14.4
13DC:  BSF    x14.0
13DE:  ADDWF  01,F
13E0:  MOVF   01,W
13E2:  BTFSS  F9E.4
13E4:  BRA    13E2
13E6:  MOVWF  FAD
13E8:  MOVFF  113,115
13EC:  MOVLW  0A
13EE:  MOVWF  x16
13F0:  MOVLB  0
13F2:  RCALL  1380
13F4:  MOVFF  00,113
13F8:  MOVF   01,W
13FA:  MOVLW  30
13FC:  BNZ   140E
13FE:  MOVLB  1
1400:  BTFSC  x14.3
1402:  BRA    141A
1404:  BTFSS  x14.0
1406:  BRA    141A
1408:  BTFSC  x14.4
140A:  MOVLW  20
140C:  MOVLB  0
140E:  ADDWF  01,F
1410:  MOVF   01,W
1412:  BTFSS  F9E.4
1414:  BRA    1412
1416:  MOVWF  FAD
1418:  MOVLB  1
141A:  MOVLW  30
141C:  ADDWF  x13,F
141E:  MOVF   x13,W
1420:  BTFSS  F9E.4
1422:  BRA    1420
1424:  MOVWF  FAD
1426:  MOVLB  0
1428:  RETURN 0
142A:  MOVFF  FEA,11C
142E:  MOVFF  FE9,11B
1432:  MOVLB  1
1434:  SWAPF  x15,W
1436:  IORLW  F0
1438:  MOVWF  x17
143A:  ADDWF  x17,F
143C:  ADDLW  E2
143E:  MOVWF  x18
1440:  ADDLW  32
1442:  MOVWF  x1A
1444:  MOVF   x15,W
1446:  ANDLW  0F
1448:  ADDWF  x18,F
144A:  ADDWF  x18,F
144C:  ADDWF  x1A,F
144E:  ADDLW  E9
1450:  MOVWF  x19
1452:  ADDWF  x19,F
1454:  ADDWF  x19,F
1456:  SWAPF  x14,W
1458:  ANDLW  0F
145A:  ADDWF  x19,F
145C:  ADDWF  x1A,F
145E:  RLCF   x19,F
1460:  RLCF   x1A,F
1462:  COMF   x1A,F
1464:  RLCF   x1A,F
1466:  MOVF   x14,W
1468:  ANDLW  0F
146A:  ADDWF  x1A,F
146C:  RLCF   x17,F
146E:  MOVLW  07
1470:  MOVWF  x16
1472:  MOVLW  0A
1474:  DECF   x19,F
1476:  ADDWF  x1A,F
1478:  BNC   1474
147A:  DECF   x18,F
147C:  ADDWF  x19,F
147E:  BNC   147A
1480:  DECF   x17,F
1482:  ADDWF  x18,F
1484:  BNC   1480
1486:  DECF   x16,F
1488:  ADDWF  x17,F
148A:  BNC   1486
148C:  MOVLW  01
148E:  MOVWF  FEA
1490:  MOVLW  16
1492:  MOVWF  FE9
1494:  MOVLW  07
1496:  ANDWF  x1B,W
1498:  BCF    x1B.6
149A:  ADDWF  FE9,F
149C:  MOVLW  00
149E:  ADDWFC FEA,F
14A0:  MOVF   FE9,W
14A2:  SUBLW  1A
14A4:  BNZ   14AC
14A6:  DECFSZ FEA,W
14A8:  BRA    14AC
14AA:  BSF    x1B.6
14AC:  MOVF   FEF,W
14AE:  MOVWF  00
14B0:  BNZ   14C2
14B2:  BTFSC  x1B.6
14B4:  BRA    14C2
14B6:  BTFSC  x1B.4
14B8:  BRA    14D2
14BA:  BTFSC  x1B.3
14BC:  BRA    14C2
14BE:  MOVLW  20
14C0:  BRA    14C8
14C2:  BSF    x1B.3
14C4:  BCF    x1B.4
14C6:  MOVLW  30
14C8:  ADDWF  00,F
14CA:  MOVF   00,W
14CC:  BTFSS  F9E.4
14CE:  BRA    14CC
14D0:  MOVWF  FAD
14D2:  MOVF   FEE,W
14D4:  BTFSS  x1B.6
14D6:  BRA    14A0
14D8:  MOVLB  0
14DA:  RETURN 0
14DC:  MOVLB  1
14DE:  BTFSC  x16.7
14E0:  BRA    1502
14E2:  MOVLW  0F
14E4:  MOVWF  00
14E6:  SWAPF  x15,W
14E8:  ANDWF  00,F
14EA:  MOVLW  0A
14EC:  SUBWF  00,W
14EE:  BC    14F6
14F0:  MOVLW  30
14F2:  ADDWF  00,F
14F4:  BRA    14FA
14F6:  MOVF   x16,W
14F8:  ADDWF  00,F
14FA:  MOVF   00,W
14FC:  BTFSS  F9E.4
14FE:  BRA    14FC
1500:  MOVWF  FAD
1502:  MOVLW  0F
1504:  ANDWF  x15,F
1506:  MOVLW  0A
1508:  SUBWF  x15,W
150A:  BC    1510
150C:  MOVLW  30
150E:  BRA    1514
1510:  BCF    x16.7
1512:  MOVF   x16,W
1514:  ADDWF  x15,F
1516:  MOVF   x15,W
1518:  BTFSS  F9E.4
151A:  BRA    1518
151C:  MOVWF  FAD
151E:  MOVLB  0
1520:  GOTO   1920 (RETURN)
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #device *=16
.................... #use delay(clock=16MHz)
*
0652:  MOVLW  01
0654:  MOVWF  FEA
0656:  MOVLW  34
0658:  MOVWF  FE9
065A:  MOVF   FEF,W
065C:  BZ    067A
065E:  MOVLW  05
0660:  MOVWF  01
0662:  CLRF   00
0664:  DECFSZ 00,F
0666:  BRA    0664
0668:  DECFSZ 01,F
066A:  BRA    0662
066C:  MOVLW  2E
066E:  MOVWF  00
0670:  DECFSZ 00,F
0672:  BRA    0670
0674:  BRA    0676
0676:  DECFSZ FEF,F
0678:  BRA    065E
067A:  RETURN 0
.................... 
.................... /* hardware I2C port is slave and is connected to DCSWC bus */
.................... #use i2c(stream=STREAM_SLAVE,SLAVE, I2C1, FORCE_HW)
*
0308:  MOVF   FC9,W
030A:  MOVFF  138,FC9
030E:  BSF    FC6.4
0310:  BCF    F9E.3
0312:  BTFSC  FC7.0
0314:  BRA    0312
0316:  CLRF   01
0318:  BTFSS  FC5.6
031A:  INCF   01,F
031C:  RETURN 0
.................... /* slave address set based on dip switch in init() */
.................... 
.................... 
.................... #fuses INTRC_IO
.................... #fuses NOPLLEN
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses PUT
.................... #fuses BROWNOUT
.................... #fuses WDT512
.................... #fuses NOHFOFST
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses NOLVP
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... #fuses NOPROTECT
.................... #fuses NOWRT
.................... #fuses NOWRTC 
.................... #fuses NOWRTB
.................... #fuses NOWRTD
.................... #fuses NOEBTR
.................... #fuses NOEBTRB
.................... 
.................... #use standard_io(ALL)
.................... 
.................... #use rs232(UART1,stream=STREAM_FTDI,baud=9600,errors)	
*
1368:  BTFSS  F9E.5
136A:  BRA    1368
136C:  MOVFF  FAB,1A
1370:  MOVFF  FAE,01
1374:  BTFSS  1A.1
1376:  BRA    137C
1378:  BCF    FAB.4
137A:  BSF    FAB.4
137C:  GOTO   1774 (RETURN)
.................... 
.................... /* program config CRC of 0 and a serial_prefix of 'A' ... that will trigger a write default on first boot */
.................... #ROM 0xF00000 = { 0x00, 0x00, 0x40, 0x00 }
.................... 
.................... 
.................... 
.................... 
.................... #define SW_OVERRIDE_A        PIN_A5
.................... #define SW_OVERRIDE_B        PIN_A4
.................... #define BRIDGE_B_A           PIN_C5
.................... #define BRIDGE_A_B           PIN_C4
.................... #define BRIDGE_A_A           PIN_C3
.................... #define BRIDGE_B_B           PIN_C6
.................... #define AN_DIP               PIN_C7
.................... #define SER_TO_PC            PIN_B7
.................... #define AN_VTEMP             PIN_A2
.................... #define AN_IN_VOLTS          PIN_C0
.................... #define LED_A                PIN_C1
.................... #define LED_B                PIN_C2
.................... #define I2C_SDA              PIN_B4
.................... #define SER_FROM_PC          PIN_B5
.................... #define I2C_SCL              PIN_B6
.................... 
.................... 
.................... /* 
.................... Parameters are stored in EEPROM
.................... */
.................... #define PARAM_CRC_ADDRESS  0x00
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2
.................... 
.................... 
.................... 
.................... /* bit positions for a channel state byte */
.................... #define CH_STATE_BIT_FUTURE   7  /* reserved for future use */
.................... #define CH_STATE_BIT_HTD      6  /* high temperature disconnect */
.................... #define CH_STATE_BIT_LTD      5  /* low temperature disconnect */
.................... #define CH_STATE_BIT_HVD      4  /* high voltage disconnect */
.................... #define CH_STATE_BIT_LVD      3  /* low voltage disconnect */
.................... #define CH_STATE_BIT_CMD_OFF  2  /* commanded off */
.................... #define CH_STATE_BIT_CMD_ON   1  /* commanded on (takes presedence over commanded off) */
.................... #define CH_STATE_BIT_OVERRIDE 0  /* override switch */
....................       
.................... 
.................... 
.................... #define CONTACTOR_POWER_SAVE_MS       200 /* milliseconds for contactor be on. Must be >0 and <= 255 */
.................... 
.................... 
.................... typedef struct {
.................... 	/* low voltage disconnect */
.................... 	int16 lvd_disconnect_adc;
.................... 	int16 lvd_disconnect_delay;
.................... 	int16 lvd_reconnect_adc;
.................... 	int16 lvd_reconnect_delay;
.................... 
.................... 	/* high voltage disconnect */
.................... 	int16 hvd_disconnect_adc;
.................... 	int16 hvd_disconnect_delay;
.................... 	int16 hvd_reconnect_adc;
.................... 	int16 hvd_reconnect_delay;
.................... 
.................... 	/* low temperature disconnect */
.................... 	int16 ltd_disconnect_adc;
.................... 	int16 ltd_disconnect_delay;
.................... 	int16 ltd_reconnect_adc;
.................... 	int16 ltd_reconnect_delay;
.................... 
.................... 	/* high temperature disconnect */
.................... 	int16 htd_disconnect_adc;
.................... 	int16 htd_disconnect_delay;
.................... 	int16 htd_reconnect_adc;
.................... 	int16 htd_reconnect_delay;
.................... } struct_config_channel;
.................... 
.................... typedef struct {
.................... 	int16 adc_sample_ticks;
.................... 
.................... 	int16 startup_power_on_delay;
.................... 	int8 reconnect_delay;
.................... 
.................... 	int16 command_off_hold_time;
.................... 	int16 command_on_hold_time;
.................... 
.................... 	struct_config_channel ch[2];
.................... } struct_config;
.................... 
.................... 
.................... typedef struct {
.................... 	int8 state;
.................... 
.................... 	int16 command_on_seconds;			/* counts down. Off at zero. */
.................... 	int16 command_on_hold_seconds;      /* counts down. Off at zero. */
.................... 
.................... 	int16 command_off_seconds;			/* counts down. Off at zero. */
.................... 	int16 command_off_hold_seconds;     /* counts down. Off at zero. */
.................... 
.................... 	int16 lvd_disconnect_delay_seconds;	/* counts down */
.................... 	int8  lvd_reconnect_delay_seconds;	/* counts down */
.................... 
.................... 	int16 hvd_disconnect_delay_seconds;	/* counts down */
.................... 	int8  hvd_reconnect_delay_seconds;	/* counts down */
.................... 
.................... 	int16 ltd_disconnect_delay_seconds; /* counts down */
.................... 	int16 ltd_reconnect_delay_seconds;  /* counts down */
.................... 
.................... 	int16 htd_disconnect_delay_seconds; /* counts down */
.................... 	int16 htd_reconnect_delay_seconds;  /* counts down */
.................... } struct_channel;
.................... 
.................... typedef struct {
.................... 	/* circular buffer for ADC readings */
.................... 	int16 adc_buffer[3][16];
.................... 	int8  adc_buffer_index;
.................... 
.................... 	int16 sequence_number;
.................... 	int16 uptime_minutes;
.................... 	int16 interval_milliseconds;
.................... 
.................... 	int8 factory_unlocked;
.................... 
.................... 
.................... 	int8 compile_year;
.................... 	int8 compile_month;
.................... 	int8 compile_day;
.................... 
.................... 
.................... 	int8 default_params_written;
.................... } struct_current;
.................... 
.................... typedef struct {
.................... 	/* action flags */
.................... 	int1 now_adc_sample;
.................... 	int1 now_adc_reset_count;
.................... 
.................... 	int1 now_millisecond;
.................... 
.................... 	int1 now_write_config;
.................... 	int1 now_reset_config;
.................... 
.................... 	/* contactor states */
.................... 	int1 contactor_a;
.................... 	int1 contactor_b;
.................... 
.................... 	/* timers */
.................... 	int8 led_on_a;
.................... 	int8 led_on_b;
.................... 
.................... 	int8  contactor_a_powersave;        /* counts down. Off at zero. */
.................... 	int8  contactor_b_powersave;        /* counts down. Off at zero. */
.................... 
.................... 
.................... 
.................... } struct_time_keep;
.................... 
.................... /* global structures */
.................... struct_config config={0};
.................... struct_current current={0};
.................... struct_time_keep timers={0};
.................... struct_channel channel[2]={0};
.................... 
.................... #include "adc_dcswc_module_latching_contactor.c"
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3};
.................... 
.................... int16 adc_get(int8 ch) {
.................... 	int16 sum;
.................... 	int8 i;
.................... 
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */
.................... 	int16 *p;
.................... 	p = current.adc_buffer[ch];
*
00DC:  MOVLB  1
00DE:  MOVF   x39,W
00E0:  MULLW  20
00E2:  MOVF   FF3,W
00E4:  CLRF   03
00E6:  ADDLW  64
00E8:  MOVWF  x3D
00EA:  MOVLW  00
00EC:  ADDWFC 03,W
00EE:  MOVWF  x3E
.................... 
.................... 	// Calculate the mean.  This is done by summing up the
.................... 	// values and dividing by the number of elements.
.................... 	sum = 0;
00F0:  CLRF   x3B
00F2:  CLRF   x3A
.................... 	for( i = 0; i < 16 ; i++ ) {
00F4:  CLRF   x3C
00F6:  MOVF   x3C,W
00F8:  SUBLW  0F
00FA:  BNC   0126
.................... //		sum += current.adc_buffer[ch][i];
.................... 		sum += p[i];
00FC:  CLRF   03
00FE:  MOVFF  13C,02
0102:  BCF    FD8.0
0104:  RLCF   02,F
0106:  RLCF   03,F
0108:  MOVF   02,W
010A:  ADDWF  x3D,W
010C:  MOVWF  FE9
010E:  MOVF   x3E,W
0110:  ADDWFC 03,W
0112:  MOVWF  FEA
0114:  MOVFF  FEC,03
0118:  MOVF   FED,F
011A:  MOVF   FEF,W
011C:  ADDWF  x3A,F
011E:  MOVF   03,W
0120:  ADDWFC x3B,F
0122:  INCF   x3C,F
0124:  BRA    00F6
.................... 	}
.................... 
.................... 	/* divide sum by our 16 samples and round by adding 8 */
.................... 	return ( (sum+8) >> 4 );
0126:  MOVLW  08
0128:  ADDWF  x3A,W
012A:  MOVWF  x3F
012C:  MOVLW  00
012E:  ADDWFC x3B,W
0130:  MOVWF  x40
0132:  RRCF   x40,W
0134:  MOVWF  03
0136:  RRCF   x3F,W
0138:  MOVWF  02
013A:  RRCF   03,F
013C:  RRCF   02,F
013E:  RRCF   03,F
0140:  RRCF   02,F
0142:  RRCF   03,F
0144:  RRCF   02,F
0146:  MOVLW  0F
0148:  ANDWF  03,F
014A:  MOVFF  02,01
014E:  MOVFF  03,02
0152:  MOVLB  0
0154:  RETURN 0
.................... }
.................... 
.................... 
.................... void adc_update(void) {
.................... 
.................... 	/* wrap buffer around */
.................... 	current.adc_buffer_index++;
*
0BB0:  INCF   xC4,F
.................... 	if ( current.adc_buffer_index >= 16 )
0BB2:  MOVF   xC4,W
0BB4:  SUBLW  0F
0BB6:  BC    0BBA
.................... 		current.adc_buffer_index=0;
0BB8:  CLRF   xC4
.................... 
.................... 	set_adc_channel(4);
0BBA:  MOVLW  10
0BBC:  MOVWF  01
0BBE:  MOVF   FC2,W
0BC0:  ANDLW  C3
0BC2:  IORWF  01,W
0BC4:  MOVWF  FC2
.................... 	current.adc_buffer[0][current.adc_buffer_index] = read_adc();
0BC6:  BCF    FD8.0
0BC8:  RLCF   xC4,W
0BCA:  CLRF   03
0BCC:  ADDLW  64
0BCE:  MOVWF  FE9
0BD0:  MOVLW  00
0BD2:  ADDWFC 03,W
0BD4:  MOVWF  FEA
0BD6:  BSF    FC2.1
0BD8:  BTFSC  FC2.1
0BDA:  BRA    0BD8
0BDC:  MOVFF  FC3,FEF
0BE0:  MOVFF  FC4,FEC
.................... 
.................... 
.................... 	set_adc_channel(2);
0BE4:  MOVLW  08
0BE6:  MOVWF  01
0BE8:  MOVF   FC2,W
0BEA:  ANDLW  C3
0BEC:  IORWF  01,W
0BEE:  MOVWF  FC2
.................... 	delay_ms(1);
0BF0:  MOVLW  01
0BF2:  MOVLB  1
0BF4:  MOVWF  x34
0BF6:  MOVLB  0
0BF8:  RCALL  0652
.................... 	current.adc_buffer[1][current.adc_buffer_index] = read_adc();
0BFA:  BCF    FD8.0
0BFC:  RLCF   xC4,W
0BFE:  CLRF   03
0C00:  ADDLW  84
0C02:  MOVWF  FE9
0C04:  MOVLW  00
0C06:  ADDWFC 03,W
0C08:  MOVWF  FEA
0C0A:  BSF    FC2.1
0C0C:  BTFSC  FC2.1
0C0E:  BRA    0C0C
0C10:  MOVFF  FC3,FEF
0C14:  MOVFF  FC4,FEC
.................... 
.................... 	set_adc_channel(9);
0C18:  MOVLW  24
0C1A:  MOVWF  01
0C1C:  MOVF   FC2,W
0C1E:  ANDLW  C3
0C20:  IORWF  01,W
0C22:  MOVWF  FC2
.................... 	delay_ms(1);
0C24:  MOVLW  01
0C26:  MOVLB  1
0C28:  MOVWF  x34
0C2A:  MOVLB  0
0C2C:  RCALL  0652
.................... 	current.adc_buffer[2][current.adc_buffer_index] = read_adc();
0C2E:  BCF    FD8.0
0C30:  RLCF   xC4,W
0C32:  CLRF   03
0C34:  ADDLW  A4
0C36:  MOVWF  FE9
0C38:  MOVLW  00
0C3A:  ADDWFC 03,W
0C3C:  MOVWF  FEA
0C3E:  BSF    FC2.1
0C40:  BTFSC  FC2.1
0C42:  BRA    0C40
0C44:  MOVFF  FC3,FEF
0C48:  MOVFF  FC4,FEC
0C4C:  RETURN 0
.................... }
.................... 
.................... #include "param_dcswc_module_latching_contactor.c"
.................... #inline
.................... char xor_crc(char oldcrc, char data) {
.................... 	return oldcrc ^ data;
*
08CA:  MOVF   x1F,W
08CC:  XORWF  x20,W
08CE:  MOVWF  01
*
0918:  MOVF   x1F,W
091A:  XORWF  x20,W
091C:  MOVWF  01
.................... }
.................... 
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) {
*
0862:  MOVLB  1
0864:  CLRF   x1B
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
0866:  MOVFF  11A,11D
086A:  MOVF   x19,W
086C:  BTFSC  FD8.2
086E:  DECF   x1A,F
0870:  DECF   x19,F
0872:  MOVWF  x1C
0874:  MOVF   x1C,F
0876:  BNZ   087C
0878:  MOVF   x1D,F
087A:  BZ    08DC
.................... 		*data = read_eeprom( address++ );
087C:  MOVFF  118,03
0880:  MOVF   x17,W
0882:  MOVWF  FE9
0884:  MOVFF  03,FEA
0888:  MOVF   x16,W
088A:  MOVWF  03
088C:  MOVF   x15,W
088E:  INCF   x15,F
0890:  BTFSC  FD8.2
0892:  INCF   x16,F
0894:  MOVWF  x1E
0896:  MOVFF  03,11F
089A:  MOVFF  FF2,120
089E:  BCF    FF2.7
08A0:  MOVFF  11E,FA9
08A4:  BCF    FA6.6
08A6:  BCF    FA6.7
08A8:  BSF    FA6.0
08AA:  MOVF   FA8,W
08AC:  BTFSC  x20.7
08AE:  BSF    FF2.7
08B0:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data);
08B2:  MOVFF  118,03
08B6:  MOVF   x17,W
08B8:  MOVWF  FE9
08BA:  MOVFF  03,FEA
08BE:  MOVFF  FEF,11C
08C2:  MOVFF  11B,11F
08C6:  MOVFF  11C,120
*
08D0:  MOVFF  01,11B
.................... 		data++;
08D4:  INCF   x17,F
08D6:  BTFSC  FD8.2
08D8:  INCF   x18,F
08DA:  BRA    0866
.................... 	}
.................... 	return crc;
08DC:  MOVFF  11B,01
08E0:  MOVLB  0
08E2:  GOTO   0B3A (RETURN)
.................... }
.................... 
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) {
08E6:  MOVLB  1
08E8:  CLRF   x1D
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
08EA:  MOVFF  11C,11F
08EE:  MOVF   x1B,W
08F0:  BTFSC  FD8.2
08F2:  DECF   x1C,F
08F4:  DECF   x1B,F
08F6:  MOVWF  x1E
08F8:  MOVF   x1E,F
08FA:  BNZ   0900
08FC:  MOVF   x1F,F
08FE:  BZ    0978
.................... 		/* restart_wdt() */
.................... 		crc = xor_crc(crc,*data);
0900:  MOVFF  11A,03
0904:  MOVF   x19,W
0906:  MOVWF  FE9
0908:  MOVFF  03,FEA
090C:  MOVFF  FEF,11E
0910:  MOVFF  11D,11F
0914:  MOVFF  11E,120
*
091E:  MOVFF  01,11D
.................... 		write_eeprom( address++, *data++ );
0922:  MOVF   x18,W
0924:  MOVWF  03
0926:  MOVF   x17,W
0928:  INCF   x17,F
092A:  BTFSC  FD8.2
092C:  INCF   x18,F
092E:  MOVWF  x1E
0930:  MOVFF  03,11F
0934:  MOVF   x1A,W
0936:  MOVWF  03
0938:  MOVF   x19,W
093A:  INCF   x19,F
093C:  BTFSC  FD8.2
093E:  INCF   x1A,F
0940:  MOVWF  FE9
0942:  MOVFF  03,FEA
0946:  MOVFF  FEF,120
094A:  MOVF   FF2,W
094C:  MOVWF  00
094E:  BCF    FF2.7
0950:  MOVFF  11E,FA9
0954:  MOVFF  120,FA8
0958:  BCF    FA6.6
095A:  BCF    FA6.7
095C:  BSF    FA6.2
095E:  MOVLB  F
0960:  MOVLW  55
0962:  MOVWF  FA7
0964:  MOVLW  AA
0966:  MOVWF  FA7
0968:  BSF    FA6.1
096A:  BTFSC  FA6.1
096C:  BRA    096A
096E:  BCF    FA6.2
0970:  MOVF   00,W
0972:  IORWF  FF2,F
0974:  MOVLB  1
0976:  BRA    08EA
.................... 	}
.................... 
.................... 	return crc;
0978:  MOVFF  11D,01
097C:  MOVLB  0
097E:  GOTO   099E (RETURN)
.................... }
.................... 
.................... void write_param_file() {
.................... 	int8 crc;
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config));
0982:  MOVLB  1
0984:  MOVLW  1B
0986:  MOVWF  x15
0988:  CLRF   x18
098A:  MOVLW  02
098C:  MOVWF  x17
098E:  CLRF   x1A
0990:  MOVFF  115,119
0994:  CLRF   x1C
0996:  MOVLW  49
0998:  MOVWF  x1B
099A:  MOVLB  0
099C:  BRA    08E6
099E:  MOVFF  01,114
.................... 	/* write the CRC was calculated on the structure */
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc);
09A2:  MOVF   FF2,W
09A4:  MOVWF  00
09A6:  BCF    FF2.7
09A8:  CLRF   FA9
09AA:  MOVFF  114,FA8
09AE:  BCF    FA6.6
09B0:  BCF    FA6.7
09B2:  BSF    FA6.2
09B4:  MOVLB  F
09B6:  MOVLW  55
09B8:  MOVWF  FA7
09BA:  MOVLW  AA
09BC:  MOVWF  FA7
09BE:  BSF    FA6.1
09C0:  BTFSC  FA6.1
09C2:  BRA    09C0
09C4:  BCF    FA6.2
09C6:  MOVF   00,W
09C8:  IORWF  FF2,F
09CA:  MOVLB  0
09CC:  RETURN 0
.................... }
.................... 
.................... void write_default_param_file() {
.................... 	int8 i;
.................... 
.................... 	current.default_params_written=1;
09CE:  MOVLW  01
09D0:  MOVWF  xCF
.................... 
.................... 	/* both LEDs on */
.................... 	timers.led_on_a=150;
09D2:  MOVLW  96
09D4:  MOVWF  xD1
.................... 	timers.led_on_b=150;
09D6:  MOVWF  xD2
.................... 
.................... 	config.adc_sample_ticks=20;
09D8:  CLRF   1C
09DA:  MOVLW  14
09DC:  MOVWF  1B
.................... 
.................... 	config.startup_power_on_delay=5;
09DE:  CLRF   1E
09E0:  MOVLW  05
09E2:  MOVWF  1D
.................... 	config.reconnect_delay=5;
09E4:  MOVWF  1F
.................... 
.................... 	config.command_off_hold_time=2;
09E6:  CLRF   21
09E8:  MOVLW  02
09EA:  MOVWF  20
.................... 
.................... 	for ( i=0 ; i<2 ; i++ ) {
09EC:  MOVLB  1
09EE:  CLRF   x13
09F0:  MOVF   x13,W
09F2:  SUBLW  01
09F4:  BTFSS  FD8.0
09F6:  BRA    0B18
.................... 		config.ch[i].lvd_disconnect_adc=303;
09F8:  MOVF   x13,W
09FA:  MULLW  20
09FC:  MOVF   FF3,W
09FE:  CLRF   03
0A00:  ADDLW  24
0A02:  MOVWF  FE9
0A04:  MOVLW  00
0A06:  ADDWFC 03,W
0A08:  MOVWF  FEA
0A0A:  MOVLW  01
0A0C:  MOVWF  FEC
0A0E:  MOVF   FED,F
0A10:  MOVLW  2F
0A12:  MOVWF  FEF
.................... 		config.ch[i].lvd_disconnect_delay=40;
0A14:  MOVF   x13,W
0A16:  MULLW  20
0A18:  MOVF   FF3,W
0A1A:  CLRF   03
0A1C:  ADDLW  09
0A1E:  MOVWF  x14
0A20:  MOVLW  00
0A22:  ADDWFC 03,W
0A24:  MOVWF  x15
0A26:  MOVLW  02
0A28:  ADDWF  x14,W
0A2A:  MOVWF  01
0A2C:  MOVLW  00
0A2E:  ADDWFC x15,W
0A30:  MOVWF  03
0A32:  MOVF   01,W
0A34:  ADDLW  1B
0A36:  MOVWF  FE9
0A38:  MOVLW  00
0A3A:  ADDWFC 03,W
0A3C:  MOVWF  FEA
0A3E:  CLRF   FEC
0A40:  MOVF   FED,F
0A42:  MOVLW  28
0A44:  MOVWF  FEF
.................... 		config.ch[i].lvd_reconnect_adc=308;
0A46:  MOVF   x13,W
0A48:  MULLW  20
0A4A:  MOVF   FF3,W
0A4C:  CLRF   03
0A4E:  ADDLW  09
0A50:  MOVWF  x14
0A52:  MOVLW  00
0A54:  ADDWFC 03,W
0A56:  MOVWF  x15
0A58:  MOVLW  04
0A5A:  ADDWF  x14,W
0A5C:  MOVWF  01
0A5E:  MOVLW  00
0A60:  ADDWFC x15,W
0A62:  MOVWF  03
0A64:  MOVF   01,W
0A66:  ADDLW  1B
0A68:  MOVWF  FE9
0A6A:  MOVLW  00
0A6C:  ADDWFC 03,W
0A6E:  MOVWF  FEA
0A70:  MOVLW  01
0A72:  MOVWF  FEC
0A74:  MOVF   FED,F
0A76:  MOVLW  34
0A78:  MOVWF  FEF
.................... 
.................... 		config.ch[i].hvd_disconnect_adc=410;
0A7A:  MOVF   x13,W
0A7C:  MULLW  20
0A7E:  MOVF   FF3,W
0A80:  CLRF   03
0A82:  ADDLW  09
0A84:  MOVWF  x14
0A86:  MOVLW  00
0A88:  ADDWFC 03,W
0A8A:  MOVWF  x15
0A8C:  MOVLW  08
0A8E:  ADDWF  x14,W
0A90:  MOVWF  01
0A92:  MOVLW  00
0A94:  ADDWFC x15,W
0A96:  MOVWF  03
0A98:  MOVF   01,W
0A9A:  ADDLW  1B
0A9C:  MOVWF  FE9
0A9E:  MOVLW  00
0AA0:  ADDWFC 03,W
0AA2:  MOVWF  FEA
0AA4:  MOVLW  01
0AA6:  MOVWF  FEC
0AA8:  MOVF   FED,F
0AAA:  MOVLW  9A
0AAC:  MOVWF  FEF
.................... 		config.ch[i].hvd_disconnect_delay=15;
0AAE:  MOVF   x13,W
0AB0:  MULLW  20
0AB2:  MOVF   FF3,W
0AB4:  CLRF   03
0AB6:  ADDLW  09
0AB8:  MOVWF  x14
0ABA:  MOVLW  00
0ABC:  ADDWFC 03,W
0ABE:  MOVWF  x15
0AC0:  MOVLW  0A
0AC2:  ADDWF  x14,W
0AC4:  MOVWF  01
0AC6:  MOVLW  00
0AC8:  ADDWFC x15,W
0ACA:  MOVWF  03
0ACC:  MOVF   01,W
0ACE:  ADDLW  1B
0AD0:  MOVWF  FE9
0AD2:  MOVLW  00
0AD4:  ADDWFC 03,W
0AD6:  MOVWF  FEA
0AD8:  CLRF   FEC
0ADA:  MOVF   FED,F
0ADC:  MOVLW  0F
0ADE:  MOVWF  FEF
.................... 		config.ch[i].hvd_reconnect_adc=385;
0AE0:  MOVF   x13,W
0AE2:  MULLW  20
0AE4:  MOVF   FF3,W
0AE6:  CLRF   03
0AE8:  ADDLW  09
0AEA:  MOVWF  x14
0AEC:  MOVLW  00
0AEE:  ADDWFC 03,W
0AF0:  MOVWF  x15
0AF2:  MOVLW  0C
0AF4:  ADDWF  x14,W
0AF6:  MOVWF  01
0AF8:  MOVLW  00
0AFA:  ADDWFC x15,W
0AFC:  MOVWF  03
0AFE:  MOVF   01,W
0B00:  ADDLW  1B
0B02:  MOVWF  FE9
0B04:  MOVLW  00
0B06:  ADDWFC 03,W
0B08:  MOVWF  FEA
0B0A:  MOVLW  01
0B0C:  MOVWF  FEC
0B0E:  MOVF   FED,F
0B10:  MOVLW  81
0B12:  MOVWF  FEF
0B14:  INCF   x13,F
0B16:  BRA    09F0
.................... 	}
.................... 	
.................... 	/* write them so next time we use from EEPROM */
.................... 	write_param_file();
0B18:  MOVLB  0
0B1A:  RCALL  0982
0B1C:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void read_param_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config)); 
0B1E:  MOVLB  1
0B20:  MOVLW  1B
0B22:  MOVWF  x13
0B24:  CLRF   x16
0B26:  MOVLW  02
0B28:  MOVWF  x15
0B2A:  CLRF   x18
0B2C:  MOVFF  113,117
0B30:  CLRF   x1A
0B32:  MOVLW  49
0B34:  MOVWF  x19
0B36:  MOVLB  0
0B38:  BRA    0862
0B3A:  MOVFF  01,112
.................... 		
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) {
0B3E:  MOVFF  FF2,113
0B42:  BCF    FF2.7
0B44:  CLRF   FA9
0B46:  BCF    FA6.6
0B48:  BCF    FA6.7
0B4A:  BSF    FA6.0
0B4C:  MOVF   FA8,W
0B4E:  MOVLB  1
0B50:  BTFSC  x13.7
0B52:  BSF    FF2.7
0B54:  SUBWF  x12,W
0B56:  BZ    0B5E
.................... 		write_default_param_file();
0B58:  MOVLB  0
0B5A:  RCALL  09CE
0B5C:  MOVLB  1
.................... 	}
0B5E:  MOVLB  0
0B60:  GOTO   1616 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... #include "i2c_handler_dcswc_module_latching_contactor.c"
.................... #include "registers_dcswc_module_latching_contactor.h"
.................... 
.................... /* first three registers will give enough information for telemetry */
.................... #define I2C_REG_VOLTAGE_INPUT_AVG             0  /* 10 bit input voltage ADC averaged value */
.................... #define I2C_REG_STATE_CONTACTORS              1  /* two 8 bit channel states (A is MSB / B is LSB) */
.................... #define I2C_REG_TEMPERATURE_BOARD_AVG         2  /* 10 bit NTC thermistor ADC averaged value */
.................... 
.................... #define I2C_REG_VOLTAGE_INPUT_NOW             3  /* 10 bit input voltage ADC latest value */
.................... #define I2C_REG_TEMPERATURE_BOARD_NOW         4  /* 10 bit NTC thermistor ADC latest value */
.................... 
.................... 
.................... /* channel 0 / A */
.................... /* command can only come from I2C interface */
.................... #define I2C_REG_COMMAND_ON_A                  5  /* R/W seconds */
.................... #define I2C_REG_COMMAND_ON_HOLD_A             6
.................... 
.................... #define I2C_REG_COMMAND_OFF_A                 7  /* R/W seconds */
.................... #define I2C_REG_COMMAND_OFF_HOLD_A            8
.................... 
.................... /* low voltage disconnect */
.................... #define I2C_REG_LVD_DISCONNECT_A              9  /* R seconds */
.................... #define I2C_REG_LVD_RECONNECT_A               10 
.................... 
.................... /* high voltage disconnect */
.................... #define I2C_REG_HVD_DISCONNECT_A              11 /* R seconds */
.................... #define I2C_REG_HVD_RECONNECT_A               12
.................... 
.................... /* low temperature disconnect */
.................... #define I2C_REG_LTD_DISCONNECT_A              13  /* R seconds */
.................... #define I2C_REG_LTD_RECONNECT_A               14
.................... 
.................... /* high temperature disconnect */
.................... #define I2C_REG_HTD_DISCONNECT_A              15 /* R seconds */
.................... #define I2C_REG_HTD_RECONNECT_A               16
.................... 
.................... /* reserved for future, unimplemented */
.................... #define I2C_REG_FUT_DISCONNECT_A              17 /* R seconds */
.................... #define I2C_REG_FUT_RECONNECT_A               18
.................... 
.................... /* channel 1 / B */
.................... /* command can only come from I2C interface */
.................... #define I2C_REG_COMMAND_ON_B                  19
.................... #define I2C_REG_COMMAND_ON_HOLD_B             20
.................... 
.................... #define I2C_REG_COMMAND_OFF_B                 21
.................... #define I2C_REG_COMMAND_OFF_HOLD_B            22
.................... 
.................... /* low voltage disconnect */
.................... #define I2C_REG_LVD_DISCONNECT_B              23
.................... #define I2C_REG_LVD_RECONNECT_B               24
.................... 
.................... /* high voltage disconnect */
.................... #define I2C_REG_HVD_DISCONNECT_B              25
.................... #define I2C_REG_HVD_RECONNECT_B               26
.................... 
.................... /* low temperature disconnect */
.................... #define I2C_REG_LTD_DISCONNECT_B              27
.................... #define I2C_REG_LTD_RECONNECT_B               28
.................... 
.................... /* high temperature disconnect */
.................... #define I2C_REG_HTD_DISCONNECT_B              29
.................... #define I2C_REG_HTD_RECONNECT_B               30
.................... 
.................... /* reserved for future, unimplemented */
.................... #define I2C_REG_FUT_DISCONNECT_B              31
.................... #define I2C_REG_FUT_RECONNECT_B               32
.................... 
.................... 
.................... /* meta */
.................... #define I2C_REG_SEQUENCE_NUMBER               34 /* R */
.................... #define I2C_REG_TIME_INTERVAL_MILLISECONDS    35
.................... #define I2C_REG_TIME_UPTIME_MINUTES           36
.................... #define I2C_REG_DEFAULT_PARAMS_WRITTEN        37
.................... 
.................... /* channel configuration */
.................... /* channel 0 / A */
.................... #define I2C_REG_CH_LVD_DISCONNECT_ADC         64
.................... #define I2C_REG_CH_LVD_DISCONNECT_DELAY       65
.................... #define I2C_REG_CH_LVD_RECONNECT_ADC          66
.................... #define I2C_REG_CH_LVD_RECONNECT_DELAY        67
.................... 
.................... #define I2C_REG_CH_HVD_DISCONNECT_ADC         68
.................... #define I2C_REG_CH_HVD_DISCONNECT_DELAY       69
.................... #define I2C_REG_CH_HVD_RECONNECT_ADC          70
.................... #define I2C_REG_CH_HVD_RECONNECT_DELAY        71
.................... 
.................... #define I2C_REG_CH_LTD_DISCONNECT_ADC         72
.................... #define I2C_REG_CH_LTD_DISCONNECT_DELAY       73
.................... #define I2C_REG_CH_LTD_RECONNECT_ADC          74
.................... #define I2C_REG_CH_LTD_RECONNECT_DELAY        75
.................... 
.................... #define I2C_REG_CH_HTD_DISCONNECT_ADC         76
.................... #define I2C_REG_CH_HTD_DISCONNECT_DELAY       77
.................... #define I2C_REG_CH_HTD_RECONNECT_ADC          78
.................... #define I2C_REG_CH_HTD_RECONNECT_DELAY        79
.................... 
.................... #define I2C_REG_CH_FUT_DISCONNECT_VALUE       80
.................... #define I2C_REG_CH_FUT_DISCONNECT_DELAY       81
.................... #define I2C_REG_CH_FUT_RECONNECT_VALUE        82
.................... #define I2C_REG_CH_FUT_RECONNECT_DELAY        83
.................... 
.................... /* channel 1 / B */
.................... #define I2C_REG_CH_LVD_DISCONNECT_ADC         84
.................... #define I2C_REG_CH_LVD_DISCONNECT_DELAY       85
.................... #define I2C_REG_CH_LVD_RECONNECT_ADC          86
.................... #define I2C_REG_CH_LVD_RECONNECT_DELAY        87
.................... 
.................... #define I2C_REG_CH_HVD_DISCONNECT_ADC         88
.................... #define I2C_REG_CH_HVD_DISCONNECT_DELAY       89
.................... #define I2C_REG_CH_HVD_RECONNECT_ADC          90
.................... #define I2C_REG_CH_HVD_RECONNECT_DELAY        91
.................... 
.................... #define I2C_REG_CH_LTD_DISCONNECT_ADC         92
.................... #define I2C_REG_CH_LTD_DISCONNECT_DELAY       93
.................... #define I2C_REG_CH_LTD_RECONNECT_ADC          94
.................... #define I2C_REG_CH_LTD_RECONNECT_DELAY        95
.................... 
.................... #define I2C_REG_CH_HTD_DISCONNECT_ADC         96
.................... #define I2C_REG_CH_HTD_DISCONNECT_DELAY       97
.................... #define I2C_REG_CH_HTD_RECONNECT_ADC          98
.................... #define I2C_REG_CH_HTD_RECONNECT_DELAY        99
.................... 
.................... #define I2C_REG_CH_FUT_DISCONNECT_VALUE       100
.................... #define I2C_REG_CH_FUT_DISCONNECT_DELAY       101
.................... #define I2C_REG_CH_FUT_RECONNECT_VALUE        102
.................... #define I2C_REG_CH_FUT_RECONNECT_DELAY        103
.................... 
.................... 
.................... /* configuration */
.................... #define I2C_REG_CONFIG_HARDWARE_MODEL              128 /* R */
.................... #define I2C_REG_CONFIG_HARDWARE_VERSION            129
.................... #define I2C_REG_CONFIG_SOFTWARE_MODEL              130
.................... #define I2C_REG_CONFIG_SOFTWARE_VERSION            131
.................... #define I2C_REG_CONFIG_SOFTWARE_YEAR               132
.................... #define I2C_REG_CONFIG_SOFTWARE_MONTH              133
.................... #define I2C_REG_CONFIG_SOFTWARE_DAY                134
.................... 
.................... #define I2C_REG_CONFIG_PARAM_WRITE                 135 /* R / W */
.................... 
.................... #define I2C_REG_CONFIG_STARTUP_POWER_ON_DELAY      136
.................... #define I2C_REG_CONFIG_RECONNECT_DELAY             137
.................... 
.................... #define I2C_REG_CONFIG_COMMAND_OFF_HOLD_TIME        44
.................... #define I2C_REG_CONFIG_COMMAND_ON_HOLD_TIME         44
.................... 
.................... 
.................... #define I2C_REG_CONFIG_LVD_DISCONNECT_VOLTAGE       49
.................... #define I2C_REG_CONFIG_LVD_DISCONNECT_DELAY         50
.................... #define I2C_REG_CONFIG_LVD_RECONNECT_VOLTAGE        51
.................... #define I2C_REG_CONFIG_HVD_DISCONNECT_VOLTAGE       52
.................... #define I2C_REG_CONFIG_HVD_DISCONNECT_DELAY         53
.................... #define I2C_REG_CONFIG_HVD_RECONNECT_VOLTAGE        54
.................... 
.................... 
.................... void write_i2c(int8 address, int16 value) {
.................... 
.................... #if 0
*
0004:  GOTO   03A6 (RETURN)
.................... 		case I2C_REG_COMMAND_OFF:
.................... 			timers.command_off_seconds=value;
.................... 			break;
.................... 
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			if ( 1 == value ) {
.................... 				timers.now_write_config=1;
.................... 			} else if ( 2 == value ) {
.................... 				timers.now_reset_config=1;
.................... 			} else if ( 1802 == value ) {
.................... 				current.factory_unlocked =1;
.................... 			} else if ( 65535 == value ) {
.................... 				reset_cpu();
.................... 			}
.................... 			break;
.................... 		case I2C_REG_CONFIG_TICKS_ADC:
.................... 			config.adc_sample_ticks=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_STARTUP_POWER_ON_DELAY:
.................... 			config.startup_power_on_delay=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_COMMAND_OFF_HOLD_TIME:
.................... 			config.command_off_hold_time=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_LVD_DISCONNECT_VOLTAGE:
.................... 			config.lvd_disconnect_adc=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_LVD_DISCONNECT_DELAY:
.................... 			config.lvd_disconnect_delay=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_LVD_RECONNECT_VOLTAGE:
.................... 			config.lvd_reconnect_adc=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_HVD_DISCONNECT_VOLTAGE:
.................... 			config.hvd_disconnect_adc=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_HVD_DISCONNECT_DELAY:
.................... 			config.hvd_disconnect_delay=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_HVD_RECONNECT_VOLTAGE:
.................... 			config.hvd_reconnect_adc=value;
.................... 			break;
.................... 		default:
.................... 			/* do nothing */
.................... 	}
.................... #endif
.................... 
.................... }
.................... 
.................... 
.................... int16 map_i2c(int8 addr) {
.................... 
.................... 	timers.led_on_a=100;
*
0156:  MOVLW  64
0158:  MOVWF  xD1
.................... 
.................... 	switch ( addr ) {
015A:  MOVLB  1
015C:  MOVF   x38,W
015E:  XORLW  00
0160:  MOVLB  0
0162:  BZ    01E2
0164:  XORLW  01
0166:  BZ    01EE
0168:  XORLW  03
016A:  BZ    01FC
016C:  XORLW  01
016E:  BZ    020A
0170:  XORLW  07
0172:  BZ    022A
0174:  XORLW  01
0176:  BTFSC  FD8.2
0178:  BRA    024A
017A:  XORLW  16
017C:  BTFSC  FD8.2
017E:  BRA    0254
0180:  XORLW  14
0182:  BTFSC  FD8.2
0184:  BRA    025E
0186:  XORLW  12
0188:  BTFSC  FD8.2
018A:  BRA    0268
018C:  XORLW  1C
018E:  BTFSC  FD8.2
0190:  BRA    0272
0192:  XORLW  1E
0194:  BTFSC  FD8.2
0196:  BRA    027C
0198:  XORLW  1C
019A:  BTFSC  FD8.2
019C:  BRA    0286
019E:  XORLW  12
01A0:  BTFSC  FD8.2
01A2:  BRA    0290
01A4:  XORLW  14
01A6:  BTFSC  FD8.2
01A8:  BRA    029A
01AA:  XORLW  16
01AC:  BTFSC  FD8.2
01AE:  BRA    02A4
01B0:  XORLW  14
01B2:  BTFSC  FD8.2
01B4:  BRA    02AE
01B6:  XORLW  12
01B8:  BTFSC  FD8.2
01BA:  BRA    02B8
01BC:  XORLW  0C
01BE:  BTFSC  FD8.2
01C0:  BRA    02C4
01C2:  XORLW  0E
01C4:  BTFSC  FD8.2
01C6:  BRA    02CC
01C8:  XORLW  3D
01CA:  BTFSC  FD8.2
01CC:  BRA    02D4
01CE:  XORLW  01
01D0:  BTFSC  FD8.2
01D2:  BRA    02DE
01D4:  XORLW  07
01D6:  BTFSC  FD8.2
01D8:  BRA    02E8
01DA:  XORLW  01
01DC:  BTFSC  FD8.2
01DE:  BRA    02F2
01E0:  BRA    02FA
.................... 		case I2C_REG_VOLTAGE_INPUT_AVG: 
.................... 			return (int16) adc_get(0);
01E2:  MOVLB  1
01E4:  CLRF   x39
01E6:  MOVLB  0
01E8:  RCALL  00DC
01EA:  MOVF   02,W
01EC:  BRA    0304
.................... 		case I2C_REG_STATE_CONTACTORS:
.................... 			return (int16) make16(channel[0].state,channel[1].state);
01EE:  MOVFF  D5,03
01F2:  MOVFF  EC,01
01F6:  MOVFF  D5,02
01FA:  BRA    0304
.................... 		case I2C_REG_TEMPERATURE_BOARD_AVG: 
.................... 			return (int16) adc_get(1);
01FC:  MOVLW  01
01FE:  MOVLB  1
0200:  MOVWF  x39
0202:  MOVLB  0
0204:  RCALL  00DC
0206:  MOVF   02,W
0208:  BRA    0304
.................... 
.................... 
.................... 		case I2C_REG_VOLTAGE_INPUT_NOW: 
.................... 			return (int16) current.adc_buffer[0][current.adc_buffer_index];
020A:  BCF    FD8.0
020C:  RLCF   xC4,W
020E:  CLRF   03
0210:  ADDLW  64
0212:  MOVWF  FE9
0214:  MOVLW  00
0216:  ADDWFC 03,W
0218:  MOVWF  FEA
021A:  MOVFF  FEC,03
021E:  MOVF   FED,F
0220:  MOVFF  FEF,01
0224:  MOVFF  03,02
0228:  BRA    0304
.................... 		case I2C_REG_TEMPERATURE_BOARD_NOW: 
.................... 			return (int16) current.adc_buffer[1][current.adc_buffer_index];
022A:  BCF    FD8.0
022C:  RLCF   xC4,W
022E:  CLRF   03
0230:  ADDLW  84
0232:  MOVWF  FE9
0234:  MOVLW  00
0236:  ADDWFC 03,W
0238:  MOVWF  FEA
023A:  MOVFF  FEC,03
023E:  MOVF   FED,F
0240:  MOVFF  FEF,01
0244:  MOVFF  03,02
0248:  BRA    0304
.................... 
.................... 		case I2C_REG_COMMAND_ON_A:
.................... 			return (int16) channel[0].command_on_seconds;
024A:  MOVFF  D6,01
024E:  MOVFF  D7,02
0252:  BRA    0304
.................... 		case I2C_REG_COMMAND_ON_B:
.................... 			return (int16) channel[1].command_on_seconds;
0254:  MOVFF  ED,01
0258:  MOVFF  EE,02
025C:  BRA    0304
.................... 
.................... 		case I2C_REG_COMMAND_OFF_A:
.................... 			return (int16) channel[0].command_off_seconds;
025E:  MOVFF  DA,01
0262:  MOVFF  DB,02
0266:  BRA    0304
.................... 		case I2C_REG_COMMAND_OFF_B:
.................... 			return (int16) channel[1].command_off_seconds;
0268:  MOVFF  F1,01
026C:  MOVFF  F2,02
0270:  BRA    0304
.................... 
.................... 		case I2C_REG_LVD_DISCONNECT_A:
.................... 			return (int16) channel[0].lvd_disconnect_delay_seconds;
0272:  MOVFF  DE,01
0276:  MOVFF  DF,02
027A:  BRA    0304
.................... 		case I2C_REG_LVD_DISCONNECT_B:
.................... 			return (int16) channel[1].lvd_disconnect_delay_seconds;
027C:  MOVFF  F5,01
0280:  MOVFF  F6,02
0284:  BRA    0304
.................... 
.................... 		case I2C_REG_HVD_DISCONNECT_A:
.................... 			return (int16) channel[0].hvd_disconnect_delay_seconds;
0286:  MOVFF  E1,01
028A:  MOVFF  E2,02
028E:  BRA    0304
.................... 		case I2C_REG_HVD_DISCONNECT_B:
.................... 			return (int16) channel[1].hvd_disconnect_delay_seconds;
0290:  MOVFF  F8,01
0294:  MOVFF  F9,02
0298:  BRA    0304
.................... 
.................... 		case I2C_REG_LTD_DISCONNECT_A:
.................... 			return (int16) channel[0].ltd_disconnect_delay_seconds;
029A:  MOVFF  E4,01
029E:  MOVFF  E5,02
02A2:  BRA    0304
.................... 		case I2C_REG_LTD_DISCONNECT_B:
.................... 			return (int16) channel[1].ltd_disconnect_delay_seconds;
02A4:  MOVFF  FB,01
02A8:  MOVFF  FC,02
02AC:  BRA    0304
.................... 
.................... 
.................... 		case I2C_REG_HTD_DISCONNECT_A:
.................... 			return (int16) channel[0].htd_disconnect_delay_seconds;
02AE:  MOVFF  E8,01
02B2:  MOVFF  E9,02
02B6:  BRA    0304
.................... 		case I2C_REG_HTD_DISCONNECT_B:
.................... 			return (int16) channel[1].htd_disconnect_delay_seconds;
02B8:  MOVFF  FF,01
02BC:  MOVFF  100,02
02C0:  MOVLB  0
02C2:  BRA    0304
.................... 
.................... 		case I2C_REG_FUT_DISCONNECT_A:
.................... 			return (int16) 0xffff; /* not yet implemented */
02C4:  MOVLW  FF
02C6:  MOVWF  01
02C8:  MOVWF  02
02CA:  BRA    0304
.................... 		case I2C_REG_FUT_DISCONNECT_B:
.................... 			return (int16) 0xffff; /* not yet implemented */
02CC:  MOVLW  FF
02CE:  MOVWF  01
02D0:  MOVWF  02
02D2:  BRA    0304
.................... 
.................... 		case I2C_REG_SEQUENCE_NUMBER:
.................... 			return (int16) current.sequence_number;
02D4:  MOVFF  C5,01
02D8:  MOVFF  C6,02
02DC:  BRA    0304
.................... 		case I2C_REG_TIME_INTERVAL_MILLISECONDS:
.................... 			return (int16) current.interval_milliseconds;
02DE:  MOVFF  C9,01
02E2:  MOVFF  CA,02
02E6:  BRA    0304
.................... 		case I2C_REG_TIME_UPTIME_MINUTES:
.................... 			return (int16) current.uptime_minutes;
02E8:  MOVFF  C7,01
02EC:  MOVFF  C8,02
02F0:  BRA    0304
.................... 		case I2C_REG_DEFAULT_PARAMS_WRITTEN:
.................... 			return (int16) current.default_params_written;
02F2:  MOVFF  CF,01
02F6:  CLRF   02
02F8:  BRA    0304
.................... 
.................... #if 0		
.................... 		/* configuration */
.................... 		case I2C_REG_CONFIG_HARDWARE_MODEL: 
.................... 			return (int16) 'P';
.................... 		case I2C_REG_CONFIG_HARDWARE_VERSION: 
.................... 			return (int16) 'Z';
.................... 		case I2C_REG_CONFIG_SOFTWARE_MODEL: 
.................... 			return (int16) 'P';
.................... 		case I2C_REG_CONFIG_SOFTWARE_VERSION: 
.................... 			return (int16) 3;
.................... 		case I2C_REG_CONFIG_SOFTWARE_YEAR:
.................... 			return (int16) current.compile_year;
.................... 		case I2C_REG_CONFIG_SOFTWARE_MONTH:
.................... 			return (int16) current.compile_month;
.................... 		case I2C_REG_CONFIG_SOFTWARE_DAY:
.................... 			return (int16) current.compile_day;
.................... 
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			/* 1 if factory unlocked */ 
.................... 			return (int16) current.factory_unlocked; 	
.................... 		case I2C_REG_CONFIG_TICKS_ADC: 
.................... 			return (int16) config.adc_sample_ticks;
.................... 		case I2C_REG_CONFIG_STARTUP_POWER_ON_DELAY: 
.................... 			return (int16) config.startup_power_on_delay;
.................... 		case I2C_REG_CONFIG_COMMAND_OFF_HOLD_TIME:
.................... 			return (int16) config.command_off_hold_time;
.................... 		case I2C_REG_CONFIG_LVD_DISCONNECT_VOLTAGE:
.................... 			return (int16) config.lvd_disconnect_adc;
.................... 		case I2C_REG_CONFIG_LVD_DISCONNECT_DELAY:
.................... 			return (int16) config.lvd_disconnect_delay;
.................... 		case I2C_REG_CONFIG_LVD_RECONNECT_VOLTAGE:
.................... 			return (int16) config.lvd_reconnect_adc;
.................... 		case I2C_REG_CONFIG_HVD_DISCONNECT_VOLTAGE:
.................... 			return (int16) config.hvd_disconnect_adc;
.................... 		case I2C_REG_CONFIG_HVD_DISCONNECT_DELAY:
.................... 			return (int16) config.hvd_disconnect_delay;
.................... 		case I2C_REG_CONFIG_HVD_RECONNECT_VOLTAGE:
.................... 			return (int16) config.hvd_reconnect_adc;
.................... 
.................... #endif
.................... 
.................... 		/* we should have range checked, and never gotten here ... or read unimplemented (future) register */
.................... 		default: return (int16) addr;
02FA:  MOVLB  1
02FC:  MOVFF  138,01
0300:  CLRF   02
0302:  MOVLB  0
.................... 	}
0304:  GOTO   03BE (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... 
.................... 
.................... #include "interrupt_dcswc_module_latching_contactor.c"
.................... #int_timer2
.................... void isr_timer2() {
.................... 	timers.now_millisecond=1;
*
00D4:  BSF    xD0.2
.................... }
.................... 
.................... 
.................... 
.................... /* I2C slave interrupt */
00D6:  BCF    F9E.1
00D8:  GOTO   006C
.................... #byte SSPSTAT=GETENV("SFR:SSPSTAT")
.................... #INT_SSP
.................... void ssp_interrupt () {
.................... 	static int8 sstate;
.................... 	int8 state;
.................... 	int8 incoming;
.................... 	static int16 lastValue;
.................... 	static int8 lastMSB;
.................... 
.................... 	static int8 address; 
.................... 
.................... 	/* 
.................... 	our implementation of i2c_isr_state() that won't overflow and switch states
.................... 	but it will quit counting at 127 bytes. 
.................... 	If more bytes are needed, external counting variables can be used or the size of state can be made larger
.................... 	*/
.................... 
.................... 
.................... 	if ( ! bit_test(SSPSTAT,5) ) {
*
031E:  BTFSC  FC7.5
0320:  BRA    032E
.................... 		/* address */
.................... 		sstate=0;
0322:  MOVLB  1
0324:  CLRF   x03
.................... 
.................... 		if ( bit_test(SSPSTAT,2) ) {
0326:  BTFSS  FC7.2
0328:  BRA    032C
.................... 			/* set high bit if read */
.................... 			bit_set(sstate,7);
032A:  BSF    x03.7
.................... 		}
.................... 	} else {
032C:  MOVLB  0
.................... 		/* data */
.................... 	}
.................... 
.................... 	/* state variable used below is not incremented */
.................... 	state=sstate;
032E:  MOVFF  103,135
.................... 
.................... 	/* increment the state counter for next pass through unless it will overflow us into another state */
.................... 	if ( sstate != 0x7f && sstate != 0xff) {
0332:  MOVLB  1
0334:  MOVF   x03,W
0336:  SUBLW  7F
0338:  BZ    0342
033A:  INCFSZ x03,W
033C:  BRA    0340
033E:  BRA    0342
.................... 		sstate++;
0340:  INCF   x03,F
.................... 	}
.................... 
.................... 	
.................... 	/* i2c_isr_state() return an 8 bit int
.................... 		0 - Address match received with R/W bit clear, perform i2c_read( ) to read the I2C address.
.................... 		1-0x7F - Master has written data; i2c_read() will immediately return the data
.................... 		0x80 - Address match received with R/W bit set; perform i2c_read( ) to read the I2C address,
.................... 		and use i2c_write( ) to pre-load the transmit buffer for the next transaction (next I2C read
.................... 		performed by master will read this byte).
.................... 		0x81-0xFF - Transmission completed and acknowledged; respond with i2c_write() to pre-load
.................... 		the transmit buffer for the next transition (the next I2C read performed by master will read this
.................... 		byte).
.................... 		Function:
.................... 		Returns the state of I2C communications in I2C slave mode after an SSP interrupt. The return
.................... 		value increments with each byte received or sent.
.................... 		If 0x00 or 0x80 is returned, an i2C_read( ) needs to be performed to read the I2C address that
.................... 		was sent (it will match the address configured by #USE I2C so this value can be ignored)
.................... 	*/
.................... 
.................... 	if ( state <= 0x80 ) {                      
0342:  MOVF   x35,W
0344:  SUBLW  80
0346:  BNC   03A8
.................... 		/* I2C master is sending us data */
.................... 		if ( 0x80 == state ) {
0348:  MOVF   x35,W
034A:  SUBLW  80
034C:  BNZ   0354
.................... 			/* i2c_read(2) casues the function to read the SSPBUF without releasing the clock */
.................... 			incoming = i2c_read(STREAM_SLAVE,2);
034E:  MOVFF  FC9,136
.................... 		} else {
0352:  BRA    0360
.................... 			incoming = i2c_read(STREAM_SLAVE);
0354:  BCF    FC6.6
0356:  BTFSS  FC7.0
0358:  BRA    0356
035A:  MOVF   FC9,W
035C:  BSF    FC6.4
035E:  MOVWF  x36
.................... 		}
.................... 
.................... 		if ( 1 == state ) {             
0360:  DECFSZ x35,W
0362:  BRA    036C
.................... 			address = incoming<<1;
0364:  BCF    FD8.0
0366:  RLCF   x36,W
0368:  MOVWF  x07
.................... 		} else if ( state >= 2 && 0x80 != state ) {
036A:  BRA    03A8
036C:  MOVF   x35,W
036E:  SUBLW  01
0370:  BC    03A8
0372:  MOVF   x35,W
0374:  SUBLW  80
0376:  BZ    03A8
.................... 			/* received byte is data */
.................... 		
.................... 			/* save MSB and we'll process it on next */
.................... 			if ( 2 == state ) {
0378:  MOVF   x35,W
037A:  SUBLW  02
037C:  BNZ   0384
.................... 				lastMSB=incoming;
037E:  MOVFF  136,106
.................... 			} else if ( 3 == state ) {
0382:  BRA    03A8
0384:  MOVF   x35,W
0386:  SUBLW  03
0388:  BNZ   03A8
.................... 				/* 16 bit value made of previous byte and this byte */
.................... 				write_i2c(address>>1,make16(lastMSB,incoming));
038A:  BCF    FD8.0
038C:  RRCF   x07,W
038E:  MOVWF  x37
0390:  MOVFF  106,139
0394:  MOVFF  136,138
0398:  MOVWF  x3A
039A:  MOVFF  106,13C
039E:  MOVFF  136,13B
03A2:  MOVLB  0
03A4:  BRA    0004
03A6:  MOVLB  1
.................... 
.................... 				/* this write only works for a single register per I2C transaction */
.................... 				/* this is not a BUG, but it would need to be implemented if this functionality is needed */
.................... 			}
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	if ( state >= 0x80 ) {
03A8:  MOVF   x35,W
03AA:  SUBLW  7F
03AC:  BC    03E4
.................... 		/* I2C master is requesting data from us */
.................... 
.................... 		if ( ! bit_test(address,0) ) {
03AE:  BTFSC  x07.0
03B0:  BRA    03D4
.................... 			/* read 16 bit register (register address half of I2C address) on even address */
.................... 			lastValue=map_i2c(address>>1);
03B2:  BCF    FD8.0
03B4:  RRCF   x07,W
03B6:  MOVWF  x37
03B8:  MOVWF  x38
03BA:  MOVLB  0
03BC:  BRA    0156
03BE:  MOVFF  02,105
03C2:  MOVFF  01,104
.................... 
.................... 			/* send the MSB */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,1));
03C6:  MOVFF  105,137
03CA:  MOVFF  105,138
03CE:  RCALL  0308
.................... 		} else {
03D0:  BRA    03E0
03D2:  MOVLB  1
.................... 			/* send LSB of 16 bit register on odd address */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,0));
03D4:  MOVFF  104,137
03D8:  MOVFF  104,138
03DC:  MOVLB  0
03DE:  RCALL  0308
.................... 		}
.................... 		address++;
03E0:  MOVLB  1
03E2:  INCF   x07,F
.................... 	}
03E4:  BCF    F9E.3
03E6:  MOVLB  0
03E8:  GOTO   006C
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... 
.................... int8 read_dip_switch(void) {
.................... 	int16 adc;
.................... 
.................... 	set_adc_channel(9);
*
067C:  MOVLW  24
067E:  MOVWF  01
0680:  MOVF   FC2,W
0682:  ANDLW  C3
0684:  IORWF  01,W
0686:  MOVWF  FC2
.................... 	delay_ms(1);
0688:  MOVLW  01
068A:  MOVLB  1
068C:  MOVWF  x34
068E:  MOVLB  0
0690:  RCALL  0652
.................... 	adc=read_adc();
0692:  BSF    FC2.1
0694:  BTFSC  FC2.1
0696:  BRA    0694
0698:  MOVFF  FC4,133
069C:  MOVFF  FC3,132
.................... 
.................... 	/* (note that table is sorted by vout reading 
.................... 	SW3.1 (LSB) SW3.2 (MSB) VALUE ADC
....................     OFF         OFF         0     1023
.................... 	OFF         ON          2     682
....................     ON          OFF         1     511
.................... 	ON          ON          3     409
.................... 	*/
.................... 
.................... 	if ( adc > (1023-64) )
06A0:  MOVLB  1
06A2:  MOVF   x33,W
06A4:  SUBLW  02
06A6:  BC    06B8
06A8:  XORLW  FF
06AA:  BNZ   06B2
06AC:  MOVF   x32,W
06AE:  SUBLW  BF
06B0:  BC    06B8
.................... 		return 0;
06B2:  MOVLW  00
06B4:  MOVWF  01
06B6:  BRA    06E8
.................... 	if ( adc > (682-64) )
06B8:  MOVF   x33,W
06BA:  SUBLW  01
06BC:  BC    06CE
06BE:  XORLW  FF
06C0:  BNZ   06C8
06C2:  MOVF   x32,W
06C4:  SUBLW  6A
06C6:  BC    06CE
.................... 		return 2;
06C8:  MOVLW  02
06CA:  MOVWF  01
06CC:  BRA    06E8
.................... 	if ( adc > (511-64) )
06CE:  MOVF   x33,W
06D0:  SUBLW  00
06D2:  BC    06E4
06D4:  XORLW  FF
06D6:  BNZ   06DE
06D8:  MOVF   x32,W
06DA:  SUBLW  BF
06DC:  BC    06E4
.................... 		return 1;
06DE:  MOVLW  01
06E0:  MOVWF  01
06E2:  BRA    06E8
.................... 
.................... 	return 3;
06E4:  MOVLW  03
06E6:  MOVWF  01
06E8:  MOVLB  0
06EA:  RETURN 0
.................... }
.................... 
.................... void contactor_on_a(void) {
.................... 	/* only turn on contactor if it isn't on or needs a refresh */
.................... 	if ( 1 == timers.contactor_a )
*
1524:  BTFSS  xD0.5
1526:  BRA    152A
.................... 		return;
1528:  BRA    1538
.................... 
.................... 	timers.contactor_a_powersave=CONTACTOR_POWER_SAVE_MS;
152A:  MOVLW  C8
152C:  MOVWF  xD3
.................... 
.................... 	output_high(BRIDGE_A_A);
152E:  BCF    F94.3
1530:  BSF    F8B.3
.................... 	output_low(BRIDGE_A_B);
1532:  BCF    F94.4
1534:  BCF    F8B.4
.................... 
.................... 	timers.contactor_a=1;
1536:  BSF    xD0.5
1538:  GOTO   1C40 (RETURN)
.................... }
.................... 
.................... void contactor_off_a(void) {
.................... 	/* only turn off contactor if it isn't on or needs a refresh */
.................... 	if ( 0 == timers.contactor_a )
153C:  BTFSC  xD0.5
153E:  BRA    1542
.................... 		return;
1540:  BRA    1550
.................... 
.................... 	timers.contactor_a_powersave=CONTACTOR_POWER_SAVE_MS;
1542:  MOVLW  C8
1544:  MOVWF  xD3
.................... 
.................... 	output_low(BRIDGE_A_A);
1546:  BCF    F94.3
1548:  BCF    F8B.3
.................... 	output_high(BRIDGE_A_B);
154A:  BCF    F94.4
154C:  BSF    F8B.4
.................... 
.................... 	timers.contactor_a=0;
154E:  BCF    xD0.5
1550:  GOTO   1C4A (RETURN)
.................... }
.................... 
.................... void contactor_on_b(void) {
.................... 	/* only turn on contactor if it isn't on or needs a refresh */
.................... 	if ( 1 == timers.contactor_b )
1554:  BTFSS  xD0.6
1556:  BRA    155A
.................... 		return;
1558:  BRA    1568
.................... 
.................... 	timers.contactor_b_powersave=CONTACTOR_POWER_SAVE_MS;
155A:  MOVLW  C8
155C:  MOVWF  xD4
.................... 
.................... 	output_high(BRIDGE_B_A);
155E:  BCF    F94.5
1560:  BSF    F8B.5
.................... 	output_low(BRIDGE_B_B);
1562:  BCF    F94.6
1564:  BCF    F8B.6
.................... 
.................... 	timers.contactor_b=1;
1566:  BSF    xD0.6
1568:  GOTO   1C6C (RETURN)
.................... }
.................... 
.................... void contactor_off_b(void) {
.................... 	/* only turn off contactor if it isn't on or needs a refresh */
.................... 	if ( 0 == timers.contactor_b )
156C:  BTFSC  xD0.6
156E:  BRA    1572
.................... 		return;
1570:  BRA    1580
.................... 
.................... 	timers.contactor_b_powersave=CONTACTOR_POWER_SAVE_MS;
1572:  MOVLW  C8
1574:  MOVWF  xD4
.................... 
.................... 	output_low(BRIDGE_B_A);
1576:  BCF    F94.5
1578:  BCF    F8B.5
.................... 	output_high(BRIDGE_B_B);
157A:  BCF    F94.6
157C:  BSF    F8B.6
.................... 
.................... 	timers.contactor_b=0;
157E:  BCF    xD0.6
1580:  GOTO   1C76 (RETURN)
.................... }
.................... 
.................... void contactor_logic(int8 c) {
.................... 	int16 adc;
.................... 
.................... 	/* TODO: implement Command On.  */
.................... 
.................... 	/* command off. 65535 disables */
.................... 	if ( 65535 != channel[c].command_off_seconds ) {
*
0C4E:  MOVLB  1
0C50:  MOVF   x12,W
0C52:  MULLW  17
0C54:  MOVF   FF3,W
0C56:  CLRF   x16
0C58:  MOVWF  x15
0C5A:  MOVLW  05
0C5C:  ADDWF  x15,W
0C5E:  MOVWF  01
0C60:  MOVLW  00
0C62:  ADDWFC x16,W
0C64:  MOVWF  03
0C66:  MOVF   01,W
0C68:  ADDLW  D5
0C6A:  MOVWF  FE9
0C6C:  MOVLW  00
0C6E:  ADDWFC 03,W
0C70:  MOVWF  FEA
0C72:  MOVFF  FEC,03
0C76:  MOVF   FED,F
0C78:  MOVF   FEF,W
0C7A:  SUBLW  FF
0C7C:  BNZ   0C84
0C7E:  INCFSZ 03,W
0C80:  BRA    0C84
0C82:  BRA    0DF0
.................... 		if ( channel[c].command_off_seconds > 0 ) {
0C84:  MOVF   x12,W
0C86:  MULLW  17
0C88:  MOVF   FF3,W
0C8A:  CLRF   x16
0C8C:  MOVWF  x15
0C8E:  MOVLW  05
0C90:  ADDWF  x15,W
0C92:  MOVWF  01
0C94:  MOVLW  00
0C96:  ADDWFC x16,W
0C98:  MOVWF  03
0C9A:  MOVF   01,W
0C9C:  ADDLW  D5
0C9E:  MOVWF  FE9
0CA0:  MOVLW  00
0CA2:  ADDWFC 03,W
0CA4:  MOVWF  FEA
0CA6:  MOVFF  FEC,116
0CAA:  MOVF   FED,F
0CAC:  MOVFF  FEF,115
0CB0:  MOVF   x15,F
0CB2:  BNZ   0CB8
0CB4:  MOVF   x16,F
0CB6:  BZ    0CE6
.................... 			/* waiting to power off */
.................... 			channel[c].command_off_seconds--;
0CB8:  MOVF   x12,W
0CBA:  MULLW  17
0CBC:  MOVF   FF3,W
0CBE:  CLRF   x16
0CC0:  MOVWF  x15
0CC2:  MOVLW  05
0CC4:  ADDWF  x15,W
0CC6:  MOVWF  01
0CC8:  MOVLW  00
0CCA:  ADDWFC x16,W
0CCC:  MOVWF  03
0CCE:  MOVF   01,W
0CD0:  ADDLW  D5
0CD2:  MOVWF  FE9
0CD4:  MOVLW  00
0CD6:  ADDWFC 03,W
0CD8:  MOVWF  FEA
0CDA:  MOVLW  FF
0CDC:  ADDWF  FEF,F
0CDE:  BC    0CE4
0CE0:  MOVF   FEE,F
0CE2:  DECF   FED,F
.................... 		} else {
0CE4:  BRA    0DF0
.................... 			/* timer at zero, ready to power off or already powered off */
.................... 			if ( ! bit_test(channel[c].state,CH_STATE_BIT_CMD_OFF) ) {
0CE6:  MOVF   x12,W
0CE8:  MULLW  17
0CEA:  MOVF   FF3,W
0CEC:  CLRF   x16
0CEE:  MOVWF  x15
0CF0:  MOVLW  D5
0CF2:  ADDWF  x15,W
0CF4:  MOVWF  FE9
0CF6:  MOVLW  00
0CF8:  ADDWFC x16,W
0CFA:  MOVWF  FEA
0CFC:  MOVFF  FEF,117
0D00:  BTFSC  x17.2
0D02:  BRA    0D4E
.................... 				/* not currently set, so we set it and start the countdown */
.................... 				bit_set(channel[c].state,CH_STATE_BIT_CMD_OFF);
0D04:  MOVF   x12,W
0D06:  MULLW  17
0D08:  MOVF   FF3,W
0D0A:  CLRF   x16
0D0C:  MOVWF  x15
0D0E:  MOVLW  D5
0D10:  ADDWF  x15,W
0D12:  MOVWF  01
0D14:  MOVLW  00
0D16:  ADDWFC x16,W
0D18:  MOVFF  01,FE9
0D1C:  MOVWF  FEA
0D1E:  BSF    FEF.2
.................... 				channel[c].command_off_hold_seconds=config.command_off_hold_time;
0D20:  MOVF   x12,W
0D22:  MULLW  17
0D24:  MOVF   FF3,W
0D26:  CLRF   x16
0D28:  MOVWF  x15
0D2A:  MOVLW  07
0D2C:  ADDWF  x15,W
0D2E:  MOVWF  01
0D30:  MOVLW  00
0D32:  ADDWFC x16,W
0D34:  MOVWF  03
0D36:  MOVF   01,W
0D38:  ADDLW  D5
0D3A:  MOVWF  FE9
0D3C:  MOVLW  00
0D3E:  ADDWFC 03,W
0D40:  MOVWF  FEA
0D42:  MOVFF  21,FEC
0D46:  MOVF   FED,F
0D48:  MOVFF  20,FEF
.................... 			} else {
0D4C:  BRA    0DF0
.................... 				/* set, so we clear it once countdown has elapsed */
.................... 				if ( 0==channel[c].command_off_hold_seconds ) {
0D4E:  MOVF   x12,W
0D50:  MULLW  17
0D52:  MOVF   FF3,W
0D54:  CLRF   x16
0D56:  MOVWF  x15
0D58:  MOVLW  07
0D5A:  ADDWF  x15,W
0D5C:  MOVWF  01
0D5E:  MOVLW  00
0D60:  ADDWFC x16,W
0D62:  MOVWF  03
0D64:  MOVF   01,W
0D66:  ADDLW  D5
0D68:  MOVWF  FE9
0D6A:  MOVLW  00
0D6C:  ADDWFC 03,W
0D6E:  MOVWF  FEA
0D70:  MOVFF  FEC,03
0D74:  MOVF   FED,F
0D76:  MOVF   FEF,W
0D78:  BNZ   0DC4
0D7A:  MOVF   03,F
0D7C:  BNZ   0DC4
.................... 					/* countdown elapsed, clear the flag and reset the timer */
.................... 					bit_clear(channel[c].state,CH_STATE_BIT_CMD_OFF);
0D7E:  MOVF   x12,W
0D80:  MULLW  17
0D82:  MOVF   FF3,W
0D84:  CLRF   x16
0D86:  MOVWF  x15
0D88:  MOVLW  D5
0D8A:  ADDWF  x15,W
0D8C:  MOVWF  01
0D8E:  MOVLW  00
0D90:  ADDWFC x16,W
0D92:  MOVFF  01,FE9
0D96:  MOVWF  FEA
0D98:  BCF    FEF.2
.................... 					channel[c].command_off_seconds=65535;
0D9A:  MOVF   x12,W
0D9C:  MULLW  17
0D9E:  MOVF   FF3,W
0DA0:  CLRF   x16
0DA2:  MOVWF  x15
0DA4:  MOVLW  05
0DA6:  ADDWF  x15,W
0DA8:  MOVWF  01
0DAA:  MOVLW  00
0DAC:  ADDWFC x16,W
0DAE:  MOVWF  03
0DB0:  MOVF   01,W
0DB2:  ADDLW  D5
0DB4:  MOVWF  FE9
0DB6:  MOVLW  00
0DB8:  ADDWFC 03,W
0DBA:  MOVWF  FEA
0DBC:  SETF   FEC
0DBE:  MOVF   FED,F
0DC0:  SETF   FEF
.................... 				} else {
0DC2:  BRA    0DF0
.................... 					channel[c].command_off_hold_seconds--;
0DC4:  MOVF   x12,W
0DC6:  MULLW  17
0DC8:  MOVF   FF3,W
0DCA:  CLRF   x16
0DCC:  MOVWF  x15
0DCE:  MOVLW  07
0DD0:  ADDWF  x15,W
0DD2:  MOVWF  01
0DD4:  MOVLW  00
0DD6:  ADDWFC x16,W
0DD8:  MOVWF  03
0DDA:  MOVF   01,W
0DDC:  ADDLW  D5
0DDE:  MOVWF  FE9
0DE0:  MOVLW  00
0DE2:  ADDWFC 03,W
0DE4:  MOVWF  FEA
0DE6:  MOVLW  FF
0DE8:  ADDWF  FEF,F
0DEA:  BC    0DF0
0DEC:  MOVF   FEE,F
0DEE:  DECF   FED,F
.................... 				}
.................... 			}		
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	/* LVD. 65535 disables */
.................... 	if ( 65535 != config.ch[c].lvd_disconnect_delay ) {
0DF0:  MOVF   x12,W
0DF2:  MULLW  20
0DF4:  MOVF   FF3,W
0DF6:  CLRF   03
0DF8:  ADDLW  09
0DFA:  MOVWF  x15
0DFC:  MOVLW  00
0DFE:  ADDWFC 03,W
0E00:  MOVWF  x16
0E02:  MOVLW  02
0E04:  ADDWF  x15,W
0E06:  MOVWF  01
0E08:  MOVLW  00
0E0A:  ADDWFC x16,W
0E0C:  MOVWF  03
0E0E:  MOVF   01,W
0E10:  ADDLW  1B
0E12:  MOVWF  FE9
0E14:  MOVLW  00
0E16:  ADDWFC 03,W
0E18:  MOVWF  FEA
0E1A:  MOVFF  FEC,03
0E1E:  MOVF   FED,F
0E20:  MOVF   FEF,W
0E22:  SUBLW  FF
0E24:  BNZ   0E2C
0E26:  INCFSZ 03,W
0E28:  BRA    0E2C
0E2A:  BRA    1034
0E2C:  CLRF   19
0E2E:  BTFSC  FF2.7
0E30:  BSF    19.7
0E32:  BCF    FF2.7
.................... 		adc=adc_get(0);
0E34:  CLRF   x39
0E36:  MOVLB  0
0E38:  CALL   00DC
0E3C:  BTFSC  19.7
0E3E:  BSF    FF2.7
0E40:  MOVFF  02,114
0E44:  MOVFF  01,113
.................... 
.................... 		if ( adc > config.ch[c].lvd_reconnect_adc ) {
0E48:  MOVLB  1
0E4A:  MOVF   x12,W
0E4C:  MULLW  20
0E4E:  MOVF   FF3,W
0E50:  CLRF   03
0E52:  ADDLW  09
0E54:  MOVWF  x15
0E56:  MOVLW  00
0E58:  ADDWFC 03,W
0E5A:  MOVWF  x16
0E5C:  MOVLW  04
0E5E:  ADDWF  x15,W
0E60:  MOVWF  01
0E62:  MOVLW  00
0E64:  ADDWFC x16,W
0E66:  MOVWF  03
0E68:  MOVF   01,W
0E6A:  ADDLW  1B
0E6C:  MOVWF  FE9
0E6E:  MOVLW  00
0E70:  ADDWFC 03,W
0E72:  MOVWF  FEA
0E74:  MOVFF  FEC,03
0E78:  MOVF   FED,F
0E7A:  MOVFF  FEF,01
0E7E:  MOVF   03,W
0E80:  SUBWF  x14,W
0E82:  BNC   0EF6
0E84:  BNZ   0E8C
0E86:  MOVF   x13,W
0E88:  SUBWF  01,W
0E8A:  BC    0EF6
.................... 			if ( channel[c].lvd_reconnect_delay_seconds > 0 ) {
0E8C:  MOVF   x12,W
0E8E:  MULLW  17
0E90:  MOVF   FF3,W
0E92:  CLRF   x16
0E94:  MOVWF  x15
0E96:  MOVLW  0B
0E98:  ADDWF  x15,W
0E9A:  MOVWF  01
0E9C:  MOVLW  00
0E9E:  ADDWFC x16,W
0EA0:  MOVWF  03
0EA2:  MOVF   01,W
0EA4:  ADDLW  D5
0EA6:  MOVWF  FE9
0EA8:  MOVLW  00
0EAA:  ADDWFC 03,W
0EAC:  MOVWF  FEA
0EAE:  MOVF   FEF,F
0EB0:  BZ    0ED8
.................... 				channel[c].lvd_reconnect_delay_seconds--;
0EB2:  MOVF   x12,W
0EB4:  MULLW  17
0EB6:  MOVF   FF3,W
0EB8:  CLRF   x16
0EBA:  MOVWF  x15
0EBC:  MOVLW  0B
0EBE:  ADDWF  x15,W
0EC0:  MOVWF  01
0EC2:  MOVLW  00
0EC4:  ADDWFC x16,W
0EC6:  MOVWF  03
0EC8:  MOVF   01,W
0ECA:  ADDLW  D5
0ECC:  MOVWF  FE9
0ECE:  MOVLW  00
0ED0:  ADDWFC 03,W
0ED2:  MOVWF  FEA
0ED4:  DECF   FEF,F
.................... 			} else {
0ED6:  BRA    0EF4
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_LVD);
0ED8:  MOVF   x12,W
0EDA:  MULLW  17
0EDC:  MOVF   FF3,W
0EDE:  CLRF   x16
0EE0:  MOVWF  x15
0EE2:  MOVLW  D5
0EE4:  ADDWF  x15,W
0EE6:  MOVWF  01
0EE8:  MOVLW  00
0EEA:  ADDWFC x16,W
0EEC:  MOVFF  01,FE9
0EF0:  MOVWF  FEA
0EF2:  BCF    FEF.3
.................... 			}
.................... 		} else {
0EF4:  BRA    0F1C
.................... 			channel[c].lvd_reconnect_delay_seconds=config.reconnect_delay; /* 5 seconds countdown before reconnecting */
0EF6:  MOVF   x12,W
0EF8:  MULLW  17
0EFA:  MOVF   FF3,W
0EFC:  CLRF   x16
0EFE:  MOVWF  x15
0F00:  MOVLW  0B
0F02:  ADDWF  x15,W
0F04:  MOVWF  01
0F06:  MOVLW  00
0F08:  ADDWFC x16,W
0F0A:  MOVWF  03
0F0C:  MOVF   01,W
0F0E:  ADDLW  D5
0F10:  MOVWF  FE9
0F12:  MOVLW  00
0F14:  ADDWFC 03,W
0F16:  MOVWF  FEA
0F18:  MOVFF  1F,FEF
.................... 		}
.................... 
.................... 		if ( adc < config.ch[c].lvd_disconnect_adc ) {
0F1C:  MOVF   x12,W
0F1E:  MULLW  20
0F20:  MOVF   FF3,W
0F22:  CLRF   03
0F24:  ADDLW  24
0F26:  MOVWF  FE9
0F28:  MOVLW  00
0F2A:  ADDWFC 03,W
0F2C:  MOVWF  FEA
0F2E:  MOVFF  FEC,03
0F32:  MOVF   FED,F
0F34:  MOVFF  FEF,01
0F38:  MOVF   x14,W
0F3A:  SUBWF  03,W
0F3C:  BNC   0FC6
0F3E:  BNZ   0F46
0F40:  MOVF   01,W
0F42:  SUBWF  x13,W
0F44:  BC    0FC6
.................... 			if ( channel[c].lvd_disconnect_delay_seconds > 0 ) {
0F46:  MOVF   x12,W
0F48:  MULLW  17
0F4A:  MOVF   FF3,W
0F4C:  CLRF   x16
0F4E:  MOVWF  x15
0F50:  MOVLW  09
0F52:  ADDWF  x15,W
0F54:  MOVWF  01
0F56:  MOVLW  00
0F58:  ADDWFC x16,W
0F5A:  MOVWF  03
0F5C:  MOVF   01,W
0F5E:  ADDLW  D5
0F60:  MOVWF  FE9
0F62:  MOVLW  00
0F64:  ADDWFC 03,W
0F66:  MOVWF  FEA
0F68:  MOVFF  FEC,116
0F6C:  MOVF   FED,F
0F6E:  MOVFF  FEF,115
0F72:  MOVF   x15,F
0F74:  BNZ   0F7A
0F76:  MOVF   x16,F
0F78:  BZ    0FA8
.................... 				channel[c].lvd_disconnect_delay_seconds--;
0F7A:  MOVF   x12,W
0F7C:  MULLW  17
0F7E:  MOVF   FF3,W
0F80:  CLRF   x16
0F82:  MOVWF  x15
0F84:  MOVLW  09
0F86:  ADDWF  x15,W
0F88:  MOVWF  01
0F8A:  MOVLW  00
0F8C:  ADDWFC x16,W
0F8E:  MOVWF  03
0F90:  MOVF   01,W
0F92:  ADDLW  D5
0F94:  MOVWF  FE9
0F96:  MOVLW  00
0F98:  ADDWFC 03,W
0F9A:  MOVWF  FEA
0F9C:  MOVLW  FF
0F9E:  ADDWF  FEF,F
0FA0:  BC    0FA6
0FA2:  MOVF   FEE,F
0FA4:  DECF   FED,F
.................... 			} else {
0FA6:  BRA    0FC4
.................... 				bit_set(channel[c].state,CH_STATE_BIT_LVD);
0FA8:  MOVF   x12,W
0FAA:  MULLW  17
0FAC:  MOVF   FF3,W
0FAE:  CLRF   x16
0FB0:  MOVWF  x15
0FB2:  MOVLW  D5
0FB4:  ADDWF  x15,W
0FB6:  MOVWF  01
0FB8:  MOVLW  00
0FBA:  ADDWFC x16,W
0FBC:  MOVFF  01,FE9
0FC0:  MOVWF  FEA
0FC2:  BSF    FEF.3
.................... 			}
.................... 		} else {
0FC4:  BRA    1034
.................... 			channel[c].lvd_disconnect_delay_seconds=config.ch[c].lvd_disconnect_delay;
0FC6:  MOVF   x12,W
0FC8:  MULLW  17
0FCA:  MOVF   FF3,W
0FCC:  CLRF   x16
0FCE:  MOVWF  x15
0FD0:  MOVLW  09
0FD2:  ADDWF  x15,W
0FD4:  MOVWF  01
0FD6:  MOVLW  00
0FD8:  ADDWFC x16,W
0FDA:  MOVWF  03
0FDC:  MOVF   01,W
0FDE:  ADDLW  D5
0FE0:  MOVWF  01
0FE2:  MOVLW  00
0FE4:  ADDWFC 03,F
0FE6:  MOVFF  01,115
0FEA:  MOVFF  03,116
0FEE:  MOVF   x12,W
0FF0:  MULLW  20
0FF2:  MOVF   FF3,W
0FF4:  CLRF   03
0FF6:  ADDLW  09
0FF8:  MOVWF  x17
0FFA:  MOVLW  00
0FFC:  ADDWFC 03,W
0FFE:  MOVWF  x18
1000:  MOVLW  02
1002:  ADDWF  x17,W
1004:  MOVWF  01
1006:  MOVLW  00
1008:  ADDWFC x18,W
100A:  MOVWF  03
100C:  MOVF   01,W
100E:  ADDLW  1B
1010:  MOVWF  FE9
1012:  MOVLW  00
1014:  ADDWFC 03,W
1016:  MOVWF  FEA
1018:  MOVFF  FEC,03
101C:  MOVF   FED,F
101E:  MOVFF  FEF,117
1022:  MOVFF  116,FEA
1026:  MOVFF  115,FE9
102A:  MOVFF  03,FEC
102E:  MOVF   FED,F
1030:  MOVFF  117,FEF
.................... 		}
.................... 	}
.................... 
.................... 	/* HVD. 65535 disables */
.................... 	if ( 65535 != config.ch[c].hvd_disconnect_delay ) {
1034:  MOVF   x12,W
1036:  MULLW  20
1038:  MOVF   FF3,W
103A:  CLRF   03
103C:  ADDLW  09
103E:  MOVWF  x15
1040:  MOVLW  00
1042:  ADDWFC 03,W
1044:  MOVWF  x16
1046:  MOVLW  0A
1048:  ADDWF  x15,W
104A:  MOVWF  01
104C:  MOVLW  00
104E:  ADDWFC x16,W
1050:  MOVWF  03
1052:  MOVF   01,W
1054:  ADDLW  1B
1056:  MOVWF  FE9
1058:  MOVLW  00
105A:  ADDWFC 03,W
105C:  MOVWF  FEA
105E:  MOVFF  FEC,03
1062:  MOVF   FED,F
1064:  MOVF   FEF,W
1066:  SUBLW  FF
1068:  BNZ   1070
106A:  INCFSZ 03,W
106C:  BRA    1070
106E:  BRA    1290
1070:  CLRF   19
1072:  BTFSC  FF2.7
1074:  BSF    19.7
1076:  BCF    FF2.7
.................... 		adc=adc_get(0);
1078:  CLRF   x39
107A:  MOVLB  0
107C:  CALL   00DC
1080:  BTFSC  19.7
1082:  BSF    FF2.7
1084:  MOVFF  02,114
1088:  MOVFF  01,113
.................... 
.................... 		if ( adc < config.ch[c].hvd_reconnect_adc ) {
108C:  MOVLB  1
108E:  MOVF   x12,W
1090:  MULLW  20
1092:  MOVF   FF3,W
1094:  CLRF   03
1096:  ADDLW  09
1098:  MOVWF  x15
109A:  MOVLW  00
109C:  ADDWFC 03,W
109E:  MOVWF  x16
10A0:  MOVLW  0C
10A2:  ADDWF  x15,W
10A4:  MOVWF  01
10A6:  MOVLW  00
10A8:  ADDWFC x16,W
10AA:  MOVWF  03
10AC:  MOVF   01,W
10AE:  ADDLW  1B
10B0:  MOVWF  FE9
10B2:  MOVLW  00
10B4:  ADDWFC 03,W
10B6:  MOVWF  FEA
10B8:  MOVFF  FEC,03
10BC:  MOVF   FED,F
10BE:  MOVFF  FEF,01
10C2:  MOVF   x14,W
10C4:  SUBWF  03,W
10C6:  BNC   113A
10C8:  BNZ   10D0
10CA:  MOVF   01,W
10CC:  SUBWF  x13,W
10CE:  BC    113A
.................... 			if ( channel[c].hvd_reconnect_delay_seconds > 0 ) {
10D0:  MOVF   x12,W
10D2:  MULLW  17
10D4:  MOVF   FF3,W
10D6:  CLRF   x16
10D8:  MOVWF  x15
10DA:  MOVLW  0E
10DC:  ADDWF  x15,W
10DE:  MOVWF  01
10E0:  MOVLW  00
10E2:  ADDWFC x16,W
10E4:  MOVWF  03
10E6:  MOVF   01,W
10E8:  ADDLW  D5
10EA:  MOVWF  FE9
10EC:  MOVLW  00
10EE:  ADDWFC 03,W
10F0:  MOVWF  FEA
10F2:  MOVF   FEF,F
10F4:  BZ    111C
.................... 				channel[c].hvd_reconnect_delay_seconds--;
10F6:  MOVF   x12,W
10F8:  MULLW  17
10FA:  MOVF   FF3,W
10FC:  CLRF   x16
10FE:  MOVWF  x15
1100:  MOVLW  0E
1102:  ADDWF  x15,W
1104:  MOVWF  01
1106:  MOVLW  00
1108:  ADDWFC x16,W
110A:  MOVWF  03
110C:  MOVF   01,W
110E:  ADDLW  D5
1110:  MOVWF  FE9
1112:  MOVLW  00
1114:  ADDWFC 03,W
1116:  MOVWF  FEA
1118:  DECF   FEF,F
.................... 			} else {
111A:  BRA    1138
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_HVD);
111C:  MOVF   x12,W
111E:  MULLW  17
1120:  MOVF   FF3,W
1122:  CLRF   x16
1124:  MOVWF  x15
1126:  MOVLW  D5
1128:  ADDWF  x15,W
112A:  MOVWF  01
112C:  MOVLW  00
112E:  ADDWFC x16,W
1130:  MOVFF  01,FE9
1134:  MOVWF  FEA
1136:  BCF    FEF.4
.................... 			}
.................... 		} else {
1138:  BRA    1160
.................... 			channel[c].hvd_reconnect_delay_seconds=config.reconnect_delay; /* 5 seconds countdown before reconnecting */
113A:  MOVF   x12,W
113C:  MULLW  17
113E:  MOVF   FF3,W
1140:  CLRF   x16
1142:  MOVWF  x15
1144:  MOVLW  0E
1146:  ADDWF  x15,W
1148:  MOVWF  01
114A:  MOVLW  00
114C:  ADDWFC x16,W
114E:  MOVWF  03
1150:  MOVF   01,W
1152:  ADDLW  D5
1154:  MOVWF  FE9
1156:  MOVLW  00
1158:  ADDWFC 03,W
115A:  MOVWF  FEA
115C:  MOVFF  1F,FEF
.................... 		}
.................... 
.................... 		if ( adc > config.ch[c].hvd_disconnect_adc ) {
1160:  MOVF   x12,W
1162:  MULLW  20
1164:  MOVF   FF3,W
1166:  CLRF   03
1168:  ADDLW  09
116A:  MOVWF  x15
116C:  MOVLW  00
116E:  ADDWFC 03,W
1170:  MOVWF  x16
1172:  MOVLW  08
1174:  ADDWF  x15,W
1176:  MOVWF  01
1178:  MOVLW  00
117A:  ADDWFC x16,W
117C:  MOVWF  03
117E:  MOVF   01,W
1180:  ADDLW  1B
1182:  MOVWF  FE9
1184:  MOVLW  00
1186:  ADDWFC 03,W
1188:  MOVWF  FEA
118A:  MOVFF  FEC,03
118E:  MOVF   FED,F
1190:  MOVFF  FEF,01
1194:  MOVF   03,W
1196:  SUBWF  x14,W
1198:  BNC   1222
119A:  BNZ   11A2
119C:  MOVF   x13,W
119E:  SUBWF  01,W
11A0:  BC    1222
.................... 			if ( channel[c].hvd_disconnect_delay_seconds > 0 ) {
11A2:  MOVF   x12,W
11A4:  MULLW  17
11A6:  MOVF   FF3,W
11A8:  CLRF   x16
11AA:  MOVWF  x15
11AC:  MOVLW  0C
11AE:  ADDWF  x15,W
11B0:  MOVWF  01
11B2:  MOVLW  00
11B4:  ADDWFC x16,W
11B6:  MOVWF  03
11B8:  MOVF   01,W
11BA:  ADDLW  D5
11BC:  MOVWF  FE9
11BE:  MOVLW  00
11C0:  ADDWFC 03,W
11C2:  MOVWF  FEA
11C4:  MOVFF  FEC,116
11C8:  MOVF   FED,F
11CA:  MOVFF  FEF,115
11CE:  MOVF   x15,F
11D0:  BNZ   11D6
11D2:  MOVF   x16,F
11D4:  BZ    1204
.................... 				channel[c].hvd_disconnect_delay_seconds--;
11D6:  MOVF   x12,W
11D8:  MULLW  17
11DA:  MOVF   FF3,W
11DC:  CLRF   x16
11DE:  MOVWF  x15
11E0:  MOVLW  0C
11E2:  ADDWF  x15,W
11E4:  MOVWF  01
11E6:  MOVLW  00
11E8:  ADDWFC x16,W
11EA:  MOVWF  03
11EC:  MOVF   01,W
11EE:  ADDLW  D5
11F0:  MOVWF  FE9
11F2:  MOVLW  00
11F4:  ADDWFC 03,W
11F6:  MOVWF  FEA
11F8:  MOVLW  FF
11FA:  ADDWF  FEF,F
11FC:  BC    1202
11FE:  MOVF   FEE,F
1200:  DECF   FED,F
.................... 			} else {
1202:  BRA    1220
.................... 				bit_set(channel[c].state,CH_STATE_BIT_HVD);
1204:  MOVF   x12,W
1206:  MULLW  17
1208:  MOVF   FF3,W
120A:  CLRF   x16
120C:  MOVWF  x15
120E:  MOVLW  D5
1210:  ADDWF  x15,W
1212:  MOVWF  01
1214:  MOVLW  00
1216:  ADDWFC x16,W
1218:  MOVFF  01,FE9
121C:  MOVWF  FEA
121E:  BSF    FEF.4
.................... 			}
.................... 		} else {
1220:  BRA    1290
.................... 			channel[c].hvd_disconnect_delay_seconds=config.ch[c].hvd_disconnect_delay;
1222:  MOVF   x12,W
1224:  MULLW  17
1226:  MOVF   FF3,W
1228:  CLRF   x16
122A:  MOVWF  x15
122C:  MOVLW  0C
122E:  ADDWF  x15,W
1230:  MOVWF  01
1232:  MOVLW  00
1234:  ADDWFC x16,W
1236:  MOVWF  03
1238:  MOVF   01,W
123A:  ADDLW  D5
123C:  MOVWF  01
123E:  MOVLW  00
1240:  ADDWFC 03,F
1242:  MOVFF  01,115
1246:  MOVFF  03,116
124A:  MOVF   x12,W
124C:  MULLW  20
124E:  MOVF   FF3,W
1250:  CLRF   03
1252:  ADDLW  09
1254:  MOVWF  x17
1256:  MOVLW  00
1258:  ADDWFC 03,W
125A:  MOVWF  x18
125C:  MOVLW  0A
125E:  ADDWF  x17,W
1260:  MOVWF  01
1262:  MOVLW  00
1264:  ADDWFC x18,W
1266:  MOVWF  03
1268:  MOVF   01,W
126A:  ADDLW  1B
126C:  MOVWF  FE9
126E:  MOVLW  00
1270:  ADDWFC 03,W
1272:  MOVWF  FEA
1274:  MOVFF  FEC,03
1278:  MOVF   FED,F
127A:  MOVFF  FEF,117
127E:  MOVFF  116,FEA
1282:  MOVFF  115,FE9
1286:  MOVFF  03,FEC
128A:  MOVF   FED,F
128C:  MOVFF  117,FEF
.................... 		}
.................... 	}
1290:  MOVLB  0
1292:  RETURN 0
.................... 
.................... 
.................... 	/* TODO: implement Low Temperature Disconnect (LTD) and High Temperature Disconnect (HTD) */
.................... }
.................... 
.................... void contactor_set() {
1294:  GOTO   1314 (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... 
.................... void periodic_millisecond(void) {
.................... 	static int8 uptimeticks=0;
.................... 	static int16 adcTicks=0;
.................... 	static int16 ticks=0;
.................... 
.................... 
.................... 	timers.now_millisecond=0;
1298:  BCF    xD0.2
.................... 
.................... 	/* LED control */
.................... 	if ( 0==timers.led_on_a ) {
129A:  MOVF   xD1,F
129C:  BNZ   12A4
.................... 		output_low(LED_A);
129E:  BCF    F94.1
12A0:  BCF    F8B.1
.................... 	} else {
12A2:  BRA    12AA
.................... 		output_high(LED_A);
12A4:  BCF    F94.1
12A6:  BSF    F8B.1
.................... 		timers.led_on_a--;
12A8:  DECF   xD1,F
.................... 	}
.................... 	if ( 0==timers.led_on_b ) {
12AA:  MOVF   xD2,F
12AC:  BNZ   12B4
.................... 		output_low(LED_B);
12AE:  BCF    F94.2
12B0:  BCF    F8B.2
.................... 	} else {
12B2:  BRA    12BA
.................... 		output_high(LED_B);
12B4:  BCF    F94.2
12B6:  BSF    F8B.2
.................... 		timers.led_on_b--;
12B8:  DECF   xD2,F
.................... 	}
.................... 
.................... 	/* some other random stuff that we don't need to do every cycle in main */
.................... 	if ( current.interval_milliseconds < 65535 ) {
12BA:  INCFSZ xC9,W
12BC:  BRA    12C4
12BE:  INCFSZ xCA,W
12C0:  BRA    12C4
12C2:  BRA    12CA
.................... 		current.interval_milliseconds++;
12C4:  INCF   xC9,F
12C6:  BTFSC  FD8.2
12C8:  INCF   xCA,F
.................... 	}
.................... 
.................... 	/* contactor timeout */
.................... 	if ( 0 == timers.contactor_a_powersave ) {
12CA:  MOVF   xD3,F
12CC:  BNZ   12D8
.................... 		output_low(BRIDGE_A_A);
12CE:  BCF    F94.3
12D0:  BCF    F8B.3
.................... 		output_low(BRIDGE_A_B);
12D2:  BCF    F94.4
12D4:  BCF    F8B.4
.................... 	} else {
12D6:  BRA    12DA
.................... 		timers.contactor_a_powersave--;
12D8:  DECF   xD3,F
.................... 	}
.................... 	if ( 0 == timers.contactor_b_powersave ) {
12DA:  MOVF   xD4,F
12DC:  BNZ   12E8
.................... 		output_low(BRIDGE_B_A);
12DE:  BCF    F94.5
12E0:  BCF    F8B.5
.................... 		output_low(BRIDGE_B_B);
12E2:  BCF    F94.6
12E4:  BCF    F8B.6
.................... 	} else {
12E6:  BRA    12EA
.................... 		timers.contactor_b_powersave--;
12E8:  DECF   xD4,F
.................... 	}
.................... 
.................... 
.................... 
.................... 
.................... 	/* seconds */
.................... 	ticks++;
12EA:  MOVLB  1
12EC:  INCF   x0B,F
12EE:  BTFSC  FD8.2
12F0:  INCF   x0C,F
.................... 	if ( 1000 == ticks ) {
12F2:  MOVF   x0B,W
12F4:  SUBLW  E8
12F6:  BNZ   1334
12F8:  MOVF   x0C,W
12FA:  SUBLW  03
12FC:  BNZ   1334
.................... 		ticks=0;
12FE:  CLRF   x0C
1300:  CLRF   x0B
.................... 
.................... 		/* set channe[n].state based on logic */
.................... 		contactor_logic(0);
1302:  CLRF   x12
1304:  MOVLB  0
1306:  RCALL  0C4E
.................... 		contactor_logic(1);
1308:  MOVLW  01
130A:  MOVLB  1
130C:  MOVWF  x12
130E:  MOVLB  0
1310:  RCALL  0C4E
.................... 
.................... 		/* set contactor outputs */
.................... 		contactor_set();
1312:  BRA    1294
.................... 		
.................... 		/* uptime counter */
.................... 		uptimeTicks++;
1314:  MOVLB  1
1316:  INCF   x08,F
.................... 		if ( 60 == uptimeTicks ) {
1318:  MOVF   x08,W
131A:  SUBLW  3C
131C:  BNZ   1334
.................... 			uptimeTicks=0;
131E:  CLRF   x08
.................... 			if ( current.uptime_minutes < 65535 ) 
1320:  MOVLB  0
1322:  INCFSZ xC7,W
1324:  BRA    132C
1326:  INCFSZ xC8,W
1328:  BRA    132C
132A:  BRA    1332
.................... 				current.uptime_minutes++;
132C:  INCF   xC7,F
132E:  BTFSC  FD8.2
1330:  INCF   xC8,F
1332:  MOVLB  1
.................... 		}
.................... 	}
.................... 
.................... 	/* ADC sample counter */
.................... 	if ( timers.now_adc_reset_count ) {
1334:  MOVLB  0
1336:  BTFSS  xD0.1
1338:  BRA    1344
.................... 		timers.now_adc_reset_count=0;
133A:  BCF    xD0.1
.................... 		adcTicks=0;
133C:  MOVLB  1
133E:  CLRF   x0A
1340:  CLRF   x09
1342:  MOVLB  0
.................... 	}
.................... 
.................... 	/* ADC sampling trigger */
.................... 	adcTicks++;
1344:  MOVLB  1
1346:  INCF   x09,F
1348:  BTFSC  FD8.2
134A:  INCF   x0A,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) {
134C:  MOVF   1B,W
134E:  SUBWF  x09,W
1350:  BNZ   1362
1352:  MOVF   1C,W
1354:  SUBWF  x0A,W
1356:  BNZ   1362
.................... 		adcTicks=0;
1358:  CLRF   x0A
135A:  CLRF   x09
.................... 		timers.now_adc_sample=1;
135C:  MOVLB  0
135E:  BSF    xD0.0
1360:  MOVLB  1
.................... 	}
1362:  MOVLB  0
1364:  GOTO   176E (RETURN)
.................... 
.................... }
.................... 
.................... void init(void) {
.................... 	int8 buff[32];
.................... 	setup_oscillator(OSC_16MHZ);
*
06EC:  MOVLW  70
06EE:  MOVWF  FD3
06F0:  BCF    F9B.6
06F2:  BCF    F9B.7
.................... 
.................... 	setup_adc(ADC_CLOCK_DIV_16);
06F4:  MOVF   FC0,W
06F6:  ANDLW  C0
06F8:  IORLW  05
06FA:  MOVWF  FC0
06FC:  BSF    FC0.7
06FE:  BSF    FC2.0
.................... 	/* NTC thermistor on sAN2, input voltage divider on sAN4, DIP switch analog on sAN9
.................... 	voltage spans between 0 and Vdd */
.................... 	setup_adc_ports(sAN2 | sAN4 | sAN9,VSS_VDD);
0700:  MOVLW  14
0702:  MOVWF  F7E
0704:  BCF    FC1.0
0706:  BCF    FC1.1
0708:  BCF    FC1.2
070A:  BCF    FC1.3
070C:  MOVLW  02
070E:  MOVWF  F7F
.................... 
.................... 	setup_wdt(WDT_512MS);
0710:  BSF    FD1.0
.................... 
.................... 	set_tris_a(0b00111111);
0712:  MOVLW  3F
0714:  MOVWF  F92
.................... 	set_tris_b(0b01110000);
0716:  MOVLW  70
0718:  MOVWF  F93
.................... 	set_tris_c(0b10000001);
071A:  MOVLW  81
071C:  MOVWF  F94
.................... //               76543210
.................... 
.................... 	port_a_pullups(0b00110000);
071E:  MOVLW  30
0720:  MOVWF  F77
0722:  BCF    FF1.7
.................... 	port_b_pullups(0b00000000);
0724:  CLRF   F78
.................... //                   76543210
.................... 
.................... 	/* data structure initialization */
.................... 	/* all initialized to 0 on declaration. Just do this if need non-zero */
.................... 	channel[0].command_off_seconds=65535;
0726:  SETF   xDB
0728:  SETF   xDA
.................... 	channel[1].command_off_seconds=65535;
072A:  SETF   xF2
072C:  SETF   xF1
.................... 	channel[0].command_on_seconds =65535;
072E:  SETF   xD7
0730:  SETF   xD6
.................... 	channel[1].command_on_seconds =65535;
0732:  SETF   xEE
0734:  SETF   xED
.................... 
.................... 
.................... 	/* get our compiled date from constant */
.................... 	strcpy(buff,__DATE__);
0736:  MOVLW  01
0738:  MOVWF  FEA
073A:  MOVLW  12
073C:  MOVWF  FE9
073E:  MOVLW  00
0740:  RCALL  00BA
0742:  TBLRD*-
0744:  TBLRD*+
0746:  MOVF   FF5,W
0748:  MOVWF  FEE
074A:  IORLW  00
074C:  BNZ   0744
.................... 	current.compile_day =(buff[0]-'0')*10;
074E:  MOVLW  30
0750:  MOVLB  1
0752:  SUBWF  x12,W
0754:  MULLW  0A
0756:  MOVFF  FF3,CE
075A:  MOVLB  0
.................... 	current.compile_day+=(buff[1]-'0');
075C:  MOVLW  30
075E:  MOVLB  1
0760:  SUBWF  x13,W
0762:  MOVLB  0
0764:  ADDWF  xCE,F
.................... 	/* determine month ... how annoying */
.................... 	if ( 'J'==buff[3] ) {
0766:  MOVLB  1
0768:  MOVF   x15,W
076A:  SUBLW  4A
076C:  BNZ   0798
.................... 		if ( 'A'==buff[4] )
076E:  MOVF   x16,W
0770:  SUBLW  41
0772:  BNZ   077E
.................... 			current.compile_month=1;
0774:  MOVLW  01
0776:  MOVLB  0
0778:  MOVWF  xCD
077A:  BRA    0794
077C:  MOVLB  1
.................... 		else if ( 'N'==buff[5] )
077E:  MOVF   x17,W
0780:  SUBLW  4E
0782:  BNZ   078E
.................... 			current.compile_month=6;
0784:  MOVLW  06
0786:  MOVLB  0
0788:  MOVWF  xCD
078A:  BRA    0794
078C:  MOVLB  1
.................... 		else
.................... 			current.compile_month=7;
078E:  MOVLW  07
0790:  MOVLB  0
0792:  MOVWF  xCD
.................... 	} else if ( 'A'==buff[3] ) {
0794:  BRA    082C
0796:  MOVLB  1
0798:  MOVF   x15,W
079A:  SUBLW  41
079C:  BNZ   07B8
.................... 		if ( 'P'==buff[4] )
079E:  MOVF   x16,W
07A0:  SUBLW  50
07A2:  BNZ   07AE
.................... 			current.compile_month=4;
07A4:  MOVLW  04
07A6:  MOVLB  0
07A8:  MOVWF  xCD
07AA:  BRA    07B4
07AC:  MOVLB  1
.................... 		else
.................... 			current.compile_month=8;
07AE:  MOVLW  08
07B0:  MOVLB  0
07B2:  MOVWF  xCD
.................... 	} else if ( 'M'==buff[3] ) {
07B4:  BRA    082C
07B6:  MOVLB  1
07B8:  MOVF   x15,W
07BA:  SUBLW  4D
07BC:  BNZ   07D8
.................... 		if ( 'R'==buff[5] )
07BE:  MOVF   x17,W
07C0:  SUBLW  52
07C2:  BNZ   07CE
.................... 			current.compile_month=3;
07C4:  MOVLW  03
07C6:  MOVLB  0
07C8:  MOVWF  xCD
07CA:  BRA    07D4
07CC:  MOVLB  1
.................... 		else
.................... 			current.compile_month=5;
07CE:  MOVLW  05
07D0:  MOVLB  0
07D2:  MOVWF  xCD
.................... 	} else if ( 'F'==buff[3] ) {
07D4:  BRA    082C
07D6:  MOVLB  1
07D8:  MOVF   x15,W
07DA:  SUBLW  46
07DC:  BNZ   07E8
.................... 		current.compile_month=2;
07DE:  MOVLW  02
07E0:  MOVLB  0
07E2:  MOVWF  xCD
.................... 	} else if ( 'S'==buff[3] ) {
07E4:  BRA    082C
07E6:  MOVLB  1
07E8:  MOVF   x15,W
07EA:  SUBLW  53
07EC:  BNZ   07F8
.................... 		current.compile_month=9;
07EE:  MOVLW  09
07F0:  MOVLB  0
07F2:  MOVWF  xCD
.................... 	} else if ( 'O'==buff[3] ) {
07F4:  BRA    082C
07F6:  MOVLB  1
07F8:  MOVF   x15,W
07FA:  SUBLW  4F
07FC:  BNZ   0808
.................... 		current.compile_month=10;
07FE:  MOVLW  0A
0800:  MOVLB  0
0802:  MOVWF  xCD
.................... 	} else if ( 'N'==buff[3] ) {
0804:  BRA    082C
0806:  MOVLB  1
0808:  MOVF   x15,W
080A:  SUBLW  4E
080C:  BNZ   0818
.................... 		current.compile_month=11;
080E:  MOVLW  0B
0810:  MOVLB  0
0812:  MOVWF  xCD
.................... 	} else if ( 'D'==buff[3] ) {
0814:  BRA    082C
0816:  MOVLB  1
0818:  MOVF   x15,W
081A:  SUBLW  44
081C:  BNZ   0828
.................... 		current.compile_month=12;
081E:  MOVLW  0C
0820:  MOVLB  0
0822:  MOVWF  xCD
.................... 	} else {
0824:  BRA    082C
0826:  MOVLB  1
.................... 		/* error parsing, shouldn't happen */
.................... 		current.compile_month=255;
0828:  MOVLB  0
082A:  SETF   xCD
.................... 	}
.................... 	current.compile_year =(buff[7]-'0')*10;
082C:  MOVLW  30
082E:  MOVLB  1
0830:  SUBWF  x19,W
0832:  MULLW  0A
0834:  MOVFF  FF3,CC
0838:  MOVLB  0
.................... 	current.compile_year+=(buff[8]-'0');
083A:  MOVLW  30
083C:  MOVLB  1
083E:  SUBWF  x1A,W
0840:  MOVLB  0
0842:  ADDWF  xCC,F
.................... 
.................... 
.................... 	/* one periodic interrupt @ 1mS. Generated from system 16 MHz clock */
.................... 	/* prescale=16, match=249, postscale=1. Match is 249 because when match occurs, one cycle is lost */
.................... 	setup_timer_2(T2_DIV_BY_16,249,1);
0844:  MOVLW  00
0846:  IORLW  06
0848:  MOVWF  FCA
084A:  MOVLW  F9
084C:  MOVWF  FCB
.................... 
.................... 	enable_interrupts(INT_TIMER2);
084E:  BSF    F9D.1
.................... 
.................... 	/* set I2C slave address, which is always an even number */
.................... 	i2c_slaveaddr(0x3e + (read_dip_switch()<<1) );
0850:  RCALL  067C
0852:  BCF    FD8.0
0854:  RLCF   01,W
0856:  ADDLW  3E
0858:  MOVLB  1
085A:  MOVWF  FC8
085C:  MOVLB  0
085E:  GOTO   1612 (RETURN)
.................... }
.................... 
.................... 
.................... void main(void) {
*
1584:  CLRF   FF8
1586:  BCF    FD0.7
1588:  BSF    07.7
158A:  BSF    F93.6
158C:  BSF    F93.4
158E:  CLRF   FC8
1590:  MOVLW  36
1592:  MOVWF  FC6
1594:  BSF    FC5.0
1596:  BSF    FC5.7
1598:  CLRF   1A
159A:  BSF    FB8.3
159C:  MOVLW  A0
159E:  MOVWF  FAF
15A0:  MOVLW  01
15A2:  MOVWF  FB0
15A4:  MOVLW  A6
15A6:  MOVWF  FAC
15A8:  MOVLW  90
15AA:  MOVWF  FAB
15AC:  MOVLB  1
15AE:  CLRF   x0E
15B0:  CLRF   x0D
15B2:  MOVLW  00
15B4:  MOVWF  F7E
15B6:  BCF    FC1.0
15B8:  BCF    FC1.1
15BA:  BCF    FC1.2
15BC:  BCF    FC1.3
15BE:  MOVWF  F7F
15C0:  CLRF   F6C
15C2:  CLRF   F6B
15C4:  CLRF   F6D
15C6:  BRA    15CE
15C8:  DATA F2,40
15CA:  DATA 1B,00
15CC:  DATA 00,00
15CE:  MOVLW  00
15D0:  MOVWF  FF8
15D2:  MOVLW  15
15D4:  MOVWF  FF7
15D6:  MOVLW  C8
15D8:  MOVWF  FF6
15DA:  TBLRD*+
15DC:  MOVF   FF5,W
15DE:  MOVWF  00
15E0:  XORLW  00
15E2:  BZ    160A
15E4:  TBLRD*+
15E6:  MOVF   FF5,W
15E8:  MOVWF  01
15EA:  BTFSC  FE8.7
15EC:  BRA    15F8
15EE:  ANDLW  3F
15F0:  MOVWF  FEA
15F2:  TBLRD*+
15F4:  MOVFF  FF5,FE9
15F8:  BTFSC  01.6
15FA:  TBLRD*+
15FC:  BTFSS  01.6
15FE:  TBLRD*+
1600:  MOVFF  FF5,FEE
1604:  DCFSNZ 00,F
1606:  BRA    15DA
1608:  BRA    15FC
160A:  CLRF   FF8
.................... 	int8 i;
.................... 	int8 last_a, last_b;
.................... 
.................... 	init();
160C:  MOVLB  0
160E:  GOTO   06EC
.................... 
.................... 
.................... 	/* read parameters from EEPROM and write defaults if CRC doesn't match */
.................... 	read_param_file();
1612:  GOTO   0B1E
.................... 
.................... 	if ( config.startup_power_on_delay > 100 )
1616:  MOVF   1E,F
1618:  BNZ   1620
161A:  MOVF   1D,W
161C:  SUBLW  64
161E:  BC    1626
.................... 		config.startup_power_on_delay=100;
1620:  CLRF   1E
1622:  MOVLW  64
1624:  MOVWF  1D
.................... 
.................... 	/* flash on startup */
.................... 	for ( i=0 ; i<config.startup_power_on_delay ; i++ ) {
1626:  MOVLB  1
1628:  CLRF   x0F
162A:  MOVF   1E,F
162C:  BNZ   1634
162E:  MOVF   1D,W
1630:  SUBWF  x0F,W
1632:  BC    165A
.................... 		restart_wdt();
1634:  CLRWDT
.................... 		output_high(LED_A);
1636:  BCF    F94.1
1638:  BSF    F8B.1
.................... 		delay_ms(200);
163A:  MOVLW  C8
163C:  MOVWF  x34
163E:  MOVLB  0
1640:  CALL   0652
.................... 		output_low(LED_A);
1644:  BCF    F94.1
1646:  BCF    F8B.1
.................... 		delay_ms(200);
1648:  MOVLW  C8
164A:  MOVLB  1
164C:  MOVWF  x34
164E:  MOVLB  0
1650:  CALL   0652
1654:  MOVLB  1
1656:  INCF   x0F,F
1658:  BRA    162A
.................... 	}
.................... 
.................... 	fprintf(STREAM_FTDI,"# dcswc_module_latching_contactor %s\r\n# ",__DATE__);
165A:  MOVLW  EC
165C:  MOVWF  FF6
165E:  MOVLW  03
1660:  MOVWF  FF7
1662:  MOVLW  22
1664:  MOVWF  x15
1666:  MOVLB  0
1668:  CALL   0B64
166C:  MOVLW  16
166E:  MOVWF  FF6
1670:  MOVLW  04
1672:  MOVWF  FF7
1674:  CALL   0B8E
1678:  MOVLW  10
167A:  MOVWF  FF6
167C:  MOVLW  04
167E:  MOVWF  FF7
1680:  MOVLW  04
1682:  MOVLB  1
1684:  MOVWF  x15
1686:  MOVLB  0
1688:  CALL   0B64
.................... 	switch ( restart_cause ) {
168C:  MOVLW  07
168E:  SUBWF  00,W
1690:  BZ    16B6
1692:  MOVLW  0B
1694:  SUBWF  00,W
1696:  BZ    16C4
1698:  MOVLW  0F
169A:  SUBWF  00,W
169C:  BZ    16D2
169E:  MOVLW  0C
16A0:  SUBWF  00,W
16A2:  BZ    16E0
16A4:  MOVLW  0E
16A6:  SUBWF  00,W
16A8:  BZ    16EE
16AA:  MOVLW  03
16AC:  SUBWF  00,W
16AE:  BZ    16FC
16B0:  MOVF   00,F
16B2:  BZ    170A
16B4:  BRA    1718
.................... 		case WDT_TIMEOUT:       fprintf(STREAM_FTDI,"WDT TIMEOUT"); break;
16B6:  MOVLW  20
16B8:  MOVWF  FF6
16BA:  MOVLW  04
16BC:  MOVWF  FF7
16BE:  CALL   0B8E
16C2:  BRA    1724
.................... 		case MCLR_FROM_SLEEP:   fprintf(STREAM_FTDI,"MCLR FROM SLEEP"); break;
16C4:  MOVLW  2C
16C6:  MOVWF  FF6
16C8:  MOVLW  04
16CA:  MOVWF  FF7
16CC:  CALL   0B8E
16D0:  BRA    1724
.................... 		case MCLR_FROM_RUN:     fprintf(STREAM_FTDI,"MCLR FROM RUN"); break;
16D2:  MOVLW  3C
16D4:  MOVWF  FF6
16D6:  MOVLW  04
16D8:  MOVWF  FF7
16DA:  CALL   0B8E
16DE:  BRA    1724
.................... 		case NORMAL_POWER_UP:   fprintf(STREAM_FTDI,"NORMAL POWER UP"); break;
16E0:  MOVLW  4A
16E2:  MOVWF  FF6
16E4:  MOVLW  04
16E6:  MOVWF  FF7
16E8:  CALL   0B8E
16EC:  BRA    1724
.................... 		case BROWNOUT_RESTART:  fprintf(STREAM_FTDI,"BROWNOUT RESTART"); break;
16EE:  MOVLW  5A
16F0:  MOVWF  FF6
16F2:  MOVLW  04
16F4:  MOVWF  FF7
16F6:  CALL   0B8E
16FA:  BRA    1724
.................... 		case WDT_FROM_SLEEP:    fprintf(STREAM_FTDI,"WDT FROM SLEEP"); break;
16FC:  MOVLW  6C
16FE:  MOVWF  FF6
1700:  MOVLW  04
1702:  MOVWF  FF7
1704:  CALL   0B8E
1708:  BRA    1724
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_FTDI,"RESET INSTRUCTION"); break;
170A:  MOVLW  7C
170C:  MOVWF  FF6
170E:  MOVLW  04
1710:  MOVWF  FF7
1712:  CALL   0B8E
1716:  BRA    1724
.................... 		default:                fprintf(STREAM_FTDI,"UNKNOWN!");
1718:  MOVLW  8E
171A:  MOVWF  FF6
171C:  MOVLW  04
171E:  MOVWF  FF7
1720:  CALL   0B8E
.................... 	}
.................... 	fprintf(STREAM_FTDI,"\r\n");
1724:  MOVLW  0D
1726:  BTFSS  F9E.4
1728:  BRA    1726
172A:  MOVWF  FAD
172C:  MOVLW  0A
172E:  BTFSS  F9E.4
1730:  BRA    172E
1732:  MOVWF  FAD
.................... 
.................... 	timers.led_on_a=500;
1734:  MOVLW  F4
1736:  MOVWF  xD1
.................... 
.................... 	enable_interrupts(GLOBAL);
1738:  MOVLW  C0
173A:  IORWF  FF2,F
.................... 
.................... 	/* Prime ADC filter */
.................... 	for ( i=0 ; i<30 ; i++ ) {
173C:  MOVLB  1
173E:  CLRF   x0F
1740:  MOVF   x0F,W
1742:  SUBLW  1D
1744:  BNC   1752
.................... 		adc_update();
1746:  MOVLB  0
1748:  CALL   0BB0
174C:  MOVLB  1
174E:  INCF   x0F,F
1750:  BRA    1740
.................... 	}
.................... 
.................... 	last_a = ! input(SW_OVERRIDE_A);
1752:  BSF    F92.5
1754:  CLRF   x10
1756:  BTFSS  F80.5
1758:  INCF   x10,F
.................... 	last_b = ! input(SW_OVERRIDE_B);
175A:  BSF    F92.4
175C:  CLRF   x11
175E:  BTFSS  F80.4
1760:  INCF   x11,F
.................... 
.................... 
.................... 	/* enable I2C slave interrupt */
.................... 	enable_interrupts(INT_SSP);
1762:  BSF    F9D.3
.................... 
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
1764:  CLRWDT
.................... 
.................... 		if ( timers.now_millisecond ) {
1766:  MOVLB  0
1768:  BTFSS  xD0.2
176A:  BRA    176E
.................... 			periodic_millisecond();
176C:  BRA    1298
.................... 		}
.................... 
.................... 		if ( kbhit() ) {
176E:  BTFSS  F9E.5
1770:  BRA    1C1E
.................... 			getc();
1772:  BRA    1368
.................... 			fprintf(STREAM_FTDI,"# read_dip_switch()=%u\r\n",read_dip_switch());
1774:  CALL   067C
1778:  MOVFF  01,112
177C:  MOVLW  98
177E:  MOVWF  FF6
1780:  MOVLW  04
1782:  MOVWF  FF7
1784:  MOVLW  14
1786:  MOVLB  1
1788:  MOVWF  x15
178A:  MOVLB  0
178C:  CALL   0B64
1790:  MOVFF  112,113
1794:  MOVLW  1B
1796:  MOVLB  1
1798:  MOVWF  x14
179A:  MOVLB  0
179C:  RCALL  13AC
179E:  MOVLW  0D
17A0:  BTFSS  F9E.4
17A2:  BRA    17A0
17A4:  MOVWF  FAD
17A6:  MOVLW  0A
17A8:  BTFSS  F9E.4
17AA:  BRA    17A8
17AC:  MOVWF  FAD
17AE:  CLRF   19
17B0:  BTFSC  FF2.7
17B2:  BSF    19.7
17B4:  BCF    FF2.7
.................... 			fprintf(STREAM_FTDI,"#    vin adc=%lu\r\n",adc_get(0));
17B6:  MOVLB  1
17B8:  CLRF   x39
17BA:  MOVLB  0
17BC:  CALL   00DC
17C0:  BTFSC  19.7
17C2:  BSF    FF2.7
17C4:  MOVFF  02,113
17C8:  MOVFF  01,112
17CC:  MOVLW  B2
17CE:  MOVWF  FF6
17D0:  MOVLW  04
17D2:  MOVWF  FF7
17D4:  MOVLW  0D
17D6:  MOVLB  1
17D8:  MOVWF  x15
17DA:  MOVLB  0
17DC:  CALL   0B64
17E0:  MOVLW  10
17E2:  MOVWF  FE9
17E4:  MOVFF  113,115
17E8:  MOVFF  112,114
17EC:  RCALL  142A
17EE:  MOVLW  0D
17F0:  BTFSS  F9E.4
17F2:  BRA    17F0
17F4:  MOVWF  FAD
17F6:  MOVLW  0A
17F8:  BTFSS  F9E.4
17FA:  BRA    17F8
17FC:  MOVWF  FAD
17FE:  CLRF   19
1800:  BTFSC  FF2.7
1802:  BSF    19.7
1804:  BCF    FF2.7
.................... 			fprintf(STREAM_FTDI,"#   temp adc=%lu\r\n",adc_get(1));
1806:  MOVLW  01
1808:  MOVLB  1
180A:  MOVWF  x39
180C:  MOVLB  0
180E:  CALL   00DC
1812:  BTFSC  19.7
1814:  BSF    FF2.7
1816:  MOVFF  02,113
181A:  MOVFF  01,112
181E:  MOVLW  C6
1820:  MOVWF  FF6
1822:  MOVLW  04
1824:  MOVWF  FF7
1826:  MOVLW  0D
1828:  MOVLB  1
182A:  MOVWF  x15
182C:  MOVLB  0
182E:  CALL   0B64
1832:  MOVLW  10
1834:  MOVWF  FE9
1836:  MOVFF  113,115
183A:  MOVFF  112,114
183E:  RCALL  142A
1840:  MOVLW  0D
1842:  BTFSS  F9E.4
1844:  BRA    1842
1846:  MOVWF  FAD
1848:  MOVLW  0A
184A:  BTFSS  F9E.4
184C:  BRA    184A
184E:  MOVWF  FAD
1850:  CLRF   19
1852:  BTFSC  FF2.7
1854:  BSF    19.7
1856:  BCF    FF2.7
.................... 			fprintf(STREAM_FTDI,"# dip sw adc=%lu\r\n",adc_get(2));
1858:  MOVLW  02
185A:  MOVLB  1
185C:  MOVWF  x39
185E:  MOVLB  0
1860:  CALL   00DC
1864:  BTFSC  19.7
1866:  BSF    FF2.7
1868:  MOVFF  02,113
186C:  MOVFF  01,112
1870:  MOVLW  DA
1872:  MOVWF  FF6
1874:  MOVLW  04
1876:  MOVWF  FF7
1878:  MOVLW  0D
187A:  MOVLB  1
187C:  MOVWF  x15
187E:  MOVLB  0
1880:  CALL   0B64
1884:  MOVLW  10
1886:  MOVWF  FE9
1888:  MOVFF  113,115
188C:  MOVFF  112,114
1890:  RCALL  142A
1892:  MOVLW  0D
1894:  BTFSS  F9E.4
1896:  BRA    1894
1898:  MOVWF  FAD
189A:  MOVLW  0A
189C:  BTFSS  F9E.4
189E:  BRA    189C
18A0:  MOVWF  FAD
.................... 
.................... 			for ( i=0 ; i<2 ; i++ ) {
18A2:  MOVLB  1
18A4:  CLRF   x0F
18A6:  MOVF   x0F,W
18A8:  SUBLW  01
18AA:  BTFSS  FD8.0
18AC:  BRA    1C1C
.................... 				restart_wdt();
18AE:  CLRWDT
.................... 				fprintf(STREAM_FTDI,"# channel[%u]\r\n",i);
18B0:  MOVLW  EE
18B2:  MOVWF  FF6
18B4:  MOVLW  04
18B6:  MOVWF  FF7
18B8:  MOVLW  0A
18BA:  MOVWF  x15
18BC:  MOVLB  0
18BE:  CALL   0B64
18C2:  MOVFF  10F,113
18C6:  MOVLW  1B
18C8:  MOVLB  1
18CA:  MOVWF  x14
18CC:  MOVLB  0
18CE:  RCALL  13AC
18D0:  MOVLW  FA
18D2:  MOVWF  FF6
18D4:  MOVLW  04
18D6:  MOVWF  FF7
18D8:  MOVLW  03
18DA:  MOVLB  1
18DC:  MOVWF  x15
18DE:  MOVLB  0
18E0:  CALL   0B64
.................... 				fprintf(STREAM_FTDI,"#                        state=0x%02x\r\n",channel[i].state);
18E4:  MOVLB  1
18E6:  MOVF   x0F,W
18E8:  MULLW  17
18EA:  MOVF   FF3,W
18EC:  CLRF   x13
18EE:  MOVWF  x12
18F0:  MOVLW  D5
18F2:  ADDWF  x12,W
18F4:  MOVWF  FE9
18F6:  MOVLW  00
18F8:  ADDWFC x13,W
18FA:  MOVWF  FEA
18FC:  MOVFF  FEF,114
1900:  MOVLW  FE
1902:  MOVWF  FF6
1904:  MOVLW  04
1906:  MOVWF  FF7
1908:  MOVLW  21
190A:  MOVWF  x15
190C:  MOVLB  0
190E:  CALL   0B64
1912:  MOVFF  114,115
1916:  MOVLW  57
1918:  MOVLB  1
191A:  MOVWF  x16
191C:  MOVLB  0
191E:  BRA    14DC
1920:  MOVLW  0D
1922:  BTFSS  F9E.4
1924:  BRA    1922
1926:  MOVWF  FAD
1928:  MOVLW  0A
192A:  BTFSS  F9E.4
192C:  BRA    192A
192E:  MOVWF  FAD
.................... 				fprintf(STREAM_FTDI,"#           command_on_seconds=%lu\r\n",channel[i].command_on_seconds);
1930:  MOVLB  1
1932:  MOVF   x0F,W
1934:  MULLW  17
1936:  MOVF   FF3,W
1938:  CLRF   x13
193A:  MOVWF  x12
193C:  MOVLW  01
193E:  ADDWF  x12,W
1940:  MOVWF  01
1942:  MOVLW  00
1944:  ADDWFC x13,W
1946:  MOVWF  03
1948:  MOVF   01,W
194A:  ADDLW  D5
194C:  MOVWF  FE9
194E:  MOVLW  00
1950:  ADDWFC 03,W
1952:  MOVWF  FEA
1954:  MOVFF  FEC,113
1958:  MOVF   FED,F
195A:  MOVFF  FEF,112
195E:  MOVLW  26
1960:  MOVWF  FF6
1962:  MOVLW  05
1964:  MOVWF  FF7
1966:  MOVLW  1F
1968:  MOVWF  x15
196A:  MOVLB  0
196C:  CALL   0B64
1970:  MOVLW  10
1972:  MOVWF  FE9
1974:  MOVFF  113,115
1978:  MOVFF  112,114
197C:  RCALL  142A
197E:  MOVLW  0D
1980:  BTFSS  F9E.4
1982:  BRA    1980
1984:  MOVWF  FAD
1986:  MOVLW  0A
1988:  BTFSS  F9E.4
198A:  BRA    1988
198C:  MOVWF  FAD
.................... 				fprintf(STREAM_FTDI,"#      command_on_hold_seconds=%lu\r\n",channel[i].command_on_hold_seconds);
198E:  MOVLB  1
1990:  MOVF   x0F,W
1992:  MULLW  17
1994:  MOVF   FF3,W
1996:  CLRF   x13
1998:  MOVWF  x12
199A:  MOVLW  03
199C:  ADDWF  x12,W
199E:  MOVWF  01
19A0:  MOVLW  00
19A2:  ADDWFC x13,W
19A4:  MOVWF  03
19A6:  MOVF   01,W
19A8:  ADDLW  D5
19AA:  MOVWF  FE9
19AC:  MOVLW  00
19AE:  ADDWFC 03,W
19B0:  MOVWF  FEA
19B2:  MOVFF  FEC,113
19B6:  MOVF   FED,F
19B8:  MOVFF  FEF,112
19BC:  MOVLW  4C
19BE:  MOVWF  FF6
19C0:  MOVLW  05
19C2:  MOVWF  FF7
19C4:  MOVLW  1F
19C6:  MOVWF  x15
19C8:  MOVLB  0
19CA:  CALL   0B64
19CE:  MOVLW  10
19D0:  MOVWF  FE9
19D2:  MOVFF  113,115
19D6:  MOVFF  112,114
19DA:  RCALL  142A
19DC:  MOVLW  0D
19DE:  BTFSS  F9E.4
19E0:  BRA    19DE
19E2:  MOVWF  FAD
19E4:  MOVLW  0A
19E6:  BTFSS  F9E.4
19E8:  BRA    19E6
19EA:  MOVWF  FAD
.................... 
.................... 				fprintf(STREAM_FTDI,"#          command_off_seconds=%lu\r\n",channel[i].command_off_seconds);
19EC:  MOVLB  1
19EE:  MOVF   x0F,W
19F0:  MULLW  17
19F2:  MOVF   FF3,W
19F4:  CLRF   x13
19F6:  MOVWF  x12
19F8:  MOVLW  05
19FA:  ADDWF  x12,W
19FC:  MOVWF  01
19FE:  MOVLW  00
1A00:  ADDWFC x13,W
1A02:  MOVWF  03
1A04:  MOVF   01,W
1A06:  ADDLW  D5
1A08:  MOVWF  FE9
1A0A:  MOVLW  00
1A0C:  ADDWFC 03,W
1A0E:  MOVWF  FEA
1A10:  MOVFF  FEC,113
1A14:  MOVF   FED,F
1A16:  MOVFF  FEF,112
1A1A:  MOVLW  72
1A1C:  MOVWF  FF6
1A1E:  MOVLW  05
1A20:  MOVWF  FF7
1A22:  MOVLW  1F
1A24:  MOVWF  x15
1A26:  MOVLB  0
1A28:  CALL   0B64
1A2C:  MOVLW  10
1A2E:  MOVWF  FE9
1A30:  MOVFF  113,115
1A34:  MOVFF  112,114
1A38:  RCALL  142A
1A3A:  MOVLW  0D
1A3C:  BTFSS  F9E.4
1A3E:  BRA    1A3C
1A40:  MOVWF  FAD
1A42:  MOVLW  0A
1A44:  BTFSS  F9E.4
1A46:  BRA    1A44
1A48:  MOVWF  FAD
.................... 				fprintf(STREAM_FTDI,"#     command_off_hold_seconds=%lu\r\n",channel[i].command_off_hold_seconds);
1A4A:  MOVLB  1
1A4C:  MOVF   x0F,W
1A4E:  MULLW  17
1A50:  MOVF   FF3,W
1A52:  CLRF   x13
1A54:  MOVWF  x12
1A56:  MOVLW  07
1A58:  ADDWF  x12,W
1A5A:  MOVWF  01
1A5C:  MOVLW  00
1A5E:  ADDWFC x13,W
1A60:  MOVWF  03
1A62:  MOVF   01,W
1A64:  ADDLW  D5
1A66:  MOVWF  FE9
1A68:  MOVLW  00
1A6A:  ADDWFC 03,W
1A6C:  MOVWF  FEA
1A6E:  MOVFF  FEC,113
1A72:  MOVF   FED,F
1A74:  MOVFF  FEF,112
1A78:  MOVLW  98
1A7A:  MOVWF  FF6
1A7C:  MOVLW  05
1A7E:  MOVWF  FF7
1A80:  MOVLW  1F
1A82:  MOVWF  x15
1A84:  MOVLB  0
1A86:  CALL   0B64
1A8A:  MOVLW  10
1A8C:  MOVWF  FE9
1A8E:  MOVFF  113,115
1A92:  MOVFF  112,114
1A96:  RCALL  142A
1A98:  MOVLW  0D
1A9A:  BTFSS  F9E.4
1A9C:  BRA    1A9A
1A9E:  MOVWF  FAD
1AA0:  MOVLW  0A
1AA2:  BTFSS  F9E.4
1AA4:  BRA    1AA2
1AA6:  MOVWF  FAD
.................... 
.................... 				fprintf(STREAM_FTDI,"# lvd_disconnect_delay_seconds=%lu\r\n",channel[i].lvd_disconnect_delay_seconds);
1AA8:  MOVLB  1
1AAA:  MOVF   x0F,W
1AAC:  MULLW  17
1AAE:  MOVF   FF3,W
1AB0:  CLRF   x13
1AB2:  MOVWF  x12
1AB4:  MOVLW  09
1AB6:  ADDWF  x12,W
1AB8:  MOVWF  01
1ABA:  MOVLW  00
1ABC:  ADDWFC x13,W
1ABE:  MOVWF  03
1AC0:  MOVF   01,W
1AC2:  ADDLW  D5
1AC4:  MOVWF  FE9
1AC6:  MOVLW  00
1AC8:  ADDWFC 03,W
1ACA:  MOVWF  FEA
1ACC:  MOVFF  FEC,113
1AD0:  MOVF   FED,F
1AD2:  MOVFF  FEF,112
1AD6:  MOVLW  BE
1AD8:  MOVWF  FF6
1ADA:  MOVLW  05
1ADC:  MOVWF  FF7
1ADE:  MOVLW  1F
1AE0:  MOVWF  x15
1AE2:  MOVLB  0
1AE4:  CALL   0B64
1AE8:  MOVLW  10
1AEA:  MOVWF  FE9
1AEC:  MOVFF  113,115
1AF0:  MOVFF  112,114
1AF4:  RCALL  142A
1AF6:  MOVLW  0D
1AF8:  BTFSS  F9E.4
1AFA:  BRA    1AF8
1AFC:  MOVWF  FAD
1AFE:  MOVLW  0A
1B00:  BTFSS  F9E.4
1B02:  BRA    1B00
1B04:  MOVWF  FAD
.................... 				fprintf(STREAM_FTDI,"#  lvd_reconnect_delay_seconds=%u\r\n",channel[i].lvd_reconnect_delay_seconds);
1B06:  MOVLB  1
1B08:  MOVF   x0F,W
1B0A:  MULLW  17
1B0C:  MOVF   FF3,W
1B0E:  CLRF   x13
1B10:  MOVWF  x12
1B12:  MOVLW  0B
1B14:  ADDWF  x12,W
1B16:  MOVWF  01
1B18:  MOVLW  00
1B1A:  ADDWFC x13,W
1B1C:  MOVWF  03
1B1E:  MOVF   01,W
1B20:  ADDLW  D5
1B22:  MOVWF  FE9
1B24:  MOVLW  00
1B26:  ADDWFC 03,W
1B28:  MOVWF  FEA
1B2A:  MOVFF  FEF,112
1B2E:  MOVLW  E4
1B30:  MOVWF  FF6
1B32:  MOVLW  05
1B34:  MOVWF  FF7
1B36:  MOVLW  1F
1B38:  MOVWF  x15
1B3A:  MOVLB  0
1B3C:  CALL   0B64
1B40:  MOVFF  112,113
1B44:  MOVLW  1B
1B46:  MOVLB  1
1B48:  MOVWF  x14
1B4A:  MOVLB  0
1B4C:  RCALL  13AC
1B4E:  MOVLW  0D
1B50:  BTFSS  F9E.4
1B52:  BRA    1B50
1B54:  MOVWF  FAD
1B56:  MOVLW  0A
1B58:  BTFSS  F9E.4
1B5A:  BRA    1B58
1B5C:  MOVWF  FAD
.................... 
.................... 				fprintf(STREAM_FTDI,"# hvd_disconnect_delay_seconds=%lu\r\n",channel[i].hvd_disconnect_delay_seconds);
1B5E:  MOVLB  1
1B60:  MOVF   x0F,W
1B62:  MULLW  17
1B64:  MOVF   FF3,W
1B66:  CLRF   x13
1B68:  MOVWF  x12
1B6A:  MOVLW  0C
1B6C:  ADDWF  x12,W
1B6E:  MOVWF  01
1B70:  MOVLW  00
1B72:  ADDWFC x13,W
1B74:  MOVWF  03
1B76:  MOVF   01,W
1B78:  ADDLW  D5
1B7A:  MOVWF  FE9
1B7C:  MOVLW  00
1B7E:  ADDWFC 03,W
1B80:  MOVWF  FEA
1B82:  MOVFF  FEC,113
1B86:  MOVF   FED,F
1B88:  MOVFF  FEF,112
1B8C:  MOVLW  08
1B8E:  MOVWF  FF6
1B90:  MOVLW  06
1B92:  MOVWF  FF7
1B94:  MOVLW  1F
1B96:  MOVWF  x15
1B98:  MOVLB  0
1B9A:  CALL   0B64
1B9E:  MOVLW  10
1BA0:  MOVWF  FE9
1BA2:  MOVFF  113,115
1BA6:  MOVFF  112,114
1BAA:  RCALL  142A
1BAC:  MOVLW  0D
1BAE:  BTFSS  F9E.4
1BB0:  BRA    1BAE
1BB2:  MOVWF  FAD
1BB4:  MOVLW  0A
1BB6:  BTFSS  F9E.4
1BB8:  BRA    1BB6
1BBA:  MOVWF  FAD
.................... 				fprintf(STREAM_FTDI,"#  hvd_reconnect_delay_seconds=%u\r\n",channel[i].hvd_reconnect_delay_seconds);
1BBC:  MOVLB  1
1BBE:  MOVF   x0F,W
1BC0:  MULLW  17
1BC2:  MOVF   FF3,W
1BC4:  CLRF   x13
1BC6:  MOVWF  x12
1BC8:  MOVLW  0E
1BCA:  ADDWF  x12,W
1BCC:  MOVWF  01
1BCE:  MOVLW  00
1BD0:  ADDWFC x13,W
1BD2:  MOVWF  03
1BD4:  MOVF   01,W
1BD6:  ADDLW  D5
1BD8:  MOVWF  FE9
1BDA:  MOVLW  00
1BDC:  ADDWFC 03,W
1BDE:  MOVWF  FEA
1BE0:  MOVFF  FEF,112
1BE4:  MOVLW  2E
1BE6:  MOVWF  FF6
1BE8:  MOVLW  06
1BEA:  MOVWF  FF7
1BEC:  MOVLW  1F
1BEE:  MOVWF  x15
1BF0:  MOVLB  0
1BF2:  CALL   0B64
1BF6:  MOVFF  112,113
1BFA:  MOVLW  1B
1BFC:  MOVLB  1
1BFE:  MOVWF  x14
1C00:  MOVLB  0
1C02:  CALL   13AC
1C06:  MOVLW  0D
1C08:  BTFSS  F9E.4
1C0A:  BRA    1C08
1C0C:  MOVWF  FAD
1C0E:  MOVLW  0A
1C10:  BTFSS  F9E.4
1C12:  BRA    1C10
1C14:  MOVWF  FAD
1C16:  MOVLB  1
1C18:  INCF   x0F,F
1C1A:  BRA    18A6
1C1C:  MOVLB  0
.................... 			}
.................... 
.................... 		}
.................... 
.................... 		if ( input(SW_OVERRIDE_A) != last_a ) {
1C1E:  BSF    F92.5
1C20:  MOVLW  00
1C22:  BTFSC  F80.5
1C24:  MOVLW  01
1C26:  MOVLB  1
1C28:  SUBWF  x10,W
1C2A:  BZ    1C4C
.................... 			last_a=input(SW_OVERRIDE_A);
1C2C:  BSF    F92.5
1C2E:  CLRF   x10
1C30:  BTFSC  F80.5
1C32:  INCF   x10,F
.................... 
.................... 			if ( last_a ) {
1C34:  MOVF   x10,F
1C36:  BZ    1C44
.................... 				timers.led_on_a=500;
1C38:  MOVLW  F4
1C3A:  MOVLB  0
1C3C:  MOVWF  xD1
.................... 				contactor_on_a();
1C3E:  BRA    1524
.................... 			} else {
1C40:  BRA    1C4A
1C42:  MOVLB  1
.................... 				timers.led_on_a=0;
1C44:  MOVLB  0
1C46:  CLRF   xD1
.................... 				contactor_off_a();
1C48:  BRA    153C
1C4A:  MOVLB  1
.................... 			}
.................... 		}
.................... 
.................... 
.................... 		if ( input(SW_OVERRIDE_B) != last_b ) {
1C4C:  BSF    F92.4
1C4E:  MOVLW  00
1C50:  BTFSC  F80.4
1C52:  MOVLW  01
1C54:  SUBWF  x11,W
1C56:  BZ    1C78
.................... 			last_B=input(SW_OVERRIDE_B);
1C58:  BSF    F92.4
1C5A:  CLRF   x11
1C5C:  BTFSC  F80.4
1C5E:  INCF   x11,F
.................... 
.................... 			if ( last_b ) {
1C60:  MOVF   x11,F
1C62:  BZ    1C70
.................... 				timers.led_on_b=500;
1C64:  MOVLW  F4
1C66:  MOVLB  0
1C68:  MOVWF  xD2
.................... 				contactor_on_b();
1C6A:  BRA    1554
.................... 			} else {
1C6C:  BRA    1C76
1C6E:  MOVLB  1
.................... 				timers.led_on_b=0;
1C70:  MOVLB  0
1C72:  CLRF   xD2
.................... 				contactor_off_b();
1C74:  BRA    156C
1C76:  MOVLB  1
.................... 			}
.................... 		}
.................... 
.................... 
.................... 
.................... 		if ( timers.now_adc_sample ) {
1C78:  MOVLB  0
1C7A:  BTFSS  xD0.0
1C7C:  BRA    1C84
.................... 			timers.now_adc_sample=0;
1C7E:  BCF    xD0.0
.................... 			adc_update();
1C80:  CALL   0BB0
.................... 		}
.................... 
.................... 		if ( timers.now_write_config ) {
1C84:  BTFSS  xD0.3
1C86:  BRA    1C8E
.................... 			timers.now_write_config=0;
1C88:  BCF    xD0.3
.................... 			write_param_file();
1C8A:  CALL   0982
.................... 		}
.................... 		if ( timers.now_reset_config ) {
1C8E:  BTFSS  xD0.4
1C90:  BRA    1C98
.................... 			timers.now_reset_config=0;
1C92:  BCF    xD0.4
.................... 			write_default_param_file();
1C94:  CALL   09CE
.................... 		}
1C98:  MOVLB  1
1C9A:  BRA    1764
.................... 
.................... 
.................... 	}
.................... 
.................... 
.................... }
1C9C:  BRA    1C9C

Configuration Fuses:
   Word  1: 2800   INTRC_IO NOPLLEN PCLKEN NOFCMEN NOIESO
   Word  2: 0E19   NOPUT NOBROWNOUT BORV19 NOWDT WDT128
   Word  3: 0000   NOHFOFST NOMCLR
   Word  4: 0009   STVREN NOLVP BBSIZ2K NOXINST DEBUG
   Word  5: C003   NOPROTECT NOCPB NOCPD
   Word  6: E003   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 4003   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.

ROM data:
F00000: 00 00 40 00                                        ..@.
