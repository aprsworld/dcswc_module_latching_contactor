CCS PCH C Compiler, Version 5.090, 49113               14-Jan-22 10:26

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\dcswc_module_latching_contactor\dcswc_module_latching_contactor.lst

               ROM used:   4050 bytes (26%)
                           Largest free fragment is 11498
               RAM used:   194 (38%) at main() level
                           238 (46%) worst case
               Stack used: 4 locations (2 in main + 2 for interrupts)
               Stack size: 30

0000:  GOTO   0D2E
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   00D4
0060:  BTFSS  F9D.3
0062:  GOTO   006C
0066:  BTFSC  F9E.3
0068:  GOTO   0432
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include "dcswc_module_latching_contactor.h"
.................... #include <18F14K22.h>
.................... //////////// Standard Header file for the PIC18F14K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F14K22
00BA:  CLRF   FF7
00BC:  ADDLW  CA
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  RETURN 0
00CA:  DATA 31,34
00CC:  DATA 2D,4A
00CE:  DATA 61,6E
00D0:  DATA 2D,32
00D2:  DATA 32,00
*
04DC:  DATA 23,20
04DE:  DATA 64,63
04E0:  DATA 73,77
04E2:  DATA 63,5F
04E4:  DATA 6D,6F
04E6:  DATA 64,75
04E8:  DATA 6C,65
04EA:  DATA 5F,6C
04EC:  DATA 61,74
04EE:  DATA 63,68
04F0:  DATA 69,6E
04F2:  DATA 67,5F
04F4:  DATA 63,6F
04F6:  DATA 6E,74
04F8:  DATA 61,63
04FA:  DATA 74,6F
04FC:  DATA 72,20
04FE:  DATA 25,73
0500:  DATA 0D,0A
0502:  DATA 00,00
0504:  DATA 31,34
0506:  DATA 2D,4A
0508:  DATA 61,6E
050A:  DATA 2D,32
050C:  DATA 32,00
050E:  DATA 23,20
0510:  DATA 72,65
0512:  DATA 61,64
0514:  DATA 5F,64
0516:  DATA 69,70
0518:  DATA 5F,73
051A:  DATA 77,69
051C:  DATA 74,63
051E:  DATA 68,28
0520:  DATA 29,3D
0522:  DATA 25,75
0524:  DATA 0D,0A
0526:  DATA 00,00
0528:  DATA 23,20
052A:  DATA 20,20
052C:  DATA 20,76
052E:  DATA 69,6E
0530:  DATA 20,61
0532:  DATA 64,63
0534:  DATA 3D,25
0536:  DATA 6C,75
0538:  DATA 0D,0A
053A:  DATA 00,00
053C:  DATA 23,20
053E:  DATA 20,20
0540:  DATA 74,65
0542:  DATA 6D,70
0544:  DATA 20,61
0546:  DATA 64,63
0548:  DATA 3D,25
054A:  DATA 6C,75
054C:  DATA 0D,0A
054E:  DATA 00,00
0550:  DATA 23,20
0552:  DATA 64,69
0554:  DATA 70,20
0556:  DATA 73,77
0558:  DATA 20,61
055A:  DATA 64,63
055C:  DATA 3D,25
055E:  DATA 6C,75
0560:  DATA 0D,0A
0562:  DATA 00,00
*
087E:  TBLRD*+
0880:  MOVFF  FF6,C3
0884:  MOVFF  FF7,C4
0888:  MOVF   FF5,W
088A:  BTFSS  F9E.4
088C:  BRA    088A
088E:  MOVWF  FAD
0890:  MOVFF  C3,FF6
0894:  MOVFF  C4,FF7
0898:  DECFSZ xC2,F
089A:  BRA    087E
089C:  RETURN 0
089E:  TBLRD*+
08A0:  MOVF   FF5,F
08A2:  BZ    08BE
08A4:  MOVFF  FF6,C0
08A8:  MOVFF  FF7,C1
08AC:  MOVF   FF5,W
08AE:  BTFSS  F9E.4
08B0:  BRA    08AE
08B2:  MOVWF  FAD
08B4:  MOVFF  C0,FF6
08B8:  MOVFF  C1,FF7
08BC:  BRA    089E
08BE:  GOTO   0E26 (RETURN)
*
0BAC:  MOVF   xC4,W
0BAE:  CLRF   01
0BB0:  SUBWF  xC3,W
0BB2:  BC    0BBA
0BB4:  MOVFF  C3,00
0BB8:  BRA    0BD2
0BBA:  CLRF   00
0BBC:  MOVLW  08
0BBE:  MOVWF  xC5
0BC0:  RLCF   xC3,F
0BC2:  RLCF   00,F
0BC4:  MOVF   xC4,W
0BC6:  SUBWF  00,W
0BC8:  BTFSC  FD8.0
0BCA:  MOVWF  00
0BCC:  RLCF   01,F
0BCE:  DECFSZ xC5,F
0BD0:  BRA    0BC0
0BD2:  RETURN 0
0BD4:  MOVF   01,W
0BD6:  MOVFF  C1,C3
0BDA:  MOVLW  64
0BDC:  MOVWF  xC4
0BDE:  RCALL  0BAC
0BE0:  MOVFF  00,C1
0BE4:  MOVF   01,W
0BE6:  MOVLW  30
0BE8:  BNZ   0BF8
0BEA:  BTFSS  xC2.1
0BEC:  BRA    0C08
0BEE:  BTFSC  xC2.3
0BF0:  BRA    0C08
0BF2:  BTFSC  xC2.4
0BF4:  MOVLW  20
0BF6:  BRA    0BFE
0BF8:  BCF    xC2.3
0BFA:  BCF    xC2.4
0BFC:  BSF    xC2.0
0BFE:  ADDWF  01,F
0C00:  MOVF   01,W
0C02:  BTFSS  F9E.4
0C04:  BRA    0C02
0C06:  MOVWF  FAD
0C08:  MOVFF  C1,C3
0C0C:  MOVLW  0A
0C0E:  MOVWF  xC4
0C10:  RCALL  0BAC
0C12:  MOVFF  00,C1
0C16:  MOVF   01,W
0C18:  MOVLW  30
0C1A:  BNZ   0C28
0C1C:  BTFSC  xC2.3
0C1E:  BRA    0C32
0C20:  BTFSS  xC2.0
0C22:  BRA    0C32
0C24:  BTFSC  xC2.4
0C26:  MOVLW  20
0C28:  ADDWF  01,F
0C2A:  MOVF   01,W
0C2C:  BTFSS  F9E.4
0C2E:  BRA    0C2C
0C30:  MOVWF  FAD
0C32:  MOVLW  30
0C34:  ADDWF  xC1,F
0C36:  MOVF   xC1,W
0C38:  BTFSS  F9E.4
0C3A:  BRA    0C38
0C3C:  MOVWF  FAD
0C3E:  GOTO   0E8A (RETURN)
0C42:  MOVFF  FEA,CA
0C46:  MOVFF  FE9,C9
0C4A:  SWAPF  xC3,W
0C4C:  IORLW  F0
0C4E:  MOVWF  xC5
0C50:  ADDWF  xC5,F
0C52:  ADDLW  E2
0C54:  MOVWF  xC6
0C56:  ADDLW  32
0C58:  MOVWF  xC8
0C5A:  MOVF   xC3,W
0C5C:  ANDLW  0F
0C5E:  ADDWF  xC6,F
0C60:  ADDWF  xC6,F
0C62:  ADDWF  xC8,F
0C64:  ADDLW  E9
0C66:  MOVWF  xC7
0C68:  ADDWF  xC7,F
0C6A:  ADDWF  xC7,F
0C6C:  SWAPF  xC2,W
0C6E:  ANDLW  0F
0C70:  ADDWF  xC7,F
0C72:  ADDWF  xC8,F
0C74:  RLCF   xC7,F
0C76:  RLCF   xC8,F
0C78:  COMF   xC8,F
0C7A:  RLCF   xC8,F
0C7C:  MOVF   xC2,W
0C7E:  ANDLW  0F
0C80:  ADDWF  xC8,F
0C82:  RLCF   xC5,F
0C84:  MOVLW  07
0C86:  MOVWF  xC4
0C88:  MOVLW  0A
0C8A:  DECF   xC7,F
0C8C:  ADDWF  xC8,F
0C8E:  BNC   0C8A
0C90:  DECF   xC6,F
0C92:  ADDWF  xC7,F
0C94:  BNC   0C90
0C96:  DECF   xC5,F
0C98:  ADDWF  xC6,F
0C9A:  BNC   0C96
0C9C:  DECF   xC4,F
0C9E:  ADDWF  xC5,F
0CA0:  BNC   0C9C
0CA2:  CLRF   FEA
0CA4:  MOVLW  C4
0CA6:  MOVWF  FE9
0CA8:  MOVLW  07
0CAA:  ANDWF  xC9,W
0CAC:  BCF    xC9.6
0CAE:  ADDWF  FE9,F
0CB0:  MOVLW  00
0CB2:  ADDWFC FEA,F
0CB4:  MOVF   FE9,W
0CB6:  SUBLW  C8
0CB8:  BNZ   0CC0
0CBA:  MOVF   FEA,F
0CBC:  BNZ   0CC0
0CBE:  BSF    xC9.6
0CC0:  MOVF   FEF,W
0CC2:  MOVWF  00
0CC4:  BNZ   0CD6
0CC6:  BTFSC  xC9.6
0CC8:  BRA    0CD6
0CCA:  BTFSC  xC9.4
0CCC:  BRA    0CE6
0CCE:  BTFSC  xC9.3
0CD0:  BRA    0CD6
0CD2:  MOVLW  20
0CD4:  BRA    0CDC
0CD6:  BSF    xC9.3
0CD8:  BCF    xC9.4
0CDA:  MOVLW  30
0CDC:  ADDWF  00,F
0CDE:  MOVF   00,W
0CE0:  BTFSS  F9E.4
0CE2:  BRA    0CE0
0CE4:  MOVWF  FAD
0CE6:  MOVF   FEE,W
0CE8:  BTFSS  xC9.6
0CEA:  BRA    0CB4
0CEC:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #device *=16
.................... #use delay(clock=16MHz)
*
0856:  CLRF   FEA
0858:  MOVLW  C2
085A:  MOVWF  FE9
085C:  MOVF   FEF,W
085E:  BZ    087C
0860:  MOVLW  05
0862:  MOVWF  01
0864:  CLRF   00
0866:  DECFSZ 00,F
0868:  BRA    0866
086A:  DECFSZ 01,F
086C:  BRA    0864
086E:  MOVLW  2E
0870:  MOVWF  00
0872:  DECFSZ 00,F
0874:  BRA    0872
0876:  BRA    0878
0878:  DECFSZ FEF,F
087A:  BRA    0860
087C:  RETURN 0
.................... #use i2c(SLAVE, I2C1, address=0x34, FORCE_HW)
*
041C:  MOVF   FC9,W
041E:  MOVFF  E5,FC9
0422:  BSF    FC6.4
0424:  BCF    F9E.3
0426:  BTFSC  FC7.0
0428:  BRA    0426
042A:  CLRF   01
042C:  BTFSS  FC5.6
042E:  INCF   01,F
0430:  RETURN 0
.................... /* Linux / i2cdetect will use the CCS address >>1. So 0x34 becomes 0x1a */
.................... 
.................... #fuses INTRC_IO
.................... #fuses NOPLLEN
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses PUT
.................... #fuses BROWNOUT
.................... #fuses WDT4096
.................... #fuses NOHFOFST
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses NOLVP
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... #fuses NOPROTECT
.................... #fuses NOWRT
.................... #fuses NOWRTC 
.................... #fuses NOWRTB
.................... #fuses NOWRTD
.................... #fuses NOEBTR
.................... #fuses NOEBTRB
.................... 
.................... #use standard_io(ALL)
.................... 
.................... #use rs232(UART1,stream=STREAM_FTDI,baud=9600,errors)	
*
0B24:  BTFSS  F9E.5
0B26:  BRA    0B24
0B28:  MOVFF  FAB,1A
0B2C:  MOVFF  FAE,01
0B30:  BTFSS  1A.1
0B32:  BRA    0B38
0B34:  BCF    FAB.4
0B36:  BSF    FAB.4
0B38:  GOTO   0E6C (RETURN)
.................... 
.................... /* program config CRC of 0 and a serial_prefix of 'A' ... that will trigger a write default on first boot */
.................... #ROM 0xF00000 = { 0x00, 0x00, 0x40, 0x00 }
.................... 
.................... 
.................... 
.................... 
.................... #define SW_OVERRIDE_A        PIN_A5
.................... #define SW_OVERRIDE_B        PIN_A4
.................... #define BRIDGE_B_A           PIN_C5
.................... #define BRIDGE_A_B           PIN_C4
.................... #define BRIDGE_A_A           PIN_C3
.................... #define BRIDGE_B_B           PIN_C6
.................... #define AN_DIP               PIN_C7
.................... #define SER_TO_PC            PIN_B7
.................... #define AN_VTEMP             PIN_A2
.................... #define AN_IN_VOLTS          PIN_C0
.................... #define LED_A                PIN_C1
.................... #define LED_B                PIN_C2
.................... #define I2C_SDA              PIN_B4
.................... #define SER_FROM_PC          PIN_B5
.................... #define I2C_SCL              PIN_B6
.................... 
.................... 
.................... /* 
.................... Parameters are stored in EEPROM
.................... */
.................... #define PARAM_CRC_ADDRESS  0x00
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2
.................... 
.................... 
.................... #define POWER_FLAG_POS_HTD            6
.................... #define POWER_FLAG_POS_LTD            5
.................... #define POWER_FLAG_POS_HVD            4
.................... #define POWER_FLAG_POS_LVD            3
.................... #define POWER_FLAG_POS_WRITE_WATCHDOG 2
.................... #define POWER_FLAG_POS_READ_WATCHDOG  1
.................... #define POWER_FLAG_POS_COMMAND_OFF    0
.................... 
.................... 
.................... #define CONTACTOR_POWER_SAVE_MS       200 /* milliseconds for contactor be on. Must be >0 and <= 255 */
.................... 
.................... 
.................... 
.................... typedef struct {
.................... 	int16 adc_sample_ticks;
.................... 
.................... 	int16 startup_power_on_delay;
.................... 
.................... 	/* command_off in current */
.................... 	int16 command_off_hold_time;
.................... 
.................... 	int16 lvd_disconnect_adc;
.................... 	int16 lvd_disconnect_delay;
.................... 	int16 lvd_reconnect_adc;
.................... 
.................... 	int16 hvd_disconnect_adc;
.................... 	int16 hvd_disconnect_delay;
.................... 	int16 hvd_reconnect_adc;
.................... } struct_config;
.................... 
.................... 
.................... 
.................... typedef struct {
.................... 	/* circular buffer for ADC readings */
.................... 	int16 adc_buffer[3][16];
.................... 	int8  adc_buffer_index;
.................... 
.................... 	int16 sequence_number;
.................... 	int16 uptime_minutes;
.................... 	int16 interval_milliseconds;
.................... 
.................... 	int8 factory_unlocked;
.................... 
.................... 
.................... 	int8 compile_year;
.................... 	int8 compile_month;
.................... 	int8 compile_day;
.................... 
.................... 	/* bit position
.................... 		7
.................... 		6 htd
.................... 		5 ltd
.................... 		4 hvd
.................... 		3 lvd
.................... 		2 write watchdog
.................... 		1 read watchdog
.................... 		0 command
.................... 	*/
.................... 	int8 power_off_flags; 
.................... 
.................... 	/* bit positions
.................... 		7
.................... 		6
.................... 		5
.................... 		4
.................... 		3
.................... 		2
.................... 		1 usb (wifi)
.................... 		0 pi (host)
.................... 	*/
.................... 
.................... 
.................... 	int8 default_params_written;
.................... } struct_current;
.................... 
.................... typedef struct {
.................... 	/* action flags */
.................... 	int1 now_adc_sample;
.................... 	int1 now_adc_reset_count;
.................... 
.................... 	int1 now_millisecond;
.................... 
.................... 	int1 now_write_config;
.................... 	int1 now_reset_config;
.................... 
.................... 	/* timers */
.................... 	int8 led_on_a;
.................... 	int8 led_on_b;
.................... 
.................... 	int16 command_off_seconds;			/* counts down. Off at zero. */
.................... 	int16 command_off_hold_seconds;     /* counts down. Off at zero. */
.................... 
.................... 	int16 read_watchdog_seconds;  		/* counts up */
.................... 	int16 read_watchdog_hold_seconds; 	/* counts down. Off at zero */
.................... 
.................... 	int16 write_watchdog_seconds; 		/* counts up */
.................... 	int16 write_watchdog_hold_seconds; 	/* counts down. Off at zero */
.................... 
.................... 	int16 lvd_disconnect_delay_seconds;	/* counts down */
.................... 	int8  lvd_reconnect_delay_seconds;	/* counts down */
.................... 
.................... 	int16 hvd_disconnect_delay_seconds;	/* counts down */
.................... 	int8  hvd_reconnect_delay_seconds;	/* counts down */
.................... 
.................... 	int8  contactor_a_powersave;        /* counts down. Off at zero. */
.................... 	int8  contactor_b_powersave;        /* counts down. Off at zero. */
.................... 
.................... } struct_time_keep;
.................... 
.................... /* global structures */
.................... struct_config config={0};
.................... struct_current current={0};
.................... struct_time_keep timers={0};
.................... 
.................... #include "adc_dcswc_module_latching_contactor.c"
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3};
.................... 
.................... int16 adc_get(int8 ch) {
.................... 	int16 sum;
.................... 	int8 i;
.................... 
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */
.................... 	int16 *p;
.................... 	p = current.adc_buffer[ch];
*
01BE:  MOVF   xE6,W
01C0:  MULLW  20
01C2:  MOVF   FF3,W
01C4:  CLRF   03
01C6:  ADDLW  2D
01C8:  MOVWF  01
01CA:  MOVLW  00
01CC:  ADDWFC 03,F
01CE:  MOVFF  01,EA
01D2:  MOVFF  03,EB
.................... 
.................... 	// Calculate the mean.  This is done by summing up the
.................... 	// values and dividing by the number of elements.
.................... 	sum = 0;
01D6:  CLRF   xE8
01D8:  CLRF   xE7
.................... 	for( i = 0; i < 16 ; i++ ) {
01DA:  CLRF   xE9
01DC:  MOVF   xE9,W
01DE:  SUBLW  0F
01E0:  BNC   020C
.................... //		sum += current.adc_buffer[ch][i];
.................... 		sum += p[i];
01E2:  CLRF   03
01E4:  MOVFF  E9,02
01E8:  BCF    FD8.0
01EA:  RLCF   02,F
01EC:  RLCF   03,F
01EE:  MOVF   02,W
01F0:  ADDWF  xEA,W
01F2:  MOVWF  FE9
01F4:  MOVF   xEB,W
01F6:  ADDWFC 03,W
01F8:  MOVWF  FEA
01FA:  MOVFF  FEC,03
01FE:  MOVF   FED,F
0200:  MOVF   FEF,W
0202:  ADDWF  xE7,F
0204:  MOVF   03,W
0206:  ADDWFC xE8,F
0208:  INCF   xE9,F
020A:  BRA    01DC
.................... 	}
.................... 
.................... 	/* divide sum by our 16 samples and round by adding 8 */
.................... 	return ( (sum+8) >> 4 );
020C:  MOVLW  08
020E:  ADDWF  xE7,W
0210:  MOVWF  xEC
0212:  MOVLW  00
0214:  ADDWFC xE8,W
0216:  MOVWF  xED
0218:  RRCF   xED,W
021A:  MOVWF  03
021C:  RRCF   xEC,W
021E:  MOVWF  02
0220:  RRCF   03,F
0222:  RRCF   02,F
0224:  RRCF   03,F
0226:  RRCF   02,F
0228:  RRCF   03,F
022A:  RRCF   02,F
022C:  MOVLW  0F
022E:  ANDWF  03,F
0230:  MOVFF  02,01
0234:  MOVFF  03,02
0238:  RETURN 0
.................... }
.................... 
.................... 
.................... void adc_update(void) {
.................... 
.................... 	/* wrap buffer around */
.................... 	current.adc_buffer_index++;
*
08C2:  INCF   x8D,F
.................... 	if ( current.adc_buffer_index >= 16 )
08C4:  MOVF   x8D,W
08C6:  SUBLW  0F
08C8:  BC    08CC
.................... 		current.adc_buffer_index=0;
08CA:  CLRF   x8D
.................... 
.................... 	set_adc_channel(4);
08CC:  MOVLW  10
08CE:  MOVWF  01
08D0:  MOVF   FC2,W
08D2:  ANDLW  C3
08D4:  IORWF  01,W
08D6:  MOVWF  FC2
.................... 	current.adc_buffer[0][current.adc_buffer_index] = read_adc();
08D8:  BCF    FD8.0
08DA:  RLCF   x8D,W
08DC:  CLRF   03
08DE:  ADDLW  2D
08E0:  MOVWF  FE9
08E2:  MOVLW  00
08E4:  ADDWFC 03,W
08E6:  MOVWF  FEA
08E8:  BSF    FC2.1
08EA:  BTFSC  FC2.1
08EC:  BRA    08EA
08EE:  MOVFF  FC3,FEF
08F2:  MOVFF  FC4,FEC
.................... 
.................... 
.................... 	set_adc_channel(2);
08F6:  MOVLW  08
08F8:  MOVWF  01
08FA:  MOVF   FC2,W
08FC:  ANDLW  C3
08FE:  IORWF  01,W
0900:  MOVWF  FC2
.................... 	delay_ms(1);
0902:  MOVLW  01
0904:  MOVWF  xC2
0906:  RCALL  0856
.................... 	current.adc_buffer[1][current.adc_buffer_index] = read_adc();
0908:  BCF    FD8.0
090A:  RLCF   x8D,W
090C:  CLRF   03
090E:  ADDLW  4D
0910:  MOVWF  FE9
0912:  MOVLW  00
0914:  ADDWFC 03,W
0916:  MOVWF  FEA
0918:  BSF    FC2.1
091A:  BTFSC  FC2.1
091C:  BRA    091A
091E:  MOVFF  FC3,FEF
0922:  MOVFF  FC4,FEC
.................... 
.................... 	set_adc_channel(9);
0926:  MOVLW  24
0928:  MOVWF  01
092A:  MOVF   FC2,W
092C:  ANDLW  C3
092E:  IORWF  01,W
0930:  MOVWF  FC2
.................... 	delay_ms(1);
0932:  MOVLW  01
0934:  MOVWF  xC2
0936:  RCALL  0856
.................... 	current.adc_buffer[2][current.adc_buffer_index] = read_adc();
0938:  BCF    FD8.0
093A:  RLCF   x8D,W
093C:  CLRF   03
093E:  ADDLW  6D
0940:  MOVWF  FE9
0942:  MOVLW  00
0944:  ADDWFC 03,W
0946:  MOVWF  FEA
0948:  BSF    FC2.1
094A:  BTFSC  FC2.1
094C:  BRA    094A
094E:  MOVFF  FC3,FEF
0952:  MOVFF  FC4,FEC
0956:  RETURN 0
.................... }
.................... 
.................... #include "param_dcswc_module_latching_contactor.c"
.................... #inline
.................... char xor_crc(char oldcrc, char data) {
.................... 	return oldcrc ^ data;
*
06DE:  MOVF   xCC,W
06E0:  XORWF  xCD,W
06E2:  MOVWF  01
*
0728:  MOVF   xCC,W
072A:  XORWF  xCD,W
072C:  MOVWF  01
.................... }
.................... 
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) {
*
0678:  CLRF   xC9
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
067A:  MOVFF  C8,CB
067E:  MOVF   xC7,W
0680:  BTFSC  FD8.2
0682:  DECF   xC8,F
0684:  DECF   xC7,F
0686:  MOVWF  xCA
0688:  MOVF   xCA,F
068A:  BNZ   0690
068C:  MOVF   xCB,F
068E:  BZ    06F0
.................... 		*data = read_eeprom( address++ );
0690:  MOVFF  C6,03
0694:  MOVF   xC5,W
0696:  MOVWF  FE9
0698:  MOVFF  03,FEA
069C:  MOVF   xC4,W
069E:  MOVWF  03
06A0:  MOVF   xC3,W
06A2:  INCF   xC3,F
06A4:  BTFSC  FD8.2
06A6:  INCF   xC4,F
06A8:  MOVWF  xCC
06AA:  MOVFF  03,CD
06AE:  MOVFF  FF2,CE
06B2:  BCF    FF2.7
06B4:  MOVFF  CC,FA9
06B8:  BCF    FA6.6
06BA:  BCF    FA6.7
06BC:  BSF    FA6.0
06BE:  MOVF   FA8,W
06C0:  BTFSC  xCE.7
06C2:  BSF    FF2.7
06C4:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data);
06C6:  MOVFF  C6,03
06CA:  MOVF   xC5,W
06CC:  MOVWF  FE9
06CE:  MOVFF  03,FEA
06D2:  MOVFF  FEF,CA
06D6:  MOVFF  C9,CC
06DA:  MOVFF  CA,CD
*
06E4:  MOVFF  01,C9
.................... 		data++;
06E8:  INCF   xC5,F
06EA:  BTFSC  FD8.2
06EC:  INCF   xC6,F
06EE:  BRA    067A
.................... 	}
.................... 	return crc;
06F0:  MOVFF  C9,01
06F4:  GOTO   0834 (RETURN)
.................... }
.................... 
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) {
06F8:  CLRF   xCA
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
06FA:  MOVFF  C9,CC
06FE:  MOVF   xC8,W
0700:  BTFSC  FD8.2
0702:  DECF   xC9,F
0704:  DECF   xC8,F
0706:  MOVWF  xCB
0708:  MOVF   xCB,F
070A:  BNZ   0710
070C:  MOVF   xCC,F
070E:  BZ    0788
.................... 		/* restart_wdt() */
.................... 		crc = xor_crc(crc,*data);
0710:  MOVFF  C7,03
0714:  MOVF   xC6,W
0716:  MOVWF  FE9
0718:  MOVFF  03,FEA
071C:  MOVFF  FEF,CB
0720:  MOVFF  CA,CC
0724:  MOVFF  CB,CD
*
072E:  MOVFF  01,CA
.................... 		write_eeprom( address++, *data++ );
0732:  MOVF   xC5,W
0734:  MOVWF  03
0736:  MOVF   xC4,W
0738:  INCF   xC4,F
073A:  BTFSC  FD8.2
073C:  INCF   xC5,F
073E:  MOVWF  xCB
0740:  MOVFF  03,CC
0744:  MOVF   xC7,W
0746:  MOVWF  03
0748:  MOVF   xC6,W
074A:  INCF   xC6,F
074C:  BTFSC  FD8.2
074E:  INCF   xC7,F
0750:  MOVWF  FE9
0752:  MOVFF  03,FEA
0756:  MOVFF  FEF,CD
075A:  MOVF   FF2,W
075C:  MOVWF  00
075E:  BCF    FF2.7
0760:  MOVFF  CB,FA9
0764:  MOVFF  CD,FA8
0768:  BCF    FA6.6
076A:  BCF    FA6.7
076C:  BSF    FA6.2
076E:  MOVLB  F
0770:  MOVLW  55
0772:  MOVWF  FA7
0774:  MOVLW  AA
0776:  MOVWF  FA7
0778:  BSF    FA6.1
077A:  BTFSC  FA6.1
077C:  BRA    077A
077E:  BCF    FA6.2
0780:  MOVF   00,W
0782:  IORWF  FF2,F
0784:  MOVLB  0
0786:  BRA    06FA
.................... 	}
.................... 
.................... 	return crc;
0788:  MOVFF  CA,01
078C:  GOTO   07A8 (RETURN)
.................... }
.................... 
.................... void write_param_file() {
.................... 	int8 crc;
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config));
0790:  MOVLW  1B
0792:  MOVWF  xC2
0794:  CLRF   xC5
0796:  MOVLW  02
0798:  MOVWF  xC4
079A:  CLRF   xC7
079C:  MOVFF  C2,C6
07A0:  CLRF   xC9
07A2:  MOVLW  12
07A4:  MOVWF  xC8
07A6:  BRA    06F8
07A8:  MOVFF  01,C1
.................... 	/* write the CRC was calculated on the structure */
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc);
07AC:  MOVF   FF2,W
07AE:  MOVWF  00
07B0:  BCF    FF2.7
07B2:  CLRF   FA9
07B4:  MOVFF  C1,FA8
07B8:  BCF    FA6.6
07BA:  BCF    FA6.7
07BC:  BSF    FA6.2
07BE:  MOVLB  F
07C0:  MOVLW  55
07C2:  MOVWF  FA7
07C4:  MOVLW  AA
07C6:  MOVWF  FA7
07C8:  BSF    FA6.1
07CA:  BTFSC  FA6.1
07CC:  BRA    07CA
07CE:  BCF    FA6.2
07D0:  MOVF   00,W
07D2:  IORWF  FF2,F
07D4:  MOVLB  0
07D6:  RETURN 0
.................... }
.................... 
.................... void write_default_param_file() {
.................... 	current.default_params_written=1;
07D8:  MOVLW  01
07DA:  MOVWF  x99
.................... 
.................... 	/* both LEDs on */
.................... 	timers.led_on_a=150;
07DC:  MOVLW  96
07DE:  MOVWF  x9B
.................... 	timers.led_on_b=150;
07E0:  MOVWF  x9C
.................... 
.................... 	config.adc_sample_ticks=20;
07E2:  CLRF   1C
07E4:  MOVLW  14
07E6:  MOVWF  1B
.................... 
.................... 	config.startup_power_on_delay=5;
07E8:  CLRF   1E
07EA:  MOVLW  05
07EC:  MOVWF  1D
.................... 
.................... 	config.command_off_hold_time=2;
07EE:  CLRF   20
07F0:  MOVLW  02
07F2:  MOVWF  1F
.................... 
.................... 	config.lvd_disconnect_adc=190;
07F4:  CLRF   22
07F6:  MOVLW  BE
07F8:  MOVWF  21
.................... 	config.lvd_disconnect_delay=65535;
07FA:  SETF   24
07FC:  SETF   23
.................... 	config.lvd_reconnect_adc=200;
07FE:  CLRF   26
0800:  MOVLW  C8
0802:  MOVWF  25
.................... 
.................... 	config.hvd_disconnect_adc=1000;
0804:  MOVLW  03
0806:  MOVWF  28
0808:  MOVLW  E8
080A:  MOVWF  27
.................... 	config.hvd_disconnect_delay=65535;
080C:  SETF   2A
080E:  SETF   29
.................... 	config.hvd_reconnect_adc=900;
0810:  MOVLW  03
0812:  MOVWF  2C
0814:  MOVLW  84
0816:  MOVWF  2B
.................... 
.................... 	/* write them so next time we use from EEPROM */
.................... 	write_param_file();
0818:  RCALL  0790
081A:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void read_param_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config)); 
081C:  MOVLW  1B
081E:  MOVWF  xC1
0820:  CLRF   xC4
0822:  MOVLW  02
0824:  MOVWF  xC3
0826:  CLRF   xC6
0828:  MOVFF  C1,C5
082C:  CLRF   xC8
082E:  MOVLW  12
0830:  MOVWF  xC7
0832:  BRA    0678
0834:  MOVFF  01,C0
.................... 		
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) {
0838:  MOVFF  FF2,C1
083C:  BCF    FF2.7
083E:  CLRF   FA9
0840:  BCF    FA6.6
0842:  BCF    FA6.7
0844:  BSF    FA6.0
0846:  MOVF   FA8,W
0848:  BTFSC  xC1.7
084A:  BSF    FF2.7
084C:  SUBWF  xC0,W
084E:  BZ    0852
.................... 		write_default_param_file();
0850:  RCALL  07D8
.................... 	}
0852:  GOTO   0DCA (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... #include "i2c_handler_dcswc_module_latching_contactor.c"
.................... #include "registers_dcswc_module_latching_contactor.h"
.................... #define I2C_REG_VOLTAGE_INPUT_NOW             0
.................... #define I2C_REG_VOLTAGE_INPUT_AVG             1
.................... #define I2C_REG_TEMPERATURE_BOARD_NOW         2
.................... #define I2C_REG_TEMPERATURE_BOARD_AVG         3
.................... #define I2C_REG_SWITCH_OVERRIDE_A             4
.................... #define I2C_REG_SWITCH_OVERRIDE_B             5
.................... #define I2C_REG_LED_A                         6
.................... #define I2C_REG_LED_B                         7
.................... #define I2C_REG_SEQUENCE_NUMBER               8
.................... #define I2C_REG_TIME_INTERVAL_MILLISECONDS    9
.................... #define I2C_REG_TIME_UPTIME_MINUTES           10
.................... #define I2C_REG_DEFAULT_PARAMS_WRITTEN        13
.................... #define I2C_REG_COMMAND_OFF                   14
.................... #define I2C_REG_POWER_OFF_FLAGS               15
.................... 
.................... 
.................... 
.................... #define I2C_REG_CONFIG_SERIAL_PREFIX                32
.................... #define I2C_REG_CONFIG_SERIAL_NUMBER                33
.................... #define I2C_REG_CONFIG_HARDWARE_MODEL               34
.................... #define I2C_REG_CONFIG_HARDWARE_VERSION             35
.................... #define I2C_REG_CONFIG_SOFTWARE_MODEL               36
.................... #define I2C_REG_CONFIG_SOFTWARE_VERSION             37
.................... #define I2C_REG_CONFIG_SOFTWARE_YEAR                38
.................... #define I2C_REG_CONFIG_SOFTWARE_MONTH               39
.................... #define I2C_REG_CONFIG_SOFTWARE_DAY                 40
.................... #define I2C_REG_CONFIG_PARAM_WRITE                  41
.................... #define I2C_REG_CONFIG_TICKS_ADC                    42
.................... #define I2C_REG_CONFIG_STARTUP_POWER_ON_DELAY       43
.................... #define I2C_REG_CONFIG_COMMAND_OFF_HOLD_TIME        44
.................... #define I2C_REG_CONFIG_LVD_DISCONNECT_VOLTAGE       49
.................... #define I2C_REG_CONFIG_LVD_DISCONNECT_DELAY         50
.................... #define I2C_REG_CONFIG_LVD_RECONNECT_VOLTAGE        51
.................... #define I2C_REG_CONFIG_HVD_DISCONNECT_VOLTAGE       52
.................... #define I2C_REG_CONFIG_HVD_DISCONNECT_DELAY         53
.................... #define I2C_REG_CONFIG_HVD_RECONNECT_VOLTAGE        54
.................... 
.................... 
.................... void write_i2c(int8 address, int16 value) {
.................... 	switch ( address ) {
*
00DC:  MOVF   xE6,W
00DE:  XORLW  06
00E0:  BZ    0114
00E2:  XORLW  01
00E4:  BZ    011A
00E6:  XORLW  09
00E8:  BZ    0120
00EA:  XORLW  27
00EC:  BZ    012A
00EE:  XORLW  03
00F0:  BZ    0162
00F2:  XORLW  01
00F4:  BZ    016C
00F6:  XORLW  07
00F8:  BZ    0176
00FA:  XORLW  1D
00FC:  BZ    0180
00FE:  XORLW  03
0100:  BZ    018A
0102:  XORLW  01
0104:  BZ    0194
0106:  XORLW  07
0108:  BZ    019E
010A:  XORLW  01
010C:  BZ    01A8
010E:  XORLW  03
0110:  BZ    01B2
0112:  BRA    01BA
.................... 		case I2C_REG_LED_A: 
.................... 			timers.led_on_a=make8(value,0);
0114:  MOVFF  E7,9B
.................... 			break;
0118:  BRA    01BA
.................... 		case I2C_REG_LED_B: 
.................... 			timers.led_on_b=make8(value,0);
011A:  MOVFF  E7,9C
.................... 			break;
011E:  BRA    01BA
.................... 
.................... 
.................... 		case I2C_REG_COMMAND_OFF:
.................... 			timers.command_off_seconds=value;
0120:  MOVFF  E8,9E
0124:  MOVFF  E7,9D
.................... 			break;
0128:  BRA    01BA
.................... 
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			if ( 1 == value ) {
012A:  DECFSZ xE7,W
012C:  BRA    0136
012E:  MOVF   xE8,F
0130:  BNZ   0136
.................... 				timers.now_write_config=1;
0132:  BSF    x9A.3
.................... 			} else if ( 2 == value ) {
0134:  BRA    0160
0136:  MOVF   xE7,W
0138:  SUBLW  02
013A:  BNZ   0144
013C:  MOVF   xE8,F
013E:  BNZ   0144
.................... 				timers.now_reset_config=1;
0140:  BSF    x9A.4
.................... 			} else if ( 1802 == value ) {
0142:  BRA    0160
0144:  MOVF   xE7,W
0146:  SUBLW  0A
0148:  BNZ   0156
014A:  MOVF   xE8,W
014C:  SUBLW  07
014E:  BNZ   0156
.................... 				current.factory_unlocked =1;
0150:  MOVLW  01
0152:  MOVWF  x94
.................... 			} else if ( 65535 == value ) {
0154:  BRA    0160
0156:  INCFSZ xE7,W
0158:  BRA    0160
015A:  INCFSZ xE8,W
015C:  BRA    0160
.................... 				reset_cpu();
015E:  RESET
.................... 			}
.................... 			break;
0160:  BRA    01BA
.................... 		case I2C_REG_CONFIG_TICKS_ADC:
.................... 			config.adc_sample_ticks=value;
0162:  MOVFF  E8,1C
0166:  MOVFF  E7,1B
.................... 			break;
016A:  BRA    01BA
.................... 		case I2C_REG_CONFIG_STARTUP_POWER_ON_DELAY:
.................... 			config.startup_power_on_delay=value;
016C:  MOVFF  E8,1E
0170:  MOVFF  E7,1D
.................... 			break;
0174:  BRA    01BA
.................... 		case I2C_REG_CONFIG_COMMAND_OFF_HOLD_TIME:
.................... 			config.command_off_hold_time=value;
0176:  MOVFF  E8,20
017A:  MOVFF  E7,1F
.................... 			break;
017E:  BRA    01BA
.................... 		case I2C_REG_CONFIG_LVD_DISCONNECT_VOLTAGE:
.................... 			config.lvd_disconnect_adc=value;
0180:  MOVFF  E8,22
0184:  MOVFF  E7,21
.................... 			break;
0188:  BRA    01BA
.................... 		case I2C_REG_CONFIG_LVD_DISCONNECT_DELAY:
.................... 			config.lvd_disconnect_delay=value;
018A:  MOVFF  E8,24
018E:  MOVFF  E7,23
.................... 			break;
0192:  BRA    01BA
.................... 		case I2C_REG_CONFIG_LVD_RECONNECT_VOLTAGE:
.................... 			config.lvd_reconnect_adc=value;
0194:  MOVFF  E8,26
0198:  MOVFF  E7,25
.................... 			break;
019C:  BRA    01BA
.................... 		case I2C_REG_CONFIG_HVD_DISCONNECT_VOLTAGE:
.................... 			config.hvd_disconnect_adc=value;
019E:  MOVFF  E8,28
01A2:  MOVFF  E7,27
.................... 			break;
01A6:  BRA    01BA
.................... 		case I2C_REG_CONFIG_HVD_DISCONNECT_DELAY:
.................... 			config.hvd_disconnect_delay=value;
01A8:  MOVFF  E8,2A
01AC:  MOVFF  E7,29
.................... 			break;
01B0:  BRA    01BA
.................... 		case I2C_REG_CONFIG_HVD_RECONNECT_VOLTAGE:
.................... 			config.hvd_reconnect_adc=value;
01B2:  MOVFF  E8,2C
01B6:  MOVFF  E7,2B
.................... 			break;
.................... 		default:
.................... 			/* do nothing */
.................... 	}
01BA:  GOTO   049E (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... int16 map_i2c(int8 addr) {
.................... 
.................... 	timers.led_on_a=100;
*
023A:  MOVLW  64
023C:  MOVWF  x9B
.................... 
.................... 
.................... 
.................... 	switch ( addr ) {
023E:  MOVF   xE5,W
0240:  BZ    02DC
0242:  XORLW  01
0244:  BZ    02FC
0246:  XORLW  03
0248:  BZ    0304
024A:  XORLW  01
024C:  BTFSC  FD8.2
024E:  BRA    0324
0250:  XORLW  0B
0252:  BTFSC  FD8.2
0254:  BRA    032E
0256:  XORLW  01
0258:  BTFSC  FD8.2
025A:  BRA    0342
025C:  XORLW  03
025E:  BTFSC  FD8.2
0260:  BRA    034C
0262:  XORLW  07
0264:  BTFSC  FD8.2
0266:  BRA    0356
0268:  XORLW  03
026A:  BTFSC  FD8.2
026C:  BRA    035E
026E:  XORLW  01
0270:  BTFSC  FD8.2
0272:  BRA    0368
0274:  XORLW  2D
0276:  BTFSC  FD8.2
0278:  BRA    0370
027A:  XORLW  01
027C:  BTFSC  FD8.2
027E:  BRA    037A
0280:  XORLW  07
0282:  BTFSC  FD8.2
0284:  BRA    0384
0286:  XORLW  01
0288:  BTFSC  FD8.2
028A:  BRA    038E
028C:  XORLW  03
028E:  BTFSC  FD8.2
0290:  BRA    0398
0292:  XORLW  01
0294:  BTFSC  FD8.2
0296:  BRA    03A0
0298:  XORLW  0F
029A:  BTFSC  FD8.2
029C:  BRA    03A8
029E:  XORLW  01
02A0:  BTFSC  FD8.2
02A2:  BRA    03B0
02A4:  XORLW  03
02A6:  BTFSC  FD8.2
02A8:  BRA    03B8
02AA:  XORLW  01
02AC:  BTFSC  FD8.2
02AE:  BRA    03C2
02B0:  XORLW  07
02B2:  BTFSC  FD8.2
02B4:  BRA    03CC
02B6:  XORLW  1D
02B8:  BTFSC  FD8.2
02BA:  BRA    03D6
02BC:  XORLW  03
02BE:  BTFSC  FD8.2
02C0:  BRA    03E0
02C2:  XORLW  01
02C4:  BTFSC  FD8.2
02C6:  BRA    03EA
02C8:  XORLW  07
02CA:  BTFSC  FD8.2
02CC:  BRA    03F4
02CE:  XORLW  01
02D0:  BTFSC  FD8.2
02D2:  BRA    03FE
02D4:  XORLW  03
02D6:  BTFSC  FD8.2
02D8:  BRA    0408
02DA:  BRA    0412
.................... 		/* analog channels */
.................... 		/* input voltage */
.................... 		case I2C_REG_VOLTAGE_INPUT_NOW: 
.................... 			return (int16) current.adc_buffer[0][current.adc_buffer_index];
02DC:  BCF    FD8.0
02DE:  RLCF   x8D,W
02E0:  CLRF   03
02E2:  ADDLW  2D
02E4:  MOVWF  FE9
02E6:  MOVLW  00
02E8:  ADDWFC 03,W
02EA:  MOVWF  FEA
02EC:  MOVFF  FEC,03
02F0:  MOVF   FED,F
02F2:  MOVFF  FEF,01
02F6:  MOVFF  03,02
02FA:  BRA    0418
.................... 		case I2C_REG_VOLTAGE_INPUT_AVG: 
.................... 			return (int16) adc_get(0);
02FC:  CLRF   xE6
02FE:  RCALL  01BE
0300:  MOVF   02,W
0302:  BRA    0418
.................... 
.................... 		/* temperature sensor */
.................... 		case I2C_REG_TEMPERATURE_BOARD_NOW: 
.................... 			return (int16) current.adc_buffer[1][current.adc_buffer_index];
0304:  BCF    FD8.0
0306:  RLCF   x8D,W
0308:  CLRF   03
030A:  ADDLW  4D
030C:  MOVWF  FE9
030E:  MOVLW  00
0310:  ADDWFC 03,W
0312:  MOVWF  FEA
0314:  MOVFF  FEC,03
0318:  MOVF   FED,F
031A:  MOVFF  FEF,01
031E:  MOVFF  03,02
0322:  BRA    0418
.................... 		case I2C_REG_TEMPERATURE_BOARD_AVG: 
.................... 			return (int16) adc_get(1);
0324:  MOVLW  01
0326:  MOVWF  xE6
0328:  RCALL  01BE
032A:  MOVF   02,W
032C:  BRA    0418
.................... 		
.................... 		/* status */
.................... 		case I2C_REG_SEQUENCE_NUMBER: 
.................... 			return (int16) current.sequence_number++;
032E:  MOVFF  8F,03
0332:  MOVF   x8E,W
0334:  INCF   x8E,F
0336:  BTFSC  FD8.2
0338:  INCF   x8F,F
033A:  MOVWF  01
033C:  MOVFF  03,02
0340:  BRA    0418
.................... 		case I2C_REG_TIME_INTERVAL_MILLISECONDS: 
.................... 			return (int16) current.interval_milliseconds; /* milliseconds since last query */
0342:  MOVFF  92,01
0346:  MOVFF  93,02
034A:  BRA    0418
.................... 		case I2C_REG_TIME_UPTIME_MINUTES: 
.................... 			return (int16) current.uptime_minutes; 
034C:  MOVFF  90,01
0350:  MOVFF  91,02
0354:  BRA    0418
.................... 		case I2C_REG_DEFAULT_PARAMS_WRITTEN:
.................... 			return (int16) current.default_params_written;
0356:  MOVFF  99,01
035A:  CLRF   02
035C:  BRA    0418
.................... 		case I2C_REG_COMMAND_OFF:
.................... 			return (int16) timers.command_off_seconds;
035E:  MOVFF  9D,01
0362:  MOVFF  9E,02
0366:  BRA    0418
.................... 		case I2C_REG_POWER_OFF_FLAGS:
.................... 			return (int16) current.power_off_flags;
0368:  MOVFF  98,01
036C:  CLRF   02
036E:  BRA    0418
.................... 
.................... 
.................... 		/* configuration */
.................... 		case I2C_REG_CONFIG_HARDWARE_MODEL: 
.................... 			return (int16) 'P';
0370:  MOVLW  50
0372:  MOVWF  01
0374:  MOVLW  00
0376:  MOVWF  02
0378:  BRA    0418
.................... 		case I2C_REG_CONFIG_HARDWARE_VERSION: 
.................... 			return (int16) 'Z';
037A:  MOVLW  5A
037C:  MOVWF  01
037E:  MOVLW  00
0380:  MOVWF  02
0382:  BRA    0418
.................... 		case I2C_REG_CONFIG_SOFTWARE_MODEL: 
.................... 			return (int16) 'P';
0384:  MOVLW  50
0386:  MOVWF  01
0388:  MOVLW  00
038A:  MOVWF  02
038C:  BRA    0418
.................... 		case I2C_REG_CONFIG_SOFTWARE_VERSION: 
.................... 			return (int16) 3;
038E:  MOVLW  03
0390:  MOVWF  01
0392:  MOVLW  00
0394:  MOVWF  02
0396:  BRA    0418
.................... 		case I2C_REG_CONFIG_SOFTWARE_YEAR:
.................... 			return (int16) current.compile_year;
0398:  MOVFF  95,01
039C:  CLRF   02
039E:  BRA    0418
.................... 		case I2C_REG_CONFIG_SOFTWARE_MONTH:
.................... 			return (int16) current.compile_month;
03A0:  MOVFF  96,01
03A4:  CLRF   02
03A6:  BRA    0418
.................... 		case I2C_REG_CONFIG_SOFTWARE_DAY:
.................... 			return (int16) current.compile_day;
03A8:  MOVFF  97,01
03AC:  CLRF   02
03AE:  BRA    0418
.................... 
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			/* 1 if factory unlocked */ 
.................... 			return (int16) current.factory_unlocked; 	
03B0:  MOVFF  94,01
03B4:  CLRF   02
03B6:  BRA    0418
.................... 		case I2C_REG_CONFIG_TICKS_ADC: 
.................... 			return (int16) config.adc_sample_ticks;
03B8:  MOVFF  1B,01
03BC:  MOVFF  1C,02
03C0:  BRA    0418
.................... 		case I2C_REG_CONFIG_STARTUP_POWER_ON_DELAY: 
.................... 			return (int16) config.startup_power_on_delay;
03C2:  MOVFF  1D,01
03C6:  MOVFF  1E,02
03CA:  BRA    0418
.................... 		case I2C_REG_CONFIG_COMMAND_OFF_HOLD_TIME:
.................... 			return (int16) config.command_off_hold_time;
03CC:  MOVFF  1F,01
03D0:  MOVFF  20,02
03D4:  BRA    0418
.................... 		case I2C_REG_CONFIG_LVD_DISCONNECT_VOLTAGE:
.................... 			return (int16) config.lvd_disconnect_adc;
03D6:  MOVFF  21,01
03DA:  MOVFF  22,02
03DE:  BRA    0418
.................... 		case I2C_REG_CONFIG_LVD_DISCONNECT_DELAY:
.................... 			return (int16) config.lvd_disconnect_delay;
03E0:  MOVFF  23,01
03E4:  MOVFF  24,02
03E8:  BRA    0418
.................... 		case I2C_REG_CONFIG_LVD_RECONNECT_VOLTAGE:
.................... 			return (int16) config.lvd_reconnect_adc;
03EA:  MOVFF  25,01
03EE:  MOVFF  26,02
03F2:  BRA    0418
.................... 		case I2C_REG_CONFIG_HVD_DISCONNECT_VOLTAGE:
.................... 			return (int16) config.hvd_disconnect_adc;
03F4:  MOVFF  27,01
03F8:  MOVFF  28,02
03FC:  BRA    0418
.................... 		case I2C_REG_CONFIG_HVD_DISCONNECT_DELAY:
.................... 			return (int16) config.hvd_disconnect_delay;
03FE:  MOVFF  29,01
0402:  MOVFF  2A,02
0406:  BRA    0418
.................... 		case I2C_REG_CONFIG_HVD_RECONNECT_VOLTAGE:
.................... 			return (int16) config.hvd_reconnect_adc;
0408:  MOVFF  2B,01
040C:  MOVFF  2C,02
0410:  BRA    0418
.................... 
.................... 
.................... 		/* we should have range checked, and never gotten here ... or read unimplemented (future) register */
.................... 		default: return (int16) addr;
0412:  MOVFF  E5,01
0416:  CLRF   02
.................... 	}
0418:  GOTO   04B2 (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... 
.................... #include "interrupt_dcswc_module_latching_contactor.c"
.................... #int_timer2
.................... void isr_timer2() {
.................... 	timers.now_millisecond=1;
*
00D4:  BSF    x9A.2
00D6:  BCF    F9E.1
00D8:  GOTO   006C
.................... }
.................... 
.................... 
.................... 
.................... unsigned int8 address;
.................... 
.................... #INT_SSP
.................... void ssp_interrupt () {
.................... 	unsigned int8 incoming, state;
.................... 	static int16 lastValue;
.................... 	static int8 lastMSB;
.................... 
.................... 
.................... 	state = i2c_isr_state();
*
0432:  BTFSC  FC7.5
0434:  BRA    043C
0436:  CLRF   xB5
0438:  BTFSC  FC7.2
043A:  BSF    xB5.7
043C:  MOVF   xB5,W
043E:  INCF   xB5,F
0440:  MOVWF  xE3
.................... 
.................... 	if(state <= 0x80) {                      
0442:  MOVF   xE3,W
0444:  SUBLW  80
0446:  BNC   049E
.................... 		// Master is sending data
.................... 		if ( state == 0x80 ) {
0448:  MOVF   xE3,W
044A:  SUBLW  80
044C:  BNZ   0454
.................... 			incoming = i2c_read(2); //Passing 2 as parameter, causes the function to read the SSPBUF without releasing the clock
044E:  MOVFF  FC9,E2
.................... 		} else {
0452:  BRA    0460
.................... 			incoming = i2c_read();
0454:  BCF    FC6.6
0456:  BTFSS  FC7.0
0458:  BRA    0456
045A:  MOVF   FC9,W
045C:  BSF    FC6.4
045E:  MOVWF  xE2
.................... 		}
.................... 
.................... 		if ( state == 1 ) {                      
0460:  DECFSZ xE3,W
0462:  BRA    046A
.................... 			// First received byte is address
.................... 			address = incoming;
0464:  MOVFF  E2,B1
.................... 		} else if ( state >= 2 && state != 0x80 ) {
0468:  BRA    049E
046A:  MOVF   xE3,W
046C:  SUBLW  01
046E:  BC    049E
0470:  MOVF   xE3,W
0472:  SUBLW  80
0474:  BZ    049E
.................... 			// Received byte is data
.................... 			// buffer[address++] = incoming;
.................... 		
.................... 			/* save MSB and we'll process it on next */
.................... 			if ( 2 == state ) {
0476:  MOVF   xE3,W
0478:  SUBLW  02
047A:  BNZ   0482
.................... 				lastMSB=incoming;
047C:  MOVFF  E2,B4
.................... 			} else if ( 3 == state ) {
0480:  BRA    049E
0482:  MOVF   xE3,W
0484:  SUBLW  03
0486:  BNZ   049E
.................... 				/* 16 bit value made of previous byte and this byte */
.................... 				write_i2c(address,make16(lastMSB,incoming));
0488:  MOVFF  B4,E5
048C:  MOVFF  E2,E4
0490:  MOVFF  B1,E6
0494:  MOVFF  B4,E8
0498:  MOVFF  E2,E7
049C:  BRA    00DC
.................... 			}
.................... 			
.................... 
.................... //			address++;
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	if ( state >= 0x80 ) {
049E:  MOVF   xE3,W
04A0:  SUBLW  7F
04A2:  BC    04D2
.................... 		//Master is requesting data
.................... 		
.................... 		if ( ! bit_test(address,0) ) {
04A4:  BTFSC  xB1.0
04A6:  BRA    04C6
.................... 			/* read 16 bit register on even address */
.................... 			lastValue=map_i2c(address>>1);
04A8:  BCF    FD8.0
04AA:  RRCF   xB1,W
04AC:  MOVWF  xE4
04AE:  MOVWF  xE5
04B0:  BRA    023A
04B2:  MOVFF  02,B3
04B6:  MOVFF  01,B2
.................... 
.................... 			 i2c_write(make8(lastValue,1));
04BA:  MOVFF  B3,E4
04BE:  MOVFF  B3,E5
04C2:  RCALL  041C
.................... 		} else {
04C4:  BRA    04D0
.................... 			/* send other byte of 16 bit register on odd address */
.................... 			i2c_write(make8(lastValue,0));
04C6:  MOVFF  B2,E4
04CA:  MOVFF  B2,E5
04CE:  RCALL  041C
.................... 		}
.................... 
.................... 		address++;
04D0:  INCF   xB1,F
.................... 	}
.................... 
.................... 	/* reset watchdog timer */
.................... 	timers.read_watchdog_seconds=0;
04D2:  CLRF   xA2
04D4:  CLRF   xA1
04D6:  BCF    F9E.3
04D8:  GOTO   006C
.................... }
.................... 
.................... 
.................... 
.................... 
.................... void init(void) {
.................... 	int8 buff[32];
.................... 	setup_oscillator(OSC_16MHZ);
*
0564:  MOVLW  70
0566:  MOVWF  FD3
0568:  BCF    F9B.6
056A:  BCF    F9B.7
.................... 
.................... 	setup_adc(ADC_CLOCK_DIV_16);
056C:  MOVF   FC0,W
056E:  ANDLW  C0
0570:  IORLW  05
0572:  MOVWF  FC0
0574:  BSF    FC0.7
0576:  BSF    FC2.0
.................... 	/* NTC thermistor on sAN2, input voltage divider on sAN4, DIP switch analog on sAN9
.................... 	voltage spans between 0 and Vdd */
.................... 	setup_adc_ports(sAN2 | sAN4 | sAN9,VSS_VDD);
0578:  MOVLW  14
057A:  MOVWF  F7E
057C:  BCF    FC1.0
057E:  BCF    FC1.1
0580:  BCF    FC1.2
0582:  BCF    FC1.3
0584:  MOVLW  02
0586:  MOVWF  F7F
.................... 
.................... 
.................... 
.................... 	set_tris_a(0b00111111);
0588:  MOVLW  3F
058A:  MOVWF  F92
.................... 	set_tris_b(0b01110000);
058C:  MOVLW  70
058E:  MOVWF  F93
.................... 	set_tris_c(0b10000001);
0590:  MOVLW  81
0592:  MOVWF  F94
.................... //               76543210
.................... 
.................... 	port_a_pullups(0b00110000);
0594:  MOVLW  30
0596:  MOVWF  F77
0598:  BCF    FF1.7
.................... 	port_b_pullups(0b00000000);
059A:  CLRF   F78
.................... //                   76543210
.................... 
.................... 	/* data structure initialization */
.................... 	/* all initialized to 0 on declaration. Just do this if need non-zero */
.................... 	timers.command_off_seconds=65535;
059C:  SETF   x9E
059E:  SETF   x9D
.................... 
.................... 	/* get our compiled date from constant */
.................... 	strcpy(buff,__DATE__);
05A0:  CLRF   FEA
05A2:  MOVLW  C0
05A4:  MOVWF  FE9
05A6:  MOVLW  00
05A8:  RCALL  00BA
05AA:  TBLRD*-
05AC:  TBLRD*+
05AE:  MOVF   FF5,W
05B0:  MOVWF  FEE
05B2:  IORLW  00
05B4:  BNZ   05AC
.................... 	current.compile_day =(buff[0]-'0')*10;
05B6:  MOVLW  30
05B8:  SUBWF  xC0,W
05BA:  MULLW  0A
05BC:  MOVFF  FF3,97
.................... 	current.compile_day+=(buff[1]-'0');
05C0:  MOVLW  30
05C2:  SUBWF  xC1,W
05C4:  ADDWF  x97,F
.................... 	/* determine month ... how annoying */
.................... 	if ( 'J'==buff[3] ) {
05C6:  MOVF   xC3,W
05C8:  SUBLW  4A
05CA:  BNZ   05EA
.................... 		if ( 'A'==buff[4] )
05CC:  MOVF   xC4,W
05CE:  SUBLW  41
05D0:  BNZ   05D8
.................... 			current.compile_month=1;
05D2:  MOVLW  01
05D4:  MOVWF  x96
05D6:  BRA    05E8
.................... 		else if ( 'N'==buff[5] )
05D8:  MOVF   xC5,W
05DA:  SUBLW  4E
05DC:  BNZ   05E4
.................... 			current.compile_month=6;
05DE:  MOVLW  06
05E0:  MOVWF  x96
05E2:  BRA    05E8
.................... 		else
.................... 			current.compile_month=7;
05E4:  MOVLW  07
05E6:  MOVWF  x96
.................... 	} else if ( 'A'==buff[3] ) {
05E8:  BRA    0658
05EA:  MOVF   xC3,W
05EC:  SUBLW  41
05EE:  BNZ   0602
.................... 		if ( 'P'==buff[4] )
05F0:  MOVF   xC4,W
05F2:  SUBLW  50
05F4:  BNZ   05FC
.................... 			current.compile_month=4;
05F6:  MOVLW  04
05F8:  MOVWF  x96
05FA:  BRA    0600
.................... 		else
.................... 			current.compile_month=8;
05FC:  MOVLW  08
05FE:  MOVWF  x96
.................... 	} else if ( 'M'==buff[3] ) {
0600:  BRA    0658
0602:  MOVF   xC3,W
0604:  SUBLW  4D
0606:  BNZ   061A
.................... 		if ( 'R'==buff[5] )
0608:  MOVF   xC5,W
060A:  SUBLW  52
060C:  BNZ   0614
.................... 			current.compile_month=3;
060E:  MOVLW  03
0610:  MOVWF  x96
0612:  BRA    0618
.................... 		else
.................... 			current.compile_month=5;
0614:  MOVLW  05
0616:  MOVWF  x96
.................... 	} else if ( 'F'==buff[3] ) {
0618:  BRA    0658
061A:  MOVF   xC3,W
061C:  SUBLW  46
061E:  BNZ   0626
.................... 		current.compile_month=2;
0620:  MOVLW  02
0622:  MOVWF  x96
.................... 	} else if ( 'S'==buff[3] ) {
0624:  BRA    0658
0626:  MOVF   xC3,W
0628:  SUBLW  53
062A:  BNZ   0632
.................... 		current.compile_month=9;
062C:  MOVLW  09
062E:  MOVWF  x96
.................... 	} else if ( 'O'==buff[3] ) {
0630:  BRA    0658
0632:  MOVF   xC3,W
0634:  SUBLW  4F
0636:  BNZ   063E
.................... 		current.compile_month=10;
0638:  MOVLW  0A
063A:  MOVWF  x96
.................... 	} else if ( 'N'==buff[3] ) {
063C:  BRA    0658
063E:  MOVF   xC3,W
0640:  SUBLW  4E
0642:  BNZ   064A
.................... 		current.compile_month=11;
0644:  MOVLW  0B
0646:  MOVWF  x96
.................... 	} else if ( 'D'==buff[3] ) {
0648:  BRA    0658
064A:  MOVF   xC3,W
064C:  SUBLW  44
064E:  BNZ   0656
.................... 		current.compile_month=12;
0650:  MOVLW  0C
0652:  MOVWF  x96
.................... 	} else {
0654:  BRA    0658
.................... 		/* error parsing, shouldn't happen */
.................... 		current.compile_month=255;
0656:  SETF   x96
.................... 	}
.................... 	current.compile_year =(buff[7]-'0')*10;
0658:  MOVLW  30
065A:  SUBWF  xC7,W
065C:  MULLW  0A
065E:  MOVFF  FF3,95
.................... 	current.compile_year+=(buff[8]-'0');
0662:  MOVLW  30
0664:  SUBWF  xC8,W
0666:  ADDWF  x95,F
.................... 
.................... 
.................... 	/* one periodic interrupt @ 1mS. Generated from system 16 MHz clock */
.................... 	/* prescale=16, match=249, postscale=1. Match is 249 because when match occurs, one cycle is lost */
.................... 	setup_timer_2(T2_DIV_BY_16,249,1);
0668:  MOVLW  00
066A:  IORLW  06
066C:  MOVWF  FCA
066E:  MOVLW  F9
0670:  MOVWF  FCB
.................... 
.................... 	enable_interrupts(INT_TIMER2);
0672:  BSF    F9D.1
0674:  GOTO   0DC8 (RETURN)
.................... }
.................... 
.................... int8 read_dip_switch(void) {
.................... 	int16 adc;
.................... 
.................... 	set_adc_channel(9);
*
0B3C:  MOVLW  24
0B3E:  MOVWF  01
0B40:  MOVF   FC2,W
0B42:  ANDLW  C3
0B44:  IORWF  01,W
0B46:  MOVWF  FC2
.................... 	delay_ms(1);
0B48:  MOVLW  01
0B4A:  MOVWF  xC2
0B4C:  RCALL  0856
.................... 	adc=read_adc();
0B4E:  BSF    FC2.1
0B50:  BTFSC  FC2.1
0B52:  BRA    0B50
0B54:  MOVFF  FC4,C1
0B58:  MOVFF  FC3,C0
.................... 
.................... 	/* (note that table is sorted by vout reading 
.................... 	SW3.1 (LSB) SW3.2 (MSB) VALUE ADC
....................     OFF         OFF         0     1023
.................... 	OFF         ON          2     682
....................     ON          OFF         1     511
.................... 	ON          ON          3     409
.................... 	*/
.................... 
.................... 	return adc;
0B5C:  MOVFF  C0,01
0B60:  BRA    0BA8
.................... 
.................... 	if ( adc > (1023-64) )
0B62:  MOVF   xC1,W
0B64:  SUBLW  02
0B66:  BC    0B78
0B68:  XORLW  FF
0B6A:  BNZ   0B72
0B6C:  MOVF   xC0,W
0B6E:  SUBLW  BF
0B70:  BC    0B78
.................... 		return 0;
0B72:  MOVLW  00
0B74:  MOVWF  01
0B76:  BRA    0BA8
.................... 	if ( adc > (682-64) )
0B78:  MOVF   xC1,W
0B7A:  SUBLW  01
0B7C:  BC    0B8E
0B7E:  XORLW  FF
0B80:  BNZ   0B88
0B82:  MOVF   xC0,W
0B84:  SUBLW  6A
0B86:  BC    0B8E
.................... 		return 2;
0B88:  MOVLW  02
0B8A:  MOVWF  01
0B8C:  BRA    0BA8
.................... 	if ( adc > (511-64) )
0B8E:  MOVF   xC1,W
0B90:  SUBLW  00
0B92:  BC    0BA4
0B94:  XORLW  FF
0B96:  BNZ   0B9E
0B98:  MOVF   xC0,W
0B9A:  SUBLW  BF
0B9C:  BC    0BA4
.................... 		return 1;
0B9E:  MOVLW  01
0BA0:  MOVWF  01
0BA2:  BRA    0BA8
.................... 
.................... 	return 3;
0BA4:  MOVLW  03
0BA6:  MOVWF  01
0BA8:  GOTO   0E6E (RETURN)
.................... }
.................... 
.................... void contactor_on_a(void) {
.................... 	timers.contactor_a_powersave=CONTACTOR_POWER_SAVE_MS;
*
0CEE:  MOVLW  C8
0CF0:  MOVWF  xAF
.................... 
.................... 	output_high(BRIDGE_A_A);
0CF2:  BCF    F94.3
0CF4:  BSF    F8B.3
.................... 	output_low(BRIDGE_A_B);
0CF6:  BCF    F94.4
0CF8:  BCF    F8B.4
0CFA:  GOTO   0F8E (RETURN)
.................... }
.................... 
.................... void contactor_off_a(void) {
.................... 	timers.contactor_a_powersave=CONTACTOR_POWER_SAVE_MS;
0CFE:  MOVLW  C8
0D00:  MOVWF  xAF
.................... 
.................... 	output_low(BRIDGE_A_A);
0D02:  BCF    F94.3
0D04:  BCF    F8B.3
.................... 	output_high(BRIDGE_A_B);
0D06:  BCF    F94.4
0D08:  BSF    F8B.4
0D0A:  GOTO   0F94 (RETURN)
.................... }
.................... 
.................... void contactor_on_b(void) {
.................... 	timers.contactor_b_powersave=CONTACTOR_POWER_SAVE_MS;
0D0E:  MOVLW  C8
0D10:  MOVWF  xB0
.................... 
.................... 	output_high(BRIDGE_B_A);
0D12:  BCF    F94.5
0D14:  BSF    F8B.5
.................... 	output_low(BRIDGE_B_B);
0D16:  BCF    F94.6
0D18:  BCF    F8B.6
0D1A:  GOTO   0FB2 (RETURN)
.................... }
.................... 
.................... void contactor_off_b(void) {
.................... 	timers.contactor_b_powersave=CONTACTOR_POWER_SAVE_MS;
0D1E:  MOVLW  C8
0D20:  MOVWF  xB0
.................... 
.................... 	output_low(BRIDGE_B_A);
0D22:  BCF    F94.5
0D24:  BCF    F8B.5
.................... 	output_high(BRIDGE_B_B);
0D26:  BCF    F94.6
0D28:  BSF    F8B.6
0D2A:  GOTO   0FB8 (RETURN)
.................... }
.................... 
.................... void periodic_millisecond(void) {
.................... 	static int8 uptimeticks=0;
.................... 	static int16 adcTicks=0;
.................... 	static int16 ticks=0;
.................... 	int16 adc;
.................... 
.................... 
.................... 	timers.now_millisecond=0;
*
0958:  BCF    x9A.2
.................... 
.................... 	/* LED control */
.................... 	if ( 0==timers.led_on_a ) {
095A:  MOVF   x9B,F
095C:  BNZ   0964
.................... 		output_low(LED_A);
095E:  BCF    F94.1
0960:  BCF    F8B.1
.................... 	} else {
0962:  BRA    096A
.................... 		output_high(LED_A);
0964:  BCF    F94.1
0966:  BSF    F8B.1
.................... 		timers.led_on_a--;
0968:  DECF   x9B,F
.................... 	}
.................... 	if ( 0==timers.led_on_b ) {
096A:  MOVF   x9C,F
096C:  BNZ   0974
.................... 		output_low(LED_B);
096E:  BCF    F94.2
0970:  BCF    F8B.2
.................... 	} else {
0972:  BRA    097A
.................... 		output_high(LED_B);
0974:  BCF    F94.2
0976:  BSF    F8B.2
.................... 		timers.led_on_b--;
0978:  DECF   x9C,F
.................... 	}
.................... 
.................... 	/* some other random stuff that we don't need to do every cycle in main */
.................... 	if ( current.interval_milliseconds < 65535 ) {
097A:  INCFSZ x92,W
097C:  BRA    0984
097E:  INCFSZ x93,W
0980:  BRA    0984
0982:  BRA    098A
.................... 		current.interval_milliseconds++;
0984:  INCF   x92,F
0986:  BTFSC  FD8.2
0988:  INCF   x93,F
.................... 	}
.................... 
.................... 	/* contactor timeout */
.................... 	if ( 0 == timers.contactor_a_powersave ) {
098A:  MOVF   xAF,F
098C:  BNZ   0998
.................... 		output_low(BRIDGE_A_A);
098E:  BCF    F94.3
0990:  BCF    F8B.3
.................... 		output_low(BRIDGE_A_B);
0992:  BCF    F94.4
0994:  BCF    F8B.4
.................... 	} else {
0996:  BRA    099A
.................... 		timers.contactor_a_powersave--;
0998:  DECF   xAF,F
.................... 	}
.................... 	if ( 0 == timers.contactor_b_powersave ) {
099A:  MOVF   xB0,F
099C:  BNZ   09A8
.................... 		output_low(BRIDGE_B_A);
099E:  BCF    F94.5
09A0:  BCF    F8B.5
.................... 		output_low(BRIDGE_B_B);
09A2:  BCF    F94.6
09A4:  BCF    F8B.6
.................... 	} else {
09A6:  BRA    09AA
.................... 		timers.contactor_b_powersave--;
09A8:  DECF   xB0,F
.................... 	}
.................... 
.................... 
.................... 	/* seconds */
.................... 	ticks++;
09AA:  INCF   xB9,F
09AC:  BTFSC  FD8.2
09AE:  INCF   xBA,F
.................... 	if ( 1000 == ticks ) {
09B0:  MOVF   xB9,W
09B2:  SUBLW  E8
09B4:  BTFSS  FD8.2
09B6:  BRA    0AFE
09B8:  MOVF   xBA,W
09BA:  SUBLW  03
09BC:  BTFSS  FD8.2
09BE:  BRA    0AFE
.................... 		ticks=0;
09C0:  CLRF   xBA
09C2:  CLRF   xB9
.................... 
.................... 		/* command off. 65535 disables */
.................... 		if ( 65535 != timers.command_off_seconds ) {
09C4:  INCFSZ x9D,W
09C6:  BRA    09CE
09C8:  INCFSZ x9E,W
09CA:  BRA    09CE
09CC:  BRA    0A08
.................... 			if ( timers.command_off_seconds > 0 ) {
09CE:  MOVF   x9D,F
09D0:  BNZ   09D6
09D2:  MOVF   x9E,F
09D4:  BZ    09E0
.................... 				/* waiting to power off */
.................... 				timers.command_off_seconds--;
09D6:  MOVF   x9D,W
09D8:  BTFSC  FD8.2
09DA:  DECF   x9E,F
09DC:  DECF   x9D,F
.................... 			} else {
09DE:  BRA    0A08
.................... 				/* timer at zero, ready to power off or already powered off */
.................... 				if ( ! bit_test(current.power_off_flags,POWER_FLAG_POS_COMMAND_OFF) ) {
09E0:  BTFSC  x98.0
09E2:  BRA    09F0
.................... 					/* not currently set, so we set it and start the countdown */
.................... 					bit_set(current.power_off_flags,POWER_FLAG_POS_COMMAND_OFF);
09E4:  BSF    x98.0
.................... 					timers.command_off_hold_seconds=config.command_off_hold_time;
09E6:  MOVFF  20,A0
09EA:  MOVFF  1F,9F
.................... 				} else {
09EE:  BRA    0A08
.................... 					/* set, so we clear it once countdown has elapsed */
.................... 					if ( 0==timers.command_off_hold_seconds ) {
09F0:  MOVF   x9F,F
09F2:  BNZ   0A00
09F4:  MOVF   xA0,F
09F6:  BNZ   0A00
.................... 						/* countdown elapsed, clear the flag and reset the timer */
.................... 						bit_clear(current.power_off_flags,POWER_FLAG_POS_COMMAND_OFF);
09F8:  BCF    x98.0
.................... 						timers.command_off_seconds=65535;
09FA:  SETF   x9E
09FC:  SETF   x9D
.................... 					} else {
09FE:  BRA    0A08
.................... 						timers.command_off_hold_seconds--;
0A00:  MOVF   x9F,W
0A02:  BTFSC  FD8.2
0A04:  DECF   xA0,F
0A06:  DECF   x9F,F
.................... 					}
.................... 				}		
.................... 			}
.................... 		}
.................... 
.................... 		/* LVD. 65535 disables */
.................... 		if ( 65535 != config.lvd_disconnect_delay ) {
0A08:  INCFSZ 23,W
0A0A:  BRA    0A12
0A0C:  INCFSZ 24,W
0A0E:  BRA    0A12
0A10:  BRA    0A76
0A12:  CLRF   19
0A14:  BTFSC  FF2.7
0A16:  BSF    19.7
0A18:  BCF    FF2.7
.................... 			adc=adc_get(0);
0A1A:  CLRF   xE6
0A1C:  CALL   01BE
0A20:  BTFSC  19.7
0A22:  BSF    FF2.7
0A24:  MOVFF  02,C1
0A28:  MOVFF  01,C0
.................... 
.................... 			if ( adc > config.lvd_reconnect_adc ) {
0A2C:  MOVF   26,W
0A2E:  SUBWF  xC1,W
0A30:  BNC   0A46
0A32:  BNZ   0A3A
0A34:  MOVF   xC0,W
0A36:  SUBWF  25,W
0A38:  BC    0A46
.................... 				if ( timers.lvd_reconnect_delay_seconds > 0 ) {
0A3A:  MOVF   xAB,F
0A3C:  BZ    0A42
.................... 					timers.lvd_reconnect_delay_seconds--;
0A3E:  DECF   xAB,F
.................... 				} else {
0A40:  BRA    0A44
.................... 					bit_clear(current.power_off_flags,POWER_FLAG_POS_LVD);
0A42:  BCF    x98.3
.................... 				}
.................... 			} else {
0A44:  BRA    0A4A
.................... 				timers.lvd_reconnect_delay_seconds=5; /* 5 seconds countdown before reconnecting */
0A46:  MOVLW  05
0A48:  MOVWF  xAB
.................... 			}
.................... 
.................... 			if ( adc < config.lvd_disconnect_adc ) {
0A4A:  MOVF   xC1,W
0A4C:  SUBWF  22,W
0A4E:  BNC   0A6E
0A50:  BNZ   0A58
0A52:  MOVF   21,W
0A54:  SUBWF  xC0,W
0A56:  BC    0A6E
.................... 				if ( timers.lvd_disconnect_delay_seconds > 0 ) {
0A58:  MOVF   xA9,F
0A5A:  BNZ   0A60
0A5C:  MOVF   xAA,F
0A5E:  BZ    0A6A
.................... 					timers.lvd_disconnect_delay_seconds--;
0A60:  MOVF   xA9,W
0A62:  BTFSC  FD8.2
0A64:  DECF   xAA,F
0A66:  DECF   xA9,F
.................... 				} else {
0A68:  BRA    0A6C
.................... 					bit_set(current.power_off_flags,POWER_FLAG_POS_LVD);
0A6A:  BSF    x98.3
.................... 				}
.................... 			} else {
0A6C:  BRA    0A76
.................... 				timers.lvd_disconnect_delay_seconds=config.lvd_disconnect_delay;
0A6E:  MOVFF  24,AA
0A72:  MOVFF  23,A9
.................... 			}
.................... 		}
.................... 
.................... 		/* HVD. 65535 disables */
.................... 		if ( 65535 != config.hvd_disconnect_delay ) {
0A76:  INCFSZ 29,W
0A78:  BRA    0A80
0A7A:  INCFSZ 2A,W
0A7C:  BRA    0A80
0A7E:  BRA    0AE4
0A80:  CLRF   19
0A82:  BTFSC  FF2.7
0A84:  BSF    19.7
0A86:  BCF    FF2.7
.................... 			adc=adc_get(0);
0A88:  CLRF   xE6
0A8A:  CALL   01BE
0A8E:  BTFSC  19.7
0A90:  BSF    FF2.7
0A92:  MOVFF  02,C1
0A96:  MOVFF  01,C0
.................... 
.................... 			if ( adc < config.hvd_reconnect_adc ) {
0A9A:  MOVF   xC1,W
0A9C:  SUBWF  2C,W
0A9E:  BNC   0AB4
0AA0:  BNZ   0AA8
0AA2:  MOVF   2B,W
0AA4:  SUBWF  xC0,W
0AA6:  BC    0AB4
.................... 				if ( timers.hvd_reconnect_delay_seconds > 0 ) {
0AA8:  MOVF   xAE,F
0AAA:  BZ    0AB0
.................... 					timers.hvd_reconnect_delay_seconds--;
0AAC:  DECF   xAE,F
.................... 				} else {
0AAE:  BRA    0AB2
.................... 					bit_clear(current.power_off_flags,POWER_FLAG_POS_HVD);
0AB0:  BCF    x98.4
.................... 				}
.................... 			} else {
0AB2:  BRA    0AB8
.................... 				timers.hvd_reconnect_delay_seconds=5; /* 5 seconds countdown before reconnecting */
0AB4:  MOVLW  05
0AB6:  MOVWF  xAE
.................... 			}
.................... 
.................... 			if ( adc > config.hvd_disconnect_adc ) {
0AB8:  MOVF   28,W
0ABA:  SUBWF  xC1,W
0ABC:  BNC   0ADC
0ABE:  BNZ   0AC6
0AC0:  MOVF   xC0,W
0AC2:  SUBWF  27,W
0AC4:  BC    0ADC
.................... 				if ( timers.hvd_disconnect_delay_seconds > 0 ) {
0AC6:  MOVF   xAC,F
0AC8:  BNZ   0ACE
0ACA:  MOVF   xAD,F
0ACC:  BZ    0AD8
.................... 					timers.hvd_disconnect_delay_seconds--;
0ACE:  MOVF   xAC,W
0AD0:  BTFSC  FD8.2
0AD2:  DECF   xAD,F
0AD4:  DECF   xAC,F
.................... 				} else {
0AD6:  BRA    0ADA
.................... 					bit_set(current.power_off_flags,POWER_FLAG_POS_HVD);
0AD8:  BSF    x98.4
.................... 				}
.................... 			} else {
0ADA:  BRA    0AE4
.................... 				timers.hvd_disconnect_delay_seconds=config.hvd_disconnect_delay;
0ADC:  MOVFF  2A,AD
0AE0:  MOVFF  29,AC
.................... 			}
.................... 		}
.................... 
.................... 		/* TODO: implement Low Temperature Disconnect (LTD) and High Temperature Disconnect (HTD) */
.................... 
.................... 		/* TODO: implement Command On */
.................... 
.................... 
.................... #if 0
.................... 		/* actually control the power switches */
.................... 		if ( current.power_off_flags ) {
.................... 			output_low(PI_POWER_EN);
.................... 			output_low(WIFI_POWER_EN);
.................... 		} else {
.................... 			output_high(PI_POWER_EN);
.................... 			output_high(WIFI_POWER_EN);
.................... 		}
.................... #endif
.................... 
.................... 
.................... 		
.................... 		/* uptime counter */
.................... 		uptimeTicks++;
0AE4:  INCF   xB6,F
.................... 		if ( 60 == uptimeTicks ) {
0AE6:  MOVF   xB6,W
0AE8:  SUBLW  3C
0AEA:  BNZ   0AFE
.................... 			uptimeTicks=0;
0AEC:  CLRF   xB6
.................... 			if ( current.uptime_minutes < 65535 ) 
0AEE:  INCFSZ x90,W
0AF0:  BRA    0AF8
0AF2:  INCFSZ x91,W
0AF4:  BRA    0AF8
0AF6:  BRA    0AFE
.................... 				current.uptime_minutes++;
0AF8:  INCF   x90,F
0AFA:  BTFSC  FD8.2
0AFC:  INCF   x91,F
.................... 		}
.................... 	}
.................... 
.................... 	/* ADC sample counter */
.................... 	if ( timers.now_adc_reset_count ) {
0AFE:  BTFSS  x9A.1
0B00:  BRA    0B08
.................... 		timers.now_adc_reset_count=0;
0B02:  BCF    x9A.1
.................... 		adcTicks=0;
0B04:  CLRF   xB8
0B06:  CLRF   xB7
.................... 	}
.................... 
.................... 	/* ADC sampling trigger */
.................... 	adcTicks++;
0B08:  INCF   xB7,F
0B0A:  BTFSC  FD8.2
0B0C:  INCF   xB8,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) {
0B0E:  MOVF   1B,W
0B10:  SUBWF  xB7,W
0B12:  BNZ   0B20
0B14:  MOVF   1C,W
0B16:  SUBWF  xB8,W
0B18:  BNZ   0B20
.................... 		adcTicks=0;
0B1A:  CLRF   xB8
0B1C:  CLRF   xB7
.................... 		timers.now_adc_sample=1;
0B1E:  BSF    x9A.0
.................... 	}
0B20:  GOTO   0E66 (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... void main(void) {
*
0D2E:  CLRF   FF8
0D30:  BCF    FD0.7
0D32:  BSF    07.7
0D34:  BSF    F93.6
0D36:  BSF    F93.4
0D38:  MOVLW  34
0D3A:  MOVWF  FC8
0D3C:  MOVLW  36
0D3E:  MOVWF  FC6
0D40:  BSF    FC5.0
0D42:  BSF    FC5.7
0D44:  CLRF   1A
0D46:  BSF    FB8.3
0D48:  MOVLW  A0
0D4A:  MOVWF  FAF
0D4C:  MOVLW  01
0D4E:  MOVWF  FB0
0D50:  MOVLW  A6
0D52:  MOVWF  FAC
0D54:  MOVLW  90
0D56:  MOVWF  FAB
0D58:  MOVLW  03
0D5A:  MOVWF  xB5
0D5C:  CLRF   xBC
0D5E:  CLRF   xBB
0D60:  MOVLW  00
0D62:  MOVWF  F7E
0D64:  BCF    FC1.0
0D66:  BCF    FC1.1
0D68:  BCF    FC1.2
0D6A:  BCF    FC1.3
0D6C:  MOVWF  F7F
0D6E:  CLRF   F6C
0D70:  CLRF   F6B
0D72:  CLRF   F6D
0D74:  BRA    0D86
0D76:  DATA 96,40
0D78:  DATA 1B,00
0D7A:  DATA 03,00
0D7C:  DATA B2,00
0D7E:  DATA 00,00
0D80:  DATA 05,40
0D82:  DATA B6,00
0D84:  DATA 00,00
0D86:  MOVLW  00
0D88:  MOVWF  FF8
0D8A:  MOVLW  0D
0D8C:  MOVWF  FF7
0D8E:  MOVLW  76
0D90:  MOVWF  FF6
0D92:  TBLRD*+
0D94:  MOVF   FF5,W
0D96:  MOVWF  00
0D98:  XORLW  00
0D9A:  BZ    0DC2
0D9C:  TBLRD*+
0D9E:  MOVF   FF5,W
0DA0:  MOVWF  01
0DA2:  BTFSC  FE8.7
0DA4:  BRA    0DB0
0DA6:  ANDLW  3F
0DA8:  MOVWF  FEA
0DAA:  TBLRD*+
0DAC:  MOVFF  FF5,FE9
0DB0:  BTFSC  01.6
0DB2:  TBLRD*+
0DB4:  BTFSS  01.6
0DB6:  TBLRD*+
0DB8:  MOVFF  FF5,FEE
0DBC:  DCFSNZ 00,F
0DBE:  BRA    0D92
0DC0:  BRA    0DB4
0DC2:  CLRF   FF8
.................... 	int8 i;
.................... 	int8 last_a, last_b;
.................... 
.................... 	init();
0DC4:  GOTO   0564
.................... 
.................... 
.................... 	/* read parameters from EEPROM and write defaults if CRC doesn't match */
.................... 	read_param_file();
0DC8:  BRA    081C
.................... 
.................... 	if ( config.startup_power_on_delay > 100 )
0DCA:  MOVF   1E,F
0DCC:  BNZ   0DD4
0DCE:  MOVF   1D,W
0DD0:  SUBLW  64
0DD2:  BC    0DDA
.................... 		config.startup_power_on_delay=100;
0DD4:  CLRF   1E
0DD6:  MOVLW  64
0DD8:  MOVWF  1D
.................... 
.................... 	/* flash on startup */
.................... 	for ( i=0 ; i<config.startup_power_on_delay ; i++ ) {
0DDA:  CLRF   xBD
0DDC:  MOVF   1E,F
0DDE:  BNZ   0DE6
0DE0:  MOVF   1D,W
0DE2:  SUBWF  xBD,W
0DE4:  BC    0E00
.................... 		restart_wdt();
0DE6:  CLRWDT
.................... 		output_high(LED_A);
0DE8:  BCF    F94.1
0DEA:  BSF    F8B.1
.................... 		delay_ms(200);
0DEC:  MOVLW  C8
0DEE:  MOVWF  xC2
0DF0:  RCALL  0856
.................... 		output_low(LED_A);
0DF2:  BCF    F94.1
0DF4:  BCF    F8B.1
.................... 		delay_ms(200);
0DF6:  MOVLW  C8
0DF8:  MOVWF  xC2
0DFA:  RCALL  0856
0DFC:  INCF   xBD,F
0DFE:  BRA    0DDC
.................... 	}
.................... 
.................... 	delay_ms(1000);
0E00:  MOVLW  04
0E02:  MOVWF  xC0
0E04:  MOVLW  FA
0E06:  MOVWF  xC2
0E08:  RCALL  0856
0E0A:  DECFSZ xC0,F
0E0C:  BRA    0E04
.................... 
.................... 	fprintf(STREAM_FTDI,"# dcswc_module_latching_contactor %s\r\n",__DATE__);
0E0E:  MOVLW  DC
0E10:  MOVWF  FF6
0E12:  MOVLW  04
0E14:  MOVWF  FF7
0E16:  MOVLW  22
0E18:  MOVWF  xC2
0E1A:  RCALL  087E
0E1C:  MOVLW  04
0E1E:  MOVWF  FF6
0E20:  MOVLW  05
0E22:  MOVWF  FF7
0E24:  BRA    089E
0E26:  MOVLW  0D
0E28:  BTFSS  F9E.4
0E2A:  BRA    0E28
0E2C:  MOVWF  FAD
0E2E:  MOVLW  0A
0E30:  BTFSS  F9E.4
0E32:  BRA    0E30
0E34:  MOVWF  FAD
.................... 
.................... 	timers.led_on_a=500;
0E36:  MOVLW  F4
0E38:  MOVWF  x9B
.................... 
.................... 	enable_interrupts(GLOBAL);
0E3A:  MOVLW  C0
0E3C:  IORWF  FF2,F
.................... 
.................... 	/* Prime ADC filter */
.................... 	for ( i=0 ; i<30 ; i++ ) {
0E3E:  CLRF   xBD
0E40:  MOVF   xBD,W
0E42:  SUBLW  1D
0E44:  BNC   0E4C
.................... 		adc_update();
0E46:  RCALL  08C2
0E48:  INCF   xBD,F
0E4A:  BRA    0E40
.................... 	}
.................... 
.................... 	last_a = ! input(SW_OVERRIDE_A);
0E4C:  BSF    F92.5
0E4E:  CLRF   xBE
0E50:  BTFSS  F80.5
0E52:  INCF   xBE,F
.................... 	last_b = ! input(SW_OVERRIDE_B);
0E54:  BSF    F92.4
0E56:  CLRF   xBF
0E58:  BTFSS  F80.4
0E5A:  INCF   xBF,F
.................... 
.................... 
.................... 	/* enable I2C slave interrupt */
.................... 	enable_interrupts(INT_SSP);
0E5C:  BSF    F9D.3
.................... 
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
0E5E:  CLRWDT
.................... 
.................... 		if ( timers.now_millisecond ) {
0E60:  BTFSS  x9A.2
0E62:  BRA    0E66
.................... 			periodic_millisecond();
0E64:  BRA    0958
.................... 		}
.................... 
.................... 		if ( kbhit() ) {
0E66:  BTFSS  F9E.5
0E68:  BRA    0F70
.................... 			getc();
0E6A:  BRA    0B24
.................... 			fprintf(STREAM_FTDI,"# read_dip_switch()=%u\r\n",read_dip_switch());
0E6C:  BRA    0B3C
0E6E:  MOVFF  01,C0
0E72:  MOVLW  0E
0E74:  MOVWF  FF6
0E76:  MOVLW  05
0E78:  MOVWF  FF7
0E7A:  MOVLW  14
0E7C:  MOVWF  xC2
0E7E:  RCALL  087E
0E80:  MOVFF  C0,C1
0E84:  MOVLW  1B
0E86:  MOVWF  xC2
0E88:  BRA    0BD4
0E8A:  MOVLW  0D
0E8C:  BTFSS  F9E.4
0E8E:  BRA    0E8C
0E90:  MOVWF  FAD
0E92:  MOVLW  0A
0E94:  BTFSS  F9E.4
0E96:  BRA    0E94
0E98:  MOVWF  FAD
0E9A:  CLRF   19
0E9C:  BTFSC  FF2.7
0E9E:  BSF    19.7
0EA0:  BCF    FF2.7
.................... 			fprintf(STREAM_FTDI,"#    vin adc=%lu\r\n",adc_get(0));
0EA2:  CLRF   xE6
0EA4:  CALL   01BE
0EA8:  BTFSC  19.7
0EAA:  BSF    FF2.7
0EAC:  MOVFF  02,C1
0EB0:  MOVFF  01,C0
0EB4:  MOVLW  28
0EB6:  MOVWF  FF6
0EB8:  MOVLW  05
0EBA:  MOVWF  FF7
0EBC:  MOVLW  0D
0EBE:  MOVWF  xC2
0EC0:  RCALL  087E
0EC2:  MOVLW  10
0EC4:  MOVWF  FE9
0EC6:  MOVFF  C1,C3
0ECA:  MOVFF  C0,C2
0ECE:  RCALL  0C42
0ED0:  MOVLW  0D
0ED2:  BTFSS  F9E.4
0ED4:  BRA    0ED2
0ED6:  MOVWF  FAD
0ED8:  MOVLW  0A
0EDA:  BTFSS  F9E.4
0EDC:  BRA    0EDA
0EDE:  MOVWF  FAD
0EE0:  CLRF   19
0EE2:  BTFSC  FF2.7
0EE4:  BSF    19.7
0EE6:  BCF    FF2.7
.................... 			fprintf(STREAM_FTDI,"#   temp adc=%lu\r\n",adc_get(1));
0EE8:  MOVLW  01
0EEA:  MOVWF  xE6
0EEC:  CALL   01BE
0EF0:  BTFSC  19.7
0EF2:  BSF    FF2.7
0EF4:  MOVFF  02,C1
0EF8:  MOVFF  01,C0
0EFC:  MOVLW  3C
0EFE:  MOVWF  FF6
0F00:  MOVLW  05
0F02:  MOVWF  FF7
0F04:  MOVLW  0D
0F06:  MOVWF  xC2
0F08:  RCALL  087E
0F0A:  MOVLW  10
0F0C:  MOVWF  FE9
0F0E:  MOVFF  C1,C3
0F12:  MOVFF  C0,C2
0F16:  RCALL  0C42
0F18:  MOVLW  0D
0F1A:  BTFSS  F9E.4
0F1C:  BRA    0F1A
0F1E:  MOVWF  FAD
0F20:  MOVLW  0A
0F22:  BTFSS  F9E.4
0F24:  BRA    0F22
0F26:  MOVWF  FAD
0F28:  CLRF   19
0F2A:  BTFSC  FF2.7
0F2C:  BSF    19.7
0F2E:  BCF    FF2.7
.................... 			fprintf(STREAM_FTDI,"# dip sw adc=%lu\r\n",adc_get(2));
0F30:  MOVLW  02
0F32:  MOVWF  xE6
0F34:  CALL   01BE
0F38:  BTFSC  19.7
0F3A:  BSF    FF2.7
0F3C:  MOVFF  02,C1
0F40:  MOVFF  01,C0
0F44:  MOVLW  50
0F46:  MOVWF  FF6
0F48:  MOVLW  05
0F4A:  MOVWF  FF7
0F4C:  MOVLW  0D
0F4E:  MOVWF  xC2
0F50:  RCALL  087E
0F52:  MOVLW  10
0F54:  MOVWF  FE9
0F56:  MOVFF  C1,C3
0F5A:  MOVFF  C0,C2
0F5E:  RCALL  0C42
0F60:  MOVLW  0D
0F62:  BTFSS  F9E.4
0F64:  BRA    0F62
0F66:  MOVWF  FAD
0F68:  MOVLW  0A
0F6A:  BTFSS  F9E.4
0F6C:  BRA    0F6A
0F6E:  MOVWF  FAD
.................... 		}
.................... 
.................... 		if ( input(SW_OVERRIDE_A) != last_a ) {
0F70:  BSF    F92.5
0F72:  MOVLW  00
0F74:  BTFSC  F80.5
0F76:  MOVLW  01
0F78:  SUBWF  xBE,W
0F7A:  BZ    0F94
.................... 			last_a=input(SW_OVERRIDE_A);
0F7C:  BSF    F92.5
0F7E:  CLRF   xBE
0F80:  BTFSC  F80.5
0F82:  INCF   xBE,F
.................... 
.................... 			if ( last_a ) {
0F84:  MOVF   xBE,F
0F86:  BZ    0F90
.................... 				timers.led_on_a=500;
0F88:  MOVLW  F4
0F8A:  MOVWF  x9B
.................... 				contactor_on_a();
0F8C:  BRA    0CEE
.................... 			} else {
0F8E:  BRA    0F94
.................... 				timers.led_on_a=0;
0F90:  CLRF   x9B
.................... 				contactor_off_a();
0F92:  BRA    0CFE
.................... 			}
.................... 		}
.................... 
.................... 
.................... 		if ( input(SW_OVERRIDE_B) != last_b ) {
0F94:  BSF    F92.4
0F96:  MOVLW  00
0F98:  BTFSC  F80.4
0F9A:  MOVLW  01
0F9C:  SUBWF  xBF,W
0F9E:  BZ    0FB8
.................... 			last_B=input(SW_OVERRIDE_B);
0FA0:  BSF    F92.4
0FA2:  CLRF   xBF
0FA4:  BTFSC  F80.4
0FA6:  INCF   xBF,F
.................... 
.................... 			if ( last_b ) {
0FA8:  MOVF   xBF,F
0FAA:  BZ    0FB4
.................... 				timers.led_on_b=500;
0FAC:  MOVLW  F4
0FAE:  MOVWF  x9C
.................... 				contactor_on_b();
0FB0:  BRA    0D0E
.................... 			} else {
0FB2:  BRA    0FB8
.................... 				timers.led_on_b=0;
0FB4:  CLRF   x9C
.................... 				contactor_off_b();
0FB6:  BRA    0D1E
.................... 			}
.................... 		}
.................... 
.................... 
.................... 
.................... 		if ( timers.now_adc_sample ) {
0FB8:  BTFSS  x9A.0
0FBA:  BRA    0FC0
.................... 			timers.now_adc_sample=0;
0FBC:  BCF    x9A.0
.................... 			adc_update();
0FBE:  RCALL  08C2
.................... 		}
.................... 
.................... 		if ( timers.now_write_config ) {
0FC0:  BTFSS  x9A.3
0FC2:  BRA    0FCA
.................... 			timers.now_write_config=0;
0FC4:  BCF    x9A.3
.................... 			write_param_file();
0FC6:  CALL   0790
.................... 		}
.................... 		if ( timers.now_reset_config ) {
0FCA:  BTFSS  x9A.4
0FCC:  BRA    0FD2
.................... 			timers.now_reset_config=0;
0FCE:  BCF    x9A.4
.................... 			write_default_param_file();
0FD0:  RCALL  07D8
.................... 		}
0FD2:  BRA    0E5E
.................... 
.................... 
.................... 	}
.................... 
.................... 
.................... }
0FD4:  BRA    0FD4

Configuration Fuses:
   Word  1: 2800   INTRC_IO NOPLLEN PCLKEN NOFCMEN NOIESO
   Word  2: 1819   NOPUT NOBROWNOUT BORV19 NOWDT WDT4096
   Word  3: 0000   NOHFOFST NOMCLR
   Word  4: 0009   STVREN NOLVP BBSIZ2K NOXINST DEBUG
   Word  5: C003   NOPROTECT NOCPB NOCPD
   Word  6: E003   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 4003   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.

ROM data:
F00000: 00 00 40 00                                        ..@.
