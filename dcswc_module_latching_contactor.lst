CCS PCH C Compiler, Version 5.090, 49113               09-Feb-22 11:42

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\dcswc_module_latching_contactor\dcswc_module_latching_contactor.lst

               ROM used:   12218 bytes (75%)
                           Largest free fragment is 4162
               RAM used:   283 (55%) at main() level
                           311 (61%) worst case
               Stack used: 4 locations (2 in main + 2 for interrupts)
               Stack size: 31

0000:  GOTO   2DAC
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   00D4
0060:  BTFSS  F9D.3
0062:  GOTO   006C
0066:  BTFSC  F9E.3
0068:  GOTO   0E8A
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include "dcswc_module_latching_contactor.h"
.................... #include <18F14K22.h>
.................... //////////// Standard Header file for the PIC18F14K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F14K22
00BA:  CLRF   FF7
00BC:  ADDLW  CA
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  RETURN 0
00CA:  DATA 39,2D
00CC:  DATA 46,65
00CE:  DATA 62,2D
00D0:  DATA 32,32
00D2:  DATA 00,00
*
0F5C:  DATA 23,20
0F5E:  DATA 20,20
0F60:  DATA 20,20
0F62:  DATA 20,20
0F64:  DATA 76,69
0F66:  DATA 6E,20
0F68:  DATA 61,64
0F6A:  DATA 63,3D
0F6C:  DATA 25,6C
0F6E:  DATA 75,0D
0F70:  DATA 0A,00
0F72:  DATA 23,20
0F74:  DATA 20,20
0F76:  DATA 20,20
0F78:  DATA 20,74
0F7A:  DATA 65,6D
0F7C:  DATA 70,20
0F7E:  DATA 61,64
0F80:  DATA 63,3D
0F82:  DATA 25,6C
0F84:  DATA 75,0D
0F86:  DATA 0A,00
0F88:  DATA 23,20
0F8A:  DATA 20,20
0F8C:  DATA 63,68
0F8E:  DATA 5B,30
0F90:  DATA 5D,2E
0F92:  DATA 73,74
0F94:  DATA 61,74
0F96:  DATA 65,3D
0F98:  DATA 30,78
0F9A:  DATA 25,32
0F9C:  DATA 58,0D
0F9E:  DATA 0A,00
0FA0:  DATA 23,20
0FA2:  DATA 20,20
0FA4:  DATA 63,68
0FA6:  DATA 5B,31
0FA8:  DATA 5D,2E
0FAA:  DATA 73,74
0FAC:  DATA 61,74
0FAE:  DATA 65,3D
0FB0:  DATA 30,78
0FB2:  DATA 25,32
0FB4:  DATA 58,0D
0FB6:  DATA 0A,00
0FB8:  DATA 23,20
0FBA:  DATA 64,63
0FBC:  DATA 73,77
0FBE:  DATA 63,5F
0FC0:  DATA 6D,6F
0FC2:  DATA 64,75
0FC4:  DATA 6C,65
0FC6:  DATA 5F,6C
0FC8:  DATA 61,74
0FCA:  DATA 63,68
0FCC:  DATA 69,6E
0FCE:  DATA 67,5F
0FD0:  DATA 63,6F
0FD2:  DATA 6E,74
0FD4:  DATA 61,63
0FD6:  DATA 74,6F
0FD8:  DATA 72,20
0FDA:  DATA 25,73
0FDC:  DATA 0D,0A
0FDE:  DATA 23,20
0FE0:  DATA 00,00
0FE2:  DATA 39,2D
0FE4:  DATA 46,65
0FE6:  DATA 62,2D
0FE8:  DATA 32,32
0FEA:  DATA 00,00
0FEC:  DATA 57,44
0FEE:  DATA 54,20
0FF0:  DATA 54,49
0FF2:  DATA 4D,45
0FF4:  DATA 4F,55
0FF6:  DATA 54,00
0FF8:  DATA 4D,43
0FFA:  DATA 4C,52
0FFC:  DATA 20,46
0FFE:  DATA 52,4F
1000:  DATA 4D,20
1002:  DATA 53,4C
1004:  DATA 45,45
1006:  DATA 50,00
1008:  DATA 4D,43
100A:  DATA 4C,52
100C:  DATA 20,46
100E:  DATA 52,4F
1010:  DATA 4D,20
1012:  DATA 52,55
1014:  DATA 4E,00
1016:  DATA 4E,4F
1018:  DATA 52,4D
101A:  DATA 41,4C
101C:  DATA 20,50
101E:  DATA 4F,57
1020:  DATA 45,52
1022:  DATA 20,55
1024:  DATA 50,00
1026:  DATA 42,52
1028:  DATA 4F,57
102A:  DATA 4E,4F
102C:  DATA 55,54
102E:  DATA 20,52
1030:  DATA 45,53
1032:  DATA 54,41
1034:  DATA 52,54
1036:  DATA 00,00
1038:  DATA 57,44
103A:  DATA 54,20
103C:  DATA 46,52
103E:  DATA 4F,4D
1040:  DATA 20,53
1042:  DATA 4C,45
1044:  DATA 45,50
1046:  DATA 00,00
1048:  DATA 52,45
104A:  DATA 53,45
104C:  DATA 54,20
104E:  DATA 49,4E
1050:  DATA 53,54
1052:  DATA 52,55
1054:  DATA 43,54
1056:  DATA 49,4F
1058:  DATA 4E,00
105A:  DATA 55,4E
105C:  DATA 4B,4E
105E:  DATA 4F,57
1060:  DATA 4E,21
1062:  DATA 00,00
*
18AC:  TBLRD*+
18AE:  MOVFF  FF6,11E
18B2:  MOVFF  FF7,11F
18B6:  MOVF   FF5,W
18B8:  BTFSS  F9E.4
18BA:  BRA    18B8
18BC:  MOVWF  FAD
18BE:  MOVFF  11E,FF6
18C2:  MOVFF  11F,FF7
18C6:  MOVLB  1
18C8:  DECFSZ x1D,F
18CA:  BRA    18CE
18CC:  BRA    18D2
18CE:  MOVLB  0
18D0:  BRA    18AC
18D2:  MOVLB  0
18D4:  RETURN 0
18D6:  TBLRD*+
18D8:  MOVF   FF5,F
18DA:  BZ    18F6
18DC:  MOVFF  FF6,11B
18E0:  MOVFF  FF7,11C
18E4:  MOVF   FF5,W
18E6:  BTFSS  F9E.4
18E8:  BRA    18E6
18EA:  MOVWF  FAD
18EC:  MOVFF  11B,FF6
18F0:  MOVFF  11C,FF7
18F4:  BRA    18D6
18F6:  RETURN 0
*
2BA8:  MOVFF  FEA,125
2BAC:  MOVFF  FE9,124
2BB0:  MOVLB  1
2BB2:  SWAPF  x1E,W
2BB4:  IORLW  F0
2BB6:  MOVWF  x20
2BB8:  ADDWF  x20,F
2BBA:  ADDLW  E2
2BBC:  MOVWF  x21
2BBE:  ADDLW  32
2BC0:  MOVWF  x23
2BC2:  MOVF   x1E,W
2BC4:  ANDLW  0F
2BC6:  ADDWF  x21,F
2BC8:  ADDWF  x21,F
2BCA:  ADDWF  x23,F
2BCC:  ADDLW  E9
2BCE:  MOVWF  x22
2BD0:  ADDWF  x22,F
2BD2:  ADDWF  x22,F
2BD4:  SWAPF  x1D,W
2BD6:  ANDLW  0F
2BD8:  ADDWF  x22,F
2BDA:  ADDWF  x23,F
2BDC:  RLCF   x22,F
2BDE:  RLCF   x23,F
2BE0:  COMF   x23,F
2BE2:  RLCF   x23,F
2BE4:  MOVF   x1D,W
2BE6:  ANDLW  0F
2BE8:  ADDWF  x23,F
2BEA:  RLCF   x20,F
2BEC:  MOVLW  07
2BEE:  MOVWF  x1F
2BF0:  MOVLW  0A
2BF2:  DECF   x22,F
2BF4:  ADDWF  x23,F
2BF6:  BNC   2BF2
2BF8:  DECF   x21,F
2BFA:  ADDWF  x22,F
2BFC:  BNC   2BF8
2BFE:  DECF   x20,F
2C00:  ADDWF  x21,F
2C02:  BNC   2BFE
2C04:  DECF   x1F,F
2C06:  ADDWF  x20,F
2C08:  BNC   2C04
2C0A:  MOVLW  01
2C0C:  MOVWF  FEA
2C0E:  MOVLW  1F
2C10:  MOVWF  FE9
2C12:  MOVLW  07
2C14:  ANDWF  x24,W
2C16:  BCF    x24.6
2C18:  ADDWF  FE9,F
2C1A:  MOVLW  00
2C1C:  ADDWFC FEA,F
2C1E:  MOVF   FE9,W
2C20:  SUBLW  23
2C22:  BNZ   2C2A
2C24:  DECFSZ FEA,W
2C26:  BRA    2C2A
2C28:  BSF    x24.6
2C2A:  MOVF   FEF,W
2C2C:  MOVWF  00
2C2E:  BNZ   2C40
2C30:  BTFSC  x24.6
2C32:  BRA    2C40
2C34:  BTFSC  x24.4
2C36:  BRA    2C50
2C38:  BTFSC  x24.3
2C3A:  BRA    2C40
2C3C:  MOVLW  20
2C3E:  BRA    2C46
2C40:  BSF    x24.3
2C42:  BCF    x24.4
2C44:  MOVLW  30
2C46:  ADDWF  00,F
2C48:  MOVF   00,W
2C4A:  BTFSS  F9E.4
2C4C:  BRA    2C4A
2C4E:  MOVWF  FAD
2C50:  MOVF   FEE,W
2C52:  BTFSS  x24.6
2C54:  BRA    2C1E
2C56:  MOVLB  0
2C58:  RETURN 0
2C5A:  MOVLB  1
2C5C:  BTFSC  x1C.7
2C5E:  BRA    2C80
2C60:  MOVLW  0F
2C62:  MOVWF  00
2C64:  SWAPF  x1B,W
2C66:  ANDWF  00,F
2C68:  MOVLW  0A
2C6A:  SUBWF  00,W
2C6C:  BC    2C74
2C6E:  MOVLW  30
2C70:  ADDWF  00,F
2C72:  BRA    2C78
2C74:  MOVF   x1C,W
2C76:  ADDWF  00,F
2C78:  MOVF   00,W
2C7A:  BTFSS  F9E.4
2C7C:  BRA    2C7A
2C7E:  MOVWF  FAD
2C80:  MOVLW  0F
2C82:  ANDWF  x1B,F
2C84:  MOVLW  0A
2C86:  SUBWF  x1B,W
2C88:  BC    2C8E
2C8A:  MOVLW  30
2C8C:  BRA    2C92
2C8E:  BCF    x1C.7
2C90:  MOVF   x1C,W
2C92:  ADDWF  x1B,F
2C94:  MOVF   x1B,W
2C96:  BTFSS  F9E.4
2C98:  BRA    2C96
2C9A:  MOVWF  FAD
2C9C:  MOVLB  0
2C9E:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #device *=16
.................... #use delay(clock=16MHz)
*
1064:  MOVLW  01
1066:  MOVWF  FEA
1068:  MOVLW  28
106A:  MOVWF  FE9
106C:  MOVF   FEF,W
106E:  BZ    108C
1070:  MOVLW  05
1072:  MOVWF  01
1074:  CLRF   00
1076:  DECFSZ 00,F
1078:  BRA    1076
107A:  DECFSZ 01,F
107C:  BRA    1074
107E:  MOVLW  2E
1080:  MOVWF  00
1082:  DECFSZ 00,F
1084:  BRA    1082
1086:  BRA    1088
1088:  DECFSZ FEF,F
108A:  BRA    1070
108C:  RETURN 0
.................... 
.................... /* hardware I2C port is slave and is connected to DCSWC bus */
.................... #use i2c(stream=STREAM_SLAVE,SLAVE, I2C1, FORCE_HW)
*
0E74:  MOVF   FC9,W
0E76:  MOVFF  12D,FC9
0E7A:  BSF    FC6.4
0E7C:  BCF    F9E.3
0E7E:  BTFSC  FC7.0
0E80:  BRA    0E7E
0E82:  CLRF   01
0E84:  BTFSS  FC5.6
0E86:  INCF   01,F
0E88:  RETURN 0
.................... /* slave address set based on dip switch in init() */
.................... 
.................... /* important FUSE notes! 
.................... MPLAB defaults to DEBUG mode and that will override fuses.
.................... make sure it is on "BUILD CONFIGURATION" of "RELEASE" under
.................... "PROJECT" menu.
.................... 
.................... CCS setup functions can override fuses. Check .LST file
.................... to see if anything has been overriden!
.................... */
.................... 
.................... #fuses NODEBUG 
.................... #fuses INTRC_IO
.................... #fuses NOPCLKEN
.................... #fuses NOPLLEN
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses BROWNOUT
.................... #fuses BORV30
.................... #fuses NOPUT
.................... #fuses WDT
.................... #fuses WDT128     /* this can be override by setup_wdt() */
.................... #fuses NOHFOFST
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses NOLVP
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... #fuses NOPROTECT
.................... #fuses NOWRT
.................... #fuses NOWRTC 
.................... #fuses NOWRTB
.................... #fuses NOWRTD
.................... #fuses NOEBTR
.................... #fuses NOEBTRB
.................... #fuses BBSIZ1K
.................... 
.................... 
.................... #use standard_io(ALL)
.................... 
.................... #use rs232(UART1,stream=STREAM_FTDI,baud=57600,errors)	
*
2B90:  BTFSS  F9E.5
2B92:  BRA    2B90
2B94:  MOVFF  FAB,1A
2B98:  MOVFF  FAE,01
2B9C:  BTFSS  1A.1
2B9E:  BRA    2BA4
2BA0:  BCF    FAB.4
2BA2:  BSF    FAB.4
2BA4:  GOTO   2F90 (RETURN)
.................... 
.................... /* program config CRC of 0 and a serial_prefix of 'A' ... that will trigger a write default on first boot */
.................... #ROM 0xF00000 = { 0x00, 0x00, 0x40, 0x00 }
.................... 
.................... 
.................... 
.................... 
.................... #define SW_OVERRIDE_A        PIN_A5
.................... #define SW_OVERRIDE_B        PIN_A4
.................... #define BRIDGE_B_A           PIN_C5
.................... #define BRIDGE_A_B           PIN_C4
.................... #define BRIDGE_A_A           PIN_C3
.................... #define BRIDGE_B_B           PIN_C6
.................... #define AN_DIP               PIN_C7
.................... #define SER_TO_PC            PIN_B7
.................... #define AN_VTEMP             PIN_A2
.................... #define AN_IN_VOLTS          PIN_C0
.................... #define LED_A                PIN_C1
.................... #define LED_B                PIN_C2
.................... #define I2C_SDA              PIN_B4
.................... #define SER_FROM_PC          PIN_B5
.................... #define I2C_SCL              PIN_B6
.................... 
.................... 
.................... /* 
.................... Parameters are stored in EEPROM
.................... */
.................... #define PARAM_CRC_ADDRESS  0x00
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2
.................... 
.................... 
.................... 
.................... /* bit positions for a channel state byte */
.................... #define CH_STATE_BIT_FUTURE   7  /* reserved for future use */
.................... #define CH_STATE_BIT_HTD      6  /* high temperature disconnect */
.................... #define CH_STATE_BIT_LTD      5  /* low temperature disconnect */
.................... #define CH_STATE_BIT_HVD      4  /* high voltage disconnect */
.................... #define CH_STATE_BIT_LVD      3  /* low voltage disconnect */
.................... #define CH_STATE_BIT_CMD_OFF  2  /* commanded off */
.................... #define CH_STATE_BIT_CMD_ON   1  /* commanded on (takes presedence over commanded off) */
.................... #define CH_STATE_BIT_OVERRIDE 0  /* override switch */
.................... 
.................... /* _OVERRIDE or _CMD_ON set means output on */
.................... #define CH_STATE_MASK_ON     0b00000011 
.................... /* _CMD_OFF, _LVD, _HVD, _LTD, _HTD means output off, unless override by on mask */
.................... #define CH_STATE_MASK_OFF    0b01111100 
.................... 
.................... #define ADC_SAMPLE_TICKS              20
.................... #define CONTACTOR_POWER_SAVE_MS       200 /* milliseconds for contactor be on. Must be >0 and <= 255 */
.................... #define CONTACTOR_REFRESH_CYCLES      10  /* re-appply contactor coil voltage every N cycles. 65525 disables */
.................... 
.................... #define BLINK_ON_TIME                 254
.................... #define BLINK_OFF_TIME                200
.................... 
.................... 
.................... typedef struct {
.................... 	/* command on hold time */
.................... 	int16 command_on_hold_time;
.................... 
.................... 	/* command off hold time */
.................... 	int16 command_off_hold_time;
.................... 
.................... 	/* low voltage disconnect */
.................... 	int16 lvd_disconnect_adc;
.................... 	int16 lvd_disconnect_delay;
.................... 	int16 lvd_reconnect_adc;
.................... 	int16 lvd_reconnect_delay;
.................... 
.................... 	/* high voltage disconnect */
.................... 	int16 hvd_disconnect_adc;
.................... 	int16 hvd_disconnect_delay;
.................... 	int16 hvd_reconnect_adc;
.................... 	int16 hvd_reconnect_delay;
.................... 
.................... 	/* low temperature disconnect */
.................... 	int16 ltd_disconnect_adc;
.................... 	int16 ltd_disconnect_delay;
.................... 	int16 ltd_reconnect_adc;
.................... 	int16 ltd_reconnect_delay;
.................... 
.................... 	/* high temperature disconnect */
.................... 	int16 htd_disconnect_adc;
.................... 	int16 htd_disconnect_delay;
.................... 	int16 htd_reconnect_adc;
.................... 	int16 htd_reconnect_delay;
.................... } struct_config_channel;
.................... 
.................... typedef struct {
.................... 	/* not much going on here */
.................... 	struct_config_channel ch[2];
.................... } struct_config;
.................... 
.................... 
.................... typedef struct {
.................... 	int8 state;
.................... 
.................... 	int16 command_on_seconds;			/* counts down. Off at zero. */
.................... 	int16 command_on_hold_seconds;      /* counts down. Off at zero. */
.................... 
.................... 	int16 command_off_seconds;			/* counts down. Off at zero. */
.................... 	int16 command_off_hold_seconds;     /* counts down. Off at zero. */
.................... 
.................... 	int16 lvd_disconnect_delay_seconds;	/* counts down */
.................... 	int16  lvd_reconnect_delay_seconds;	/* counts down */
.................... 
.................... 	int16 hvd_disconnect_delay_seconds;	/* counts down */
.................... 	int16  hvd_reconnect_delay_seconds;	/* counts down */
.................... 
.................... 	int16 ltd_disconnect_delay_seconds; /* counts down */
.................... 	int16 ltd_reconnect_delay_seconds;  /* counts down */
.................... 
.................... 	int16 htd_disconnect_delay_seconds; /* counts down */
.................... 	int16 htd_reconnect_delay_seconds;  /* counts down */
.................... } struct_channel;
.................... 
.................... typedef struct {
.................... 	/* circular buffer for ADC readings */
.................... 	int16 adc_buffer[3][16];
.................... 	int8  adc_buffer_index;
.................... 
.................... 	int16 sequence_number;
.................... 	int16 uptime_minutes;
.................... 	int16 interval_milliseconds;
.................... 
.................... 	int8 factory_unlocked;
.................... 
.................... 
.................... 	int8 compile_year;
.................... 	int8 compile_month;
.................... 	int8 compile_day;
.................... 
.................... 
.................... 	int8 default_params_written;
.................... } struct_current;
.................... 
.................... typedef struct {
.................... 	/* action flags */
.................... 	int1 now_adc_sample;
.................... 	int1 now_adc_reset_count;
.................... 
.................... 	int1 now_millisecond;
.................... 
.................... 	int1 now_write_config;
.................... 	int1 now_reset_config;
.................... 
.................... 	int1 now_debug_dump;
.................... 
.................... 
.................... 	/* timers */
.................... 	int8 led_blink[2];
.................... 	int8 led_on[2];
.................... 	int8 led_off[2];
.................... 
.................... 	/* contactors */
.................... 	int8 contactor[2]; 	         /* current state */
.................... 	int8 contactor_powersave[2]; /* countdown to shut off power to coil at 0 */
.................... } struct_time_keep;
.................... 
.................... /* global structures */
.................... struct_config config={0};
.................... struct_current current={0};
.................... struct_time_keep timers={0};
.................... struct_channel channel[2]={0};
.................... 
.................... #include "adc_dcswc_module_latching_contactor.c"
.................... int16 adc_get(int8 ch) {
.................... 	int16 sum;
.................... 	int8 i;
.................... 
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */
.................... 	int16 *p;
.................... 	p = current.adc_buffer[ch];
*
0594:  MOVLB  1
0596:  MOVF   x2F,W
0598:  MULLW  20
059A:  MOVF   FF3,W
059C:  CLRF   03
059E:  ADDLW  63
05A0:  MOVWF  01
05A2:  MOVLW  00
05A4:  ADDWFC 03,F
05A6:  MOVFF  01,133
05AA:  MOVFF  03,134
.................... 
.................... 	// Calculate the mean.  This is done by summing up the
.................... 	// values and dividing by the number of elements.
.................... 	sum = 0;
05AE:  CLRF   x31
05B0:  CLRF   x30
.................... 	for( i = 0; i < 16 ; i++ ) {
05B2:  CLRF   x32
05B4:  MOVF   x32,W
05B6:  SUBLW  0F
05B8:  BNC   05E4
.................... //		sum += current.adc_buffer[ch][i];
.................... 		sum += p[i];
05BA:  CLRF   03
05BC:  MOVFF  132,02
05C0:  BCF    FD8.0
05C2:  RLCF   02,F
05C4:  RLCF   03,F
05C6:  MOVF   02,W
05C8:  ADDWF  x33,W
05CA:  MOVWF  FE9
05CC:  MOVF   x34,W
05CE:  ADDWFC 03,W
05D0:  MOVWF  FEA
05D2:  MOVFF  FEC,03
05D6:  MOVF   FED,F
05D8:  MOVF   FEF,W
05DA:  ADDWF  x30,F
05DC:  MOVF   03,W
05DE:  ADDWFC x31,F
05E0:  INCF   x32,F
05E2:  BRA    05B4
.................... 	}
.................... 
.................... 	/* divide sum by our 16 samples and round by adding 8 */
.................... 	return ( (sum+8) >> 4 );
05E4:  MOVLW  08
05E6:  ADDWF  x30,W
05E8:  MOVWF  x35
05EA:  MOVLW  00
05EC:  ADDWFC x31,W
05EE:  MOVWF  x36
05F0:  RRCF   x36,W
05F2:  MOVWF  03
05F4:  RRCF   x35,W
05F6:  MOVWF  02
05F8:  RRCF   03,F
05FA:  RRCF   02,F
05FC:  RRCF   03,F
05FE:  RRCF   02,F
0600:  RRCF   03,F
0602:  RRCF   02,F
0604:  MOVLW  0F
0606:  ANDWF  03,F
0608:  MOVFF  02,01
060C:  MOVFF  03,02
0610:  MOVLB  0
0612:  RETURN 0
.................... }
.................... 
.................... 
.................... void adc_update(void) {
.................... 
.................... 	/* wrap buffer around */
.................... 	current.adc_buffer_index++;
*
18F8:  INCF   xC3,F
.................... 	if ( current.adc_buffer_index >= 16 )
18FA:  MOVF   xC3,W
18FC:  SUBLW  0F
18FE:  BC    1902
.................... 		current.adc_buffer_index=0;
1900:  CLRF   xC3
.................... 
.................... 	set_adc_channel(4);
1902:  MOVLW  10
1904:  MOVWF  01
1906:  MOVF   FC2,W
1908:  ANDLW  C3
190A:  IORWF  01,W
190C:  MOVWF  FC2
.................... 	current.adc_buffer[0][current.adc_buffer_index] = read_adc();
190E:  BCF    FD8.0
1910:  RLCF   xC3,W
1912:  CLRF   03
1914:  ADDLW  63
1916:  MOVWF  FE9
1918:  MOVLW  00
191A:  ADDWFC 03,W
191C:  MOVWF  FEA
191E:  BSF    FC2.1
1920:  BTFSC  FC2.1
1922:  BRA    1920
1924:  MOVFF  FC3,FEF
1928:  MOVFF  FC4,FEC
.................... 
.................... 
.................... 	set_adc_channel(2);
192C:  MOVLW  08
192E:  MOVWF  01
1930:  MOVF   FC2,W
1932:  ANDLW  C3
1934:  IORWF  01,W
1936:  MOVWF  FC2
.................... 	delay_ms(1);
1938:  MOVLW  01
193A:  MOVLB  1
193C:  MOVWF  x28
193E:  MOVLB  0
1940:  CALL   1064
.................... 	current.adc_buffer[1][current.adc_buffer_index] = read_adc();
1944:  BCF    FD8.0
1946:  RLCF   xC3,W
1948:  CLRF   03
194A:  ADDLW  83
194C:  MOVWF  FE9
194E:  MOVLW  00
1950:  ADDWFC 03,W
1952:  MOVWF  FEA
1954:  BSF    FC2.1
1956:  BTFSC  FC2.1
1958:  BRA    1956
195A:  MOVFF  FC3,FEF
195E:  MOVFF  FC4,FEC
.................... 
.................... 	set_adc_channel(9);
1962:  MOVLW  24
1964:  MOVWF  01
1966:  MOVF   FC2,W
1968:  ANDLW  C3
196A:  IORWF  01,W
196C:  MOVWF  FC2
.................... 	delay_ms(1);
196E:  MOVLW  01
1970:  MOVLB  1
1972:  MOVWF  x28
1974:  MOVLB  0
1976:  CALL   1064
.................... 	current.adc_buffer[2][current.adc_buffer_index] = read_adc();
197A:  BCF    FD8.0
197C:  RLCF   xC3,W
197E:  CLRF   03
1980:  ADDLW  A3
1982:  MOVWF  FE9
1984:  MOVLW  00
1986:  ADDWFC 03,W
1988:  MOVWF  FEA
198A:  BSF    FC2.1
198C:  BTFSC  FC2.1
198E:  BRA    198C
1990:  MOVFF  FC3,FEF
1994:  MOVFF  FC4,FEC
1998:  RETURN 0
.................... }
.................... 
.................... int8 read_dip_switch(void) {
.................... 	int16 adc;
.................... 
.................... 	set_adc_channel(9);
*
108E:  MOVLW  24
1090:  MOVWF  01
1092:  MOVF   FC2,W
1094:  ANDLW  C3
1096:  IORWF  01,W
1098:  MOVWF  FC2
.................... 	delay_ms(1);
109A:  MOVLW  01
109C:  MOVLB  1
109E:  MOVWF  x28
10A0:  MOVLB  0
10A2:  RCALL  1064
.................... 	adc=read_adc();
10A4:  BSF    FC2.1
10A6:  BTFSC  FC2.1
10A8:  BRA    10A6
10AA:  MOVFF  FC4,127
10AE:  MOVFF  FC3,126
.................... 
.................... 	/* (note that table is sorted by vout reading 
.................... 	SW3.1 (LSB) SW3.2 (MSB) VALUE ADC
....................     OFF         OFF         0     1023
.................... 	OFF         ON          2     682
....................     ON          OFF         1     511
.................... 	ON          ON          3     409
.................... 	*/
.................... 
.................... 	if ( adc > (1023-64) )
10B2:  MOVLB  1
10B4:  MOVF   x27,W
10B6:  SUBLW  02
10B8:  BC    10CA
10BA:  XORLW  FF
10BC:  BNZ   10C4
10BE:  MOVF   x26,W
10C0:  SUBLW  BF
10C2:  BC    10CA
.................... 		return 0;
10C4:  MOVLW  00
10C6:  MOVWF  01
10C8:  BRA    10FA
.................... 	if ( adc > (682-64) )
10CA:  MOVF   x27,W
10CC:  SUBLW  01
10CE:  BC    10E0
10D0:  XORLW  FF
10D2:  BNZ   10DA
10D4:  MOVF   x26,W
10D6:  SUBLW  6A
10D8:  BC    10E0
.................... 		return 2;
10DA:  MOVLW  02
10DC:  MOVWF  01
10DE:  BRA    10FA
.................... 	if ( adc > (511-64) )
10E0:  MOVF   x27,W
10E2:  SUBLW  00
10E4:  BC    10F6
10E6:  XORLW  FF
10E8:  BNZ   10F0
10EA:  MOVF   x26,W
10EC:  SUBLW  BF
10EE:  BC    10F6
.................... 		return 1;
10F0:  MOVLW  01
10F2:  MOVWF  01
10F4:  BRA    10FA
.................... 
.................... 	return 3;
10F6:  MOVLW  03
10F8:  MOVWF  01
10FA:  MOVLB  0
10FC:  GOTO   13B2 (RETURN)
.................... }
.................... 
.................... #include "param_dcswc_module_latching_contactor.c"
.................... #inline
.................... char xor_crc(char oldcrc, char data) {
.................... 	return oldcrc ^ data;
*
147C:  MOVF   x28,W
147E:  XORWF  x29,W
1480:  MOVWF  01
*
14CA:  MOVF   x28,W
14CC:  XORWF  x29,W
14CE:  MOVWF  01
.................... }
.................... 
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) {
*
1414:  MOVLB  1
1416:  CLRF   x24
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
1418:  MOVFF  123,126
141C:  MOVF   x22,W
141E:  BTFSC  FD8.2
1420:  DECF   x23,F
1422:  DECF   x22,F
1424:  MOVWF  x25
1426:  MOVF   x25,F
1428:  BNZ   142E
142A:  MOVF   x26,F
142C:  BZ    148E
.................... 		*data = read_eeprom( address++ );
142E:  MOVFF  121,03
1432:  MOVF   x20,W
1434:  MOVWF  FE9
1436:  MOVFF  03,FEA
143A:  MOVF   x1F,W
143C:  MOVWF  03
143E:  MOVF   x1E,W
1440:  INCF   x1E,F
1442:  BTFSC  FD8.2
1444:  INCF   x1F,F
1446:  MOVWF  x27
1448:  MOVFF  03,128
144C:  MOVFF  FF2,129
1450:  BCF    FF2.7
1452:  MOVFF  127,FA9
1456:  BCF    FA6.6
1458:  BCF    FA6.7
145A:  BSF    FA6.0
145C:  MOVF   FA8,W
145E:  BTFSC  x29.7
1460:  BSF    FF2.7
1462:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data);
1464:  MOVFF  121,03
1468:  MOVF   x20,W
146A:  MOVWF  FE9
146C:  MOVFF  03,FEA
1470:  MOVFF  FEF,125
1474:  MOVFF  124,128
1478:  MOVFF  125,129
*
1482:  MOVFF  01,124
.................... 		data++;
1486:  INCF   x20,F
1488:  BTFSC  FD8.2
148A:  INCF   x21,F
148C:  BRA    1418
.................... 	}
.................... 	return crc;
148E:  MOVFF  124,01
1492:  MOVLB  0
1494:  GOTO   1882 (RETURN)
.................... }
.................... 
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) {
1498:  MOVLB  1
149A:  CLRF   x26
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
149C:  MOVFF  125,128
14A0:  MOVF   x24,W
14A2:  BTFSC  FD8.2
14A4:  DECF   x25,F
14A6:  DECF   x24,F
14A8:  MOVWF  x27
14AA:  MOVF   x27,F
14AC:  BNZ   14B2
14AE:  MOVF   x28,F
14B0:  BZ    152A
.................... 		/* restart_wdt() */
.................... 		crc = xor_crc(crc,*data);
14B2:  MOVFF  123,03
14B6:  MOVF   x22,W
14B8:  MOVWF  FE9
14BA:  MOVFF  03,FEA
14BE:  MOVFF  FEF,127
14C2:  MOVFF  126,128
14C6:  MOVFF  127,129
*
14D0:  MOVFF  01,126
.................... 		write_eeprom( address++, *data++ );
14D4:  MOVF   x21,W
14D6:  MOVWF  03
14D8:  MOVF   x20,W
14DA:  INCF   x20,F
14DC:  BTFSC  FD8.2
14DE:  INCF   x21,F
14E0:  MOVWF  x27
14E2:  MOVFF  03,128
14E6:  MOVF   x23,W
14E8:  MOVWF  03
14EA:  MOVF   x22,W
14EC:  INCF   x22,F
14EE:  BTFSC  FD8.2
14F0:  INCF   x23,F
14F2:  MOVWF  FE9
14F4:  MOVFF  03,FEA
14F8:  MOVFF  FEF,129
14FC:  MOVF   FF2,W
14FE:  MOVWF  00
1500:  BCF    FF2.7
1502:  MOVFF  127,FA9
1506:  MOVFF  129,FA8
150A:  BCF    FA6.6
150C:  BCF    FA6.7
150E:  BSF    FA6.2
1510:  MOVLB  F
1512:  MOVLW  55
1514:  MOVWF  FA7
1516:  MOVLW  AA
1518:  MOVWF  FA7
151A:  BSF    FA6.1
151C:  BTFSC  FA6.1
151E:  BRA    151C
1520:  BCF    FA6.2
1522:  MOVF   00,W
1524:  IORWF  FF2,F
1526:  MOVLB  1
1528:  BRA    149C
.................... 	}
.................... 
.................... 	return crc;
152A:  MOVFF  126,01
152E:  MOVLB  0
1530:  GOTO   1550 (RETURN)
.................... }
.................... 
.................... void write_param_file() {
.................... 	int8 crc;
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config));
1534:  MOVLB  1
1536:  MOVLW  1B
1538:  MOVWF  x1E
153A:  CLRF   x21
153C:  MOVLW  02
153E:  MOVWF  x20
1540:  CLRF   x23
1542:  MOVFF  11E,122
1546:  CLRF   x25
1548:  MOVLW  48
154A:  MOVWF  x24
154C:  MOVLB  0
154E:  BRA    1498
1550:  MOVFF  01,11D
.................... 	/* write the CRC was calculated on the structure */
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc);
1554:  MOVF   FF2,W
1556:  MOVWF  00
1558:  BCF    FF2.7
155A:  CLRF   FA9
155C:  MOVFF  11D,FA8
1560:  BCF    FA6.6
1562:  BCF    FA6.7
1564:  BSF    FA6.2
1566:  MOVLB  F
1568:  MOVLW  55
156A:  MOVWF  FA7
156C:  MOVLW  AA
156E:  MOVWF  FA7
1570:  BSF    FA6.1
1572:  BTFSC  FA6.1
1574:  BRA    1572
1576:  BCF    FA6.2
1578:  MOVF   00,W
157A:  IORWF  FF2,F
157C:  MOVLB  0
157E:  RETURN 0
.................... }
.................... 
.................... void write_default_param_file() {
.................... 	int8 i;
.................... 
.................... 	current.default_params_written=1;
1580:  MOVLW  01
1582:  MOVWF  xCE
.................... 
.................... 	/* both LEDs on */
.................... 	timers.led_blink[0]=255;
1584:  SETF   xD0
.................... 	timers.led_blink[1]=255;
1586:  SETF   xD1
.................... 
.................... 
.................... 	for ( i=0 ; i<2 ; i++ ) {
1588:  MOVLB  1
158A:  CLRF   x1C
158C:  MOVF   x1C,W
158E:  SUBLW  01
1590:  BTFSS  FD8.0
1592:  BRA    1840
.................... 		/* low voltage disconnect */
.................... 		config.ch[i].lvd_disconnect_adc=606;
1594:  MOVF   x1C,W
1596:  MULLW  24
1598:  MOVF   FF3,W
159A:  CLRF   x1E
159C:  MOVWF  x1D
159E:  MOVLW  04
15A0:  ADDWF  x1D,W
15A2:  MOVWF  01
15A4:  MOVLW  00
15A6:  ADDWFC x1E,W
15A8:  MOVWF  03
15AA:  MOVF   01,W
15AC:  ADDLW  1B
15AE:  MOVWF  FE9
15B0:  MOVLW  00
15B2:  ADDWFC 03,W
15B4:  MOVWF  FEA
15B6:  MOVLW  02
15B8:  MOVWF  FEC
15BA:  MOVF   FED,F
15BC:  MOVLW  5E
15BE:  MOVWF  FEF
.................... 		config.ch[i].lvd_disconnect_delay=20; /* 65535 disables LVD */
15C0:  MOVF   x1C,W
15C2:  MULLW  24
15C4:  MOVF   FF3,W
15C6:  CLRF   x1E
15C8:  MOVWF  x1D
15CA:  MOVLW  06
15CC:  ADDWF  x1D,W
15CE:  MOVWF  01
15D0:  MOVLW  00
15D2:  ADDWFC x1E,W
15D4:  MOVWF  03
15D6:  MOVF   01,W
15D8:  ADDLW  1B
15DA:  MOVWF  FE9
15DC:  MOVLW  00
15DE:  ADDWFC 03,W
15E0:  MOVWF  FEA
15E2:  CLRF   FEC
15E4:  MOVF   FED,F
15E6:  MOVLW  14
15E8:  MOVWF  FEF
.................... 		config.ch[i].lvd_reconnect_adc=616;
15EA:  MOVF   x1C,W
15EC:  MULLW  24
15EE:  MOVF   FF3,W
15F0:  CLRF   x1E
15F2:  MOVWF  x1D
15F4:  MOVLW  08
15F6:  ADDWF  x1D,W
15F8:  MOVWF  01
15FA:  MOVLW  00
15FC:  ADDWFC x1E,W
15FE:  MOVWF  03
1600:  MOVF   01,W
1602:  ADDLW  1B
1604:  MOVWF  FE9
1606:  MOVLW  00
1608:  ADDWFC 03,W
160A:  MOVWF  FEA
160C:  MOVLW  02
160E:  MOVWF  FEC
1610:  MOVF   FED,F
1612:  MOVLW  68
1614:  MOVWF  FEF
.................... 		config.ch[i].lvd_reconnect_delay=10;
1616:  MOVF   x1C,W
1618:  MULLW  24
161A:  MOVF   FF3,W
161C:  CLRF   x1E
161E:  MOVWF  x1D
1620:  MOVLW  0A
1622:  ADDWF  x1D,W
1624:  MOVWF  01
1626:  MOVLW  00
1628:  ADDWFC x1E,W
162A:  MOVWF  03
162C:  MOVF   01,W
162E:  ADDLW  1B
1630:  MOVWF  FE9
1632:  MOVLW  00
1634:  ADDWFC 03,W
1636:  MOVWF  FEA
1638:  CLRF   FEC
163A:  MOVF   FED,F
163C:  MOVLW  0A
163E:  MOVWF  FEF
.................... 		
.................... 		/* high voltage disconnect */
.................... 		config.ch[i].hvd_disconnect_adc=700; 
1640:  MOVF   x1C,W
1642:  MULLW  24
1644:  MOVF   FF3,W
1646:  CLRF   x1E
1648:  MOVWF  x1D
164A:  MOVLW  0C
164C:  ADDWF  x1D,W
164E:  MOVWF  01
1650:  MOVLW  00
1652:  ADDWFC x1E,W
1654:  MOVWF  03
1656:  MOVF   01,W
1658:  ADDLW  1B
165A:  MOVWF  FE9
165C:  MOVLW  00
165E:  ADDWFC 03,W
1660:  MOVWF  FEA
1662:  MOVLW  02
1664:  MOVWF  FEC
1666:  MOVF   FED,F
1668:  MOVLW  BC
166A:  MOVWF  FEF
.................... 		config.ch[i].hvd_disconnect_delay=65535; /* 65535 disables HVD */
166C:  MOVF   x1C,W
166E:  MULLW  24
1670:  MOVF   FF3,W
1672:  CLRF   x1E
1674:  MOVWF  x1D
1676:  MOVLW  0E
1678:  ADDWF  x1D,W
167A:  MOVWF  01
167C:  MOVLW  00
167E:  ADDWFC x1E,W
1680:  MOVWF  03
1682:  MOVF   01,W
1684:  ADDLW  1B
1686:  MOVWF  FE9
1688:  MOVLW  00
168A:  ADDWFC 03,W
168C:  MOVWF  FEA
168E:  SETF   FEC
1690:  MOVF   FED,F
1692:  SETF   FEF
.................... 		config.ch[i].hvd_reconnect_adc=650;
1694:  MOVF   x1C,W
1696:  MULLW  24
1698:  MOVF   FF3,W
169A:  CLRF   x1E
169C:  MOVWF  x1D
169E:  MOVLW  10
16A0:  ADDWF  x1D,W
16A2:  MOVWF  01
16A4:  MOVLW  00
16A6:  ADDWFC x1E,W
16A8:  MOVWF  03
16AA:  MOVF   01,W
16AC:  ADDLW  1B
16AE:  MOVWF  FE9
16B0:  MOVLW  00
16B2:  ADDWFC 03,W
16B4:  MOVWF  FEA
16B6:  MOVLW  02
16B8:  MOVWF  FEC
16BA:  MOVF   FED,F
16BC:  MOVLW  8A
16BE:  MOVWF  FEF
.................... 		config.ch[i].hvd_reconnect_delay=60;
16C0:  MOVF   x1C,W
16C2:  MULLW  24
16C4:  MOVF   FF3,W
16C6:  CLRF   x1E
16C8:  MOVWF  x1D
16CA:  MOVLW  12
16CC:  ADDWF  x1D,W
16CE:  MOVWF  01
16D0:  MOVLW  00
16D2:  ADDWFC x1E,W
16D4:  MOVWF  03
16D6:  MOVF   01,W
16D8:  ADDLW  1B
16DA:  MOVWF  FE9
16DC:  MOVLW  00
16DE:  ADDWFC 03,W
16E0:  MOVWF  FEA
16E2:  CLRF   FEC
16E4:  MOVF   FED,F
16E6:  MOVLW  3C
16E8:  MOVWF  FEF
.................... 
.................... 		/* low temperature disconnect */
.................... 		config.ch[i].ltd_disconnect_adc=786; // 0C / 32F
16EA:  MOVF   x1C,W
16EC:  MULLW  24
16EE:  MOVF   FF3,W
16F0:  CLRF   x1E
16F2:  MOVWF  x1D
16F4:  MOVLW  14
16F6:  ADDWF  x1D,W
16F8:  MOVWF  01
16FA:  MOVLW  00
16FC:  ADDWFC x1E,W
16FE:  MOVWF  03
1700:  MOVF   01,W
1702:  ADDLW  1B
1704:  MOVWF  FE9
1706:  MOVLW  00
1708:  ADDWFC 03,W
170A:  MOVWF  FEA
170C:  MOVLW  03
170E:  MOVWF  FEC
1710:  MOVF   FED,F
1712:  MOVLW  12
1714:  MOVWF  FEF
.................... 		config.ch[i].ltd_disconnect_delay=65535; /* 65535 disables LTD */
1716:  MOVF   x1C,W
1718:  MULLW  24
171A:  MOVF   FF3,W
171C:  CLRF   x1E
171E:  MOVWF  x1D
1720:  MOVLW  16
1722:  ADDWF  x1D,W
1724:  MOVWF  01
1726:  MOVLW  00
1728:  ADDWFC x1E,W
172A:  MOVWF  03
172C:  MOVF   01,W
172E:  ADDLW  1B
1730:  MOVWF  FE9
1732:  MOVLW  00
1734:  ADDWFC 03,W
1736:  MOVWF  FEA
1738:  SETF   FEC
173A:  MOVF   FED,F
173C:  SETF   FEF
.................... 		config.ch[i].ltd_reconnect_adc=683;  // 10C / 50F
173E:  MOVF   x1C,W
1740:  MULLW  24
1742:  MOVF   FF3,W
1744:  CLRF   x1E
1746:  MOVWF  x1D
1748:  MOVLW  18
174A:  ADDWF  x1D,W
174C:  MOVWF  01
174E:  MOVLW  00
1750:  ADDWFC x1E,W
1752:  MOVWF  03
1754:  MOVF   01,W
1756:  ADDLW  1B
1758:  MOVWF  FE9
175A:  MOVLW  00
175C:  ADDWFC 03,W
175E:  MOVWF  FEA
1760:  MOVLW  02
1762:  MOVWF  FEC
1764:  MOVF   FED,F
1766:  MOVLW  AB
1768:  MOVWF  FEF
.................... 		config.ch[i].ltd_reconnect_delay=4;
176A:  MOVF   x1C,W
176C:  MULLW  24
176E:  MOVF   FF3,W
1770:  CLRF   x1E
1772:  MOVWF  x1D
1774:  MOVLW  1A
1776:  ADDWF  x1D,W
1778:  MOVWF  01
177A:  MOVLW  00
177C:  ADDWFC x1E,W
177E:  MOVWF  03
1780:  MOVF   01,W
1782:  ADDLW  1B
1784:  MOVWF  FE9
1786:  MOVLW  00
1788:  ADDWFC 03,W
178A:  MOVWF  FEA
178C:  CLRF   FEC
178E:  MOVF   FED,F
1790:  MOVLW  04
1792:  MOVWF  FEF
.................... 
.................... 		/* high temperature disconnect */
.................... 		config.ch[i].htd_disconnect_adc=405; // 35C / 95F
1794:  MOVF   x1C,W
1796:  MULLW  24
1798:  MOVF   FF3,W
179A:  CLRF   x1E
179C:  MOVWF  x1D
179E:  MOVLW  1C
17A0:  ADDWF  x1D,W
17A2:  MOVWF  01
17A4:  MOVLW  00
17A6:  ADDWFC x1E,W
17A8:  MOVWF  03
17AA:  MOVF   01,W
17AC:  ADDLW  1B
17AE:  MOVWF  FE9
17B0:  MOVLW  00
17B2:  ADDWFC 03,W
17B4:  MOVWF  FEA
17B6:  MOVLW  01
17B8:  MOVWF  FEC
17BA:  MOVF   FED,F
17BC:  MOVLW  95
17BE:  MOVWF  FEF
.................... 		config.ch[i].htd_disconnect_delay=65535; /* 65535 disables LTD */
17C0:  MOVF   x1C,W
17C2:  MULLW  24
17C4:  MOVF   FF3,W
17C6:  CLRF   x1E
17C8:  MOVWF  x1D
17CA:  MOVLW  1E
17CC:  ADDWF  x1D,W
17CE:  MOVWF  01
17D0:  MOVLW  00
17D2:  ADDWFC x1E,W
17D4:  MOVWF  03
17D6:  MOVF   01,W
17D8:  ADDLW  1B
17DA:  MOVWF  FE9
17DC:  MOVLW  00
17DE:  ADDWFC 03,W
17E0:  MOVWF  FEA
17E2:  SETF   FEC
17E4:  MOVF   FED,F
17E6:  SETF   FEF
.................... 		config.ch[i].htd_reconnect_adc=512;  // 25C / 77F
17E8:  MOVF   x1C,W
17EA:  MULLW  24
17EC:  MOVF   FF3,W
17EE:  CLRF   x1E
17F0:  MOVWF  x1D
17F2:  MOVLW  20
17F4:  ADDWF  x1D,W
17F6:  MOVWF  01
17F8:  MOVLW  00
17FA:  ADDWFC x1E,W
17FC:  MOVWF  03
17FE:  MOVF   01,W
1800:  ADDLW  1B
1802:  MOVWF  FE9
1804:  MOVLW  00
1806:  ADDWFC 03,W
1808:  MOVWF  FEA
180A:  MOVLW  02
180C:  MOVWF  FEC
180E:  MOVF   FED,F
1810:  CLRF   FEF
.................... 		config.ch[i].htd_reconnect_delay=4;
1812:  MOVF   x1C,W
1814:  MULLW  24
1816:  MOVF   FF3,W
1818:  CLRF   x1E
181A:  MOVWF  x1D
181C:  MOVLW  22
181E:  ADDWF  x1D,W
1820:  MOVWF  01
1822:  MOVLW  00
1824:  ADDWFC x1E,W
1826:  MOVWF  03
1828:  MOVF   01,W
182A:  ADDLW  1B
182C:  MOVWF  FE9
182E:  MOVLW  00
1830:  ADDWFC 03,W
1832:  MOVWF  FEA
1834:  CLRF   FEC
1836:  MOVF   FED,F
1838:  MOVLW  04
183A:  MOVWF  FEF
183C:  INCF   x1C,F
183E:  BRA    158C
.................... 	}
.................... 	
.................... 
.................... 	/* set the two channels differently */
.................... 	/* LVD 1 bus (modem, etc) @ Fairway */
.................... 	config.ch[0].lvd_disconnect_adc=602; /* 23.5 */
1840:  MOVLW  02
1842:  MOVWF  20
1844:  MOVLW  5A
1846:  MOVWF  1F
.................... 	config.ch[0].lvd_reconnect_adc=627;  /* 24.5 */
1848:  MOVLW  02
184A:  MOVWF  24
184C:  MOVLW  73
184E:  MOVWF  23
....................  	/* LVD 2 bus (CODAR) @ Fairway */
.................... 	config.ch[1].lvd_disconnect_adc=614; /* 24.0 */
1850:  MOVLW  02
1852:  MOVWF  44
1854:  MOVLW  66
1856:  MOVWF  43
.................... 	config.ch[1].lvd_reconnect_adc=640;  /* 25.0 */		
1858:  MOVLW  02
185A:  MOVWF  48
185C:  MOVLW  80
185E:  MOVWF  47
.................... 
.................... 	/* write them so next time we use from EEPROM */
.................... 	write_param_file();
1860:  MOVLB  0
1862:  RCALL  1534
1864:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void read_param_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config)); 
1866:  MOVLB  1
1868:  MOVLW  1B
186A:  MOVWF  x1C
186C:  CLRF   x1F
186E:  MOVLW  02
1870:  MOVWF  x1E
1872:  CLRF   x21
1874:  MOVFF  11C,120
1878:  CLRF   x23
187A:  MOVLW  48
187C:  MOVWF  x22
187E:  MOVLB  0
1880:  BRA    1414
1882:  MOVFF  01,11B
.................... 		
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) {
1886:  MOVFF  FF2,11C
188A:  BCF    FF2.7
188C:  CLRF   FA9
188E:  BCF    FA6.6
1890:  BCF    FA6.7
1892:  BSF    FA6.0
1894:  MOVF   FA8,W
1896:  MOVLB  1
1898:  BTFSC  x1C.7
189A:  BSF    FF2.7
189C:  SUBWF  x1B,W
189E:  BZ    18A6
.................... 		write_default_param_file();
18A0:  MOVLB  0
18A2:  RCALL  1580
18A4:  MOVLB  1
.................... 	}
18A6:  MOVLB  0
18A8:  GOTO   2E5A (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... #include "i2c_handler_dcswc_module_latching_contactor.c"
.................... #include "registers_dcswc_module_latching_contactor.h"
.................... 
.................... /* first two or three registers will give enough information for telemetry */
.................... /* 10 bit input voltage ADC averaged value */
.................... #define I2C_REG_VOLTAGE_INPUT_AVG             0  
.................... /* two 8 bit channel states (A is MSB / B is LSB) */
.................... #define I2C_REG_STATE_CONTACTORS              1 
.................... /* 10 bit NTC thermistor ADC averaged value */
.................... #define I2C_REG_TEMPERATURE_BOARD_AVG         2
.................... 
....................   
.................... /* channel 0 / A */
.................... /* command can only come from I2C interface */
.................... #define I2C_REG_CH0_COMMAND_ON                3 /* R/W seconds */
.................... #define I2C_REG_CH0_COMMAND_ON_HOLD           4
.................... 
.................... #define I2C_REG_CH0_COMMAND_OFF               5 /* R/W seconds */
.................... #define I2C_REG_CH0_COMMAND_OFF_HOLD          6
.................... 
.................... /* low voltage disconnect */
.................... #define I2C_REG_CH0_LVD_DISCONNECT            7  /* R seconds */
.................... #define I2C_REG_CH0_LVD_RECONNECT             8 
.................... 
.................... /* high voltage disconnect */
.................... #define I2C_REG_CH0_HVD_DISCONNECT            9 /* R seconds */
.................... #define I2C_REG_CH0_HVD_RECONNECT             10
.................... 
.................... /* low temperature disconnect */
.................... #define I2C_REG_CH0_LTD_DISCONNECT            11  /* R seconds */
.................... #define I2C_REG_CH0_LTD_RECONNECT             12
.................... 
.................... /* high temperature disconnect */
.................... #define I2C_REG_CH0_HTD_DISCONNECT            13 /* R seconds */
.................... #define I2C_REG_CH0_HTD_RECONNECT             14
.................... 
.................... /* reserved for future, unimplemented */
.................... #define I2C_REG_CH0_FUT_DISCONNECT            15 /* R seconds */
.................... #define I2C_REG_CH0_FUT_RECONNECT             16
.................... 
.................... /* channel 1 / B */
.................... /* command can only come from I2C interface */
.................... #define I2C_REG_CH1_COMMAND_ON                17 /* R/W seconds */
.................... #define I2C_REG_CH1_COMMAND_ON_HOLD           18
.................... 
.................... #define I2C_REG_CH1_COMMAND_OFF               19 /* R/W seconds */
.................... #define I2C_REG_CH1_COMMAND_OFF_HOLD          20
.................... 
.................... /* low voltage disconnect */
.................... #define I2C_REG_CH1_LVD_DISCONNECT            21 /* R seconds */
.................... #define I2C_REG_CH1_LVD_RECONNECT             22 
.................... 
.................... /* high voltage disconnect */
.................... #define I2C_REG_CH1_HVD_DISCONNECT            23 /* R seconds */
.................... #define I2C_REG_CH1_HVD_RECONNECT             24
.................... 
.................... /* low temperature disconnect */
.................... #define I2C_REG_CH1_LTD_DISCONNECT            25  /* R seconds */
.................... #define I2C_REG_CH1_LTD_RECONNECT             26
.................... 
.................... /* high temperature disconnect */
.................... #define I2C_REG_CH1_HTD_DISCONNECT            27 /* R seconds */
.................... #define I2C_REG_CH1_HTD_RECONNECT             28
.................... 
.................... /* reserved for future, unimplemented */
.................... #define I2C_REG_CH1_FUT_DISCONNECT            29 /* R seconds */
.................... #define I2C_REG_CH1_FUT_RECONNECT             30
.................... 
.................... /* meta */
.................... #define I2C_REG_SEQUENCE_NUMBER               31 /* R */
.................... #define I2C_REG_TIME_INTERVAL_MILLISECONDS    32
.................... #define I2C_REG_TIME_UPTIME_MINUTES           33
.................... #define I2C_REG_DEFAULT_PARAMS_WRITTEN        34
.................... 
.................... /* channel configuration */
.................... /* channel 0 / A */
.................... #define I2C_REG_CH0_COMMAND_ON_HOLD_INITIAL   64
.................... 
.................... #define I2C_REG_CH0_COMMAND_OFF_HOLD_INITIAL  65
.................... 
.................... #define I2C_REG_CH0_LVD_DISCONNECT_ADC        66
.................... #define I2C_REG_CH0_LVD_DISCONNECT_DELAY      67
.................... #define I2C_REG_CH0_LVD_RECONNECT_ADC         68
.................... #define I2C_REG_CH0_LVD_RECONNECT_DELAY       69
.................... 
.................... #define I2C_REG_CH0_HVD_DISCONNECT_ADC        70
.................... #define I2C_REG_CH0_HVD_DISCONNECT_DELAY      71
.................... #define I2C_REG_CH0_HVD_RECONNECT_ADC         72
.................... #define I2C_REG_CH0_HVD_RECONNECT_DELAY       73
.................... 
.................... #define I2C_REG_CH0_LTD_DISCONNECT_ADC        74
.................... #define I2C_REG_CH0_LTD_DISCONNECT_DELAY      75
.................... #define I2C_REG_CH0_LTD_RECONNECT_ADC         76
.................... #define I2C_REG_CH0_LTD_RECONNECT_DELAY       77
.................... 
.................... #define I2C_REG_CH0_HTD_DISCONNECT_ADC        78
.................... #define I2C_REG_CH0_HTD_DISCONNECT_DELAY      79
.................... #define I2C_REG_CH0_HTD_RECONNECT_ADC         80
.................... #define I2C_REG_CH0_HTD_RECONNECT_DELAY       81
.................... 
.................... #define I2C_REG_CH0_FUT_DISCONNECT_VALUE      82
.................... #define I2C_REG_CH0_FUT_DISCONNECT_DELAY      83
.................... #define I2C_REG_CH0_FUT_RECONNECT_VALUE       84
.................... #define I2C_REG_CH0_FUT_RECONNECT_DELAY       85
.................... 
.................... /* channel 1 / B */
.................... #define I2C_REG_CH1_COMMAND_ON_HOLD_INITIAL   86
.................... 
.................... #define I2C_REG_CH1_COMMAND_OFF_HOLD_INITIAL  87
.................... 
.................... #define I2C_REG_CH1_LVD_DISCONNECT_ADC        88
.................... #define I2C_REG_CH1_LVD_DISCONNECT_DELAY      89
.................... #define I2C_REG_CH1_LVD_RECONNECT_ADC         90
.................... #define I2C_REG_CH1_LVD_RECONNECT_DELAY       91
.................... 
.................... #define I2C_REG_CH1_HVD_DISCONNECT_ADC        92
.................... #define I2C_REG_CH1_HVD_DISCONNECT_DELAY      93
.................... #define I2C_REG_CH1_HVD_RECONNECT_ADC         94
.................... #define I2C_REG_CH1_HVD_RECONNECT_DELAY       95
.................... 
.................... #define I2C_REG_CH1_LTD_DISCONNECT_ADC        96
.................... #define I2C_REG_CH1_LTD_DISCONNECT_DELAY      97
.................... #define I2C_REG_CH1_LTD_RECONNECT_ADC         98
.................... #define I2C_REG_CH1_LTD_RECONNECT_DELAY       99
.................... 
.................... #define I2C_REG_CH1_HTD_DISCONNECT_ADC        100
.................... #define I2C_REG_CH1_HTD_DISCONNECT_DELAY      101
.................... #define I2C_REG_CH1_HTD_RECONNECT_ADC         102
.................... #define I2C_REG_CH1_HTD_RECONNECT_DELAY       103
.................... 
.................... #define I2C_REG_CH1_FUT_DISCONNECT_VALUE      104
.................... #define I2C_REG_CH1_FUT_DISCONNECT_DELAY      105
.................... #define I2C_REG_CH1_FUT_RECONNECT_VALUE       106
.................... #define I2C_REG_CH1_FUT_RECONNECT_DELAY       107
.................... 
.................... 
.................... /* configuration */
.................... #define I2C_REG_CONFIG_HARDWARE_MODEL              128 /* R */
.................... #define I2C_REG_CONFIG_HARDWARE_VERSION            129
.................... #define I2C_REG_CONFIG_SOFTWARE_MODEL              130
.................... #define I2C_REG_CONFIG_SOFTWARE_VERSION            131
.................... #define I2C_REG_CONFIG_SOFTWARE_YEAR               132
.................... #define I2C_REG_CONFIG_SOFTWARE_MONTH              133
.................... #define I2C_REG_CONFIG_SOFTWARE_DAY                134
.................... 
.................... #define I2C_REG_CONFIG_PARAM_WRITE                 135 /* R / W */
.................... 
.................... 
.................... 
.................... void write_i2c(int8 addr, int16 value) {
.................... 	int8 c;
.................... 
.................... 	/* c is the channel we are accessing based on register range */
.................... 	if ( addr >= I2C_REG_CH1_COMMAND_ON && addr <= I2C_REG_CH1_FUT_RECONNECT ) {
*
00DC:  MOVLB  1
00DE:  MOVF   x2F,W
00E0:  SUBLW  10
00E2:  BC    00F4
00E4:  MOVF   x2F,W
00E6:  SUBLW  1E
00E8:  BNC   00F4
.................... 		/* channel 1 status region */
.................... 		c=1;
00EA:  MOVLW  01
00EC:  MOVWF  x32
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON - I2C_REG_CH0_COMMAND_ON);
00EE:  MOVLW  0E
00F0:  SUBWF  x2F,F
.................... 	} else if ( addr >= I2C_REG_CH1_COMMAND_ON_HOLD && addr <= I2C_REG_CH1_FUT_RECONNECT_DELAY ) {
00F2:  BRA    010C
00F4:  MOVF   x2F,W
00F6:  SUBLW  11
00F8:  BC    010A
00FA:  MOVF   x2F,W
00FC:  SUBLW  6B
00FE:  BNC   010A
.................... 		/* channel 1 configuration region */
.................... 		c=1;
0100:  MOVLW  01
0102:  MOVWF  x32
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON_HOLD - I2C_REG_CH0_COMMAND_ON_HOLD );
0104:  MOVLW  0E
0106:  SUBWF  x2F,F
.................... 	} else {
0108:  BRA    010C
.................... 		c=0;
010A:  CLRF   x32
.................... 	}
.................... 
.................... 	switch ( addr ) {
010C:  MOVF   x2F,W
010E:  XORLW  03
0110:  MOVLB  0
0112:  BZ    018A
0114:  XORLW  07
0116:  BZ    01BA
0118:  XORLW  01
011A:  BZ    01EA
011C:  XORLW  03
011E:  BTFSC  FD8.2
0120:  BRA    021A
0122:  XORLW  44
0124:  BTFSC  FD8.2
0126:  BRA    024A
0128:  XORLW  01
012A:  BTFSC  FD8.2
012C:  BRA    027A
012E:  XORLW  07
0130:  BTFSC  FD8.2
0132:  BRA    02AA
0134:  XORLW  01
0136:  BTFSC  FD8.2
0138:  BRA    02DA
013A:  XORLW  03
013C:  BTFSC  FD8.2
013E:  BRA    030A
0140:  XORLW  01
0142:  BTFSC  FD8.2
0144:  BRA    033A
0146:  XORLW  0F
0148:  BTFSC  FD8.2
014A:  BRA    036A
014C:  XORLW  01
014E:  BTFSC  FD8.2
0150:  BRA    039A
0152:  XORLW  03
0154:  BTFSC  FD8.2
0156:  BRA    03CA
0158:  XORLW  01
015A:  BTFSC  FD8.2
015C:  BRA    03FA
015E:  XORLW  07
0160:  BTFSC  FD8.2
0162:  BRA    042A
0164:  XORLW  01
0166:  BTFSC  FD8.2
0168:  BRA    045A
016A:  XORLW  03
016C:  BTFSC  FD8.2
016E:  BRA    048A
0170:  XORLW  01
0172:  BTFSC  FD8.2
0174:  BRA    04BA
0176:  XORLW  1F
0178:  BTFSC  FD8.2
017A:  BRA    04EA
017C:  XORLW  01
017E:  BTFSC  FD8.2
0180:  BRA    051A
0182:  XORLW  D6
0184:  BTFSC  FD8.2
0186:  BRA    054A
0188:  BRA    0590
.................... 		case I2C_REG_CH0_COMMAND_ON:
.................... 			channel[c].command_on_seconds=value;
018A:  MOVLB  1
018C:  MOVF   x32,W
018E:  MULLW  19
0190:  MOVF   FF3,W
0192:  CLRF   x34
0194:  MOVWF  x33
0196:  MOVLW  01
0198:  ADDWF  x33,W
019A:  MOVWF  01
019C:  MOVLW  00
019E:  ADDWFC x34,W
01A0:  MOVWF  03
01A2:  MOVF   01,W
01A4:  ADDLW  DA
01A6:  MOVWF  FE9
01A8:  MOVLW  00
01AA:  ADDWFC 03,W
01AC:  MOVWF  FEA
01AE:  MOVFF  131,FEC
01B2:  MOVF   FED,F
01B4:  MOVFF  130,FEF
01B8:  MOVLB  0
.................... 		case I2C_REG_CH0_COMMAND_ON_HOLD:
.................... 			channel[c].command_on_hold_seconds=value;
01BA:  MOVLB  1
01BC:  MOVF   x32,W
01BE:  MULLW  19
01C0:  MOVF   FF3,W
01C2:  CLRF   x34
01C4:  MOVWF  x33
01C6:  MOVLW  03
01C8:  ADDWF  x33,W
01CA:  MOVWF  01
01CC:  MOVLW  00
01CE:  ADDWFC x34,W
01D0:  MOVWF  03
01D2:  MOVF   01,W
01D4:  ADDLW  DA
01D6:  MOVWF  FE9
01D8:  MOVLW  00
01DA:  ADDWFC 03,W
01DC:  MOVWF  FEA
01DE:  MOVFF  131,FEC
01E2:  MOVF   FED,F
01E4:  MOVFF  130,FEF
01E8:  MOVLB  0
.................... 	
.................... 		case I2C_REG_CH0_COMMAND_OFF:
.................... 			channel[c].command_off_seconds=value;
01EA:  MOVLB  1
01EC:  MOVF   x32,W
01EE:  MULLW  19
01F0:  MOVF   FF3,W
01F2:  CLRF   x34
01F4:  MOVWF  x33
01F6:  MOVLW  05
01F8:  ADDWF  x33,W
01FA:  MOVWF  01
01FC:  MOVLW  00
01FE:  ADDWFC x34,W
0200:  MOVWF  03
0202:  MOVF   01,W
0204:  ADDLW  DA
0206:  MOVWF  FE9
0208:  MOVLW  00
020A:  ADDWFC 03,W
020C:  MOVWF  FEA
020E:  MOVFF  131,FEC
0212:  MOVF   FED,F
0214:  MOVFF  130,FEF
0218:  MOVLB  0
.................... 		case I2C_REG_CH0_COMMAND_OFF_HOLD:
.................... 			channel[c].command_off_hold_seconds=value;
021A:  MOVLB  1
021C:  MOVF   x32,W
021E:  MULLW  19
0220:  MOVF   FF3,W
0222:  CLRF   x34
0224:  MOVWF  x33
0226:  MOVLW  07
0228:  ADDWF  x33,W
022A:  MOVWF  01
022C:  MOVLW  00
022E:  ADDWFC x34,W
0230:  MOVWF  03
0232:  MOVF   01,W
0234:  ADDLW  DA
0236:  MOVWF  FE9
0238:  MOVLW  00
023A:  ADDWFC 03,W
023C:  MOVWF  FEA
023E:  MOVFF  131,FEC
0242:  MOVF   FED,F
0244:  MOVFF  130,FEF
0248:  MOVLB  0
.................... 
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_ADC:
.................... 			config.ch[c].lvd_disconnect_adc=value;
024A:  MOVLB  1
024C:  MOVF   x32,W
024E:  MULLW  24
0250:  MOVF   FF3,W
0252:  CLRF   x34
0254:  MOVWF  x33
0256:  MOVLW  04
0258:  ADDWF  x33,W
025A:  MOVWF  01
025C:  MOVLW  00
025E:  ADDWFC x34,W
0260:  MOVWF  03
0262:  MOVF   01,W
0264:  ADDLW  1B
0266:  MOVWF  FE9
0268:  MOVLW  00
026A:  ADDWFC 03,W
026C:  MOVWF  FEA
026E:  MOVFF  131,FEC
0272:  MOVF   FED,F
0274:  MOVFF  130,FEF
0278:  MOVLB  0
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_DELAY:
.................... 			config.ch[c].lvd_disconnect_delay=value;
027A:  MOVLB  1
027C:  MOVF   x32,W
027E:  MULLW  24
0280:  MOVF   FF3,W
0282:  CLRF   x34
0284:  MOVWF  x33
0286:  MOVLW  06
0288:  ADDWF  x33,W
028A:  MOVWF  01
028C:  MOVLW  00
028E:  ADDWFC x34,W
0290:  MOVWF  03
0292:  MOVF   01,W
0294:  ADDLW  1B
0296:  MOVWF  FE9
0298:  MOVLW  00
029A:  ADDWFC 03,W
029C:  MOVWF  FEA
029E:  MOVFF  131,FEC
02A2:  MOVF   FED,F
02A4:  MOVFF  130,FEF
02A8:  MOVLB  0
.................... 		case I2C_REG_CH0_LVD_RECONNECT_ADC:
.................... 			config.ch[c].lvd_reconnect_adc=value;
02AA:  MOVLB  1
02AC:  MOVF   x32,W
02AE:  MULLW  24
02B0:  MOVF   FF3,W
02B2:  CLRF   x34
02B4:  MOVWF  x33
02B6:  MOVLW  08
02B8:  ADDWF  x33,W
02BA:  MOVWF  01
02BC:  MOVLW  00
02BE:  ADDWFC x34,W
02C0:  MOVWF  03
02C2:  MOVF   01,W
02C4:  ADDLW  1B
02C6:  MOVWF  FE9
02C8:  MOVLW  00
02CA:  ADDWFC 03,W
02CC:  MOVWF  FEA
02CE:  MOVFF  131,FEC
02D2:  MOVF   FED,F
02D4:  MOVFF  130,FEF
02D8:  MOVLB  0
.................... 		case I2C_REG_CH0_LVD_RECONNECT_DELAY:
.................... 			config.ch[c].lvd_reconnect_delay=value;
02DA:  MOVLB  1
02DC:  MOVF   x32,W
02DE:  MULLW  24
02E0:  MOVF   FF3,W
02E2:  CLRF   x34
02E4:  MOVWF  x33
02E6:  MOVLW  0A
02E8:  ADDWF  x33,W
02EA:  MOVWF  01
02EC:  MOVLW  00
02EE:  ADDWFC x34,W
02F0:  MOVWF  03
02F2:  MOVF   01,W
02F4:  ADDLW  1B
02F6:  MOVWF  FE9
02F8:  MOVLW  00
02FA:  ADDWFC 03,W
02FC:  MOVWF  FEA
02FE:  MOVFF  131,FEC
0302:  MOVF   FED,F
0304:  MOVFF  130,FEF
0308:  MOVLB  0
.................... 
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_ADC:
.................... 			config.ch[c].hvd_disconnect_adc=value;
030A:  MOVLB  1
030C:  MOVF   x32,W
030E:  MULLW  24
0310:  MOVF   FF3,W
0312:  CLRF   x34
0314:  MOVWF  x33
0316:  MOVLW  0C
0318:  ADDWF  x33,W
031A:  MOVWF  01
031C:  MOVLW  00
031E:  ADDWFC x34,W
0320:  MOVWF  03
0322:  MOVF   01,W
0324:  ADDLW  1B
0326:  MOVWF  FE9
0328:  MOVLW  00
032A:  ADDWFC 03,W
032C:  MOVWF  FEA
032E:  MOVFF  131,FEC
0332:  MOVF   FED,F
0334:  MOVFF  130,FEF
0338:  MOVLB  0
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_DELAY:
.................... 			config.ch[c].hvd_disconnect_delay=value;
033A:  MOVLB  1
033C:  MOVF   x32,W
033E:  MULLW  24
0340:  MOVF   FF3,W
0342:  CLRF   x34
0344:  MOVWF  x33
0346:  MOVLW  0E
0348:  ADDWF  x33,W
034A:  MOVWF  01
034C:  MOVLW  00
034E:  ADDWFC x34,W
0350:  MOVWF  03
0352:  MOVF   01,W
0354:  ADDLW  1B
0356:  MOVWF  FE9
0358:  MOVLW  00
035A:  ADDWFC 03,W
035C:  MOVWF  FEA
035E:  MOVFF  131,FEC
0362:  MOVF   FED,F
0364:  MOVFF  130,FEF
0368:  MOVLB  0
.................... 		case I2C_REG_CH0_HVD_RECONNECT_ADC:
.................... 			config.ch[c].hvd_reconnect_adc=value;
036A:  MOVLB  1
036C:  MOVF   x32,W
036E:  MULLW  24
0370:  MOVF   FF3,W
0372:  CLRF   x34
0374:  MOVWF  x33
0376:  MOVLW  10
0378:  ADDWF  x33,W
037A:  MOVWF  01
037C:  MOVLW  00
037E:  ADDWFC x34,W
0380:  MOVWF  03
0382:  MOVF   01,W
0384:  ADDLW  1B
0386:  MOVWF  FE9
0388:  MOVLW  00
038A:  ADDWFC 03,W
038C:  MOVWF  FEA
038E:  MOVFF  131,FEC
0392:  MOVF   FED,F
0394:  MOVFF  130,FEF
0398:  MOVLB  0
.................... 		case I2C_REG_CH0_HVD_RECONNECT_DELAY:
.................... 			config.ch[c].hvd_reconnect_delay=value;
039A:  MOVLB  1
039C:  MOVF   x32,W
039E:  MULLW  24
03A0:  MOVF   FF3,W
03A2:  CLRF   x34
03A4:  MOVWF  x33
03A6:  MOVLW  12
03A8:  ADDWF  x33,W
03AA:  MOVWF  01
03AC:  MOVLW  00
03AE:  ADDWFC x34,W
03B0:  MOVWF  03
03B2:  MOVF   01,W
03B4:  ADDLW  1B
03B6:  MOVWF  FE9
03B8:  MOVLW  00
03BA:  ADDWFC 03,W
03BC:  MOVWF  FEA
03BE:  MOVFF  131,FEC
03C2:  MOVF   FED,F
03C4:  MOVFF  130,FEF
03C8:  MOVLB  0
.................... 
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_ADC:
.................... 			config.ch[c].ltd_disconnect_adc=value;
03CA:  MOVLB  1
03CC:  MOVF   x32,W
03CE:  MULLW  24
03D0:  MOVF   FF3,W
03D2:  CLRF   x34
03D4:  MOVWF  x33
03D6:  MOVLW  14
03D8:  ADDWF  x33,W
03DA:  MOVWF  01
03DC:  MOVLW  00
03DE:  ADDWFC x34,W
03E0:  MOVWF  03
03E2:  MOVF   01,W
03E4:  ADDLW  1B
03E6:  MOVWF  FE9
03E8:  MOVLW  00
03EA:  ADDWFC 03,W
03EC:  MOVWF  FEA
03EE:  MOVFF  131,FEC
03F2:  MOVF   FED,F
03F4:  MOVFF  130,FEF
03F8:  MOVLB  0
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_DELAY:
.................... 			config.ch[c].ltd_disconnect_delay=value;
03FA:  MOVLB  1
03FC:  MOVF   x32,W
03FE:  MULLW  24
0400:  MOVF   FF3,W
0402:  CLRF   x34
0404:  MOVWF  x33
0406:  MOVLW  16
0408:  ADDWF  x33,W
040A:  MOVWF  01
040C:  MOVLW  00
040E:  ADDWFC x34,W
0410:  MOVWF  03
0412:  MOVF   01,W
0414:  ADDLW  1B
0416:  MOVWF  FE9
0418:  MOVLW  00
041A:  ADDWFC 03,W
041C:  MOVWF  FEA
041E:  MOVFF  131,FEC
0422:  MOVF   FED,F
0424:  MOVFF  130,FEF
0428:  MOVLB  0
.................... 		case I2C_REG_CH0_LTD_RECONNECT_ADC:
.................... 			config.ch[c].ltd_reconnect_adc=value;
042A:  MOVLB  1
042C:  MOVF   x32,W
042E:  MULLW  24
0430:  MOVF   FF3,W
0432:  CLRF   x34
0434:  MOVWF  x33
0436:  MOVLW  18
0438:  ADDWF  x33,W
043A:  MOVWF  01
043C:  MOVLW  00
043E:  ADDWFC x34,W
0440:  MOVWF  03
0442:  MOVF   01,W
0444:  ADDLW  1B
0446:  MOVWF  FE9
0448:  MOVLW  00
044A:  ADDWFC 03,W
044C:  MOVWF  FEA
044E:  MOVFF  131,FEC
0452:  MOVF   FED,F
0454:  MOVFF  130,FEF
0458:  MOVLB  0
.................... 		case I2C_REG_CH0_LTD_RECONNECT_DELAY:
.................... 			config.ch[c].ltd_reconnect_delay=value;
045A:  MOVLB  1
045C:  MOVF   x32,W
045E:  MULLW  24
0460:  MOVF   FF3,W
0462:  CLRF   x34
0464:  MOVWF  x33
0466:  MOVLW  1A
0468:  ADDWF  x33,W
046A:  MOVWF  01
046C:  MOVLW  00
046E:  ADDWFC x34,W
0470:  MOVWF  03
0472:  MOVF   01,W
0474:  ADDLW  1B
0476:  MOVWF  FE9
0478:  MOVLW  00
047A:  ADDWFC 03,W
047C:  MOVWF  FEA
047E:  MOVFF  131,FEC
0482:  MOVF   FED,F
0484:  MOVFF  130,FEF
0488:  MOVLB  0
.................... 
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_ADC:
.................... 			config.ch[c].htd_disconnect_adc=value;
048A:  MOVLB  1
048C:  MOVF   x32,W
048E:  MULLW  24
0490:  MOVF   FF3,W
0492:  CLRF   x34
0494:  MOVWF  x33
0496:  MOVLW  1C
0498:  ADDWF  x33,W
049A:  MOVWF  01
049C:  MOVLW  00
049E:  ADDWFC x34,W
04A0:  MOVWF  03
04A2:  MOVF   01,W
04A4:  ADDLW  1B
04A6:  MOVWF  FE9
04A8:  MOVLW  00
04AA:  ADDWFC 03,W
04AC:  MOVWF  FEA
04AE:  MOVFF  131,FEC
04B2:  MOVF   FED,F
04B4:  MOVFF  130,FEF
04B8:  MOVLB  0
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_DELAY:
.................... 			config.ch[c].htd_disconnect_delay=value;
04BA:  MOVLB  1
04BC:  MOVF   x32,W
04BE:  MULLW  24
04C0:  MOVF   FF3,W
04C2:  CLRF   x34
04C4:  MOVWF  x33
04C6:  MOVLW  1E
04C8:  ADDWF  x33,W
04CA:  MOVWF  01
04CC:  MOVLW  00
04CE:  ADDWFC x34,W
04D0:  MOVWF  03
04D2:  MOVF   01,W
04D4:  ADDLW  1B
04D6:  MOVWF  FE9
04D8:  MOVLW  00
04DA:  ADDWFC 03,W
04DC:  MOVWF  FEA
04DE:  MOVFF  131,FEC
04E2:  MOVF   FED,F
04E4:  MOVFF  130,FEF
04E8:  MOVLB  0
.................... 		case I2C_REG_CH0_HTD_RECONNECT_ADC:
.................... 			config.ch[c].htd_reconnect_adc=value;
04EA:  MOVLB  1
04EC:  MOVF   x32,W
04EE:  MULLW  24
04F0:  MOVF   FF3,W
04F2:  CLRF   x34
04F4:  MOVWF  x33
04F6:  MOVLW  20
04F8:  ADDWF  x33,W
04FA:  MOVWF  01
04FC:  MOVLW  00
04FE:  ADDWFC x34,W
0500:  MOVWF  03
0502:  MOVF   01,W
0504:  ADDLW  1B
0506:  MOVWF  FE9
0508:  MOVLW  00
050A:  ADDWFC 03,W
050C:  MOVWF  FEA
050E:  MOVFF  131,FEC
0512:  MOVF   FED,F
0514:  MOVFF  130,FEF
0518:  MOVLB  0
.................... 		case I2C_REG_CH0_HTD_RECONNECT_DELAY:
.................... 			config.ch[c].htd_reconnect_delay=value;
051A:  MOVLB  1
051C:  MOVF   x32,W
051E:  MULLW  24
0520:  MOVF   FF3,W
0522:  CLRF   x34
0524:  MOVWF  x33
0526:  MOVLW  22
0528:  ADDWF  x33,W
052A:  MOVWF  01
052C:  MOVLW  00
052E:  ADDWFC x34,W
0530:  MOVWF  03
0532:  MOVF   01,W
0534:  ADDLW  1B
0536:  MOVWF  FE9
0538:  MOVLW  00
053A:  ADDWFC 03,W
053C:  MOVWF  FEA
053E:  MOVFF  131,FEC
0542:  MOVF   FED,F
0544:  MOVFF  130,FEF
0548:  MOVLB  0
.................... 
.................... 		/* don't need to implement FUT ... there is nowhere for it to go anyhow */
.................... 
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			if ( 1 == value ) {
054A:  MOVLB  1
054C:  DECFSZ x30,W
054E:  BRA    055C
0550:  MOVF   x31,F
0552:  BNZ   055C
.................... 				timers.now_write_config=1;
0554:  MOVLB  0
0556:  BSF    xCF.3
.................... 			} else if ( 2 == value ) {
0558:  BRA    0590
055A:  MOVLB  1
055C:  MOVF   x30,W
055E:  SUBLW  02
0560:  BNZ   056E
0562:  MOVF   x31,F
0564:  BNZ   056E
.................... 				timers.now_reset_config=1;
0566:  MOVLB  0
0568:  BSF    xCF.4
.................... 			} else if ( 1802 == value ) {
056A:  BRA    0590
056C:  MOVLB  1
056E:  MOVF   x30,W
0570:  SUBLW  0A
0572:  BNZ   0584
0574:  MOVF   x31,W
0576:  SUBLW  07
0578:  BNZ   0584
.................... 				current.factory_unlocked =1;
057A:  MOVLW  01
057C:  MOVLB  0
057E:  MOVWF  xCA
.................... 			} else if ( 65535 == value ) {
0580:  BRA    0590
0582:  MOVLB  1
0584:  INCFSZ x30,W
0586:  BRA    058E
0588:  INCFSZ x31,W
058A:  BRA    058E
.................... 				reset_cpu();
058C:  RESET
058E:  MOVLB  0
.................... 			}
.................... 			break;
.................... 		default:
.................... 			/* do nothing */
.................... 	}
0590:  GOTO   0F14 (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... int16 map_i2c(int8 addr) {
.................... 	int8 c;
.................... 
.................... 	/* c is the channel we are accessing based on register range */
.................... 	if ( addr >= I2C_REG_CH1_COMMAND_ON && addr <= I2C_REG_CH1_FUT_RECONNECT ) {
*
0614:  MOVLB  1
0616:  MOVF   x2D,W
0618:  SUBLW  10
061A:  BC    062C
061C:  MOVF   x2D,W
061E:  SUBLW  1E
0620:  BNC   062C
.................... 		/* channel 1 status region */
.................... 		c=1;
0622:  MOVLW  01
0624:  MOVWF  x2E
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON - I2C_REG_CH0_COMMAND_ON);
0626:  MOVLW  0E
0628:  SUBWF  x2D,F
.................... 	} else if ( addr >= I2C_REG_CH1_COMMAND_ON_HOLD && addr <= I2C_REG_CH1_FUT_RECONNECT_DELAY ) {
062A:  BRA    0644
062C:  MOVF   x2D,W
062E:  SUBLW  11
0630:  BC    0642
0632:  MOVF   x2D,W
0634:  SUBLW  6B
0636:  BNC   0642
.................... 		/* channel 1 configuration region */
.................... 		c=1;
0638:  MOVLW  01
063A:  MOVWF  x2E
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON_HOLD - I2C_REG_CH0_COMMAND_ON_HOLD );
063C:  MOVLW  0E
063E:  SUBWF  x2D,F
.................... 	} else {
0640:  BRA    0644
.................... 		c=0;
0642:  CLRF   x2E
.................... 	}
.................... 
.................... 	switch ( addr ) {
0644:  MOVF   x2D,W
0646:  XORLW  00
0648:  MOVLB  0
064A:  BTFSC  FD8.2
064C:  BRA    077C
064E:  XORLW  01
0650:  BTFSC  FD8.2
0652:  BRA    0788
0654:  XORLW  03
0656:  BTFSC  FD8.2
0658:  BRA    0796
065A:  XORLW  01
065C:  BTFSC  FD8.2
065E:  BRA    07A4
0660:  XORLW  07
0662:  BTFSC  FD8.2
0664:  BRA    07DA
0666:  XORLW  01
0668:  BTFSC  FD8.2
066A:  BRA    0810
066C:  XORLW  03
066E:  BTFSC  FD8.2
0670:  BRA    0846
0672:  XORLW  01
0674:  BTFSC  FD8.2
0676:  BRA    087C
0678:  XORLW  0F
067A:  BTFSC  FD8.2
067C:  BRA    08B2
067E:  XORLW  01
0680:  BTFSC  FD8.2
0682:  BRA    08E8
0684:  XORLW  03
0686:  BTFSC  FD8.2
0688:  BRA    091E
068A:  XORLW  01
068C:  BTFSC  FD8.2
068E:  BRA    0954
0690:  XORLW  07
0692:  BTFSC  FD8.2
0694:  BRA    098A
0696:  XORLW  01
0698:  BTFSC  FD8.2
069A:  BRA    09C0
069C:  XORLW  03
069E:  BTFSC  FD8.2
06A0:  BRA    09F6
06A2:  XORLW  01
06A4:  BTFSC  FD8.2
06A6:  BRA    0A2C
06A8:  XORLW  1F
06AA:  BTFSC  FD8.2
06AC:  BRA    0A2C
06AE:  XORLW  0F
06B0:  BTFSC  FD8.2
06B2:  BRA    0A34
06B4:  XORLW  3F
06B6:  BTFSC  FD8.2
06B8:  BRA    0A3E
06BA:  XORLW  01
06BC:  BTFSC  FD8.2
06BE:  BRA    0A48
06C0:  XORLW  03
06C2:  BTFSC  FD8.2
06C4:  BRA    0A52
06C6:  XORLW  62
06C8:  BTFSC  FD8.2
06CA:  BRA    0A5A
06CC:  XORLW  01
06CE:  BTFSC  FD8.2
06D0:  BRA    0A84
06D2:  XORLW  03
06D4:  BTFSC  FD8.2
06D6:  BRA    0ABA
06D8:  XORLW  01
06DA:  BTFSC  FD8.2
06DC:  BRA    0AF0
06DE:  XORLW  07
06E0:  BTFSC  FD8.2
06E2:  BRA    0B26
06E4:  XORLW  01
06E6:  BTFSC  FD8.2
06E8:  BRA    0B5C
06EA:  XORLW  03
06EC:  BTFSC  FD8.2
06EE:  BRA    0B92
06F0:  XORLW  01
06F2:  BTFSC  FD8.2
06F4:  BRA    0BC8
06F6:  XORLW  0F
06F8:  BTFSC  FD8.2
06FA:  BRA    0BFE
06FC:  XORLW  01
06FE:  BTFSC  FD8.2
0700:  BRA    0C34
0702:  XORLW  03
0704:  BTFSC  FD8.2
0706:  BRA    0C6A
0708:  XORLW  01
070A:  BTFSC  FD8.2
070C:  BRA    0CA0
070E:  XORLW  07
0710:  BTFSC  FD8.2
0712:  BRA    0CD6
0714:  XORLW  01
0716:  BTFSC  FD8.2
0718:  BRA    0D0C
071A:  XORLW  03
071C:  BTFSC  FD8.2
071E:  BRA    0D42
0720:  XORLW  01
0722:  BTFSC  FD8.2
0724:  BRA    0D78
0726:  XORLW  1F
0728:  BTFSC  FD8.2
072A:  BRA    0DAE
072C:  XORLW  01
072E:  BTFSC  FD8.2
0730:  BRA    0DE4
0732:  XORLW  03
0734:  BTFSC  FD8.2
0736:  BRA    0E1A
0738:  XORLW  01
073A:  BTFSC  FD8.2
073C:  BRA    0E1A
073E:  XORLW  07
0740:  BTFSC  FD8.2
0742:  BRA    0E1A
0744:  XORLW  01
0746:  BTFSC  FD8.2
0748:  BRA    0E1A
074A:  XORLW  D5
074C:  BTFSC  FD8.2
074E:  BRA    0E22
0750:  XORLW  01
0752:  BTFSC  FD8.2
0754:  BRA    0E2C
0756:  XORLW  03
0758:  BTFSC  FD8.2
075A:  BRA    0E36
075C:  XORLW  01
075E:  BTFSC  FD8.2
0760:  BRA    0E40
0762:  XORLW  07
0764:  BTFSC  FD8.2
0766:  BRA    0E4A
0768:  XORLW  01
076A:  BTFSC  FD8.2
076C:  BRA    0E52
076E:  XORLW  03
0770:  BTFSC  FD8.2
0772:  BRA    0E5A
0774:  XORLW  01
0776:  BTFSC  FD8.2
0778:  BRA    0E62
077A:  BRA    0E6A
.................... 		/* not channel based */
.................... 		case I2C_REG_VOLTAGE_INPUT_AVG: 
.................... 			return (int16) adc_get(0);
077C:  MOVLB  1
077E:  CLRF   x2F
0780:  MOVLB  0
0782:  RCALL  0594
0784:  MOVF   02,W
0786:  BRA    0E70
.................... 		case I2C_REG_STATE_CONTACTORS:
.................... 			return (int16) make16(channel[0].state,channel[1].state);
0788:  MOVFF  DA,03
078C:  MOVFF  F3,01
0790:  MOVFF  DA,02
0794:  BRA    0E70
.................... 		case I2C_REG_TEMPERATURE_BOARD_AVG: 
.................... 			return (int16) adc_get(1);
0796:  MOVLW  01
0798:  MOVLB  1
079A:  MOVWF  x2F
079C:  MOVLB  0
079E:  RCALL  0594
07A0:  MOVF   02,W
07A2:  BRA    0E70
.................... 
.................... 		/* status based on channel value c */
.................... 		case I2C_REG_CH0_COMMAND_ON :
.................... 			return (int16) channel[c].command_on_seconds;
07A4:  MOVLB  1
07A6:  MOVF   x2E,W
07A8:  MULLW  19
07AA:  MOVF   FF3,W
07AC:  CLRF   x30
07AE:  MOVWF  x2F
07B0:  MOVLW  01
07B2:  ADDWF  x2F,W
07B4:  MOVWF  01
07B6:  MOVLW  00
07B8:  ADDWFC x30,W
07BA:  MOVWF  03
07BC:  MOVF   01,W
07BE:  ADDLW  DA
07C0:  MOVWF  FE9
07C2:  MOVLW  00
07C4:  ADDWFC 03,W
07C6:  MOVWF  FEA
07C8:  MOVFF  FEC,03
07CC:  MOVF   FED,F
07CE:  MOVFF  FEF,01
07D2:  MOVFF  03,02
07D6:  MOVLB  0
07D8:  BRA    0E70
.................... 		case I2C_REG_CH0_COMMAND_ON_HOLD:
.................... 			return (int16) channel[c].command_on_hold_seconds;
07DA:  MOVLB  1
07DC:  MOVF   x2E,W
07DE:  MULLW  19
07E0:  MOVF   FF3,W
07E2:  CLRF   x30
07E4:  MOVWF  x2F
07E6:  MOVLW  03
07E8:  ADDWF  x2F,W
07EA:  MOVWF  01
07EC:  MOVLW  00
07EE:  ADDWFC x30,W
07F0:  MOVWF  03
07F2:  MOVF   01,W
07F4:  ADDLW  DA
07F6:  MOVWF  FE9
07F8:  MOVLW  00
07FA:  ADDWFC 03,W
07FC:  MOVWF  FEA
07FE:  MOVFF  FEC,03
0802:  MOVF   FED,F
0804:  MOVFF  FEF,01
0808:  MOVFF  03,02
080C:  MOVLB  0
080E:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_COMMAND_OFF:
.................... 			return (int16) channel[c].command_off_seconds;
0810:  MOVLB  1
0812:  MOVF   x2E,W
0814:  MULLW  19
0816:  MOVF   FF3,W
0818:  CLRF   x30
081A:  MOVWF  x2F
081C:  MOVLW  05
081E:  ADDWF  x2F,W
0820:  MOVWF  01
0822:  MOVLW  00
0824:  ADDWFC x30,W
0826:  MOVWF  03
0828:  MOVF   01,W
082A:  ADDLW  DA
082C:  MOVWF  FE9
082E:  MOVLW  00
0830:  ADDWFC 03,W
0832:  MOVWF  FEA
0834:  MOVFF  FEC,03
0838:  MOVF   FED,F
083A:  MOVFF  FEF,01
083E:  MOVFF  03,02
0842:  MOVLB  0
0844:  BRA    0E70
.................... 		case I2C_REG_CH0_COMMAND_OFF_HOLD:
.................... 			return (int16) channel[c].command_off_hold_seconds;
0846:  MOVLB  1
0848:  MOVF   x2E,W
084A:  MULLW  19
084C:  MOVF   FF3,W
084E:  CLRF   x30
0850:  MOVWF  x2F
0852:  MOVLW  07
0854:  ADDWF  x2F,W
0856:  MOVWF  01
0858:  MOVLW  00
085A:  ADDWFC x30,W
085C:  MOVWF  03
085E:  MOVF   01,W
0860:  ADDLW  DA
0862:  MOVWF  FE9
0864:  MOVLW  00
0866:  ADDWFC 03,W
0868:  MOVWF  FEA
086A:  MOVFF  FEC,03
086E:  MOVF   FED,F
0870:  MOVFF  FEF,01
0874:  MOVFF  03,02
0878:  MOVLB  0
087A:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_LVD_DISCONNECT:
.................... 			return (int16) channel[c].lvd_disconnect_delay_seconds;
087C:  MOVLB  1
087E:  MOVF   x2E,W
0880:  MULLW  19
0882:  MOVF   FF3,W
0884:  CLRF   x30
0886:  MOVWF  x2F
0888:  MOVLW  09
088A:  ADDWF  x2F,W
088C:  MOVWF  01
088E:  MOVLW  00
0890:  ADDWFC x30,W
0892:  MOVWF  03
0894:  MOVF   01,W
0896:  ADDLW  DA
0898:  MOVWF  FE9
089A:  MOVLW  00
089C:  ADDWFC 03,W
089E:  MOVWF  FEA
08A0:  MOVFF  FEC,03
08A4:  MOVF   FED,F
08A6:  MOVFF  FEF,01
08AA:  MOVFF  03,02
08AE:  MOVLB  0
08B0:  BRA    0E70
.................... 		case I2C_REG_CH0_LVD_RECONNECT:
.................... 			return (int16) channel[c].lvd_reconnect_delay_seconds;
08B2:  MOVLB  1
08B4:  MOVF   x2E,W
08B6:  MULLW  19
08B8:  MOVF   FF3,W
08BA:  CLRF   x30
08BC:  MOVWF  x2F
08BE:  MOVLW  0B
08C0:  ADDWF  x2F,W
08C2:  MOVWF  01
08C4:  MOVLW  00
08C6:  ADDWFC x30,W
08C8:  MOVWF  03
08CA:  MOVF   01,W
08CC:  ADDLW  DA
08CE:  MOVWF  FE9
08D0:  MOVLW  00
08D2:  ADDWFC 03,W
08D4:  MOVWF  FEA
08D6:  MOVFF  FEC,03
08DA:  MOVF   FED,F
08DC:  MOVFF  FEF,01
08E0:  MOVFF  03,02
08E4:  MOVLB  0
08E6:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_HVD_DISCONNECT:
.................... 			return (int16) channel[c].hvd_disconnect_delay_seconds;
08E8:  MOVLB  1
08EA:  MOVF   x2E,W
08EC:  MULLW  19
08EE:  MOVF   FF3,W
08F0:  CLRF   x30
08F2:  MOVWF  x2F
08F4:  MOVLW  0D
08F6:  ADDWF  x2F,W
08F8:  MOVWF  01
08FA:  MOVLW  00
08FC:  ADDWFC x30,W
08FE:  MOVWF  03
0900:  MOVF   01,W
0902:  ADDLW  DA
0904:  MOVWF  FE9
0906:  MOVLW  00
0908:  ADDWFC 03,W
090A:  MOVWF  FEA
090C:  MOVFF  FEC,03
0910:  MOVF   FED,F
0912:  MOVFF  FEF,01
0916:  MOVFF  03,02
091A:  MOVLB  0
091C:  BRA    0E70
.................... 		case I2C_REG_CH0_HVD_RECONNECT:
.................... 			return (int16) channel[c].hvd_reconnect_delay_seconds;
091E:  MOVLB  1
0920:  MOVF   x2E,W
0922:  MULLW  19
0924:  MOVF   FF3,W
0926:  CLRF   x30
0928:  MOVWF  x2F
092A:  MOVLW  0F
092C:  ADDWF  x2F,W
092E:  MOVWF  01
0930:  MOVLW  00
0932:  ADDWFC x30,W
0934:  MOVWF  03
0936:  MOVF   01,W
0938:  ADDLW  DA
093A:  MOVWF  FE9
093C:  MOVLW  00
093E:  ADDWFC 03,W
0940:  MOVWF  FEA
0942:  MOVFF  FEC,03
0946:  MOVF   FED,F
0948:  MOVFF  FEF,01
094C:  MOVFF  03,02
0950:  MOVLB  0
0952:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_LTD_DISCONNECT:
.................... 			return (int16) channel[c].ltd_disconnect_delay_seconds;
0954:  MOVLB  1
0956:  MOVF   x2E,W
0958:  MULLW  19
095A:  MOVF   FF3,W
095C:  CLRF   x30
095E:  MOVWF  x2F
0960:  MOVLW  11
0962:  ADDWF  x2F,W
0964:  MOVWF  01
0966:  MOVLW  00
0968:  ADDWFC x30,W
096A:  MOVWF  03
096C:  MOVF   01,W
096E:  ADDLW  DA
0970:  MOVWF  FE9
0972:  MOVLW  00
0974:  ADDWFC 03,W
0976:  MOVWF  FEA
0978:  MOVFF  FEC,03
097C:  MOVF   FED,F
097E:  MOVFF  FEF,01
0982:  MOVFF  03,02
0986:  MOVLB  0
0988:  BRA    0E70
.................... 		case I2C_REG_CH0_LTD_RECONNECT:
.................... 			return (int16) channel[c].ltd_reconnect_delay_seconds;
098A:  MOVLB  1
098C:  MOVF   x2E,W
098E:  MULLW  19
0990:  MOVF   FF3,W
0992:  CLRF   x30
0994:  MOVWF  x2F
0996:  MOVLW  13
0998:  ADDWF  x2F,W
099A:  MOVWF  01
099C:  MOVLW  00
099E:  ADDWFC x30,W
09A0:  MOVWF  03
09A2:  MOVF   01,W
09A4:  ADDLW  DA
09A6:  MOVWF  FE9
09A8:  MOVLW  00
09AA:  ADDWFC 03,W
09AC:  MOVWF  FEA
09AE:  MOVFF  FEC,03
09B2:  MOVF   FED,F
09B4:  MOVFF  FEF,01
09B8:  MOVFF  03,02
09BC:  MOVLB  0
09BE:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_HTD_DISCONNECT:
.................... 			return (int16) channel[c].htd_disconnect_delay_seconds;
09C0:  MOVLB  1
09C2:  MOVF   x2E,W
09C4:  MULLW  19
09C6:  MOVF   FF3,W
09C8:  CLRF   x30
09CA:  MOVWF  x2F
09CC:  MOVLW  15
09CE:  ADDWF  x2F,W
09D0:  MOVWF  01
09D2:  MOVLW  00
09D4:  ADDWFC x30,W
09D6:  MOVWF  03
09D8:  MOVF   01,W
09DA:  ADDLW  DA
09DC:  MOVWF  FE9
09DE:  MOVLW  00
09E0:  ADDWFC 03,W
09E2:  MOVWF  FEA
09E4:  MOVFF  FEC,03
09E8:  MOVF   FED,F
09EA:  MOVFF  FEF,01
09EE:  MOVFF  03,02
09F2:  MOVLB  0
09F4:  BRA    0E70
.................... 		case I2C_REG_CH0_HTD_RECONNECT:
.................... 			return (int16) channel[c].htd_reconnect_delay_seconds;
09F6:  MOVLB  1
09F8:  MOVF   x2E,W
09FA:  MULLW  19
09FC:  MOVF   FF3,W
09FE:  CLRF   x30
0A00:  MOVWF  x2F
0A02:  MOVLW  17
0A04:  ADDWF  x2F,W
0A06:  MOVWF  01
0A08:  MOVLW  00
0A0A:  ADDWFC x30,W
0A0C:  MOVWF  03
0A0E:  MOVF   01,W
0A10:  ADDLW  DA
0A12:  MOVWF  FE9
0A14:  MOVLW  00
0A16:  ADDWFC 03,W
0A18:  MOVWF  FEA
0A1A:  MOVFF  FEC,03
0A1E:  MOVF   FED,F
0A20:  MOVFF  FEF,01
0A24:  MOVFF  03,02
0A28:  MOVLB  0
0A2A:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_FUT_DISCONNECT:
.................... 		case I2C_REG_CH0_FUT_RECONNECT:
.................... 			return (int16) 0xffff; /* not yet implemented */
0A2C:  MOVLW  FF
0A2E:  MOVWF  01
0A30:  MOVWF  02
0A32:  BRA    0E70
.................... 
.................... 
.................... 		/* non-channel based meta */
.................... 		case I2C_REG_SEQUENCE_NUMBER:
.................... 			return (int16) current.sequence_number;
0A34:  MOVFF  C4,01
0A38:  MOVFF  C5,02
0A3C:  BRA    0E70
.................... 		case I2C_REG_TIME_INTERVAL_MILLISECONDS:
.................... 			return (int16) current.interval_milliseconds;
0A3E:  MOVFF  C8,01
0A42:  MOVFF  C9,02
0A46:  BRA    0E70
.................... 		case I2C_REG_TIME_UPTIME_MINUTES:
.................... 			return (int16) current.uptime_minutes;
0A48:  MOVFF  C6,01
0A4C:  MOVFF  C7,02
0A50:  BRA    0E70
.................... 		case I2C_REG_DEFAULT_PARAMS_WRITTEN:
.................... 			return (int16) current.default_params_written;
0A52:  MOVFF  CE,01
0A56:  CLRF   02
0A58:  BRA    0E70
.................... 
.................... 		/* channel based configuration */
.................... 		case I2C_REG_CH0_COMMAND_ON_HOLD_INITIAL:
.................... 			return (int16) config.ch[c].command_on_hold_time;
0A5A:  MOVLB  1
0A5C:  MOVF   x2E,W
0A5E:  MULLW  24
0A60:  MOVF   FF3,W
0A62:  CLRF   x30
0A64:  MOVWF  x2F
0A66:  MOVLW  1B
0A68:  ADDWF  x2F,W
0A6A:  MOVWF  FE9
0A6C:  MOVLW  00
0A6E:  ADDWFC x30,W
0A70:  MOVWF  FEA
0A72:  MOVFF  FEC,03
0A76:  MOVF   FED,F
0A78:  MOVFF  FEF,01
0A7C:  MOVFF  03,02
0A80:  MOVLB  0
0A82:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_COMMAND_OFF_HOLD_INITIAL:
.................... 			return (int16) config.ch[c].command_off_hold_time;
0A84:  MOVLB  1
0A86:  MOVF   x2E,W
0A88:  MULLW  24
0A8A:  MOVF   FF3,W
0A8C:  CLRF   x30
0A8E:  MOVWF  x2F
0A90:  MOVLW  02
0A92:  ADDWF  x2F,W
0A94:  MOVWF  01
0A96:  MOVLW  00
0A98:  ADDWFC x30,W
0A9A:  MOVWF  03
0A9C:  MOVF   01,W
0A9E:  ADDLW  1B
0AA0:  MOVWF  FE9
0AA2:  MOVLW  00
0AA4:  ADDWFC 03,W
0AA6:  MOVWF  FEA
0AA8:  MOVFF  FEC,03
0AAC:  MOVF   FED,F
0AAE:  MOVFF  FEF,01
0AB2:  MOVFF  03,02
0AB6:  MOVLB  0
0AB8:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].lvd_disconnect_adc;
0ABA:  MOVLB  1
0ABC:  MOVF   x2E,W
0ABE:  MULLW  24
0AC0:  MOVF   FF3,W
0AC2:  CLRF   x30
0AC4:  MOVWF  x2F
0AC6:  MOVLW  04
0AC8:  ADDWF  x2F,W
0ACA:  MOVWF  01
0ACC:  MOVLW  00
0ACE:  ADDWFC x30,W
0AD0:  MOVWF  03
0AD2:  MOVF   01,W
0AD4:  ADDLW  1B
0AD6:  MOVWF  FE9
0AD8:  MOVLW  00
0ADA:  ADDWFC 03,W
0ADC:  MOVWF  FEA
0ADE:  MOVFF  FEC,03
0AE2:  MOVF   FED,F
0AE4:  MOVFF  FEF,01
0AE8:  MOVFF  03,02
0AEC:  MOVLB  0
0AEE:  BRA    0E70
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].lvd_disconnect_delay;
0AF0:  MOVLB  1
0AF2:  MOVF   x2E,W
0AF4:  MULLW  24
0AF6:  MOVF   FF3,W
0AF8:  CLRF   x30
0AFA:  MOVWF  x2F
0AFC:  MOVLW  06
0AFE:  ADDWF  x2F,W
0B00:  MOVWF  01
0B02:  MOVLW  00
0B04:  ADDWFC x30,W
0B06:  MOVWF  03
0B08:  MOVF   01,W
0B0A:  ADDLW  1B
0B0C:  MOVWF  FE9
0B0E:  MOVLW  00
0B10:  ADDWFC 03,W
0B12:  MOVWF  FEA
0B14:  MOVFF  FEC,03
0B18:  MOVF   FED,F
0B1A:  MOVFF  FEF,01
0B1E:  MOVFF  03,02
0B22:  MOVLB  0
0B24:  BRA    0E70
.................... 		case I2C_REG_CH0_LVD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].lvd_reconnect_adc;
0B26:  MOVLB  1
0B28:  MOVF   x2E,W
0B2A:  MULLW  24
0B2C:  MOVF   FF3,W
0B2E:  CLRF   x30
0B30:  MOVWF  x2F
0B32:  MOVLW  08
0B34:  ADDWF  x2F,W
0B36:  MOVWF  01
0B38:  MOVLW  00
0B3A:  ADDWFC x30,W
0B3C:  MOVWF  03
0B3E:  MOVF   01,W
0B40:  ADDLW  1B
0B42:  MOVWF  FE9
0B44:  MOVLW  00
0B46:  ADDWFC 03,W
0B48:  MOVWF  FEA
0B4A:  MOVFF  FEC,03
0B4E:  MOVF   FED,F
0B50:  MOVFF  FEF,01
0B54:  MOVFF  03,02
0B58:  MOVLB  0
0B5A:  BRA    0E70
.................... 		case I2C_REG_CH0_LVD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].lvd_reconnect_delay;
0B5C:  MOVLB  1
0B5E:  MOVF   x2E,W
0B60:  MULLW  24
0B62:  MOVF   FF3,W
0B64:  CLRF   x30
0B66:  MOVWF  x2F
0B68:  MOVLW  0A
0B6A:  ADDWF  x2F,W
0B6C:  MOVWF  01
0B6E:  MOVLW  00
0B70:  ADDWFC x30,W
0B72:  MOVWF  03
0B74:  MOVF   01,W
0B76:  ADDLW  1B
0B78:  MOVWF  FE9
0B7A:  MOVLW  00
0B7C:  ADDWFC 03,W
0B7E:  MOVWF  FEA
0B80:  MOVFF  FEC,03
0B84:  MOVF   FED,F
0B86:  MOVFF  FEF,01
0B8A:  MOVFF  03,02
0B8E:  MOVLB  0
0B90:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].hvd_disconnect_adc;
0B92:  MOVLB  1
0B94:  MOVF   x2E,W
0B96:  MULLW  24
0B98:  MOVF   FF3,W
0B9A:  CLRF   x30
0B9C:  MOVWF  x2F
0B9E:  MOVLW  0C
0BA0:  ADDWF  x2F,W
0BA2:  MOVWF  01
0BA4:  MOVLW  00
0BA6:  ADDWFC x30,W
0BA8:  MOVWF  03
0BAA:  MOVF   01,W
0BAC:  ADDLW  1B
0BAE:  MOVWF  FE9
0BB0:  MOVLW  00
0BB2:  ADDWFC 03,W
0BB4:  MOVWF  FEA
0BB6:  MOVFF  FEC,03
0BBA:  MOVF   FED,F
0BBC:  MOVFF  FEF,01
0BC0:  MOVFF  03,02
0BC4:  MOVLB  0
0BC6:  BRA    0E70
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].hvd_disconnect_delay;
0BC8:  MOVLB  1
0BCA:  MOVF   x2E,W
0BCC:  MULLW  24
0BCE:  MOVF   FF3,W
0BD0:  CLRF   x30
0BD2:  MOVWF  x2F
0BD4:  MOVLW  0E
0BD6:  ADDWF  x2F,W
0BD8:  MOVWF  01
0BDA:  MOVLW  00
0BDC:  ADDWFC x30,W
0BDE:  MOVWF  03
0BE0:  MOVF   01,W
0BE2:  ADDLW  1B
0BE4:  MOVWF  FE9
0BE6:  MOVLW  00
0BE8:  ADDWFC 03,W
0BEA:  MOVWF  FEA
0BEC:  MOVFF  FEC,03
0BF0:  MOVF   FED,F
0BF2:  MOVFF  FEF,01
0BF6:  MOVFF  03,02
0BFA:  MOVLB  0
0BFC:  BRA    0E70
.................... 		case I2C_REG_CH0_HVD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].hvd_reconnect_adc;
0BFE:  MOVLB  1
0C00:  MOVF   x2E,W
0C02:  MULLW  24
0C04:  MOVF   FF3,W
0C06:  CLRF   x30
0C08:  MOVWF  x2F
0C0A:  MOVLW  10
0C0C:  ADDWF  x2F,W
0C0E:  MOVWF  01
0C10:  MOVLW  00
0C12:  ADDWFC x30,W
0C14:  MOVWF  03
0C16:  MOVF   01,W
0C18:  ADDLW  1B
0C1A:  MOVWF  FE9
0C1C:  MOVLW  00
0C1E:  ADDWFC 03,W
0C20:  MOVWF  FEA
0C22:  MOVFF  FEC,03
0C26:  MOVF   FED,F
0C28:  MOVFF  FEF,01
0C2C:  MOVFF  03,02
0C30:  MOVLB  0
0C32:  BRA    0E70
.................... 		case I2C_REG_CH0_HVD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].hvd_reconnect_delay;
0C34:  MOVLB  1
0C36:  MOVF   x2E,W
0C38:  MULLW  24
0C3A:  MOVF   FF3,W
0C3C:  CLRF   x30
0C3E:  MOVWF  x2F
0C40:  MOVLW  12
0C42:  ADDWF  x2F,W
0C44:  MOVWF  01
0C46:  MOVLW  00
0C48:  ADDWFC x30,W
0C4A:  MOVWF  03
0C4C:  MOVF   01,W
0C4E:  ADDLW  1B
0C50:  MOVWF  FE9
0C52:  MOVLW  00
0C54:  ADDWFC 03,W
0C56:  MOVWF  FEA
0C58:  MOVFF  FEC,03
0C5C:  MOVF   FED,F
0C5E:  MOVFF  FEF,01
0C62:  MOVFF  03,02
0C66:  MOVLB  0
0C68:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_disconnect_adc;
0C6A:  MOVLB  1
0C6C:  MOVF   x2E,W
0C6E:  MULLW  24
0C70:  MOVF   FF3,W
0C72:  CLRF   x30
0C74:  MOVWF  x2F
0C76:  MOVLW  14
0C78:  ADDWF  x2F,W
0C7A:  MOVWF  01
0C7C:  MOVLW  00
0C7E:  ADDWFC x30,W
0C80:  MOVWF  03
0C82:  MOVF   01,W
0C84:  ADDLW  1B
0C86:  MOVWF  FE9
0C88:  MOVLW  00
0C8A:  ADDWFC 03,W
0C8C:  MOVWF  FEA
0C8E:  MOVFF  FEC,03
0C92:  MOVF   FED,F
0C94:  MOVFF  FEF,01
0C98:  MOVFF  03,02
0C9C:  MOVLB  0
0C9E:  BRA    0E70
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_disconnect_delay;
0CA0:  MOVLB  1
0CA2:  MOVF   x2E,W
0CA4:  MULLW  24
0CA6:  MOVF   FF3,W
0CA8:  CLRF   x30
0CAA:  MOVWF  x2F
0CAC:  MOVLW  16
0CAE:  ADDWF  x2F,W
0CB0:  MOVWF  01
0CB2:  MOVLW  00
0CB4:  ADDWFC x30,W
0CB6:  MOVWF  03
0CB8:  MOVF   01,W
0CBA:  ADDLW  1B
0CBC:  MOVWF  FE9
0CBE:  MOVLW  00
0CC0:  ADDWFC 03,W
0CC2:  MOVWF  FEA
0CC4:  MOVFF  FEC,03
0CC8:  MOVF   FED,F
0CCA:  MOVFF  FEF,01
0CCE:  MOVFF  03,02
0CD2:  MOVLB  0
0CD4:  BRA    0E70
.................... 		case I2C_REG_CH0_LTD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_reconnect_adc;
0CD6:  MOVLB  1
0CD8:  MOVF   x2E,W
0CDA:  MULLW  24
0CDC:  MOVF   FF3,W
0CDE:  CLRF   x30
0CE0:  MOVWF  x2F
0CE2:  MOVLW  18
0CE4:  ADDWF  x2F,W
0CE6:  MOVWF  01
0CE8:  MOVLW  00
0CEA:  ADDWFC x30,W
0CEC:  MOVWF  03
0CEE:  MOVF   01,W
0CF0:  ADDLW  1B
0CF2:  MOVWF  FE9
0CF4:  MOVLW  00
0CF6:  ADDWFC 03,W
0CF8:  MOVWF  FEA
0CFA:  MOVFF  FEC,03
0CFE:  MOVF   FED,F
0D00:  MOVFF  FEF,01
0D04:  MOVFF  03,02
0D08:  MOVLB  0
0D0A:  BRA    0E70
.................... 		case I2C_REG_CH0_LTD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_reconnect_delay;
0D0C:  MOVLB  1
0D0E:  MOVF   x2E,W
0D10:  MULLW  24
0D12:  MOVF   FF3,W
0D14:  CLRF   x30
0D16:  MOVWF  x2F
0D18:  MOVLW  1A
0D1A:  ADDWF  x2F,W
0D1C:  MOVWF  01
0D1E:  MOVLW  00
0D20:  ADDWFC x30,W
0D22:  MOVWF  03
0D24:  MOVF   01,W
0D26:  ADDLW  1B
0D28:  MOVWF  FE9
0D2A:  MOVLW  00
0D2C:  ADDWFC 03,W
0D2E:  MOVWF  FEA
0D30:  MOVFF  FEC,03
0D34:  MOVF   FED,F
0D36:  MOVFF  FEF,01
0D3A:  MOVFF  03,02
0D3E:  MOVLB  0
0D40:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_disconnect_adc;
0D42:  MOVLB  1
0D44:  MOVF   x2E,W
0D46:  MULLW  24
0D48:  MOVF   FF3,W
0D4A:  CLRF   x30
0D4C:  MOVWF  x2F
0D4E:  MOVLW  14
0D50:  ADDWF  x2F,W
0D52:  MOVWF  01
0D54:  MOVLW  00
0D56:  ADDWFC x30,W
0D58:  MOVWF  03
0D5A:  MOVF   01,W
0D5C:  ADDLW  1B
0D5E:  MOVWF  FE9
0D60:  MOVLW  00
0D62:  ADDWFC 03,W
0D64:  MOVWF  FEA
0D66:  MOVFF  FEC,03
0D6A:  MOVF   FED,F
0D6C:  MOVFF  FEF,01
0D70:  MOVFF  03,02
0D74:  MOVLB  0
0D76:  BRA    0E70
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_disconnect_delay;
0D78:  MOVLB  1
0D7A:  MOVF   x2E,W
0D7C:  MULLW  24
0D7E:  MOVF   FF3,W
0D80:  CLRF   x30
0D82:  MOVWF  x2F
0D84:  MOVLW  16
0D86:  ADDWF  x2F,W
0D88:  MOVWF  01
0D8A:  MOVLW  00
0D8C:  ADDWFC x30,W
0D8E:  MOVWF  03
0D90:  MOVF   01,W
0D92:  ADDLW  1B
0D94:  MOVWF  FE9
0D96:  MOVLW  00
0D98:  ADDWFC 03,W
0D9A:  MOVWF  FEA
0D9C:  MOVFF  FEC,03
0DA0:  MOVF   FED,F
0DA2:  MOVFF  FEF,01
0DA6:  MOVFF  03,02
0DAA:  MOVLB  0
0DAC:  BRA    0E70
.................... 		case I2C_REG_CH0_HTD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_reconnect_adc;
0DAE:  MOVLB  1
0DB0:  MOVF   x2E,W
0DB2:  MULLW  24
0DB4:  MOVF   FF3,W
0DB6:  CLRF   x30
0DB8:  MOVWF  x2F
0DBA:  MOVLW  18
0DBC:  ADDWF  x2F,W
0DBE:  MOVWF  01
0DC0:  MOVLW  00
0DC2:  ADDWFC x30,W
0DC4:  MOVWF  03
0DC6:  MOVF   01,W
0DC8:  ADDLW  1B
0DCA:  MOVWF  FE9
0DCC:  MOVLW  00
0DCE:  ADDWFC 03,W
0DD0:  MOVWF  FEA
0DD2:  MOVFF  FEC,03
0DD6:  MOVF   FED,F
0DD8:  MOVFF  FEF,01
0DDC:  MOVFF  03,02
0DE0:  MOVLB  0
0DE2:  BRA    0E70
.................... 		case I2C_REG_CH0_HTD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_reconnect_delay;	
0DE4:  MOVLB  1
0DE6:  MOVF   x2E,W
0DE8:  MULLW  24
0DEA:  MOVF   FF3,W
0DEC:  CLRF   x30
0DEE:  MOVWF  x2F
0DF0:  MOVLW  1A
0DF2:  ADDWF  x2F,W
0DF4:  MOVWF  01
0DF6:  MOVLW  00
0DF8:  ADDWFC x30,W
0DFA:  MOVWF  03
0DFC:  MOVF   01,W
0DFE:  ADDLW  1B
0E00:  MOVWF  FE9
0E02:  MOVLW  00
0E04:  ADDWFC 03,W
0E06:  MOVWF  FEA
0E08:  MOVFF  FEC,03
0E0C:  MOVF   FED,F
0E0E:  MOVFF  FEF,01
0E12:  MOVFF  03,02
0E16:  MOVLB  0
0E18:  BRA    0E70
.................... 
.................... 		case I2C_REG_CH0_FUT_DISCONNECT_VALUE:
.................... 		case I2C_REG_CH0_FUT_DISCONNECT_DELAY:
.................... 		case I2C_REG_CH0_FUT_RECONNECT_VALUE:
.................... 		case I2C_REG_CH0_FUT_RECONNECT_DELAY:
.................... 			return (int16) 0xffff; /* not yet implemented */
0E1A:  MOVLW  FF
0E1C:  MOVWF  01
0E1E:  MOVWF  02
0E20:  BRA    0E70
.................... 		
.................... 		/* configuration */
.................... 		case I2C_REG_CONFIG_HARDWARE_MODEL: 
.................... 			return (int16) 'D';
0E22:  MOVLW  44
0E24:  MOVWF  01
0E26:  MOVLW  00
0E28:  MOVWF  02
0E2A:  BRA    0E70
.................... 		case I2C_REG_CONFIG_HARDWARE_VERSION: 
.................... 			return (int16) '2';
0E2C:  MOVLW  32
0E2E:  MOVWF  01
0E30:  MOVLW  00
0E32:  MOVWF  02
0E34:  BRA    0E70
.................... 		case I2C_REG_CONFIG_SOFTWARE_MODEL: 
.................... 			return (int16) 'L';
0E36:  MOVLW  4C
0E38:  MOVWF  01
0E3A:  MOVLW  00
0E3C:  MOVWF  02
0E3E:  BRA    0E70
.................... 		case I2C_REG_CONFIG_SOFTWARE_VERSION: 
.................... 			return (int16) '0';
0E40:  MOVLW  30
0E42:  MOVWF  01
0E44:  MOVLW  00
0E46:  MOVWF  02
0E48:  BRA    0E70
.................... 		case I2C_REG_CONFIG_SOFTWARE_YEAR:
.................... 			return (int16) current.compile_year;
0E4A:  MOVFF  CB,01
0E4E:  CLRF   02
0E50:  BRA    0E70
.................... 		case I2C_REG_CONFIG_SOFTWARE_MONTH:
.................... 			return (int16) current.compile_month;
0E52:  MOVFF  CC,01
0E56:  CLRF   02
0E58:  BRA    0E70
.................... 		case I2C_REG_CONFIG_SOFTWARE_DAY:
.................... 			return (int16) current.compile_day;
0E5A:  MOVFF  CD,01
0E5E:  CLRF   02
0E60:  BRA    0E70
.................... 
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			/* 1 if factory unlocked */ 
.................... 			return (int16) current.factory_unlocked; 	
0E62:  MOVFF  CA,01
0E66:  CLRF   02
0E68:  BRA    0E70
.................... 
.................... 		/* we should have range checked, and never gotten here ... or read unimplemented (future) register */
.................... 		default: return (int16) 0xffff;
0E6A:  MOVLW  FF
0E6C:  MOVWF  01
0E6E:  MOVWF  02
.................... 	}
0E70:  GOTO   0F2E (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... 
.................... 
.................... #include "interrupt_dcswc_module_latching_contactor.c"
.................... #int_timer2
.................... void isr_timer2() {
.................... 	timers.now_millisecond=1;
*
00D4:  BSF    xCF.2
.................... }
.................... 
.................... 
.................... 
.................... /* I2C slave interrupt */
00D6:  BCF    F9E.1
00D8:  GOTO   006C
.................... #byte SSPSTAT=GETENV("SFR:SSPSTAT")
.................... #INT_SSP
.................... void ssp_interrupt () {
.................... 	static int8 sstate;
.................... 	int8 state;
.................... 	int8 incoming;
.................... 	static int16 lastValue;
.................... 	static int8 lastMSB;
.................... 
.................... 	static int8 address; 
.................... 
.................... 	/* 
.................... 	our implementation of i2c_isr_state() that won't overflow and switch states
.................... 	but it will quit counting at 127 bytes. 
.................... 	If more bytes are needed, external counting variables can be used or the size of state can be made larger
.................... 	*/
.................... 
.................... 
.................... 	if ( ! bit_test(SSPSTAT,5) ) {
*
0E8A:  BTFSC  FC7.5
0E8C:  BRA    0E9A
.................... 		/* address */
.................... 		sstate=0;
0E8E:  MOVLB  1
0E90:  CLRF   x0C
.................... 
.................... 		if ( bit_test(SSPSTAT,2) ) {
0E92:  BTFSS  FC7.2
0E94:  BRA    0E98
.................... 			/* set high bit if read */
.................... 			bit_set(sstate,7);
0E96:  BSF    x0C.7
.................... 		}
.................... 	} else {
0E98:  MOVLB  0
.................... 		/* data */
.................... 	}
.................... 
.................... 	/* state variable used below is not incremented */
.................... 	state=sstate;
0E9A:  MOVFF  10C,12A
.................... 
.................... 	/* increment the state counter for next pass through unless it will overflow us into another state */
.................... 	if ( sstate != 0x7f && sstate != 0xff) {
0E9E:  MOVLB  1
0EA0:  MOVF   x0C,W
0EA2:  SUBLW  7F
0EA4:  BZ    0EAE
0EA6:  INCFSZ x0C,W
0EA8:  BRA    0EAC
0EAA:  BRA    0EAE
.................... 		sstate++;
0EAC:  INCF   x0C,F
.................... 	}
.................... 
.................... 	
.................... 	/* i2c_isr_state() return an 8 bit int
.................... 		0 - Address match received with R/W bit clear, perform i2c_read( ) to read the I2C address.
.................... 		1-0x7F - Master has written data; i2c_read() will immediately return the data
.................... 		0x80 - Address match received with R/W bit set; perform i2c_read( ) to read the I2C address,
.................... 		and use i2c_write( ) to pre-load the transmit buffer for the next transaction (next I2C read
.................... 		performed by master will read this byte).
.................... 		0x81-0xFF - Transmission completed and acknowledged; respond with i2c_write() to pre-load
.................... 		the transmit buffer for the next transition (the next I2C read performed by master will read this
.................... 		byte).
.................... 		Function:
.................... 		Returns the state of I2C communications in I2C slave mode after an SSP interrupt. The return
.................... 		value increments with each byte received or sent.
.................... 		If 0x00 or 0x80 is returned, an i2C_read( ) needs to be performed to read the I2C address that
.................... 		was sent (it will match the address configured by #USE I2C so this value can be ignored)
.................... 	*/
.................... 
.................... 	if ( state <= 0x80 ) {                      
0EAE:  MOVF   x2A,W
0EB0:  SUBLW  80
0EB2:  BNC   0F16
.................... 		/* I2C master is sending us data */
.................... 		if ( 0x80 == state ) {
0EB4:  MOVF   x2A,W
0EB6:  SUBLW  80
0EB8:  BNZ   0EC0
.................... 			/* i2c_read(2) casues the function to read the SSPBUF without releasing the clock */
.................... 			incoming = i2c_read(STREAM_SLAVE,2);
0EBA:  MOVFF  FC9,12B
.................... 		} else {
0EBE:  BRA    0ECC
.................... 			incoming = i2c_read(STREAM_SLAVE);
0EC0:  BCF    FC6.6
0EC2:  BTFSS  FC7.0
0EC4:  BRA    0EC2
0EC6:  MOVF   FC9,W
0EC8:  BSF    FC6.4
0ECA:  MOVWF  x2B
.................... 		}
.................... 
.................... 		if ( 1 == state ) {             
0ECC:  DECFSZ x2A,W
0ECE:  BRA    0ED8
.................... 			address = incoming<<1;
0ED0:  BCF    FD8.0
0ED2:  RLCF   x2B,W
0ED4:  MOVWF  x10
.................... 		} else if ( state >= 2 && 0x80 != state ) {
0ED6:  BRA    0F16
0ED8:  MOVF   x2A,W
0EDA:  SUBLW  01
0EDC:  BC    0F16
0EDE:  MOVF   x2A,W
0EE0:  SUBLW  80
0EE2:  BZ    0F16
.................... 			/* received byte is data */
.................... 		
.................... 			/* save MSB and we'll process it on next */
.................... 			if ( 2 == state ) {
0EE4:  MOVF   x2A,W
0EE6:  SUBLW  02
0EE8:  BNZ   0EF0
.................... 				lastMSB=incoming;
0EEA:  MOVFF  12B,10F
.................... 			} else if ( 3 == state ) {
0EEE:  BRA    0F16
0EF0:  MOVF   x2A,W
0EF2:  SUBLW  03
0EF4:  BNZ   0F16
.................... 				/* 16 bit value made of previous byte and this byte */
.................... 				write_i2c(address>>1,make16(lastMSB,incoming));
0EF6:  BCF    FD8.0
0EF8:  RRCF   x10,W
0EFA:  MOVWF  x2C
0EFC:  MOVFF  10F,12E
0F00:  MOVFF  12B,12D
0F04:  MOVWF  x2F
0F06:  MOVFF  10F,131
0F0A:  MOVFF  12B,130
0F0E:  MOVLB  0
0F10:  GOTO   00DC
0F14:  MOVLB  1
.................... 
.................... 				/* this write only works for a single register per I2C transaction */
.................... 				/* this is not a BUG, but it would need to be implemented if this functionality is needed */
.................... 			}
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	if ( state >= 0x80 ) {
0F16:  MOVF   x2A,W
0F18:  SUBLW  7F
0F1A:  BC    0F54
.................... 		/* I2C master is requesting data from us */
.................... 
.................... 		if ( ! bit_test(address,0) ) {
0F1C:  BTFSC  x10.0
0F1E:  BRA    0F44
.................... 			/* read 16 bit register (register address half of I2C address) on even address */
.................... 			lastValue=map_i2c(address>>1);
0F20:  BCF    FD8.0
0F22:  RRCF   x10,W
0F24:  MOVWF  x2C
0F26:  MOVWF  x2D
0F28:  MOVLB  0
0F2A:  GOTO   0614
0F2E:  MOVFF  02,10E
0F32:  MOVFF  01,10D
.................... 
.................... 			/* send the MSB */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,1));
0F36:  MOVFF  10E,12C
0F3A:  MOVFF  10E,12D
0F3E:  RCALL  0E74
.................... 		} else {
0F40:  BRA    0F50
0F42:  MOVLB  1
.................... 			/* send LSB of 16 bit register on odd address */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,0));
0F44:  MOVFF  10D,12C
0F48:  MOVFF  10D,12D
0F4C:  MOVLB  0
0F4E:  RCALL  0E74
.................... 		}
.................... 		address++;
0F50:  MOVLB  1
0F52:  INCF   x10,F
.................... 	}
.................... }
.................... 
.................... 
.................... 
.................... 
0F54:  BCF    F9E.3
0F56:  MOVLB  0
0F58:  GOTO   006C
.................... #include "debug_dcswc_module_latching_contactor.c"
.................... void debug_dump(void) {
.................... 
.................... //	int8 i;
.................... 
.................... 	
.................... 	restart_wdt();
*
2CA0:  CLRWDT
2CA2:  CLRF   19
2CA4:  BTFSC  FF2.7
2CA6:  BSF    19.7
2CA8:  BCF    FF2.7
.................... #if 0
.................... 	fprintf(STREAM_FTDI,"# '%s'\r\n",__DATE__);
.................... 	fprintf(STREAM_FTDI,"#  compile_year=%u\r\n",current.compile_year);
.................... 	fprintf(STREAM_FTDI,"# compile_month=%u\r\n",current.compile_month);
.................... 	fprintf(STREAM_FTDI,"#   compile_day=%u\r\n",current.compile_day);
.................... #endif
.................... 	fprintf(STREAM_FTDI,"#       vin adc=%lu\r\n",adc_get(0));
2CAA:  MOVLB  1
2CAC:  CLRF   x2F
2CAE:  MOVLB  0
2CB0:  CALL   0594
2CB4:  BTFSC  19.7
2CB6:  BSF    FF2.7
2CB8:  MOVFF  02,11C
2CBC:  MOVFF  01,11B
2CC0:  MOVLW  5C
2CC2:  MOVWF  FF6
2CC4:  MOVLW  0F
2CC6:  MOVWF  FF7
2CC8:  MOVLW  10
2CCA:  MOVLB  1
2CCC:  MOVWF  x1D
2CCE:  MOVLB  0
2CD0:  CALL   18AC
2CD4:  MOVLW  10
2CD6:  MOVWF  FE9
2CD8:  MOVFF  11C,11E
2CDC:  MOVFF  11B,11D
2CE0:  RCALL  2BA8
2CE2:  MOVLW  0D
2CE4:  BTFSS  F9E.4
2CE6:  BRA    2CE4
2CE8:  MOVWF  FAD
2CEA:  MOVLW  0A
2CEC:  BTFSS  F9E.4
2CEE:  BRA    2CEC
2CF0:  MOVWF  FAD
2CF2:  CLRF   19
2CF4:  BTFSC  FF2.7
2CF6:  BSF    19.7
2CF8:  BCF    FF2.7
.................... 	fprintf(STREAM_FTDI,"#      temp adc=%lu\r\n",adc_get(1));
2CFA:  MOVLW  01
2CFC:  MOVLB  1
2CFE:  MOVWF  x2F
2D00:  MOVLB  0
2D02:  CALL   0594
2D06:  BTFSC  19.7
2D08:  BSF    FF2.7
2D0A:  MOVFF  02,11C
2D0E:  MOVFF  01,11B
2D12:  MOVLW  72
2D14:  MOVWF  FF6
2D16:  MOVLW  0F
2D18:  MOVWF  FF7
2D1A:  MOVLW  10
2D1C:  MOVLB  1
2D1E:  MOVWF  x1D
2D20:  MOVLB  0
2D22:  CALL   18AC
2D26:  MOVLW  10
2D28:  MOVWF  FE9
2D2A:  MOVFF  11C,11E
2D2E:  MOVFF  11B,11D
2D32:  RCALL  2BA8
2D34:  MOVLW  0D
2D36:  BTFSS  F9E.4
2D38:  BRA    2D36
2D3A:  MOVWF  FAD
2D3C:  MOVLW  0A
2D3E:  BTFSS  F9E.4
2D40:  BRA    2D3E
2D42:  MOVWF  FAD
.................... 	fprintf(STREAM_FTDI,"#   ch[0].state=0x%2X\r\n",channel[0].state);
2D44:  MOVLW  88
2D46:  MOVWF  FF6
2D48:  MOVLW  0F
2D4A:  MOVWF  FF7
2D4C:  MOVLW  12
2D4E:  MOVLB  1
2D50:  MOVWF  x1D
2D52:  MOVLB  0
2D54:  CALL   18AC
2D58:  MOVFF  DA,11B
2D5C:  MOVLW  37
2D5E:  MOVLB  1
2D60:  MOVWF  x1C
2D62:  MOVLB  0
2D64:  RCALL  2C5A
2D66:  MOVLW  0D
2D68:  BTFSS  F9E.4
2D6A:  BRA    2D68
2D6C:  MOVWF  FAD
2D6E:  MOVLW  0A
2D70:  BTFSS  F9E.4
2D72:  BRA    2D70
2D74:  MOVWF  FAD
.................... 	fprintf(STREAM_FTDI,"#   ch[1].state=0x%2X\r\n",channel[1].state);
2D76:  MOVLW  A0
2D78:  MOVWF  FF6
2D7A:  MOVLW  0F
2D7C:  MOVWF  FF7
2D7E:  MOVLW  12
2D80:  MOVLB  1
2D82:  MOVWF  x1D
2D84:  MOVLB  0
2D86:  CALL   18AC
2D8A:  MOVFF  F3,11B
2D8E:  MOVLW  37
2D90:  MOVLB  1
2D92:  MOVWF  x1C
2D94:  MOVLB  0
2D96:  RCALL  2C5A
2D98:  MOVLW  0D
2D9A:  BTFSS  F9E.4
2D9C:  BRA    2D9A
2D9E:  MOVWF  FAD
2DA0:  MOVLW  0A
2DA2:  BTFSS  F9E.4
2DA4:  BRA    2DA2
2DA6:  MOVWF  FAD
.................... //	fprintf(STREAM_FTDI,"# read_dip_sw()=%u\r\n",read_dip_switch());
.................... //	fprintf(STREAM_FTDI,"#    dip sw adc=%lu\r\n",adc_get(2));
.................... 
.................... #if 0
2DA8:  GOTO   2F9A (RETURN)
.................... 	for ( i=0 ; i<2 ; i++ ) {
.................... 		restart_wdt();
.................... 		fprintf(STREAM_FTDI,"#-------\r\n");
.................... 		fprintf(STREAM_FTDI,"# config.ch[%u]\r\n",i);
.................... 		fprintf(STREAM_FTDI,"# command_off_hold_time=%lu\r\n",config.ch[i].command_off_hold_time);
.................... 
.................... 		fprintf(STREAM_FTDI,"#    lvd_disconnect_adc=%lu\r\n",config.ch[i].lvd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  lvd_disconnect_delay=%lu\r\n",config.ch[i].lvd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     lvd_reconnect_adc=%lu\r\n",config.ch[i].lvd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   lvd_reconnect_delay=%lu\r\n",config.ch[i].lvd_reconnect_delay);
.................... 
.................... 		fprintf(STREAM_FTDI,"#    hvd_disconnect_adc=%lu\r\n",config.ch[i].hvd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  hvd_disconnect_delay=%lu\r\n",config.ch[i].hvd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     hvd_reconnect_adc=%lu\r\n",config.ch[i].hvd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   hvd_reconnect_delay=%lu\r\n",config.ch[i].hvd_reconnect_delay);
.................... 
.................... 		restart_wdt();
.................... 		fprintf(STREAM_FTDI,"#    ltd_disconnect_adc=%lu\r\n",config.ch[i].ltd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  ltd_disconnect_delay=%lu\r\n",config.ch[i].ltd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     ltd_reconnect_adc=%lu\r\n",config.ch[i].ltd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   ltd_reconnect_delay=%lu\r\n",config.ch[i].ltd_reconnect_delay);
.................... 
.................... 		fprintf(STREAM_FTDI,"#    htd_disconnect_adc=%lu\r\n",config.ch[i].htd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  htd_disconnect_delay=%lu\r\n",config.ch[i].htd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     htd_reconnect_adc=%lu\r\n",config.ch[i].htd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   htd_reconnect_delay=%lu\r\n",config.ch[i].htd_reconnect_delay);
.................... 
.................... 
.................... 		restart_wdt();
.................... 		fprintf(STREAM_FTDI,"#\r\n");
.................... 		fprintf(STREAM_FTDI,"# channel[%u]\r\n",i);
.................... 		fprintf(STREAM_FTDI,"#                        state=0x%02x\r\n",channel[i].state);
.................... 		fprintf(STREAM_FTDI,"#           command_on_seconds=%lu\r\n",channel[i].command_on_seconds);
.................... 		fprintf(STREAM_FTDI,"#      command_on_hold_seconds=%lu\r\n",channel[i].command_on_hold_seconds);
.................... 
.................... 		fprintf(STREAM_FTDI,"#          command_off_seconds=%lu\r\n",channel[i].command_off_seconds);
.................... 		fprintf(STREAM_FTDI,"#     command_off_hold_seconds=%lu\r\n",channel[i].command_off_hold_seconds);
.................... 
.................... 		fprintf(STREAM_FTDI,"# lvd_disconnect_delay_seconds=%lu\r\n",channel[i].lvd_disconnect_delay_seconds);
.................... 		fprintf(STREAM_FTDI,"#  lvd_reconnect_delay_seconds=%lu\r\n",channel[i].lvd_reconnect_delay_seconds);
.................... 
.................... 		fprintf(STREAM_FTDI,"# hvd_disconnect_delay_seconds=%lu\r\n",channel[i].hvd_disconnect_delay_seconds);
.................... 		fprintf(STREAM_FTDI,"#  hvd_reconnect_delay_seconds=%lu\r\n",channel[i].hvd_reconnect_delay_seconds);
.................... 
.................... 		restart_wdt();
.................... 		fprintf(STREAM_FTDI,"# ltd_disconnect_delay_seconds=%lu\r\n",channel[i].ltd_disconnect_delay_seconds);
.................... 		fprintf(STREAM_FTDI,"#  ltd_reconnect_delay_seconds=%lu\r\n",channel[i].ltd_reconnect_delay_seconds);
.................... 
.................... 		fprintf(STREAM_FTDI,"# htd_disconnect_delay_seconds=%lu\r\n",channel[i].htd_disconnect_delay_seconds);
.................... 		fprintf(STREAM_FTDI,"#  htd_reconnect_delay_seconds=%lu\r\n",channel[i].htd_reconnect_delay_seconds);
.................... 	}
.................... 	#endif
.................... }
.................... 
.................... 
.................... 
.................... void contactor_on(int8 c) {
.................... 	/* only turn on contactor if it isn't on or needs a refresh */
.................... 	if ( 1 == timers.contactor[c] ) {
*
2806:  CLRF   03
2808:  MOVLB  1
280A:  MOVF   x1E,W
280C:  ADDLW  D6
280E:  MOVWF  FE9
2810:  MOVLW  00
2812:  ADDWFC 03,W
2814:  MOVWF  FEA
2816:  MOVF   FEF,W
2818:  SUBLW  01
281A:  BNZ   281E
.................... 		return;
281C:  BRA    2858
.................... 	}
.................... 
.................... 	/* we start the powersave count down */
.................... 	timers.contactor_powersave[c]=CONTACTOR_POWER_SAVE_MS;
281E:  CLRF   03
2820:  MOVF   x1E,W
2822:  ADDLW  D8
2824:  MOVWF  FE9
2826:  MOVLW  00
2828:  ADDWFC 03,W
282A:  MOVWF  FEA
282C:  MOVLW  C8
282E:  MOVWF  FEF
.................... 
.................... 	/* control the actual coil depending on what channel we are on */
.................... 	if ( 0==c ) {
2830:  MOVF   x1E,F
2832:  BNZ   283E
.................... 		/* contactor A pins */
.................... 		output_low(BRIDGE_A_A);
2834:  BCF    F94.3
2836:  BCF    F8B.3
.................... 		output_high(BRIDGE_A_B);
2838:  BCF    F94.4
283A:  BSF    F8B.4
.................... 	} else {
283C:  BRA    2846
.................... 		/* contactor B pins */
.................... 		output_low(BRIDGE_B_A);
283E:  BCF    F94.5
2840:  BCF    F8B.5
.................... 		output_high(BRIDGE_B_B);
2842:  BCF    F94.6
2844:  BSF    F8B.6
.................... 	}
.................... 
.................... 	/* save state for next time */
.................... 	timers.contactor[c]=1;
2846:  CLRF   03
2848:  MOVF   x1E,W
284A:  ADDLW  D6
284C:  MOVWF  FE9
284E:  MOVLW  00
2850:  ADDWFC 03,W
2852:  MOVWF  FEA
2854:  MOVLW  01
2856:  MOVWF  FEF
2858:  MOVLB  0
285A:  GOTO   28C0 (RETURN)
.................... }
.................... 
.................... void contactor_off(int8 c) {
.................... 	/* only turn off contactor if it isn't on or needs a refresh */
.................... 	if ( 0 == timers.contactor[c] ) {
*
13C2:  CLRF   03
13C4:  MOVLB  1
13C6:  MOVF   x1E,W
13C8:  ADDLW  D6
13CA:  MOVWF  FE9
13CC:  MOVLW  00
13CE:  ADDWFC 03,W
13D0:  MOVWF  FEA
13D2:  MOVF   FEF,W
13D4:  BNZ   13D8
.................... 		return;
13D6:  BRA    1410
.................... 	}
.................... 
.................... 	/* we start the powersave count down */
.................... 	timers.contactor_powersave[c]=CONTACTOR_POWER_SAVE_MS;
13D8:  CLRF   03
13DA:  MOVF   x1E,W
13DC:  ADDLW  D8
13DE:  MOVWF  FE9
13E0:  MOVLW  00
13E2:  ADDWFC 03,W
13E4:  MOVWF  FEA
13E6:  MOVLW  C8
13E8:  MOVWF  FEF
.................... 
.................... 	/* control the actual coil depending on what channel we are on */
.................... 	if ( 0==c ) {
13EA:  MOVF   x1E,F
13EC:  BNZ   13F8
.................... 		output_high(BRIDGE_A_A);
13EE:  BCF    F94.3
13F0:  BSF    F8B.3
.................... 		output_low(BRIDGE_A_B);
13F2:  BCF    F94.4
13F4:  BCF    F8B.4
.................... 	} else {
13F6:  BRA    1400
.................... 		output_high(BRIDGE_B_A);
13F8:  BCF    F94.5
13FA:  BSF    F8B.5
.................... 		output_low(BRIDGE_B_B);
13FC:  BCF    F94.6
13FE:  BCF    F8B.6
.................... 	}
.................... 
.................... 	/* save state for next time */
.................... 	timers.contactor[c]=0;
1400:  CLRF   03
1402:  MOVF   x1E,W
1404:  ADDLW  D6
1406:  MOVWF  FE9
1408:  MOVLW  00
140A:  ADDWFC 03,W
140C:  MOVWF  FEA
140E:  CLRF   FEF
1410:  MOVLB  0
1412:  RETURN 0
.................... }
.................... 
.................... void contactor_set(int8 c) {
*
285E:  MOVLW  01
2860:  MOVLB  1
2862:  MOVWF  x1D
.................... 	int8 state=1;
.................... 
.................... 	/* if nothing is set in channel[c].state, contactor is on */
.................... 	state=1; 
2864:  MOVWF  x1D
.................... 
.................... 	if ( channel[c].state & CH_STATE_MASK_ON ) {
2866:  MOVF   x1C,W
2868:  MULLW  19
286A:  MOVF   FF3,W
286C:  CLRF   x1F
286E:  MOVWF  x1E
2870:  MOVLW  DA
2872:  ADDWF  x1E,W
2874:  MOVWF  FE9
2876:  MOVLW  00
2878:  ADDWFC x1F,W
287A:  MOVWF  FEA
287C:  MOVF   FEF,W
287E:  ANDLW  03
2880:  BZ    2888
.................... 		/* if override button (switch) is set or we are commanded on, then we will be on */
.................... 		state=1;
2882:  MOVLW  01
2884:  MOVWF  x1D
.................... 	} else if ( channel[c].state & CH_STATE_MASK_OFF ) {
2886:  BRA    28A6
2888:  MOVF   x1C,W
288A:  MULLW  19
288C:  MOVF   FF3,W
288E:  CLRF   x1F
2890:  MOVWF  x1E
2892:  MOVLW  DA
2894:  ADDWF  x1E,W
2896:  MOVWF  FE9
2898:  MOVLW  00
289A:  ADDWFC x1F,W
289C:  MOVWF  FEA
289E:  MOVF   FEF,W
28A0:  ANDLW  7C
28A2:  BZ    28A6
.................... 		/* if one of the disconnect bits is set, we will be off */
.................... 		state=0;
28A4:  CLRF   x1D
.................... 	}
.................... 
.................... 	if ( 0==state ) {
28A6:  MOVF   x1D,F
28A8:  BNZ   28B8
.................... 		contactor_off(c);
28AA:  MOVFF  11C,11E
28AE:  MOVLB  0
28B0:  CALL   13C2
.................... 	} else {
28B4:  BRA    28C0
28B6:  MOVLB  1
.................... 		contactor_on(c);
28B8:  MOVFF  11C,11E
28BC:  MOVLB  0
28BE:  BRA    2806
.................... 	}
28C0:  RETURN 0
.................... 
.................... }
.................... 
.................... void contactor_logic(int8 c) {
.................... 	int16 adc;
.................... 
.................... 	/* override button / switch */
.................... 	if ( (0==c && 0==input(SW_OVERRIDE_A)) || (1==c && 0==input(SW_OVERRIDE_B)) ) {
*
19C2:  MOVLB  1
19C4:  MOVF   x1C,F
19C6:  BNZ   19CE
19C8:  BSF    F92.5
19CA:  BTFSS  F80.5
19CC:  BRA    19D8
19CE:  DECFSZ x1C,W
19D0:  BRA    19F6
19D2:  BSF    F92.4
19D4:  BTFSC  F80.4
19D6:  BRA    19F6
.................... 		bit_set(channel[c].state,CH_STATE_BIT_OVERRIDE);
19D8:  MOVF   x1C,W
19DA:  MULLW  19
19DC:  MOVF   FF3,W
19DE:  CLRF   x20
19E0:  MOVWF  x1F
19E2:  MOVLW  DA
19E4:  ADDWF  x1F,W
19E6:  MOVWF  01
19E8:  MOVLW  00
19EA:  ADDWFC x20,W
19EC:  MOVFF  01,FE9
19F0:  MOVWF  FEA
19F2:  BSF    FEF.0
.................... 	} else {
19F4:  BRA    1A12
.................... 		bit_clear(channel[c].state,CH_STATE_BIT_OVERRIDE);
19F6:  MOVF   x1C,W
19F8:  MULLW  19
19FA:  MOVF   FF3,W
19FC:  CLRF   x20
19FE:  MOVWF  x1F
1A00:  MOVLW  DA
1A02:  ADDWF  x1F,W
1A04:  MOVWF  01
1A06:  MOVLW  00
1A08:  ADDWFC x20,W
1A0A:  MOVFF  01,FE9
1A0E:  MOVWF  FEA
1A10:  BCF    FEF.0
.................... 	}
.................... 
.................... 	/* command on. 65535 disables */
.................... 	if ( 65535 != channel[c].command_on_seconds ) {
1A12:  MOVF   x1C,W
1A14:  MULLW  19
1A16:  MOVF   FF3,W
1A18:  CLRF   x20
1A1A:  MOVWF  x1F
1A1C:  MOVLW  01
1A1E:  ADDWF  x1F,W
1A20:  MOVWF  01
1A22:  MOVLW  00
1A24:  ADDWFC x20,W
1A26:  MOVWF  03
1A28:  MOVF   01,W
1A2A:  ADDLW  DA
1A2C:  MOVWF  FE9
1A2E:  MOVLW  00
1A30:  ADDWFC 03,W
1A32:  MOVWF  FEA
1A34:  MOVFF  FEC,03
1A38:  MOVF   FED,F
1A3A:  MOVF   FEF,W
1A3C:  SUBLW  FF
1A3E:  BNZ   1A46
1A40:  INCFSZ 03,W
1A42:  BRA    1A46
1A44:  BRA    1BDC
.................... 		if ( channel[c].command_on_seconds > 0 ) {
1A46:  MOVF   x1C,W
1A48:  MULLW  19
1A4A:  MOVF   FF3,W
1A4C:  CLRF   x20
1A4E:  MOVWF  x1F
1A50:  MOVLW  01
1A52:  ADDWF  x1F,W
1A54:  MOVWF  01
1A56:  MOVLW  00
1A58:  ADDWFC x20,W
1A5A:  MOVWF  03
1A5C:  MOVF   01,W
1A5E:  ADDLW  DA
1A60:  MOVWF  FE9
1A62:  MOVLW  00
1A64:  ADDWFC 03,W
1A66:  MOVWF  FEA
1A68:  MOVFF  FEC,120
1A6C:  MOVF   FED,F
1A6E:  MOVFF  FEF,11F
1A72:  MOVF   x1F,F
1A74:  BNZ   1A7A
1A76:  MOVF   x20,F
1A78:  BZ    1AA8
.................... 			/* waiting to power on */
.................... 			channel[c].command_on_seconds--;
1A7A:  MOVF   x1C,W
1A7C:  MULLW  19
1A7E:  MOVF   FF3,W
1A80:  CLRF   x20
1A82:  MOVWF  x1F
1A84:  MOVLW  01
1A86:  ADDWF  x1F,W
1A88:  MOVWF  01
1A8A:  MOVLW  00
1A8C:  ADDWFC x20,W
1A8E:  MOVWF  03
1A90:  MOVF   01,W
1A92:  ADDLW  DA
1A94:  MOVWF  FE9
1A96:  MOVLW  00
1A98:  ADDWFC 03,W
1A9A:  MOVWF  FEA
1A9C:  MOVLW  FF
1A9E:  ADDWF  FEF,F
1AA0:  BC    1AA6
1AA2:  MOVF   FEE,F
1AA4:  DECF   FED,F
.................... 		} else {
1AA6:  BRA    1BDC
.................... 			/* timer at zero, ready to power on or already powered on */
.................... 			if ( ! bit_test(channel[c].state,CH_STATE_BIT_CMD_ON) ) {
1AA8:  MOVF   x1C,W
1AAA:  MULLW  19
1AAC:  MOVF   FF3,W
1AAE:  CLRF   x20
1AB0:  MOVWF  x1F
1AB2:  MOVLW  DA
1AB4:  ADDWF  x1F,W
1AB6:  MOVWF  FE9
1AB8:  MOVLW  00
1ABA:  ADDWFC x20,W
1ABC:  MOVWF  FEA
1ABE:  MOVFF  FEF,121
1AC2:  BTFSC  x21.1
1AC4:  BRA    1B3A
.................... 				/* not currently set, so we set it and start the countdown */
.................... 				bit_set(channel[c].state,CH_STATE_BIT_CMD_ON);
1AC6:  MOVF   x1C,W
1AC8:  MULLW  19
1ACA:  MOVF   FF3,W
1ACC:  CLRF   x20
1ACE:  MOVWF  x1F
1AD0:  MOVLW  DA
1AD2:  ADDWF  x1F,W
1AD4:  MOVWF  01
1AD6:  MOVLW  00
1AD8:  ADDWFC x20,W
1ADA:  MOVFF  01,FE9
1ADE:  MOVWF  FEA
1AE0:  BSF    FEF.1
.................... 				channel[c].command_on_hold_seconds=config.ch[c].command_on_hold_time;
1AE2:  MOVF   x1C,W
1AE4:  MULLW  19
1AE6:  MOVF   FF3,W
1AE8:  CLRF   x20
1AEA:  MOVWF  x1F
1AEC:  MOVLW  03
1AEE:  ADDWF  x1F,W
1AF0:  MOVWF  01
1AF2:  MOVLW  00
1AF4:  ADDWFC x20,W
1AF6:  MOVWF  03
1AF8:  MOVF   01,W
1AFA:  ADDLW  DA
1AFC:  MOVWF  01
1AFE:  MOVLW  00
1B00:  ADDWFC 03,F
1B02:  MOVFF  03,120
1B06:  MOVF   x1C,W
1B08:  MULLW  24
1B0A:  MOVF   FF3,W
1B0C:  CLRF   x22
1B0E:  MOVWF  x21
1B10:  MOVLW  1B
1B12:  ADDWF  x21,W
1B14:  MOVWF  FE9
1B16:  MOVLW  00
1B18:  ADDWFC x22,W
1B1A:  MOVWF  FEA
1B1C:  MOVFF  FEC,03
1B20:  MOVF   FED,F
1B22:  MOVFF  FEF,123
1B26:  MOVFF  120,FEA
1B2A:  MOVFF  01,FE9
1B2E:  MOVFF  03,FEC
1B32:  MOVF   FED,F
1B34:  MOVFF  123,FEF
.................... 			} else {
1B38:  BRA    1BDC
.................... 				/* set, so we clear it once countdown has elapsed */
.................... 				if ( 0==channel[c].command_on_hold_seconds ) {
1B3A:  MOVF   x1C,W
1B3C:  MULLW  19
1B3E:  MOVF   FF3,W
1B40:  CLRF   x20
1B42:  MOVWF  x1F
1B44:  MOVLW  03
1B46:  ADDWF  x1F,W
1B48:  MOVWF  01
1B4A:  MOVLW  00
1B4C:  ADDWFC x20,W
1B4E:  MOVWF  03
1B50:  MOVF   01,W
1B52:  ADDLW  DA
1B54:  MOVWF  FE9
1B56:  MOVLW  00
1B58:  ADDWFC 03,W
1B5A:  MOVWF  FEA
1B5C:  MOVFF  FEC,03
1B60:  MOVF   FED,F
1B62:  MOVF   FEF,W
1B64:  BNZ   1BB0
1B66:  MOVF   03,F
1B68:  BNZ   1BB0
.................... 					/* countdown elapsed, clear the flag and reset the timer */
.................... 					bit_clear(channel[c].state,CH_STATE_BIT_CMD_ON);
1B6A:  MOVF   x1C,W
1B6C:  MULLW  19
1B6E:  MOVF   FF3,W
1B70:  CLRF   x20
1B72:  MOVWF  x1F
1B74:  MOVLW  DA
1B76:  ADDWF  x1F,W
1B78:  MOVWF  01
1B7A:  MOVLW  00
1B7C:  ADDWFC x20,W
1B7E:  MOVFF  01,FE9
1B82:  MOVWF  FEA
1B84:  BCF    FEF.1
.................... 					channel[c].command_on_seconds=65535;
1B86:  MOVF   x1C,W
1B88:  MULLW  19
1B8A:  MOVF   FF3,W
1B8C:  CLRF   x20
1B8E:  MOVWF  x1F
1B90:  MOVLW  01
1B92:  ADDWF  x1F,W
1B94:  MOVWF  01
1B96:  MOVLW  00
1B98:  ADDWFC x20,W
1B9A:  MOVWF  03
1B9C:  MOVF   01,W
1B9E:  ADDLW  DA
1BA0:  MOVWF  FE9
1BA2:  MOVLW  00
1BA4:  ADDWFC 03,W
1BA6:  MOVWF  FEA
1BA8:  SETF   FEC
1BAA:  MOVF   FED,F
1BAC:  SETF   FEF
.................... 				} else {
1BAE:  BRA    1BDC
.................... 					channel[c].command_on_hold_seconds--;
1BB0:  MOVF   x1C,W
1BB2:  MULLW  19
1BB4:  MOVF   FF3,W
1BB6:  CLRF   x20
1BB8:  MOVWF  x1F
1BBA:  MOVLW  03
1BBC:  ADDWF  x1F,W
1BBE:  MOVWF  01
1BC0:  MOVLW  00
1BC2:  ADDWFC x20,W
1BC4:  MOVWF  03
1BC6:  MOVF   01,W
1BC8:  ADDLW  DA
1BCA:  MOVWF  FE9
1BCC:  MOVLW  00
1BCE:  ADDWFC 03,W
1BD0:  MOVWF  FEA
1BD2:  MOVLW  FF
1BD4:  ADDWF  FEF,F
1BD6:  BC    1BDC
1BD8:  MOVF   FEE,F
1BDA:  DECF   FED,F
.................... 				}
.................... 			}		
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	/* command off. 65535 disables */
.................... 	if ( 65535 != channel[c].command_off_seconds ) {
1BDC:  MOVF   x1C,W
1BDE:  MULLW  19
1BE0:  MOVF   FF3,W
1BE2:  CLRF   x20
1BE4:  MOVWF  x1F
1BE6:  MOVLW  05
1BE8:  ADDWF  x1F,W
1BEA:  MOVWF  01
1BEC:  MOVLW  00
1BEE:  ADDWFC x20,W
1BF0:  MOVWF  03
1BF2:  MOVF   01,W
1BF4:  ADDLW  DA
1BF6:  MOVWF  FE9
1BF8:  MOVLW  00
1BFA:  ADDWFC 03,W
1BFC:  MOVWF  FEA
1BFE:  MOVFF  FEC,03
1C02:  MOVF   FED,F
1C04:  MOVF   FEF,W
1C06:  SUBLW  FF
1C08:  BNZ   1C10
1C0A:  INCFSZ 03,W
1C0C:  BRA    1C10
1C0E:  BRA    1DB6
.................... 		if ( channel[c].command_off_seconds > 0 ) {
1C10:  MOVF   x1C,W
1C12:  MULLW  19
1C14:  MOVF   FF3,W
1C16:  CLRF   x20
1C18:  MOVWF  x1F
1C1A:  MOVLW  05
1C1C:  ADDWF  x1F,W
1C1E:  MOVWF  01
1C20:  MOVLW  00
1C22:  ADDWFC x20,W
1C24:  MOVWF  03
1C26:  MOVF   01,W
1C28:  ADDLW  DA
1C2A:  MOVWF  FE9
1C2C:  MOVLW  00
1C2E:  ADDWFC 03,W
1C30:  MOVWF  FEA
1C32:  MOVFF  FEC,120
1C36:  MOVF   FED,F
1C38:  MOVFF  FEF,11F
1C3C:  MOVF   x1F,F
1C3E:  BNZ   1C44
1C40:  MOVF   x20,F
1C42:  BZ    1C72
.................... 			/* waiting to power off */
.................... 			channel[c].command_off_seconds--;
1C44:  MOVF   x1C,W
1C46:  MULLW  19
1C48:  MOVF   FF3,W
1C4A:  CLRF   x20
1C4C:  MOVWF  x1F
1C4E:  MOVLW  05
1C50:  ADDWF  x1F,W
1C52:  MOVWF  01
1C54:  MOVLW  00
1C56:  ADDWFC x20,W
1C58:  MOVWF  03
1C5A:  MOVF   01,W
1C5C:  ADDLW  DA
1C5E:  MOVWF  FE9
1C60:  MOVLW  00
1C62:  ADDWFC 03,W
1C64:  MOVWF  FEA
1C66:  MOVLW  FF
1C68:  ADDWF  FEF,F
1C6A:  BC    1C70
1C6C:  MOVF   FEE,F
1C6E:  DECF   FED,F
.................... 		} else {
1C70:  BRA    1DB6
.................... 			/* timer at zero, ready to power off or already powered off */
.................... 			if ( ! bit_test(channel[c].state,CH_STATE_BIT_CMD_OFF) ) {
1C72:  MOVF   x1C,W
1C74:  MULLW  19
1C76:  MOVF   FF3,W
1C78:  CLRF   x20
1C7A:  MOVWF  x1F
1C7C:  MOVLW  DA
1C7E:  ADDWF  x1F,W
1C80:  MOVWF  FE9
1C82:  MOVLW  00
1C84:  ADDWFC x20,W
1C86:  MOVWF  FEA
1C88:  MOVFF  FEF,121
1C8C:  BTFSC  x21.2
1C8E:  BRA    1D14
.................... 				/* not currently set, so we set it and start the countdown */
.................... 				bit_set(channel[c].state,CH_STATE_BIT_CMD_OFF);
1C90:  MOVF   x1C,W
1C92:  MULLW  19
1C94:  MOVF   FF3,W
1C96:  CLRF   x20
1C98:  MOVWF  x1F
1C9A:  MOVLW  DA
1C9C:  ADDWF  x1F,W
1C9E:  MOVWF  01
1CA0:  MOVLW  00
1CA2:  ADDWFC x20,W
1CA4:  MOVFF  01,FE9
1CA8:  MOVWF  FEA
1CAA:  BSF    FEF.2
.................... 				channel[c].command_off_hold_seconds=config.ch[c].command_off_hold_time;
1CAC:  MOVF   x1C,W
1CAE:  MULLW  19
1CB0:  MOVF   FF3,W
1CB2:  CLRF   x20
1CB4:  MOVWF  x1F
1CB6:  MOVLW  07
1CB8:  ADDWF  x1F,W
1CBA:  MOVWF  01
1CBC:  MOVLW  00
1CBE:  ADDWFC x20,W
1CC0:  MOVWF  03
1CC2:  MOVF   01,W
1CC4:  ADDLW  DA
1CC6:  MOVWF  01
1CC8:  MOVLW  00
1CCA:  ADDWFC 03,F
1CCC:  MOVFF  01,11F
1CD0:  MOVFF  03,120
1CD4:  MOVF   x1C,W
1CD6:  MULLW  24
1CD8:  MOVF   FF3,W
1CDA:  CLRF   x22
1CDC:  MOVWF  x21
1CDE:  MOVLW  02
1CE0:  ADDWF  x21,W
1CE2:  MOVWF  01
1CE4:  MOVLW  00
1CE6:  ADDWFC x22,W
1CE8:  MOVWF  03
1CEA:  MOVF   01,W
1CEC:  ADDLW  1B
1CEE:  MOVWF  FE9
1CF0:  MOVLW  00
1CF2:  ADDWFC 03,W
1CF4:  MOVWF  FEA
1CF6:  MOVFF  FEC,03
1CFA:  MOVF   FED,F
1CFC:  MOVFF  FEF,121
1D00:  MOVFF  120,FEA
1D04:  MOVFF  11F,FE9
1D08:  MOVFF  03,FEC
1D0C:  MOVF   FED,F
1D0E:  MOVFF  121,FEF
.................... 			} else {
1D12:  BRA    1DB6
.................... 				/* set, so we clear it once countdown has elapsed */
.................... 				if ( 0==channel[c].command_off_hold_seconds ) {
1D14:  MOVF   x1C,W
1D16:  MULLW  19
1D18:  MOVF   FF3,W
1D1A:  CLRF   x20
1D1C:  MOVWF  x1F
1D1E:  MOVLW  07
1D20:  ADDWF  x1F,W
1D22:  MOVWF  01
1D24:  MOVLW  00
1D26:  ADDWFC x20,W
1D28:  MOVWF  03
1D2A:  MOVF   01,W
1D2C:  ADDLW  DA
1D2E:  MOVWF  FE9
1D30:  MOVLW  00
1D32:  ADDWFC 03,W
1D34:  MOVWF  FEA
1D36:  MOVFF  FEC,03
1D3A:  MOVF   FED,F
1D3C:  MOVF   FEF,W
1D3E:  BNZ   1D8A
1D40:  MOVF   03,F
1D42:  BNZ   1D8A
.................... 					/* countdown elapsed, clear the flag and reset the timer */
.................... 					bit_clear(channel[c].state,CH_STATE_BIT_CMD_OFF);
1D44:  MOVF   x1C,W
1D46:  MULLW  19
1D48:  MOVF   FF3,W
1D4A:  CLRF   x20
1D4C:  MOVWF  x1F
1D4E:  MOVLW  DA
1D50:  ADDWF  x1F,W
1D52:  MOVWF  01
1D54:  MOVLW  00
1D56:  ADDWFC x20,W
1D58:  MOVFF  01,FE9
1D5C:  MOVWF  FEA
1D5E:  BCF    FEF.2
.................... 					channel[c].command_off_seconds=65535;
1D60:  MOVF   x1C,W
1D62:  MULLW  19
1D64:  MOVF   FF3,W
1D66:  CLRF   x20
1D68:  MOVWF  x1F
1D6A:  MOVLW  05
1D6C:  ADDWF  x1F,W
1D6E:  MOVWF  01
1D70:  MOVLW  00
1D72:  ADDWFC x20,W
1D74:  MOVWF  03
1D76:  MOVF   01,W
1D78:  ADDLW  DA
1D7A:  MOVWF  FE9
1D7C:  MOVLW  00
1D7E:  ADDWFC 03,W
1D80:  MOVWF  FEA
1D82:  SETF   FEC
1D84:  MOVF   FED,F
1D86:  SETF   FEF
.................... 				} else {
1D88:  BRA    1DB6
.................... 					channel[c].command_off_hold_seconds--;
1D8A:  MOVF   x1C,W
1D8C:  MULLW  19
1D8E:  MOVF   FF3,W
1D90:  CLRF   x20
1D92:  MOVWF  x1F
1D94:  MOVLW  07
1D96:  ADDWF  x1F,W
1D98:  MOVWF  01
1D9A:  MOVLW  00
1D9C:  ADDWFC x20,W
1D9E:  MOVWF  03
1DA0:  MOVF   01,W
1DA2:  ADDLW  DA
1DA4:  MOVWF  FE9
1DA6:  MOVLW  00
1DA8:  ADDWFC 03,W
1DAA:  MOVWF  FEA
1DAC:  MOVLW  FF
1DAE:  ADDWF  FEF,F
1DB0:  BC    1DB6
1DB2:  MOVF   FEE,F
1DB4:  DECF   FED,F
.................... 				}
.................... 			}		
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	/* Low Voltage Disconnect. 65535 disables */
.................... 	if ( 65535 != config.ch[c].lvd_disconnect_delay ) {
1DB6:  MOVF   x1C,W
1DB8:  MULLW  24
1DBA:  MOVF   FF3,W
1DBC:  CLRF   x20
1DBE:  MOVWF  x1F
1DC0:  MOVLW  06
1DC2:  ADDWF  x1F,W
1DC4:  MOVWF  01
1DC6:  MOVLW  00
1DC8:  ADDWFC x20,W
1DCA:  MOVWF  03
1DCC:  MOVF   01,W
1DCE:  ADDLW  1B
1DD0:  MOVWF  FE9
1DD2:  MOVLW  00
1DD4:  ADDWFC 03,W
1DD6:  MOVWF  FEA
1DD8:  MOVFF  FEC,03
1DDC:  MOVF   FED,F
1DDE:  MOVF   FEF,W
1DE0:  SUBLW  FF
1DE2:  BNZ   1DEA
1DE4:  INCFSZ 03,W
1DE6:  BRA    1DEA
1DE8:  BRA    2048
1DEA:  CLRF   19
1DEC:  BTFSC  FF2.7
1DEE:  BSF    19.7
1DF0:  BCF    FF2.7
.................... 		adc=adc_get(0);
1DF2:  CLRF   x2F
1DF4:  MOVLB  0
1DF6:  CALL   0594
1DFA:  BTFSC  19.7
1DFC:  BSF    FF2.7
1DFE:  MOVFF  02,11E
1E02:  MOVFF  01,11D
.................... 
.................... 		if ( adc > config.ch[c].lvd_reconnect_adc ) {
1E06:  MOVLB  1
1E08:  MOVF   x1C,W
1E0A:  MULLW  24
1E0C:  MOVF   FF3,W
1E0E:  CLRF   x20
1E10:  MOVWF  x1F
1E12:  MOVLW  08
1E14:  ADDWF  x1F,W
1E16:  MOVWF  01
1E18:  MOVLW  00
1E1A:  ADDWFC x20,W
1E1C:  MOVWF  03
1E1E:  MOVF   01,W
1E20:  ADDLW  1B
1E22:  MOVWF  FE9
1E24:  MOVLW  00
1E26:  ADDWFC 03,W
1E28:  MOVWF  FEA
1E2A:  MOVFF  FEC,03
1E2E:  MOVF   FED,F
1E30:  MOVFF  FEF,01
1E34:  MOVF   03,W
1E36:  SUBWF  x1E,W
1E38:  BNC   1EC2
1E3A:  BNZ   1E42
1E3C:  MOVF   x1D,W
1E3E:  SUBWF  01,W
1E40:  BC    1EC2
.................... 			if ( channel[c].lvd_reconnect_delay_seconds > 0 ) {
1E42:  MOVF   x1C,W
1E44:  MULLW  19
1E46:  MOVF   FF3,W
1E48:  CLRF   x20
1E4A:  MOVWF  x1F
1E4C:  MOVLW  0B
1E4E:  ADDWF  x1F,W
1E50:  MOVWF  01
1E52:  MOVLW  00
1E54:  ADDWFC x20,W
1E56:  MOVWF  03
1E58:  MOVF   01,W
1E5A:  ADDLW  DA
1E5C:  MOVWF  FE9
1E5E:  MOVLW  00
1E60:  ADDWFC 03,W
1E62:  MOVWF  FEA
1E64:  MOVFF  FEC,120
1E68:  MOVF   FED,F
1E6A:  MOVFF  FEF,11F
1E6E:  MOVF   x1F,F
1E70:  BNZ   1E76
1E72:  MOVF   x20,F
1E74:  BZ    1EA4
.................... 				channel[c].lvd_reconnect_delay_seconds--;
1E76:  MOVF   x1C,W
1E78:  MULLW  19
1E7A:  MOVF   FF3,W
1E7C:  CLRF   x20
1E7E:  MOVWF  x1F
1E80:  MOVLW  0B
1E82:  ADDWF  x1F,W
1E84:  MOVWF  01
1E86:  MOVLW  00
1E88:  ADDWFC x20,W
1E8A:  MOVWF  03
1E8C:  MOVF   01,W
1E8E:  ADDLW  DA
1E90:  MOVWF  FE9
1E92:  MOVLW  00
1E94:  ADDWFC 03,W
1E96:  MOVWF  FEA
1E98:  MOVLW  FF
1E9A:  ADDWF  FEF,F
1E9C:  BC    1EA2
1E9E:  MOVF   FEE,F
1EA0:  DECF   FED,F
.................... 			} else {
1EA2:  BRA    1EC0
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_LVD);
1EA4:  MOVF   x1C,W
1EA6:  MULLW  19
1EA8:  MOVF   FF3,W
1EAA:  CLRF   x20
1EAC:  MOVWF  x1F
1EAE:  MOVLW  DA
1EB0:  ADDWF  x1F,W
1EB2:  MOVWF  01
1EB4:  MOVLW  00
1EB6:  ADDWFC x20,W
1EB8:  MOVFF  01,FE9
1EBC:  MOVWF  FEA
1EBE:  BCF    FEF.3
.................... 			}
.................... 		} else {
1EC0:  BRA    1F28
.................... 			channel[c].lvd_reconnect_delay_seconds=config.ch[c].lvd_reconnect_delay;
1EC2:  MOVF   x1C,W
1EC4:  MULLW  19
1EC6:  MOVF   FF3,W
1EC8:  CLRF   x20
1ECA:  MOVWF  x1F
1ECC:  MOVLW  0B
1ECE:  ADDWF  x1F,W
1ED0:  MOVWF  01
1ED2:  MOVLW  00
1ED4:  ADDWFC x20,W
1ED6:  MOVWF  03
1ED8:  MOVF   01,W
1EDA:  ADDLW  DA
1EDC:  MOVWF  01
1EDE:  MOVLW  00
1EE0:  ADDWFC 03,F
1EE2:  MOVFF  01,11F
1EE6:  MOVFF  03,120
1EEA:  MOVF   x1C,W
1EEC:  MULLW  24
1EEE:  MOVF   FF3,W
1EF0:  CLRF   x22
1EF2:  MOVWF  x21
1EF4:  MOVLW  0A
1EF6:  ADDWF  x21,W
1EF8:  MOVWF  01
1EFA:  MOVLW  00
1EFC:  ADDWFC x22,W
1EFE:  MOVWF  03
1F00:  MOVF   01,W
1F02:  ADDLW  1B
1F04:  MOVWF  FE9
1F06:  MOVLW  00
1F08:  ADDWFC 03,W
1F0A:  MOVWF  FEA
1F0C:  MOVFF  FEC,03
1F10:  MOVF   FED,F
1F12:  MOVFF  FEF,121
1F16:  MOVFF  120,FEA
1F1A:  MOVFF  11F,FE9
1F1E:  MOVFF  03,FEC
1F22:  MOVF   FED,F
1F24:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc < config.ch[c].lvd_disconnect_adc ) {
1F28:  MOVF   x1C,W
1F2A:  MULLW  24
1F2C:  MOVF   FF3,W
1F2E:  CLRF   x20
1F30:  MOVWF  x1F
1F32:  MOVLW  04
1F34:  ADDWF  x1F,W
1F36:  MOVWF  01
1F38:  MOVLW  00
1F3A:  ADDWFC x20,W
1F3C:  MOVWF  03
1F3E:  MOVF   01,W
1F40:  ADDLW  1B
1F42:  MOVWF  FE9
1F44:  MOVLW  00
1F46:  ADDWFC 03,W
1F48:  MOVWF  FEA
1F4A:  MOVFF  FEC,03
1F4E:  MOVF   FED,F
1F50:  MOVFF  FEF,01
1F54:  MOVF   x1E,W
1F56:  SUBWF  03,W
1F58:  BNC   1FE2
1F5A:  BNZ   1F62
1F5C:  MOVF   01,W
1F5E:  SUBWF  x1D,W
1F60:  BC    1FE2
.................... 			if ( channel[c].lvd_disconnect_delay_seconds > 0 ) {
1F62:  MOVF   x1C,W
1F64:  MULLW  19
1F66:  MOVF   FF3,W
1F68:  CLRF   x20
1F6A:  MOVWF  x1F
1F6C:  MOVLW  09
1F6E:  ADDWF  x1F,W
1F70:  MOVWF  01
1F72:  MOVLW  00
1F74:  ADDWFC x20,W
1F76:  MOVWF  03
1F78:  MOVF   01,W
1F7A:  ADDLW  DA
1F7C:  MOVWF  FE9
1F7E:  MOVLW  00
1F80:  ADDWFC 03,W
1F82:  MOVWF  FEA
1F84:  MOVFF  FEC,120
1F88:  MOVF   FED,F
1F8A:  MOVFF  FEF,11F
1F8E:  MOVF   x1F,F
1F90:  BNZ   1F96
1F92:  MOVF   x20,F
1F94:  BZ    1FC4
.................... 				channel[c].lvd_disconnect_delay_seconds--;
1F96:  MOVF   x1C,W
1F98:  MULLW  19
1F9A:  MOVF   FF3,W
1F9C:  CLRF   x20
1F9E:  MOVWF  x1F
1FA0:  MOVLW  09
1FA2:  ADDWF  x1F,W
1FA4:  MOVWF  01
1FA6:  MOVLW  00
1FA8:  ADDWFC x20,W
1FAA:  MOVWF  03
1FAC:  MOVF   01,W
1FAE:  ADDLW  DA
1FB0:  MOVWF  FE9
1FB2:  MOVLW  00
1FB4:  ADDWFC 03,W
1FB6:  MOVWF  FEA
1FB8:  MOVLW  FF
1FBA:  ADDWF  FEF,F
1FBC:  BC    1FC2
1FBE:  MOVF   FEE,F
1FC0:  DECF   FED,F
.................... 			} else {
1FC2:  BRA    1FE0
.................... 				bit_set(channel[c].state,CH_STATE_BIT_LVD);
1FC4:  MOVF   x1C,W
1FC6:  MULLW  19
1FC8:  MOVF   FF3,W
1FCA:  CLRF   x20
1FCC:  MOVWF  x1F
1FCE:  MOVLW  DA
1FD0:  ADDWF  x1F,W
1FD2:  MOVWF  01
1FD4:  MOVLW  00
1FD6:  ADDWFC x20,W
1FD8:  MOVFF  01,FE9
1FDC:  MOVWF  FEA
1FDE:  BSF    FEF.3
.................... 			}
.................... 		} else {
1FE0:  BRA    2048
.................... 			channel[c].lvd_disconnect_delay_seconds=config.ch[c].lvd_disconnect_delay;
1FE2:  MOVF   x1C,W
1FE4:  MULLW  19
1FE6:  MOVF   FF3,W
1FE8:  CLRF   x20
1FEA:  MOVWF  x1F
1FEC:  MOVLW  09
1FEE:  ADDWF  x1F,W
1FF0:  MOVWF  01
1FF2:  MOVLW  00
1FF4:  ADDWFC x20,W
1FF6:  MOVWF  03
1FF8:  MOVF   01,W
1FFA:  ADDLW  DA
1FFC:  MOVWF  01
1FFE:  MOVLW  00
2000:  ADDWFC 03,F
2002:  MOVFF  01,11F
2006:  MOVFF  03,120
200A:  MOVF   x1C,W
200C:  MULLW  24
200E:  MOVF   FF3,W
2010:  CLRF   x22
2012:  MOVWF  x21
2014:  MOVLW  06
2016:  ADDWF  x21,W
2018:  MOVWF  01
201A:  MOVLW  00
201C:  ADDWFC x22,W
201E:  MOVWF  03
2020:  MOVF   01,W
2022:  ADDLW  1B
2024:  MOVWF  FE9
2026:  MOVLW  00
2028:  ADDWFC 03,W
202A:  MOVWF  FEA
202C:  MOVFF  FEC,03
2030:  MOVF   FED,F
2032:  MOVFF  FEF,121
2036:  MOVFF  120,FEA
203A:  MOVFF  11F,FE9
203E:  MOVFF  03,FEC
2042:  MOVF   FED,F
2044:  MOVFF  121,FEF
.................... 		}
.................... 	}
.................... 
.................... 	/* High Voltage Disconnect. 65535 disables */
.................... 	if ( 65535 != config.ch[c].hvd_disconnect_delay ) {
2048:  MOVF   x1C,W
204A:  MULLW  24
204C:  MOVF   FF3,W
204E:  CLRF   x20
2050:  MOVWF  x1F
2052:  MOVLW  0E
2054:  ADDWF  x1F,W
2056:  MOVWF  01
2058:  MOVLW  00
205A:  ADDWFC x20,W
205C:  MOVWF  03
205E:  MOVF   01,W
2060:  ADDLW  1B
2062:  MOVWF  FE9
2064:  MOVLW  00
2066:  ADDWFC 03,W
2068:  MOVWF  FEA
206A:  MOVFF  FEC,03
206E:  MOVF   FED,F
2070:  MOVF   FEF,W
2072:  SUBLW  FF
2074:  BNZ   207C
2076:  INCFSZ 03,W
2078:  BRA    207C
207A:  BRA    22DA
207C:  CLRF   19
207E:  BTFSC  FF2.7
2080:  BSF    19.7
2082:  BCF    FF2.7
.................... 		adc=adc_get(0);
2084:  CLRF   x2F
2086:  MOVLB  0
2088:  CALL   0594
208C:  BTFSC  19.7
208E:  BSF    FF2.7
2090:  MOVFF  02,11E
2094:  MOVFF  01,11D
.................... 
.................... 		if ( adc < config.ch[c].hvd_reconnect_adc ) {
2098:  MOVLB  1
209A:  MOVF   x1C,W
209C:  MULLW  24
209E:  MOVF   FF3,W
20A0:  CLRF   x20
20A2:  MOVWF  x1F
20A4:  MOVLW  10
20A6:  ADDWF  x1F,W
20A8:  MOVWF  01
20AA:  MOVLW  00
20AC:  ADDWFC x20,W
20AE:  MOVWF  03
20B0:  MOVF   01,W
20B2:  ADDLW  1B
20B4:  MOVWF  FE9
20B6:  MOVLW  00
20B8:  ADDWFC 03,W
20BA:  MOVWF  FEA
20BC:  MOVFF  FEC,03
20C0:  MOVF   FED,F
20C2:  MOVFF  FEF,01
20C6:  MOVF   x1E,W
20C8:  SUBWF  03,W
20CA:  BNC   2154
20CC:  BNZ   20D4
20CE:  MOVF   01,W
20D0:  SUBWF  x1D,W
20D2:  BC    2154
.................... 			if ( channel[c].hvd_reconnect_delay_seconds > 0 ) {
20D4:  MOVF   x1C,W
20D6:  MULLW  19
20D8:  MOVF   FF3,W
20DA:  CLRF   x20
20DC:  MOVWF  x1F
20DE:  MOVLW  0F
20E0:  ADDWF  x1F,W
20E2:  MOVWF  01
20E4:  MOVLW  00
20E6:  ADDWFC x20,W
20E8:  MOVWF  03
20EA:  MOVF   01,W
20EC:  ADDLW  DA
20EE:  MOVWF  FE9
20F0:  MOVLW  00
20F2:  ADDWFC 03,W
20F4:  MOVWF  FEA
20F6:  MOVFF  FEC,120
20FA:  MOVF   FED,F
20FC:  MOVFF  FEF,11F
2100:  MOVF   x1F,F
2102:  BNZ   2108
2104:  MOVF   x20,F
2106:  BZ    2136
.................... 				channel[c].hvd_reconnect_delay_seconds--;
2108:  MOVF   x1C,W
210A:  MULLW  19
210C:  MOVF   FF3,W
210E:  CLRF   x20
2110:  MOVWF  x1F
2112:  MOVLW  0F
2114:  ADDWF  x1F,W
2116:  MOVWF  01
2118:  MOVLW  00
211A:  ADDWFC x20,W
211C:  MOVWF  03
211E:  MOVF   01,W
2120:  ADDLW  DA
2122:  MOVWF  FE9
2124:  MOVLW  00
2126:  ADDWFC 03,W
2128:  MOVWF  FEA
212A:  MOVLW  FF
212C:  ADDWF  FEF,F
212E:  BC    2134
2130:  MOVF   FEE,F
2132:  DECF   FED,F
.................... 			} else {
2134:  BRA    2152
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_HVD);
2136:  MOVF   x1C,W
2138:  MULLW  19
213A:  MOVF   FF3,W
213C:  CLRF   x20
213E:  MOVWF  x1F
2140:  MOVLW  DA
2142:  ADDWF  x1F,W
2144:  MOVWF  01
2146:  MOVLW  00
2148:  ADDWFC x20,W
214A:  MOVFF  01,FE9
214E:  MOVWF  FEA
2150:  BCF    FEF.4
.................... 			}
.................... 		} else {
2152:  BRA    21BA
.................... 			channel[c].hvd_reconnect_delay_seconds=config.ch[c].hvd_reconnect_delay;
2154:  MOVF   x1C,W
2156:  MULLW  19
2158:  MOVF   FF3,W
215A:  CLRF   x20
215C:  MOVWF  x1F
215E:  MOVLW  0F
2160:  ADDWF  x1F,W
2162:  MOVWF  01
2164:  MOVLW  00
2166:  ADDWFC x20,W
2168:  MOVWF  03
216A:  MOVF   01,W
216C:  ADDLW  DA
216E:  MOVWF  01
2170:  MOVLW  00
2172:  ADDWFC 03,F
2174:  MOVFF  01,11F
2178:  MOVFF  03,120
217C:  MOVF   x1C,W
217E:  MULLW  24
2180:  MOVF   FF3,W
2182:  CLRF   x22
2184:  MOVWF  x21
2186:  MOVLW  12
2188:  ADDWF  x21,W
218A:  MOVWF  01
218C:  MOVLW  00
218E:  ADDWFC x22,W
2190:  MOVWF  03
2192:  MOVF   01,W
2194:  ADDLW  1B
2196:  MOVWF  FE9
2198:  MOVLW  00
219A:  ADDWFC 03,W
219C:  MOVWF  FEA
219E:  MOVFF  FEC,03
21A2:  MOVF   FED,F
21A4:  MOVFF  FEF,121
21A8:  MOVFF  120,FEA
21AC:  MOVFF  11F,FE9
21B0:  MOVFF  03,FEC
21B4:  MOVF   FED,F
21B6:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc > config.ch[c].hvd_disconnect_adc ) {
21BA:  MOVF   x1C,W
21BC:  MULLW  24
21BE:  MOVF   FF3,W
21C0:  CLRF   x20
21C2:  MOVWF  x1F
21C4:  MOVLW  0C
21C6:  ADDWF  x1F,W
21C8:  MOVWF  01
21CA:  MOVLW  00
21CC:  ADDWFC x20,W
21CE:  MOVWF  03
21D0:  MOVF   01,W
21D2:  ADDLW  1B
21D4:  MOVWF  FE9
21D6:  MOVLW  00
21D8:  ADDWFC 03,W
21DA:  MOVWF  FEA
21DC:  MOVFF  FEC,03
21E0:  MOVF   FED,F
21E2:  MOVFF  FEF,01
21E6:  MOVF   03,W
21E8:  SUBWF  x1E,W
21EA:  BNC   2274
21EC:  BNZ   21F4
21EE:  MOVF   x1D,W
21F0:  SUBWF  01,W
21F2:  BC    2274
.................... 			if ( channel[c].hvd_disconnect_delay_seconds > 0 ) {
21F4:  MOVF   x1C,W
21F6:  MULLW  19
21F8:  MOVF   FF3,W
21FA:  CLRF   x20
21FC:  MOVWF  x1F
21FE:  MOVLW  0D
2200:  ADDWF  x1F,W
2202:  MOVWF  01
2204:  MOVLW  00
2206:  ADDWFC x20,W
2208:  MOVWF  03
220A:  MOVF   01,W
220C:  ADDLW  DA
220E:  MOVWF  FE9
2210:  MOVLW  00
2212:  ADDWFC 03,W
2214:  MOVWF  FEA
2216:  MOVFF  FEC,120
221A:  MOVF   FED,F
221C:  MOVFF  FEF,11F
2220:  MOVF   x1F,F
2222:  BNZ   2228
2224:  MOVF   x20,F
2226:  BZ    2256
.................... 				channel[c].hvd_disconnect_delay_seconds--;
2228:  MOVF   x1C,W
222A:  MULLW  19
222C:  MOVF   FF3,W
222E:  CLRF   x20
2230:  MOVWF  x1F
2232:  MOVLW  0D
2234:  ADDWF  x1F,W
2236:  MOVWF  01
2238:  MOVLW  00
223A:  ADDWFC x20,W
223C:  MOVWF  03
223E:  MOVF   01,W
2240:  ADDLW  DA
2242:  MOVWF  FE9
2244:  MOVLW  00
2246:  ADDWFC 03,W
2248:  MOVWF  FEA
224A:  MOVLW  FF
224C:  ADDWF  FEF,F
224E:  BC    2254
2250:  MOVF   FEE,F
2252:  DECF   FED,F
.................... 			} else {
2254:  BRA    2272
.................... 				bit_set(channel[c].state,CH_STATE_BIT_HVD);
2256:  MOVF   x1C,W
2258:  MULLW  19
225A:  MOVF   FF3,W
225C:  CLRF   x20
225E:  MOVWF  x1F
2260:  MOVLW  DA
2262:  ADDWF  x1F,W
2264:  MOVWF  01
2266:  MOVLW  00
2268:  ADDWFC x20,W
226A:  MOVFF  01,FE9
226E:  MOVWF  FEA
2270:  BSF    FEF.4
.................... 			}
.................... 		} else {
2272:  BRA    22DA
.................... 			channel[c].hvd_disconnect_delay_seconds=config.ch[c].hvd_disconnect_delay;
2274:  MOVF   x1C,W
2276:  MULLW  19
2278:  MOVF   FF3,W
227A:  CLRF   x20
227C:  MOVWF  x1F
227E:  MOVLW  0D
2280:  ADDWF  x1F,W
2282:  MOVWF  01
2284:  MOVLW  00
2286:  ADDWFC x20,W
2288:  MOVWF  03
228A:  MOVF   01,W
228C:  ADDLW  DA
228E:  MOVWF  01
2290:  MOVLW  00
2292:  ADDWFC 03,F
2294:  MOVFF  01,11F
2298:  MOVFF  03,120
229C:  MOVF   x1C,W
229E:  MULLW  24
22A0:  MOVF   FF3,W
22A2:  CLRF   x22
22A4:  MOVWF  x21
22A6:  MOVLW  0E
22A8:  ADDWF  x21,W
22AA:  MOVWF  01
22AC:  MOVLW  00
22AE:  ADDWFC x22,W
22B0:  MOVWF  03
22B2:  MOVF   01,W
22B4:  ADDLW  1B
22B6:  MOVWF  FE9
22B8:  MOVLW  00
22BA:  ADDWFC 03,W
22BC:  MOVWF  FEA
22BE:  MOVFF  FEC,03
22C2:  MOVF   FED,F
22C4:  MOVFF  FEF,121
22C8:  MOVFF  120,FEA
22CC:  MOVFF  11F,FE9
22D0:  MOVFF  03,FEC
22D4:  MOVF   FED,F
22D6:  MOVFF  121,FEF
.................... 		}
.................... 	}
.................... 
.................... 	/* Low Temperature Disconnect. 65535 disables */
.................... 	if ( 65535 != config.ch[c].ltd_disconnect_delay ) {
22DA:  MOVF   x1C,W
22DC:  MULLW  24
22DE:  MOVF   FF3,W
22E0:  CLRF   x20
22E2:  MOVWF  x1F
22E4:  MOVLW  16
22E6:  ADDWF  x1F,W
22E8:  MOVWF  01
22EA:  MOVLW  00
22EC:  ADDWFC x20,W
22EE:  MOVWF  03
22F0:  MOVF   01,W
22F2:  ADDLW  1B
22F4:  MOVWF  FE9
22F6:  MOVLW  00
22F8:  ADDWFC 03,W
22FA:  MOVWF  FEA
22FC:  MOVFF  FEC,03
2300:  MOVF   FED,F
2302:  MOVF   FEF,W
2304:  SUBLW  FF
2306:  BNZ   230E
2308:  INCFSZ 03,W
230A:  BRA    230E
230C:  BRA    256E
230E:  CLRF   19
2310:  BTFSC  FF2.7
2312:  BSF    19.7
2314:  BCF    FF2.7
.................... 		adc=adc_get(1);
2316:  MOVLW  01
2318:  MOVWF  x2F
231A:  MOVLB  0
231C:  CALL   0594
2320:  BTFSC  19.7
2322:  BSF    FF2.7
2324:  MOVFF  02,11E
2328:  MOVFF  01,11D
.................... 
.................... 		if ( adc < config.ch[c].ltd_reconnect_adc ) {
232C:  MOVLB  1
232E:  MOVF   x1C,W
2330:  MULLW  24
2332:  MOVF   FF3,W
2334:  CLRF   x20
2336:  MOVWF  x1F
2338:  MOVLW  18
233A:  ADDWF  x1F,W
233C:  MOVWF  01
233E:  MOVLW  00
2340:  ADDWFC x20,W
2342:  MOVWF  03
2344:  MOVF   01,W
2346:  ADDLW  1B
2348:  MOVWF  FE9
234A:  MOVLW  00
234C:  ADDWFC 03,W
234E:  MOVWF  FEA
2350:  MOVFF  FEC,03
2354:  MOVF   FED,F
2356:  MOVFF  FEF,01
235A:  MOVF   x1E,W
235C:  SUBWF  03,W
235E:  BNC   23E8
2360:  BNZ   2368
2362:  MOVF   01,W
2364:  SUBWF  x1D,W
2366:  BC    23E8
.................... 			/* above reconnect temperature */
.................... 			if ( channel[c].ltd_reconnect_delay_seconds > 0 ) {
2368:  MOVF   x1C,W
236A:  MULLW  19
236C:  MOVF   FF3,W
236E:  CLRF   x20
2370:  MOVWF  x1F
2372:  MOVLW  13
2374:  ADDWF  x1F,W
2376:  MOVWF  01
2378:  MOVLW  00
237A:  ADDWFC x20,W
237C:  MOVWF  03
237E:  MOVF   01,W
2380:  ADDLW  DA
2382:  MOVWF  FE9
2384:  MOVLW  00
2386:  ADDWFC 03,W
2388:  MOVWF  FEA
238A:  MOVFF  FEC,120
238E:  MOVF   FED,F
2390:  MOVFF  FEF,11F
2394:  MOVF   x1F,F
2396:  BNZ   239C
2398:  MOVF   x20,F
239A:  BZ    23CA
.................... 				channel[c].ltd_reconnect_delay_seconds--;
239C:  MOVF   x1C,W
239E:  MULLW  19
23A0:  MOVF   FF3,W
23A2:  CLRF   x20
23A4:  MOVWF  x1F
23A6:  MOVLW  13
23A8:  ADDWF  x1F,W
23AA:  MOVWF  01
23AC:  MOVLW  00
23AE:  ADDWFC x20,W
23B0:  MOVWF  03
23B2:  MOVF   01,W
23B4:  ADDLW  DA
23B6:  MOVWF  FE9
23B8:  MOVLW  00
23BA:  ADDWFC 03,W
23BC:  MOVWF  FEA
23BE:  MOVLW  FF
23C0:  ADDWF  FEF,F
23C2:  BC    23C8
23C4:  MOVF   FEE,F
23C6:  DECF   FED,F
.................... 			} else {
23C8:  BRA    23E6
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_LTD);
23CA:  MOVF   x1C,W
23CC:  MULLW  19
23CE:  MOVF   FF3,W
23D0:  CLRF   x20
23D2:  MOVWF  x1F
23D4:  MOVLW  DA
23D6:  ADDWF  x1F,W
23D8:  MOVWF  01
23DA:  MOVLW  00
23DC:  ADDWFC x20,W
23DE:  MOVFF  01,FE9
23E2:  MOVWF  FEA
23E4:  BCF    FEF.5
.................... 			}
.................... 		} else {
23E6:  BRA    244E
.................... 			channel[c].ltd_reconnect_delay_seconds=config.ch[c].ltd_reconnect_delay;
23E8:  MOVF   x1C,W
23EA:  MULLW  19
23EC:  MOVF   FF3,W
23EE:  CLRF   x20
23F0:  MOVWF  x1F
23F2:  MOVLW  13
23F4:  ADDWF  x1F,W
23F6:  MOVWF  01
23F8:  MOVLW  00
23FA:  ADDWFC x20,W
23FC:  MOVWF  03
23FE:  MOVF   01,W
2400:  ADDLW  DA
2402:  MOVWF  01
2404:  MOVLW  00
2406:  ADDWFC 03,F
2408:  MOVFF  01,11F
240C:  MOVFF  03,120
2410:  MOVF   x1C,W
2412:  MULLW  24
2414:  MOVF   FF3,W
2416:  CLRF   x22
2418:  MOVWF  x21
241A:  MOVLW  1A
241C:  ADDWF  x21,W
241E:  MOVWF  01
2420:  MOVLW  00
2422:  ADDWFC x22,W
2424:  MOVWF  03
2426:  MOVF   01,W
2428:  ADDLW  1B
242A:  MOVWF  FE9
242C:  MOVLW  00
242E:  ADDWFC 03,W
2430:  MOVWF  FEA
2432:  MOVFF  FEC,03
2436:  MOVF   FED,F
2438:  MOVFF  FEF,121
243C:  MOVFF  120,FEA
2440:  MOVFF  11F,FE9
2444:  MOVFF  03,FEC
2448:  MOVF   FED,F
244A:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc > config.ch[c].ltd_disconnect_adc ) {
244E:  MOVF   x1C,W
2450:  MULLW  24
2452:  MOVF   FF3,W
2454:  CLRF   x20
2456:  MOVWF  x1F
2458:  MOVLW  14
245A:  ADDWF  x1F,W
245C:  MOVWF  01
245E:  MOVLW  00
2460:  ADDWFC x20,W
2462:  MOVWF  03
2464:  MOVF   01,W
2466:  ADDLW  1B
2468:  MOVWF  FE9
246A:  MOVLW  00
246C:  ADDWFC 03,W
246E:  MOVWF  FEA
2470:  MOVFF  FEC,03
2474:  MOVF   FED,F
2476:  MOVFF  FEF,01
247A:  MOVF   03,W
247C:  SUBWF  x1E,W
247E:  BNC   2508
2480:  BNZ   2488
2482:  MOVF   x1D,W
2484:  SUBWF  01,W
2486:  BC    2508
.................... 			/* below disconnect temperature */
.................... 			if ( channel[c].ltd_disconnect_delay_seconds > 0 ) {
2488:  MOVF   x1C,W
248A:  MULLW  19
248C:  MOVF   FF3,W
248E:  CLRF   x20
2490:  MOVWF  x1F
2492:  MOVLW  11
2494:  ADDWF  x1F,W
2496:  MOVWF  01
2498:  MOVLW  00
249A:  ADDWFC x20,W
249C:  MOVWF  03
249E:  MOVF   01,W
24A0:  ADDLW  DA
24A2:  MOVWF  FE9
24A4:  MOVLW  00
24A6:  ADDWFC 03,W
24A8:  MOVWF  FEA
24AA:  MOVFF  FEC,120
24AE:  MOVF   FED,F
24B0:  MOVFF  FEF,11F
24B4:  MOVF   x1F,F
24B6:  BNZ   24BC
24B8:  MOVF   x20,F
24BA:  BZ    24EA
.................... 				channel[c].ltd_disconnect_delay_seconds--;
24BC:  MOVF   x1C,W
24BE:  MULLW  19
24C0:  MOVF   FF3,W
24C2:  CLRF   x20
24C4:  MOVWF  x1F
24C6:  MOVLW  11
24C8:  ADDWF  x1F,W
24CA:  MOVWF  01
24CC:  MOVLW  00
24CE:  ADDWFC x20,W
24D0:  MOVWF  03
24D2:  MOVF   01,W
24D4:  ADDLW  DA
24D6:  MOVWF  FE9
24D8:  MOVLW  00
24DA:  ADDWFC 03,W
24DC:  MOVWF  FEA
24DE:  MOVLW  FF
24E0:  ADDWF  FEF,F
24E2:  BC    24E8
24E4:  MOVF   FEE,F
24E6:  DECF   FED,F
.................... 			} else {
24E8:  BRA    2506
.................... 				bit_set(channel[c].state,CH_STATE_BIT_LTD);
24EA:  MOVF   x1C,W
24EC:  MULLW  19
24EE:  MOVF   FF3,W
24F0:  CLRF   x20
24F2:  MOVWF  x1F
24F4:  MOVLW  DA
24F6:  ADDWF  x1F,W
24F8:  MOVWF  01
24FA:  MOVLW  00
24FC:  ADDWFC x20,W
24FE:  MOVFF  01,FE9
2502:  MOVWF  FEA
2504:  BSF    FEF.5
.................... 			}
.................... 		} else {
2506:  BRA    256E
.................... 			channel[c].ltd_disconnect_delay_seconds=config.ch[c].ltd_disconnect_delay;
2508:  MOVF   x1C,W
250A:  MULLW  19
250C:  MOVF   FF3,W
250E:  CLRF   x20
2510:  MOVWF  x1F
2512:  MOVLW  11
2514:  ADDWF  x1F,W
2516:  MOVWF  01
2518:  MOVLW  00
251A:  ADDWFC x20,W
251C:  MOVWF  03
251E:  MOVF   01,W
2520:  ADDLW  DA
2522:  MOVWF  01
2524:  MOVLW  00
2526:  ADDWFC 03,F
2528:  MOVFF  01,11F
252C:  MOVFF  03,120
2530:  MOVF   x1C,W
2532:  MULLW  24
2534:  MOVF   FF3,W
2536:  CLRF   x22
2538:  MOVWF  x21
253A:  MOVLW  16
253C:  ADDWF  x21,W
253E:  MOVWF  01
2540:  MOVLW  00
2542:  ADDWFC x22,W
2544:  MOVWF  03
2546:  MOVF   01,W
2548:  ADDLW  1B
254A:  MOVWF  FE9
254C:  MOVLW  00
254E:  ADDWFC 03,W
2550:  MOVWF  FEA
2552:  MOVFF  FEC,03
2556:  MOVF   FED,F
2558:  MOVFF  FEF,121
255C:  MOVFF  120,FEA
2560:  MOVFF  11F,FE9
2564:  MOVFF  03,FEC
2568:  MOVF   FED,F
256A:  MOVFF  121,FEF
.................... 		}
.................... 	}
.................... 
.................... 	/* High Temperature Disconnect. 65535 disables */
.................... 	if ( 65535 != config.ch[c].htd_disconnect_delay ) {
256E:  MOVF   x1C,W
2570:  MULLW  24
2572:  MOVF   FF3,W
2574:  CLRF   x20
2576:  MOVWF  x1F
2578:  MOVLW  1E
257A:  ADDWF  x1F,W
257C:  MOVWF  01
257E:  MOVLW  00
2580:  ADDWFC x20,W
2582:  MOVWF  03
2584:  MOVF   01,W
2586:  ADDLW  1B
2588:  MOVWF  FE9
258A:  MOVLW  00
258C:  ADDWFC 03,W
258E:  MOVWF  FEA
2590:  MOVFF  FEC,03
2594:  MOVF   FED,F
2596:  MOVF   FEF,W
2598:  SUBLW  FF
259A:  BNZ   25A2
259C:  INCFSZ 03,W
259E:  BRA    25A2
25A0:  BRA    2802
25A2:  CLRF   19
25A4:  BTFSC  FF2.7
25A6:  BSF    19.7
25A8:  BCF    FF2.7
.................... 		adc=adc_get(1);
25AA:  MOVLW  01
25AC:  MOVWF  x2F
25AE:  MOVLB  0
25B0:  CALL   0594
25B4:  BTFSC  19.7
25B6:  BSF    FF2.7
25B8:  MOVFF  02,11E
25BC:  MOVFF  01,11D
.................... 
.................... 		if ( adc > config.ch[c].htd_reconnect_adc ) {
25C0:  MOVLB  1
25C2:  MOVF   x1C,W
25C4:  MULLW  24
25C6:  MOVF   FF3,W
25C8:  CLRF   x20
25CA:  MOVWF  x1F
25CC:  MOVLW  20
25CE:  ADDWF  x1F,W
25D0:  MOVWF  01
25D2:  MOVLW  00
25D4:  ADDWFC x20,W
25D6:  MOVWF  03
25D8:  MOVF   01,W
25DA:  ADDLW  1B
25DC:  MOVWF  FE9
25DE:  MOVLW  00
25E0:  ADDWFC 03,W
25E2:  MOVWF  FEA
25E4:  MOVFF  FEC,03
25E8:  MOVF   FED,F
25EA:  MOVFF  FEF,01
25EE:  MOVF   03,W
25F0:  SUBWF  x1E,W
25F2:  BNC   267C
25F4:  BNZ   25FC
25F6:  MOVF   x1D,W
25F8:  SUBWF  01,W
25FA:  BC    267C
.................... 			if ( channel[c].htd_reconnect_delay_seconds > 0 ) {
25FC:  MOVF   x1C,W
25FE:  MULLW  19
2600:  MOVF   FF3,W
2602:  CLRF   x20
2604:  MOVWF  x1F
2606:  MOVLW  17
2608:  ADDWF  x1F,W
260A:  MOVWF  01
260C:  MOVLW  00
260E:  ADDWFC x20,W
2610:  MOVWF  03
2612:  MOVF   01,W
2614:  ADDLW  DA
2616:  MOVWF  FE9
2618:  MOVLW  00
261A:  ADDWFC 03,W
261C:  MOVWF  FEA
261E:  MOVFF  FEC,120
2622:  MOVF   FED,F
2624:  MOVFF  FEF,11F
2628:  MOVF   x1F,F
262A:  BNZ   2630
262C:  MOVF   x20,F
262E:  BZ    265E
.................... 				channel[c].htd_reconnect_delay_seconds--;
2630:  MOVF   x1C,W
2632:  MULLW  19
2634:  MOVF   FF3,W
2636:  CLRF   x20
2638:  MOVWF  x1F
263A:  MOVLW  17
263C:  ADDWF  x1F,W
263E:  MOVWF  01
2640:  MOVLW  00
2642:  ADDWFC x20,W
2644:  MOVWF  03
2646:  MOVF   01,W
2648:  ADDLW  DA
264A:  MOVWF  FE9
264C:  MOVLW  00
264E:  ADDWFC 03,W
2650:  MOVWF  FEA
2652:  MOVLW  FF
2654:  ADDWF  FEF,F
2656:  BC    265C
2658:  MOVF   FEE,F
265A:  DECF   FED,F
.................... 			} else {
265C:  BRA    267A
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_HTD);
265E:  MOVF   x1C,W
2660:  MULLW  19
2662:  MOVF   FF3,W
2664:  CLRF   x20
2666:  MOVWF  x1F
2668:  MOVLW  DA
266A:  ADDWF  x1F,W
266C:  MOVWF  01
266E:  MOVLW  00
2670:  ADDWFC x20,W
2672:  MOVFF  01,FE9
2676:  MOVWF  FEA
2678:  BCF    FEF.6
.................... 			}
.................... 		} else {
267A:  BRA    26E2
.................... 			channel[c].htd_reconnect_delay_seconds=config.ch[c].htd_reconnect_delay;
267C:  MOVF   x1C,W
267E:  MULLW  19
2680:  MOVF   FF3,W
2682:  CLRF   x20
2684:  MOVWF  x1F
2686:  MOVLW  17
2688:  ADDWF  x1F,W
268A:  MOVWF  01
268C:  MOVLW  00
268E:  ADDWFC x20,W
2690:  MOVWF  03
2692:  MOVF   01,W
2694:  ADDLW  DA
2696:  MOVWF  01
2698:  MOVLW  00
269A:  ADDWFC 03,F
269C:  MOVFF  01,11F
26A0:  MOVFF  03,120
26A4:  MOVF   x1C,W
26A6:  MULLW  24
26A8:  MOVF   FF3,W
26AA:  CLRF   x22
26AC:  MOVWF  x21
26AE:  MOVLW  22
26B0:  ADDWF  x21,W
26B2:  MOVWF  01
26B4:  MOVLW  00
26B6:  ADDWFC x22,W
26B8:  MOVWF  03
26BA:  MOVF   01,W
26BC:  ADDLW  1B
26BE:  MOVWF  FE9
26C0:  MOVLW  00
26C2:  ADDWFC 03,W
26C4:  MOVWF  FEA
26C6:  MOVFF  FEC,03
26CA:  MOVF   FED,F
26CC:  MOVFF  FEF,121
26D0:  MOVFF  120,FEA
26D4:  MOVFF  11F,FE9
26D8:  MOVFF  03,FEC
26DC:  MOVF   FED,F
26DE:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc < config.ch[c].htd_disconnect_adc ) {
26E2:  MOVF   x1C,W
26E4:  MULLW  24
26E6:  MOVF   FF3,W
26E8:  CLRF   x20
26EA:  MOVWF  x1F
26EC:  MOVLW  1C
26EE:  ADDWF  x1F,W
26F0:  MOVWF  01
26F2:  MOVLW  00
26F4:  ADDWFC x20,W
26F6:  MOVWF  03
26F8:  MOVF   01,W
26FA:  ADDLW  1B
26FC:  MOVWF  FE9
26FE:  MOVLW  00
2700:  ADDWFC 03,W
2702:  MOVWF  FEA
2704:  MOVFF  FEC,03
2708:  MOVF   FED,F
270A:  MOVFF  FEF,01
270E:  MOVF   x1E,W
2710:  SUBWF  03,W
2712:  BNC   279C
2714:  BNZ   271C
2716:  MOVF   01,W
2718:  SUBWF  x1D,W
271A:  BC    279C
.................... 			if ( channel[c].htd_disconnect_delay_seconds > 0 ) {
271C:  MOVF   x1C,W
271E:  MULLW  19
2720:  MOVF   FF3,W
2722:  CLRF   x20
2724:  MOVWF  x1F
2726:  MOVLW  15
2728:  ADDWF  x1F,W
272A:  MOVWF  01
272C:  MOVLW  00
272E:  ADDWFC x20,W
2730:  MOVWF  03
2732:  MOVF   01,W
2734:  ADDLW  DA
2736:  MOVWF  FE9
2738:  MOVLW  00
273A:  ADDWFC 03,W
273C:  MOVWF  FEA
273E:  MOVFF  FEC,120
2742:  MOVF   FED,F
2744:  MOVFF  FEF,11F
2748:  MOVF   x1F,F
274A:  BNZ   2750
274C:  MOVF   x20,F
274E:  BZ    277E
.................... 				channel[c].htd_disconnect_delay_seconds--;
2750:  MOVF   x1C,W
2752:  MULLW  19
2754:  MOVF   FF3,W
2756:  CLRF   x20
2758:  MOVWF  x1F
275A:  MOVLW  15
275C:  ADDWF  x1F,W
275E:  MOVWF  01
2760:  MOVLW  00
2762:  ADDWFC x20,W
2764:  MOVWF  03
2766:  MOVF   01,W
2768:  ADDLW  DA
276A:  MOVWF  FE9
276C:  MOVLW  00
276E:  ADDWFC 03,W
2770:  MOVWF  FEA
2772:  MOVLW  FF
2774:  ADDWF  FEF,F
2776:  BC    277C
2778:  MOVF   FEE,F
277A:  DECF   FED,F
.................... 			} else {
277C:  BRA    279A
.................... 				bit_set(channel[c].state,CH_STATE_BIT_HTD);
277E:  MOVF   x1C,W
2780:  MULLW  19
2782:  MOVF   FF3,W
2784:  CLRF   x20
2786:  MOVWF  x1F
2788:  MOVLW  DA
278A:  ADDWF  x1F,W
278C:  MOVWF  01
278E:  MOVLW  00
2790:  ADDWFC x20,W
2792:  MOVFF  01,FE9
2796:  MOVWF  FEA
2798:  BSF    FEF.6
.................... 			}
.................... 		} else {
279A:  BRA    2802
.................... 			channel[c].htd_disconnect_delay_seconds=config.ch[c].htd_disconnect_delay;
279C:  MOVF   x1C,W
279E:  MULLW  19
27A0:  MOVF   FF3,W
27A2:  CLRF   x20
27A4:  MOVWF  x1F
27A6:  MOVLW  15
27A8:  ADDWF  x1F,W
27AA:  MOVWF  01
27AC:  MOVLW  00
27AE:  ADDWFC x20,W
27B0:  MOVWF  03
27B2:  MOVF   01,W
27B4:  ADDLW  DA
27B6:  MOVWF  01
27B8:  MOVLW  00
27BA:  ADDWFC 03,F
27BC:  MOVFF  01,11F
27C0:  MOVFF  03,120
27C4:  MOVF   x1C,W
27C6:  MULLW  24
27C8:  MOVF   FF3,W
27CA:  CLRF   x22
27CC:  MOVWF  x21
27CE:  MOVLW  1E
27D0:  ADDWF  x21,W
27D2:  MOVWF  01
27D4:  MOVLW  00
27D6:  ADDWFC x22,W
27D8:  MOVWF  03
27DA:  MOVF   01,W
27DC:  ADDLW  1B
27DE:  MOVWF  FE9
27E0:  MOVLW  00
27E2:  ADDWFC 03,W
27E4:  MOVWF  FEA
27E6:  MOVFF  FEC,03
27EA:  MOVF   FED,F
27EC:  MOVFF  FEF,121
27F0:  MOVFF  120,FEA
27F4:  MOVFF  11F,FE9
27F8:  MOVFF  03,FEC
27FC:  MOVF   FED,F
27FE:  MOVFF  121,FEF
.................... 		}
.................... 	}
2802:  MOVLB  0
2804:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void led_status_update(void) {
.................... 	static int8 cycle=0;
.................... 	int8 led;
.................... 
.................... 	for ( led=0 ; led<2 ; led++ ) {
*
28C2:  MOVLB  1
28C4:  CLRF   x1C
28C6:  MOVF   x1C,W
28C8:  SUBLW  01
28CA:  BNC   29A0
.................... 		if ( cycle < 8 ) {
28CC:  MOVF   x11,W
28CE:  SUBLW  07
28D0:  BNC   2938
.................... 			/* first 8 cycles are 8 bits of state bit field */
.................... 
.................... 			/* if bit is set, then we blink the number of times+1 of the bit we are in. So bit 1 set means we blink 2 times */
.................... 			if ( bit_test(channel[led].state,cycle) ) {
28D2:  MOVF   x1C,W
28D4:  MULLW  19
28D6:  MOVF   FF3,W
28D8:  CLRF   x1E
28DA:  MOVWF  x1D
28DC:  MOVLW  DA
28DE:  ADDWF  x1D,W
28E0:  MOVWF  FE9
28E2:  MOVLW  00
28E4:  ADDWFC x1E,W
28E6:  MOVWF  FEA
28E8:  MOVFF  FEF,00
28EC:  MOVF   x11,W
28EE:  MOVWF  01
28F0:  BZ    28FA
28F2:  BCF    FD8.0
28F4:  RRCF   00,F
28F6:  DECFSZ 01,F
28F8:  BRA    28F2
28FA:  BTFSS  00.0
28FC:  BRA    2926
.................... 				timers.led_blink[led]=cycle+1;      /* number of blinks */
28FE:  CLRF   03
2900:  MOVF   x1C,W
2902:  ADDLW  D0
2904:  MOVWF  FE9
2906:  MOVLW  00
2908:  ADDWFC 03,W
290A:  MOVWF  FEA
290C:  MOVLW  01
290E:  ADDWF  x11,W
2910:  MOVWF  FEF
.................... 				timers.led_on[led]=BLINK_ON_TIME;   /* how long to be on */
2912:  CLRF   03
2914:  MOVF   x1C,W
2916:  ADDLW  D2
2918:  MOVWF  FE9
291A:  MOVLW  00
291C:  ADDWFC 03,W
291E:  MOVWF  FEA
2920:  MOVLW  FE
2922:  MOVWF  FEF
.................... 			} else {
2924:  BRA    2936
.................... 				timers.led_blink[led]=0;
2926:  CLRF   03
2928:  MOVF   x1C,W
292A:  ADDLW  D0
292C:  MOVWF  FE9
292E:  MOVLW  00
2930:  ADDWFC 03,W
2932:  MOVWF  FEA
2934:  CLRF   FEF
.................... 			}
.................... 		} else if ( 8 == cycle ) {
2936:  BRA    299C
2938:  MOVF   x11,W
293A:  SUBLW  08
293C:  BNZ   2950
.................... 			/* solid light to mark start of next cycle */
.................... 			timers.led_blink[led]=255;
293E:  CLRF   03
2940:  MOVF   x1C,W
2942:  ADDLW  D0
2944:  MOVWF  FE9
2946:  MOVLW  00
2948:  ADDWFC 03,W
294A:  MOVWF  FEA
294C:  SETF   FEF
.................... 		} else if ( 9 == cycle ) {
294E:  BRA    299C
2950:  MOVF   x11,W
2952:  SUBLW  09
2954:  BNZ   298C
.................... 			/* solid on if contactor state is on, otherwise off */
.................... 			if ( timers.contactor[led] ) {
2956:  CLRF   03
2958:  MOVF   x1C,W
295A:  ADDLW  D6
295C:  MOVWF  FE9
295E:  MOVLW  00
2960:  ADDWFC 03,W
2962:  MOVWF  FEA
2964:  MOVF   FEF,F
2966:  BZ    297A
.................... 				timers.led_blink[led]=255;
2968:  CLRF   03
296A:  MOVF   x1C,W
296C:  ADDLW  D0
296E:  MOVWF  FE9
2970:  MOVLW  00
2972:  ADDWFC 03,W
2974:  MOVWF  FEA
2976:  SETF   FEF
.................... 			} else {
2978:  BRA    298A
.................... 				timers.led_blink[led]=0;
297A:  CLRF   03
297C:  MOVF   x1C,W
297E:  ADDLW  D0
2980:  MOVWF  FE9
2982:  MOVLW  00
2984:  ADDWFC 03,W
2986:  MOVWF  FEA
2988:  CLRF   FEF
.................... 			}
.................... 		} else {
298A:  BRA    299C
.................... 			/* blank period before starting the bit field */
.................... 			timers.led_blink[led]=0;
298C:  CLRF   03
298E:  MOVF   x1C,W
2990:  ADDLW  D0
2992:  MOVWF  FE9
2994:  MOVLW  00
2996:  ADDWFC 03,W
2998:  MOVWF  FEA
299A:  CLRF   FEF
.................... 		}
299C:  INCF   x1C,F
299E:  BRA    28C6
.................... 	}
.................... 
.................... //	fprintf(STREAM_FTDI,"# LED %u A=%03u (0x%02X) B=%03u (0x%02X)\r\n",cycle,timers.led_blink[0],channel[0].state,timers.led_blink[1],channel[1].state);
.................... 
.................... 	if ( 10 == cycle ) {
29A0:  MOVF   x11,W
29A2:  SUBLW  0A
29A4:  BNZ   29AA
.................... 		cycle=0; 
29A6:  CLRF   x11
.................... 	} else {
29A8:  BRA    29AC
.................... 		cycle++;
29AA:  INCF   x11,F
.................... 	}
29AC:  MOVLB  0
29AE:  GOTO   2B5C (RETURN)
.................... }
.................... 
.................... void led_on(int8 c) {
.................... 	if ( 0==c ) 
*
199A:  MOVLB  1
199C:  MOVF   x1C,F
199E:  BNZ   19A6
.................... 		output_high(LED_A);
19A0:  BCF    F94.1
19A2:  BSF    F8B.1
19A4:  BRA    19AA
.................... 	else
.................... 		output_high(LED_B);
19A6:  BCF    F94.2
19A8:  BSF    F8B.2
19AA:  MOVLB  0
19AC:  RETURN 0
.................... }
.................... 
.................... void led_off(int8 c) {
.................... 	if ( 0==c ) 
19AE:  MOVLB  1
19B0:  MOVF   x1C,F
19B2:  BNZ   19BA
.................... 		output_low(LED_A);
19B4:  BCF    F94.1
19B6:  BCF    F8B.1
19B8:  BRA    19BE
.................... 	else
.................... 		output_low(LED_B);
19BA:  BCF    F94.2
19BC:  BCF    F8B.2
19BE:  MOVLB  0
19C0:  RETURN 0
.................... }
.................... 
.................... void periodic_millisecond(void) {
.................... 	static int8  uptimeTicks=0;
.................... 	static int8  statusTicks=0;
.................... 	static int16 adcTicks=0;
.................... 	static int16 ticks=0;
.................... 
.................... 	int8 i;
.................... 
.................... 
.................... 	timers.now_millisecond=0;
*
29B2:  BCF    xCF.2
.................... 
.................... 	/* set LED output */
.................... 	for ( i=0 ; i<2 ; i++ ) {
29B4:  MOVLB  1
29B6:  CLRF   x1B
29B8:  MOVF   x1B,W
29BA:  SUBLW  01
29BC:  BTFSS  FD8.0
29BE:  BRA    2ABE
.................... 		if ( 255 == timers.led_blink[i] ) {
29C0:  CLRF   03
29C2:  MOVF   x1B,W
29C4:  ADDLW  D0
29C6:  MOVWF  FE9
29C8:  MOVLW  00
29CA:  ADDWFC 03,W
29CC:  MOVWF  FEA
29CE:  MOVF   FEF,W
29D0:  SUBLW  FF
29D2:  BNZ   29E2
.................... 			led_on(i);
29D4:  MOVFF  11B,11C
29D8:  MOVLB  0
29DA:  CALL   199A
.................... 		} else if ( 0 == timers.led_blink[i] ) {
29DE:  BRA    2AB8
29E0:  MOVLB  1
29E2:  CLRF   03
29E4:  MOVF   x1B,W
29E6:  ADDLW  D0
29E8:  MOVWF  FE9
29EA:  MOVLW  00
29EC:  ADDWFC 03,W
29EE:  MOVWF  FEA
29F0:  MOVF   FEF,W
29F2:  BNZ   2A02
.................... 			led_off(i);
29F4:  MOVFF  11B,11C
29F8:  MOVLB  0
29FA:  CALL   19AE
.................... 		} else {
29FE:  BRA    2AB8
2A00:  MOVLB  1
.................... 			/* led_blink[i] is somewhere between 1 and 254 */
.................... 			if ( timers.led_on[i] > 0 ) {
2A02:  CLRF   03
2A04:  MOVF   x1B,W
2A06:  ADDLW  D2
2A08:  MOVWF  FE9
2A0A:  MOVLW  00
2A0C:  ADDWFC 03,W
2A0E:  MOVWF  FEA
2A10:  MOVF   FEF,F
2A12:  BZ    2A54
.................... 				led_on(i);
2A14:  MOVFF  11B,11C
2A18:  MOVLB  0
2A1A:  CALL   199A
.................... 				timers.led_on[i]--;
2A1E:  CLRF   03
2A20:  MOVLB  1
2A22:  MOVF   x1B,W
2A24:  ADDLW  D2
2A26:  MOVWF  FE9
2A28:  MOVLW  00
2A2A:  ADDWFC 03,W
2A2C:  MOVWF  FEA
2A2E:  DECF   FEF,F
.................... 
.................... 				if ( 0==timers.led_on[i] ) {
2A30:  CLRF   03
2A32:  MOVF   x1B,W
2A34:  ADDLW  D2
2A36:  MOVWF  FE9
2A38:  MOVLW  00
2A3A:  ADDWFC 03,W
2A3C:  MOVWF  FEA
2A3E:  MOVF   FEF,W
2A40:  BNZ   2A54
.................... 					/* hit zero, switch to our off timer */
.................... 					timers.led_off[i]=BLINK_OFF_TIME;
2A42:  CLRF   03
2A44:  MOVF   x1B,W
2A46:  ADDLW  D4
2A48:  MOVWF  FE9
2A4A:  MOVLW  00
2A4C:  ADDWFC 03,W
2A4E:  MOVWF  FEA
2A50:  MOVLW  C8
2A52:  MOVWF  FEF
.................... 				}
.................... 			}
.................... 
.................... 			if ( timers.led_off[i] > 0 ) {
2A54:  CLRF   03
2A56:  MOVF   x1B,W
2A58:  ADDLW  D4
2A5A:  MOVWF  FE9
2A5C:  MOVLW  00
2A5E:  ADDWFC 03,W
2A60:  MOVWF  FEA
2A62:  MOVF   FEF,F
2A64:  BZ    2AB6
.................... 				led_off(i);
2A66:  MOVFF  11B,11C
2A6A:  MOVLB  0
2A6C:  CALL   19AE
.................... 				timers.led_off[i]--;
2A70:  CLRF   03
2A72:  MOVLB  1
2A74:  MOVF   x1B,W
2A76:  ADDLW  D4
2A78:  MOVWF  FE9
2A7A:  MOVLW  00
2A7C:  ADDWFC 03,W
2A7E:  MOVWF  FEA
2A80:  DECF   FEF,F
.................... 
.................... 				if ( 0==timers.led_off[i] ) {
2A82:  CLRF   03
2A84:  MOVF   x1B,W
2A86:  ADDLW  D4
2A88:  MOVWF  FE9
2A8A:  MOVLW  00
2A8C:  ADDWFC 03,W
2A8E:  MOVWF  FEA
2A90:  MOVF   FEF,W
2A92:  BNZ   2AB6
.................... 					/* hit zero, preload for next */
.................... 					timers.led_on[i]=BLINK_ON_TIME;
2A94:  CLRF   03
2A96:  MOVF   x1B,W
2A98:  ADDLW  D2
2A9A:  MOVWF  FE9
2A9C:  MOVLW  00
2A9E:  ADDWFC 03,W
2AA0:  MOVWF  FEA
2AA2:  MOVLW  FE
2AA4:  MOVWF  FEF
.................... 					/* done with this blink cycle */	
.................... 					timers.led_blink[i]--;
2AA6:  CLRF   03
2AA8:  MOVF   x1B,W
2AAA:  ADDLW  D0
2AAC:  MOVWF  FE9
2AAE:  MOVLW  00
2AB0:  ADDWFC 03,W
2AB2:  MOVWF  FEA
2AB4:  DECF   FEF,F
2AB6:  MOVLB  0
.................... 				}
.................... 			}
.................... 		}
2AB8:  MOVLB  1
2ABA:  INCF   x1B,F
2ABC:  BRA    29B8
.................... 	}
.................... 
.................... 
.................... 	/* some other random stuff that we don't need to do every cycle in main */
.................... 	if ( current.interval_milliseconds < 65535 ) {
2ABE:  MOVLB  0
2AC0:  INCFSZ xC8,W
2AC2:  BRA    2ACA
2AC4:  INCFSZ xC9,W
2AC6:  BRA    2ACA
2AC8:  BRA    2AD0
.................... 		current.interval_milliseconds++;
2ACA:  INCF   xC8,F
2ACC:  BTFSC  FD8.2
2ACE:  INCF   xC9,F
.................... 	}
.................... 
.................... 
.................... 	/* contactor timeout */
.................... 	if ( 0 == timers.contactor_powersave[0] ) {
2AD0:  MOVF   xD8,F
2AD2:  BNZ   2ADE
.................... 		output_low(BRIDGE_A_A);
2AD4:  BCF    F94.3
2AD6:  BCF    F8B.3
.................... 		output_low(BRIDGE_A_B);
2AD8:  BCF    F94.4
2ADA:  BCF    F8B.4
.................... 	} else {
2ADC:  BRA    2AE0
.................... 		timers.contactor_powersave[0]--;
2ADE:  DECF   xD8,F
.................... 	}
.................... 	if ( 0 == timers.contactor_powersave[1] ) {
2AE0:  MOVF   xD9,F
2AE2:  BNZ   2AEE
.................... 		output_low(BRIDGE_B_A);
2AE4:  BCF    F94.5
2AE6:  BCF    F8B.5
.................... 		output_low(BRIDGE_B_B);
2AE8:  BCF    F94.6
2AEA:  BCF    F8B.6
.................... 	} else {
2AEC:  BRA    2AF0
.................... 		timers.contactor_powersave[1]--;
2AEE:  DECF   xD9,F
.................... 	}
.................... 
.................... 
.................... 
.................... 
.................... 	/* seconds */
.................... 	ticks++;
2AF0:  MOVLB  1
2AF2:  INCF   x16,F
2AF4:  BTFSC  FD8.2
2AF6:  INCF   x17,F
.................... 	if ( 1000 == ticks ) {
2AF8:  MOVF   x16,W
2AFA:  SUBLW  E8
2AFC:  BNZ   2B5E
2AFE:  MOVF   x17,W
2B00:  SUBLW  03
2B02:  BNZ   2B5E
.................... 		ticks=0;
2B04:  CLRF   x17
2B06:  CLRF   x16
.................... 
.................... 		/* set channe[n].state based on logic */
.................... 		contactor_logic(0);
2B08:  CLRF   x1C
2B0A:  MOVLB  0
2B0C:  CALL   19C2
.................... 		contactor_logic(1);
2B10:  MOVLW  01
2B12:  MOVLB  1
2B14:  MOVWF  x1C
2B16:  MOVLB  0
2B18:  CALL   19C2
.................... 
.................... 		/* set contactor outputs based on their state bit field */
.................... 		contactor_set(0);
2B1C:  MOVLB  1
2B1E:  CLRF   x1C
2B20:  MOVLB  0
2B22:  RCALL  285E
.................... 		contactor_set(1);		
2B24:  MOVLW  01
2B26:  MOVLB  1
2B28:  MOVWF  x1C
2B2A:  MOVLB  0
2B2C:  RCALL  285E
.................... 
.................... 		/* uptime counter */
.................... 		uptimeTicks++;
2B2E:  MOVLB  1
2B30:  INCF   x12,F
.................... 		if ( 60 == uptimeTicks ) {
2B32:  MOVF   x12,W
2B34:  SUBLW  3C
2B36:  BNZ   2B4E
.................... 			uptimeTicks=0;
2B38:  CLRF   x12
.................... 			if ( current.uptime_minutes < 65535 ) 
2B3A:  MOVLB  0
2B3C:  INCFSZ xC6,W
2B3E:  BRA    2B46
2B40:  INCFSZ xC7,W
2B42:  BRA    2B46
2B44:  BRA    2B4C
.................... 				current.uptime_minutes++;
2B46:  INCF   xC6,F
2B48:  BTFSC  FD8.2
2B4A:  INCF   xC7,F
2B4C:  MOVLB  1
.................... 		}
.................... 
.................... 		/* LED status update every 4 seconds */
.................... 		statusTicks++;
2B4E:  INCF   x13,F
.................... 		if ( 4 == statusTicks ) {
2B50:  MOVF   x13,W
2B52:  SUBLW  04
2B54:  BNZ   2B5E
.................... 			/* LED state display update */
.................... 			statusTicks=0;
2B56:  CLRF   x13
.................... 			led_status_update();
2B58:  MOVLB  0
2B5A:  BRA    28C2
2B5C:  MOVLB  1
.................... 		}
.................... 
.................... 
.................... 	}
.................... 
.................... 	/* ADC sample counter */
.................... 	if ( timers.now_adc_reset_count ) {
2B5E:  MOVLB  0
2B60:  BTFSS  xCF.1
2B62:  BRA    2B6E
.................... 		timers.now_adc_reset_count=0;
2B64:  BCF    xCF.1
.................... 		adcTicks=0;
2B66:  MOVLB  1
2B68:  CLRF   x15
2B6A:  CLRF   x14
2B6C:  MOVLB  0
.................... 	}
.................... 
.................... 	/* ADC sampling trigger */
.................... 	adcTicks++;
2B6E:  MOVLB  1
2B70:  INCF   x14,F
2B72:  BTFSC  FD8.2
2B74:  INCF   x15,F
.................... 	if ( ADC_SAMPLE_TICKS == adcTicks ) {
2B76:  MOVF   x14,W
2B78:  SUBLW  14
2B7A:  BNZ   2B8A
2B7C:  MOVF   x15,F
2B7E:  BNZ   2B8A
.................... 		adcTicks=0;
2B80:  CLRF   x15
2B82:  CLRF   x14
.................... 		timers.now_adc_sample=1;
2B84:  MOVLB  0
2B86:  BSF    xCF.0
2B88:  MOVLB  1
.................... 	}
2B8A:  MOVLB  0
2B8C:  GOTO   2F8A (RETURN)
.................... 
.................... }
.................... 
.................... void init(void) {
.................... 	int8 i;
.................... 	int8 buff[10];
.................... 	setup_oscillator(OSC_16MHZ);
*
1100:  MOVLW  70
1102:  MOVWF  FD3
1104:  BCF    F9B.6
1106:  BCF    F9B.7
.................... 
.................... 	setup_adc(ADC_CLOCK_DIV_16);
1108:  MOVF   FC0,W
110A:  ANDLW  C0
110C:  IORLW  05
110E:  MOVWF  FC0
1110:  BSF    FC0.7
1112:  BSF    FC2.0
.................... 	/* NTC thermistor on sAN2, input voltage divider on sAN4, DIP switch analog on sAN9
.................... 	voltage spans between 0 and Vdd */
.................... 	setup_adc_ports(sAN2 | sAN4 | sAN9,VSS_VDD);
1114:  MOVLW  14
1116:  MOVWF  F7E
1118:  BCF    FC1.0
111A:  BCF    FC1.1
111C:  BCF    FC1.2
111E:  BCF    FC1.3
1120:  MOVLW  02
1122:  MOVWF  F7F
.................... 
.................... 	setup_wdt(WDT_512MS); /* forces the fuse to WDT128 */
1124:  BSF    FD1.0
.................... 
.................... 	set_tris_a(0b00111111);
1126:  MOVLW  3F
1128:  MOVWF  F92
.................... 	set_tris_b(0b01110000);
112A:  MOVLW  70
112C:  MOVWF  F93
.................... 	set_tris_c(0b10000001);
112E:  MOVLW  81
1130:  MOVWF  F94
.................... //               76543210
.................... 
.................... 	port_a_pullups(0b00110000);
1132:  MOVLW  30
1134:  MOVWF  F77
1136:  BCF    FF1.7
.................... 	port_b_pullups(0b00000000);
1138:  CLRF   F78
.................... //                   76543210
.................... 
.................... 	/* data structure initialization */
.................... 	/* all initialized to 0 on declaration. Just do this if need non-zero */
.................... 	for ( i=0 ; i<=1 ; i++ ) {
113A:  MOVLB  1
113C:  CLRF   x1B
113E:  MOVF   x1B,W
1140:  SUBLW  01
1142:  BNC   1198
.................... 		channel[i].command_off_seconds=65535;
1144:  MOVF   x1B,W
1146:  MULLW  19
1148:  MOVF   FF3,W
114A:  CLRF   x27
114C:  MOVWF  x26
114E:  MOVLW  05
1150:  ADDWF  x26,W
1152:  MOVWF  01
1154:  MOVLW  00
1156:  ADDWFC x27,W
1158:  MOVWF  03
115A:  MOVF   01,W
115C:  ADDLW  DA
115E:  MOVWF  FE9
1160:  MOVLW  00
1162:  ADDWFC 03,W
1164:  MOVWF  FEA
1166:  SETF   FEC
1168:  MOVF   FED,F
116A:  SETF   FEF
.................... 		channel[i].command_on_seconds =65535;
116C:  MOVF   x1B,W
116E:  MULLW  19
1170:  MOVF   FF3,W
1172:  CLRF   x27
1174:  MOVWF  x26
1176:  MOVLW  01
1178:  ADDWF  x26,W
117A:  MOVWF  01
117C:  MOVLW  00
117E:  ADDWFC x27,W
1180:  MOVWF  03
1182:  MOVF   01,W
1184:  ADDLW  DA
1186:  MOVWF  FE9
1188:  MOVLW  00
118A:  ADDWFC 03,W
118C:  MOVWF  FEA
118E:  SETF   FEC
1190:  MOVF   FED,F
1192:  SETF   FEF
1194:  INCF   x1B,F
1196:  BRA    113E
.................... 	}
.................... 
.................... 	/* get our compiled date from constant  
.................... 	'5-Feb-22'
.................... 	 01234567
.................... 
.................... 	'25-Feb-22'
.................... 	 012345678
.................... 	*/
.................... 	strcpy(buff,__DATE__);
1198:  MOVLW  01
119A:  MOVWF  FEA
119C:  MOVLW  1C
119E:  MOVWF  FE9
11A0:  MOVLW  00
11A2:  MOVLB  0
11A4:  CALL   00BA
11A8:  TBLRD*-
11AA:  TBLRD*+
11AC:  MOVF   FF5,W
11AE:  MOVWF  FEE
11B0:  IORLW  00
11B2:  BNZ   11AA
.................... 	i=0;
11B4:  MOVLB  1
11B6:  CLRF   x1B
.................... 	if ( '-' != buff[1] ) {
11B8:  MOVF   x1D,W
11BA:  SUBLW  2D
11BC:  BZ    11DC
.................... 		/* day can be one or two digits */
.................... 		current.compile_day =(buff[i]-'0')*10;
11BE:  CLRF   03
11C0:  MOVF   x1B,W
11C2:  ADDLW  1C
11C4:  MOVWF  FE9
11C6:  MOVLW  01
11C8:  ADDWFC 03,W
11CA:  MOVWF  FEA
11CC:  MOVLW  30
11CE:  SUBWF  FEF,W
11D0:  MULLW  0A
11D2:  MOVFF  FF3,CD
11D6:  MOVLB  0
.................... 		i++;
11D8:  MOVLB  1
11DA:  INCF   x1B,F
.................... 	}
.................... 	current.compile_day+=(buff[i]-'0');
11DC:  CLRF   03
11DE:  MOVF   x1B,W
11E0:  ADDLW  1C
11E2:  MOVWF  FE9
11E4:  MOVLW  01
11E6:  ADDWFC 03,W
11E8:  MOVWF  FEA
11EA:  MOVLW  30
11EC:  SUBWF  FEF,W
11EE:  MOVLB  0
11F0:  ADDWF  xCD,F
.................... 	i+=2; /* now points to month */
11F2:  MOVLW  02
11F4:  MOVLB  1
11F6:  ADDWF  x1B,F
.................... 
.................... 	/* determine month ... how annoying */
.................... 	if ( 'J'==buff[i+0] ) {
11F8:  CLRF   03
11FA:  MOVF   x1B,W
11FC:  ADDLW  1C
11FE:  MOVWF  FE9
1200:  MOVLW  01
1202:  ADDWFC 03,W
1204:  MOVWF  FEA
1206:  MOVF   FEF,W
1208:  SUBLW  4A
120A:  BNZ   1256
.................... 		if ( 'A'==buff[i+1] )
120C:  MOVLW  01
120E:  ADDWF  x1B,W
1210:  CLRF   03
1212:  ADDLW  1C
1214:  MOVWF  FE9
1216:  MOVLW  01
1218:  ADDWFC 03,W
121A:  MOVWF  FEA
121C:  MOVF   FEF,W
121E:  SUBLW  41
1220:  BNZ   122C
.................... 			current.compile_month=1;
1222:  MOVLW  01
1224:  MOVLB  0
1226:  MOVWF  xCC
1228:  BRA    1252
122A:  MOVLB  1
.................... 		else if ( 'N'==buff[i+2] )
122C:  MOVLW  02
122E:  ADDWF  x1B,W
1230:  CLRF   03
1232:  ADDLW  1C
1234:  MOVWF  FE9
1236:  MOVLW  01
1238:  ADDWFC 03,W
123A:  MOVWF  FEA
123C:  MOVF   FEF,W
123E:  SUBLW  4E
1240:  BNZ   124C
.................... 			current.compile_month=6;
1242:  MOVLW  06
1244:  MOVLB  0
1246:  MOVWF  xCC
1248:  BRA    1252
124A:  MOVLB  1
.................... 		else
.................... 			current.compile_month=7;
124C:  MOVLW  07
124E:  MOVLB  0
1250:  MOVWF  xCC
.................... 	} else if ( 'A'==buff[i+0] ) {
1252:  BRA    136C
1254:  MOVLB  1
1256:  CLRF   03
1258:  MOVF   x1B,W
125A:  ADDLW  1C
125C:  MOVWF  FE9
125E:  MOVLW  01
1260:  ADDWFC 03,W
1262:  MOVWF  FEA
1264:  MOVF   FEF,W
1266:  SUBLW  41
1268:  BNZ   1294
.................... 		if ( 'P'==buff[i+1] )
126A:  MOVLW  01
126C:  ADDWF  x1B,W
126E:  CLRF   03
1270:  ADDLW  1C
1272:  MOVWF  FE9
1274:  MOVLW  01
1276:  ADDWFC 03,W
1278:  MOVWF  FEA
127A:  MOVF   FEF,W
127C:  SUBLW  50
127E:  BNZ   128A
.................... 			current.compile_month=4;
1280:  MOVLW  04
1282:  MOVLB  0
1284:  MOVWF  xCC
1286:  BRA    1290
1288:  MOVLB  1
.................... 		else
.................... 			current.compile_month=8;
128A:  MOVLW  08
128C:  MOVLB  0
128E:  MOVWF  xCC
.................... 	} else if ( 'M'==buff[i+0] ) {
1290:  BRA    136C
1292:  MOVLB  1
1294:  CLRF   03
1296:  MOVF   x1B,W
1298:  ADDLW  1C
129A:  MOVWF  FE9
129C:  MOVLW  01
129E:  ADDWFC 03,W
12A0:  MOVWF  FEA
12A2:  MOVF   FEF,W
12A4:  SUBLW  4D
12A6:  BNZ   12D2
.................... 		if ( 'R'==buff[i+2] )
12A8:  MOVLW  02
12AA:  ADDWF  x1B,W
12AC:  CLRF   03
12AE:  ADDLW  1C
12B0:  MOVWF  FE9
12B2:  MOVLW  01
12B4:  ADDWFC 03,W
12B6:  MOVWF  FEA
12B8:  MOVF   FEF,W
12BA:  SUBLW  52
12BC:  BNZ   12C8
.................... 			current.compile_month=3;
12BE:  MOVLW  03
12C0:  MOVLB  0
12C2:  MOVWF  xCC
12C4:  BRA    12CE
12C6:  MOVLB  1
.................... 		else
.................... 			current.compile_month=5;
12C8:  MOVLW  05
12CA:  MOVLB  0
12CC:  MOVWF  xCC
.................... 	} else if ( 'F'==buff[i+0] ) {
12CE:  BRA    136C
12D0:  MOVLB  1
12D2:  CLRF   03
12D4:  MOVF   x1B,W
12D6:  ADDLW  1C
12D8:  MOVWF  FE9
12DA:  MOVLW  01
12DC:  ADDWFC 03,W
12DE:  MOVWF  FEA
12E0:  MOVF   FEF,W
12E2:  SUBLW  46
12E4:  BNZ   12F0
.................... 		current.compile_month=2;
12E6:  MOVLW  02
12E8:  MOVLB  0
12EA:  MOVWF  xCC
.................... 	} else if ( 'S'==buff[i+0] ) {
12EC:  BRA    136C
12EE:  MOVLB  1
12F0:  CLRF   03
12F2:  MOVF   x1B,W
12F4:  ADDLW  1C
12F6:  MOVWF  FE9
12F8:  MOVLW  01
12FA:  ADDWFC 03,W
12FC:  MOVWF  FEA
12FE:  MOVF   FEF,W
1300:  SUBLW  53
1302:  BNZ   130E
.................... 		current.compile_month=9;
1304:  MOVLW  09
1306:  MOVLB  0
1308:  MOVWF  xCC
.................... 	} else if ( 'O'==buff[i+0] ) {
130A:  BRA    136C
130C:  MOVLB  1
130E:  CLRF   03
1310:  MOVF   x1B,W
1312:  ADDLW  1C
1314:  MOVWF  FE9
1316:  MOVLW  01
1318:  ADDWFC 03,W
131A:  MOVWF  FEA
131C:  MOVF   FEF,W
131E:  SUBLW  4F
1320:  BNZ   132C
.................... 		current.compile_month=10;
1322:  MOVLW  0A
1324:  MOVLB  0
1326:  MOVWF  xCC
.................... 	} else if ( 'N'==buff[i+0] ) {
1328:  BRA    136C
132A:  MOVLB  1
132C:  CLRF   03
132E:  MOVF   x1B,W
1330:  ADDLW  1C
1332:  MOVWF  FE9
1334:  MOVLW  01
1336:  ADDWFC 03,W
1338:  MOVWF  FEA
133A:  MOVF   FEF,W
133C:  SUBLW  4E
133E:  BNZ   134A
.................... 		current.compile_month=11;
1340:  MOVLW  0B
1342:  MOVLB  0
1344:  MOVWF  xCC
.................... 	} else if ( 'D'==buff[i+0] ) {
1346:  BRA    136C
1348:  MOVLB  1
134A:  CLRF   03
134C:  MOVF   x1B,W
134E:  ADDLW  1C
1350:  MOVWF  FE9
1352:  MOVLW  01
1354:  ADDWFC 03,W
1356:  MOVWF  FEA
1358:  MOVF   FEF,W
135A:  SUBLW  44
135C:  BNZ   1368
.................... 		current.compile_month=12;
135E:  MOVLW  0C
1360:  MOVLB  0
1362:  MOVWF  xCC
.................... 	} else {
1364:  BRA    136C
1366:  MOVLB  1
.................... 		/* error parsing, shouldn't happen */
.................... 		current.compile_month=255;
1368:  MOVLB  0
136A:  SETF   xCC
.................... 	}
.................... 	current.compile_year =(buff[i+4]-'0')*10;
136C:  MOVLW  04
136E:  MOVLB  1
1370:  ADDWF  x1B,W
1372:  CLRF   03
1374:  ADDLW  1C
1376:  MOVWF  FE9
1378:  MOVLW  01
137A:  ADDWFC 03,W
137C:  MOVWF  FEA
137E:  MOVLW  30
1380:  SUBWF  FEF,W
1382:  MULLW  0A
1384:  MOVFF  FF3,CB
1388:  MOVLB  0
.................... 	current.compile_year+=(buff[i+5]-'0');
138A:  MOVLW  05
138C:  MOVLB  1
138E:  ADDWF  x1B,W
1390:  CLRF   03
1392:  ADDLW  1C
1394:  MOVWF  FE9
1396:  MOVLW  01
1398:  ADDWFC 03,W
139A:  MOVWF  FEA
139C:  MOVLW  30
139E:  SUBWF  FEF,W
13A0:  MOVLB  0
13A2:  ADDWF  xCB,F
.................... 
.................... 
.................... 	/* one periodic interrupt @ 1mS. Generated from system 16 MHz clock */
.................... 	/* prescale=16, match=249, postscale=1. Match is 249 because when match occurs, one cycle is lost */
.................... 	setup_timer_2(T2_DIV_BY_16,249,1);
13A4:  MOVLW  00
13A6:  IORLW  06
13A8:  MOVWF  FCA
13AA:  MOVLW  F9
13AC:  MOVWF  FCB
.................... 
.................... 	enable_interrupts(INT_TIMER2);
13AE:  BSF    F9D.1
.................... 
.................... 	/* set I2C slave address, which is always an even number */
.................... 	i2c_slaveaddr(STREAM_SLAVE,0x3e + (read_dip_switch()<<1) );
13B0:  BRA    108E
13B2:  BCF    FD8.0
13B4:  RLCF   01,W
13B6:  ADDLW  3E
13B8:  MOVLB  1
13BA:  MOVWF  FC8
13BC:  MOVLB  0
13BE:  GOTO   2E3A (RETURN)
.................... }
.................... 
.................... 
.................... void main(void) {
*
2DAC:  CLRF   FF8
2DAE:  BCF    FD0.7
2DB0:  BSF    07.7
2DB2:  BSF    F93.6
2DB4:  BSF    F93.4
2DB6:  CLRF   FC8
2DB8:  MOVLW  36
2DBA:  MOVWF  FC6
2DBC:  BSF    FC5.0
2DBE:  BSF    FC5.7
2DC0:  CLRF   1A
2DC2:  BSF    FB8.3
2DC4:  MOVLW  44
2DC6:  MOVWF  FAF
2DC8:  MOVLW  00
2DCA:  MOVWF  FB0
2DCC:  MOVLW  A6
2DCE:  MOVWF  FAC
2DD0:  MOVLW  90
2DD2:  MOVWF  FAB
2DD4:  MOVLB  1
2DD6:  CLRF   x19
2DD8:  CLRF   x18
2DDA:  MOVLW  00
2DDC:  MOVWF  F7E
2DDE:  BCF    FC1.0
2DE0:  BCF    FC1.1
2DE2:  BCF    FC1.2
2DE4:  BCF    FC1.3
2DE6:  MOVWF  F7F
2DE8:  CLRF   F6C
2DEA:  CLRF   F6B
2DEC:  CLRF   F6D
2DEE:  BRA    2DF6
2DF0:  DATA FD,40
2DF2:  DATA 1B,00
2DF4:  DATA 00,00
2DF6:  MOVLW  00
2DF8:  MOVWF  FF8
2DFA:  MOVLW  2D
2DFC:  MOVWF  FF7
2DFE:  MOVLW  F0
2E00:  MOVWF  FF6
2E02:  TBLRD*+
2E04:  MOVF   FF5,W
2E06:  MOVWF  00
2E08:  XORLW  00
2E0A:  BZ    2E32
2E0C:  TBLRD*+
2E0E:  MOVF   FF5,W
2E10:  MOVWF  01
2E12:  BTFSC  FE8.7
2E14:  BRA    2E20
2E16:  ANDLW  3F
2E18:  MOVWF  FEA
2E1A:  TBLRD*+
2E1C:  MOVFF  FF5,FE9
2E20:  BTFSC  01.6
2E22:  TBLRD*+
2E24:  BTFSS  01.6
2E26:  TBLRD*+
2E28:  MOVFF  FF5,FEE
2E2C:  DCFSNZ 00,F
2E2E:  BRA    2E02
2E30:  BRA    2E24
2E32:  CLRF   FF8
.................... 	int8 i;
.................... 
.................... 	init();
2E34:  MOVLB  0
2E36:  GOTO   1100
.................... 
.................... 	/* force off both contactors */
.................... 	timers.contactor[0]=1;
2E3A:  MOVLW  01
2E3C:  MOVWF  xD6
.................... 	timers.contactor[1]=1;
2E3E:  MOVWF  xD7
.................... 	contactor_off(0);
2E40:  MOVLB  1
2E42:  CLRF   x1E
2E44:  MOVLB  0
2E46:  CALL   13C2
.................... 	contactor_off(1);
2E4A:  MOVLW  01
2E4C:  MOVLB  1
2E4E:  MOVWF  x1E
2E50:  MOVLB  0
2E52:  CALL   13C2
.................... 
.................... 
.................... 	/* read parameters from EEPROM and write defaults if CRC doesn't match */
.................... 	read_param_file();
2E56:  GOTO   1866
.................... 
.................... 
.................... 	/* flash on startup */
.................... 	for ( i=0 ; i<5 ; i++ ) {
2E5A:  MOVLB  1
2E5C:  CLRF   x1A
2E5E:  MOVF   x1A,W
2E60:  SUBLW  04
2E62:  BNC   2E8A
.................... 		restart_wdt();
2E64:  CLRWDT
.................... 		output_high(LED_A);
2E66:  BCF    F94.1
2E68:  BSF    F8B.1
.................... 		delay_ms(200);
2E6A:  MOVLW  C8
2E6C:  MOVWF  x28
2E6E:  MOVLB  0
2E70:  CALL   1064
.................... 		output_low(LED_A);
2E74:  BCF    F94.1
2E76:  BCF    F8B.1
.................... 		delay_ms(200);
2E78:  MOVLW  C8
2E7A:  MOVLB  1
2E7C:  MOVWF  x28
2E7E:  MOVLB  0
2E80:  CALL   1064
2E84:  MOVLB  1
2E86:  INCF   x1A,F
2E88:  BRA    2E5E
.................... 	}
.................... 
.................... 	fprintf(STREAM_FTDI,"# dcswc_module_latching_contactor %s\r\n# ",__DATE__);
2E8A:  MOVLW  B8
2E8C:  MOVWF  FF6
2E8E:  MOVLW  0F
2E90:  MOVWF  FF7
2E92:  MOVLW  22
2E94:  MOVWF  x1D
2E96:  MOVLB  0
2E98:  CALL   18AC
2E9C:  MOVLW  E2
2E9E:  MOVWF  FF6
2EA0:  MOVLW  0F
2EA2:  MOVWF  FF7
2EA4:  CALL   18D6
2EA8:  MOVLW  DC
2EAA:  MOVWF  FF6
2EAC:  MOVLW  0F
2EAE:  MOVWF  FF7
2EB0:  MOVLW  04
2EB2:  MOVLB  1
2EB4:  MOVWF  x1D
2EB6:  MOVLB  0
2EB8:  CALL   18AC
.................... 	switch ( restart_cause ) {
2EBC:  MOVLW  07
2EBE:  SUBWF  00,W
2EC0:  BZ    2EE6
2EC2:  MOVLW  0B
2EC4:  SUBWF  00,W
2EC6:  BZ    2EF4
2EC8:  MOVLW  0F
2ECA:  SUBWF  00,W
2ECC:  BZ    2F02
2ECE:  MOVLW  0C
2ED0:  SUBWF  00,W
2ED2:  BZ    2F10
2ED4:  MOVLW  0E
2ED6:  SUBWF  00,W
2ED8:  BZ    2F1E
2EDA:  MOVLW  03
2EDC:  SUBWF  00,W
2EDE:  BZ    2F2C
2EE0:  MOVF   00,F
2EE2:  BZ    2F3A
2EE4:  BRA    2F48
.................... 		case WDT_TIMEOUT:       fprintf(STREAM_FTDI,"WDT TIMEOUT"); break;
2EE6:  MOVLW  EC
2EE8:  MOVWF  FF6
2EEA:  MOVLW  0F
2EEC:  MOVWF  FF7
2EEE:  CALL   18D6
2EF2:  BRA    2F54
.................... 		case MCLR_FROM_SLEEP:   fprintf(STREAM_FTDI,"MCLR FROM SLEEP"); break;
2EF4:  MOVLW  F8
2EF6:  MOVWF  FF6
2EF8:  MOVLW  0F
2EFA:  MOVWF  FF7
2EFC:  CALL   18D6
2F00:  BRA    2F54
.................... 		case MCLR_FROM_RUN:     fprintf(STREAM_FTDI,"MCLR FROM RUN"); break;
2F02:  MOVLW  08
2F04:  MOVWF  FF6
2F06:  MOVLW  10
2F08:  MOVWF  FF7
2F0A:  CALL   18D6
2F0E:  BRA    2F54
.................... 		case NORMAL_POWER_UP:   fprintf(STREAM_FTDI,"NORMAL POWER UP"); break;
2F10:  MOVLW  16
2F12:  MOVWF  FF6
2F14:  MOVLW  10
2F16:  MOVWF  FF7
2F18:  CALL   18D6
2F1C:  BRA    2F54
.................... 		case BROWNOUT_RESTART:  fprintf(STREAM_FTDI,"BROWNOUT RESTART"); break;
2F1E:  MOVLW  26
2F20:  MOVWF  FF6
2F22:  MOVLW  10
2F24:  MOVWF  FF7
2F26:  CALL   18D6
2F2A:  BRA    2F54
.................... 		case WDT_FROM_SLEEP:    fprintf(STREAM_FTDI,"WDT FROM SLEEP"); break;
2F2C:  MOVLW  38
2F2E:  MOVWF  FF6
2F30:  MOVLW  10
2F32:  MOVWF  FF7
2F34:  CALL   18D6
2F38:  BRA    2F54
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_FTDI,"RESET INSTRUCTION"); break;
2F3A:  MOVLW  48
2F3C:  MOVWF  FF6
2F3E:  MOVLW  10
2F40:  MOVWF  FF7
2F42:  CALL   18D6
2F46:  BRA    2F54
.................... 		default:                fprintf(STREAM_FTDI,"UNKNOWN!");
2F48:  MOVLW  5A
2F4A:  MOVWF  FF6
2F4C:  MOVLW  10
2F4E:  MOVWF  FF7
2F50:  CALL   18D6
.................... 	}
.................... 	fprintf(STREAM_FTDI,"\r\n");
2F54:  MOVLW  0D
2F56:  BTFSS  F9E.4
2F58:  BRA    2F56
2F5A:  MOVWF  FAD
2F5C:  MOVLW  0A
2F5E:  BTFSS  F9E.4
2F60:  BRA    2F5E
2F62:  MOVWF  FAD
.................... 
.................... 	enable_interrupts(GLOBAL);
2F64:  MOVLW  C0
2F66:  IORWF  FF2,F
.................... 
.................... 	/* Prime ADC filter */
.................... 	for ( i=0 ; i<30 ; i++ ) {
2F68:  MOVLB  1
2F6A:  CLRF   x1A
2F6C:  MOVF   x1A,W
2F6E:  SUBLW  1D
2F70:  BNC   2F7E
.................... 		adc_update();
2F72:  MOVLB  0
2F74:  CALL   18F8
2F78:  MOVLB  1
2F7A:  INCF   x1A,F
2F7C:  BRA    2F6C
.................... 	}
.................... 
.................... 
.................... 	/* enable I2C slave interrupt */
.................... 	enable_interrupts(INT_SSP);
2F7E:  BSF    F9D.3
.................... 
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
2F80:  CLRWDT
.................... 
.................... 		if ( timers.now_millisecond ) {
2F82:  MOVLB  0
2F84:  BTFSS  xCF.2
2F86:  BRA    2F8A
.................... 			periodic_millisecond();
2F88:  BRA    29B2
.................... 		}
.................... 
.................... 		if ( kbhit() ) {
2F8A:  BTFSS  F9E.5
2F8C:  BRA    2F92
.................... 			getc();
2F8E:  BRA    2B90
.................... 			timers.now_debug_dump=1;
2F90:  BSF    xCF.5
.................... 		}
.................... 
.................... 		if ( timers.now_debug_dump ) {
2F92:  BTFSS  xCF.5
2F94:  BRA    2F9A
.................... 			timers.now_debug_dump=0;
2F96:  BCF    xCF.5
.................... 
.................... 			debug_dump();
2F98:  BRA    2CA0
.................... 		}
.................... 
.................... 		if ( timers.now_adc_sample ) {
2F9A:  BTFSS  xCF.0
2F9C:  BRA    2FA4
.................... 			timers.now_adc_sample=0;
2F9E:  BCF    xCF.0
.................... 			adc_update();
2FA0:  CALL   18F8
.................... 		}
.................... 
.................... 		if ( timers.now_write_config ) {
2FA4:  BTFSS  xCF.3
2FA6:  BRA    2FAE
.................... 			timers.now_write_config=0;
2FA8:  BCF    xCF.3
.................... 			write_param_file();
2FAA:  CALL   1534
.................... 		}
.................... 		if ( timers.now_reset_config ) {
2FAE:  BTFSS  xCF.4
2FB0:  BRA    2FB8
.................... 			timers.now_reset_config=0;
2FB2:  BCF    xCF.4
.................... 			write_default_param_file();
2FB4:  CALL   1580
.................... 		}
2FB8:  MOVLB  1
2FBA:  BRA    2F80
.................... 
.................... 
.................... 	}
.................... 
.................... 
.................... }
2FBC:  SLEEP 

Configuration Fuses:
   Word  1: 0800   INTRC_IO NOPLLEN NOPCLKEN NOFCMEN NOIESO
   Word  2: 0F07   NOPUT BROWNOUT BORV30 WDT WDT128
   Word  3: 0000   NOHFOFST NOMCLR
   Word  4: 0081   STVREN NOLVP BBSIZ1K NOXINST NODEBUG
   Word  5: C003   NOPROTECT NOCPB NOCPD
   Word  6: E003   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 4003   NOEBTR NOEBTRB

ROM data:
F00000: 00 00 40 00                                        ..@.
