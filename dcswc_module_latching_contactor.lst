CCS PCH C Compiler, Version 5.090, 49113               04-Nov-23 18:16

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\dcswc_module_latching_contactor\dcswc_module_latching_contactor.lst

               ROM used:   12184 bytes (74%)
                           Largest free fragment is 4196
               RAM used:   283 (55%) at main() level
                           311 (61%) worst case
               Stack used: 4 locations (2 in main + 2 for interrupts)
               Stack size: 31

0000:  GOTO   2D8A
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   00D4
0060:  BTFSS  F9D.3
0062:  GOTO   006C
0066:  BTFSC  F9E.3
0068:  GOTO   0E8E
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include "dcswc_module_latching_contactor.h"
.................... #include <18F14K22.h>
.................... //////////// Standard Header file for the PIC18F14K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F14K22
00BA:  CLRF   FF7
00BC:  ADDLW  CA
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  RETURN 0
00CA:  DATA 34,2D
00CC:  DATA 4E,6F
00CE:  DATA 76,2D
00D0:  DATA 32,33
00D2:  DATA 00,00
*
0F5A:  DATA 23,20
0F5C:  DATA 20,20
0F5E:  DATA 20,20
0F60:  DATA 20,20
0F62:  DATA 76,69
0F64:  DATA 6E,20
0F66:  DATA 61,64
0F68:  DATA 63,3D
0F6A:  DATA 25,6C
0F6C:  DATA 75,0D
0F6E:  DATA 0A,00
0F70:  DATA 23,20
0F72:  DATA 20,20
0F74:  DATA 20,20
0F76:  DATA 20,74
0F78:  DATA 65,6D
0F7A:  DATA 70,20
0F7C:  DATA 61,64
0F7E:  DATA 63,3D
0F80:  DATA 25,6C
0F82:  DATA 75,0D
0F84:  DATA 0A,00
0F86:  DATA 23,20
0F88:  DATA 20,20
0F8A:  DATA 63,68
0F8C:  DATA 5B,30
0F8E:  DATA 5D,2E
0F90:  DATA 73,74
0F92:  DATA 61,74
0F94:  DATA 65,3D
0F96:  DATA 30,78
0F98:  DATA 25,32
0F9A:  DATA 58,0D
0F9C:  DATA 0A,00
0F9E:  DATA 23,20
0FA0:  DATA 20,20
0FA2:  DATA 63,68
0FA4:  DATA 5B,31
0FA6:  DATA 5D,2E
0FA8:  DATA 73,74
0FAA:  DATA 61,74
0FAC:  DATA 65,3D
0FAE:  DATA 30,78
0FB0:  DATA 25,32
0FB2:  DATA 58,0D
0FB4:  DATA 0A,00
0FB6:  DATA 23,20
0FB8:  DATA 64,63
0FBA:  DATA 73,77
0FBC:  DATA 63,5F
0FBE:  DATA 6D,6F
0FC0:  DATA 64,75
0FC2:  DATA 6C,65
0FC4:  DATA 5F,6C
0FC6:  DATA 61,74
0FC8:  DATA 63,68
0FCA:  DATA 69,6E
0FCC:  DATA 67,5F
0FCE:  DATA 63,6F
0FD0:  DATA 6E,74
0FD2:  DATA 61,63
0FD4:  DATA 74,6F
0FD6:  DATA 72,20
0FD8:  DATA 25,73
0FDA:  DATA 0D,0A
0FDC:  DATA 23,20
0FDE:  DATA 00,00
0FE0:  DATA 34,2D
0FE2:  DATA 4E,6F
0FE4:  DATA 76,2D
0FE6:  DATA 32,33
0FE8:  DATA 00,00
0FEA:  DATA 57,44
0FEC:  DATA 54,20
0FEE:  DATA 54,49
0FF0:  DATA 4D,45
0FF2:  DATA 4F,55
0FF4:  DATA 54,00
0FF6:  DATA 4D,43
0FF8:  DATA 4C,52
0FFA:  DATA 20,46
0FFC:  DATA 52,4F
0FFE:  DATA 4D,20
1000:  DATA 53,4C
1002:  DATA 45,45
1004:  DATA 50,00
1006:  DATA 4D,43
1008:  DATA 4C,52
100A:  DATA 20,46
100C:  DATA 52,4F
100E:  DATA 4D,20
1010:  DATA 52,55
1012:  DATA 4E,00
1014:  DATA 4E,4F
1016:  DATA 52,4D
1018:  DATA 41,4C
101A:  DATA 20,50
101C:  DATA 4F,57
101E:  DATA 45,52
1020:  DATA 20,55
1022:  DATA 50,00
1024:  DATA 42,52
1026:  DATA 4F,57
1028:  DATA 4E,4F
102A:  DATA 55,54
102C:  DATA 20,52
102E:  DATA 45,53
1030:  DATA 54,41
1032:  DATA 52,54
1034:  DATA 00,00
1036:  DATA 57,44
1038:  DATA 54,20
103A:  DATA 46,52
103C:  DATA 4F,4D
103E:  DATA 20,53
1040:  DATA 4C,45
1042:  DATA 45,50
1044:  DATA 00,00
1046:  DATA 52,45
1048:  DATA 53,45
104A:  DATA 54,20
104C:  DATA 49,4E
104E:  DATA 53,54
1050:  DATA 52,55
1052:  DATA 43,54
1054:  DATA 49,4F
1056:  DATA 4E,00
1058:  DATA 55,4E
105A:  DATA 4B,4E
105C:  DATA 4F,57
105E:  DATA 4E,21
1060:  DATA 00,00
*
188A:  TBLRD*+
188C:  MOVFF  FF6,11E
1890:  MOVFF  FF7,11F
1894:  MOVF   FF5,W
1896:  BTFSS  F9E.4
1898:  BRA    1896
189A:  MOVWF  FAD
189C:  MOVFF  11E,FF6
18A0:  MOVFF  11F,FF7
18A4:  MOVLB  1
18A6:  DECFSZ x1D,F
18A8:  BRA    18AC
18AA:  BRA    18B0
18AC:  MOVLB  0
18AE:  BRA    188A
18B0:  MOVLB  0
18B2:  RETURN 0
18B4:  TBLRD*+
18B6:  MOVF   FF5,F
18B8:  BZ    18D4
18BA:  MOVFF  FF6,11B
18BE:  MOVFF  FF7,11C
18C2:  MOVF   FF5,W
18C4:  BTFSS  F9E.4
18C6:  BRA    18C4
18C8:  MOVWF  FAD
18CA:  MOVFF  11B,FF6
18CE:  MOVFF  11C,FF7
18D2:  BRA    18B4
18D4:  RETURN 0
*
2B86:  MOVFF  FEA,125
2B8A:  MOVFF  FE9,124
2B8E:  MOVLB  1
2B90:  SWAPF  x1E,W
2B92:  IORLW  F0
2B94:  MOVWF  x20
2B96:  ADDWF  x20,F
2B98:  ADDLW  E2
2B9A:  MOVWF  x21
2B9C:  ADDLW  32
2B9E:  MOVWF  x23
2BA0:  MOVF   x1E,W
2BA2:  ANDLW  0F
2BA4:  ADDWF  x21,F
2BA6:  ADDWF  x21,F
2BA8:  ADDWF  x23,F
2BAA:  ADDLW  E9
2BAC:  MOVWF  x22
2BAE:  ADDWF  x22,F
2BB0:  ADDWF  x22,F
2BB2:  SWAPF  x1D,W
2BB4:  ANDLW  0F
2BB6:  ADDWF  x22,F
2BB8:  ADDWF  x23,F
2BBA:  RLCF   x22,F
2BBC:  RLCF   x23,F
2BBE:  COMF   x23,F
2BC0:  RLCF   x23,F
2BC2:  MOVF   x1D,W
2BC4:  ANDLW  0F
2BC6:  ADDWF  x23,F
2BC8:  RLCF   x20,F
2BCA:  MOVLW  07
2BCC:  MOVWF  x1F
2BCE:  MOVLW  0A
2BD0:  DECF   x22,F
2BD2:  ADDWF  x23,F
2BD4:  BNC   2BD0
2BD6:  DECF   x21,F
2BD8:  ADDWF  x22,F
2BDA:  BNC   2BD6
2BDC:  DECF   x20,F
2BDE:  ADDWF  x21,F
2BE0:  BNC   2BDC
2BE2:  DECF   x1F,F
2BE4:  ADDWF  x20,F
2BE6:  BNC   2BE2
2BE8:  MOVLW  01
2BEA:  MOVWF  FEA
2BEC:  MOVLW  1F
2BEE:  MOVWF  FE9
2BF0:  MOVLW  07
2BF2:  ANDWF  x24,W
2BF4:  BCF    x24.6
2BF6:  ADDWF  FE9,F
2BF8:  MOVLW  00
2BFA:  ADDWFC FEA,F
2BFC:  MOVF   FE9,W
2BFE:  SUBLW  23
2C00:  BNZ   2C08
2C02:  DECFSZ FEA,W
2C04:  BRA    2C08
2C06:  BSF    x24.6
2C08:  MOVF   FEF,W
2C0A:  MOVWF  00
2C0C:  BNZ   2C1E
2C0E:  BTFSC  x24.6
2C10:  BRA    2C1E
2C12:  BTFSC  x24.4
2C14:  BRA    2C2E
2C16:  BTFSC  x24.3
2C18:  BRA    2C1E
2C1A:  MOVLW  20
2C1C:  BRA    2C24
2C1E:  BSF    x24.3
2C20:  BCF    x24.4
2C22:  MOVLW  30
2C24:  ADDWF  00,F
2C26:  MOVF   00,W
2C28:  BTFSS  F9E.4
2C2A:  BRA    2C28
2C2C:  MOVWF  FAD
2C2E:  MOVF   FEE,W
2C30:  BTFSS  x24.6
2C32:  BRA    2BFC
2C34:  MOVLB  0
2C36:  RETURN 0
2C38:  MOVLB  1
2C3A:  BTFSC  x1C.7
2C3C:  BRA    2C5E
2C3E:  MOVLW  0F
2C40:  MOVWF  00
2C42:  SWAPF  x1B,W
2C44:  ANDWF  00,F
2C46:  MOVLW  0A
2C48:  SUBWF  00,W
2C4A:  BC    2C52
2C4C:  MOVLW  30
2C4E:  ADDWF  00,F
2C50:  BRA    2C56
2C52:  MOVF   x1C,W
2C54:  ADDWF  00,F
2C56:  MOVF   00,W
2C58:  BTFSS  F9E.4
2C5A:  BRA    2C58
2C5C:  MOVWF  FAD
2C5E:  MOVLW  0F
2C60:  ANDWF  x1B,F
2C62:  MOVLW  0A
2C64:  SUBWF  x1B,W
2C66:  BC    2C6C
2C68:  MOVLW  30
2C6A:  BRA    2C70
2C6C:  BCF    x1C.7
2C6E:  MOVF   x1C,W
2C70:  ADDWF  x1B,F
2C72:  MOVF   x1B,W
2C74:  BTFSS  F9E.4
2C76:  BRA    2C74
2C78:  MOVWF  FAD
2C7A:  MOVLB  0
2C7C:  RETURN 0
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #device *=16
.................... #use delay(clock=16MHz)
*
1062:  MOVLW  01
1064:  MOVWF  FEA
1066:  MOVLW  28
1068:  MOVWF  FE9
106A:  MOVF   FEF,W
106C:  BZ    108A
106E:  MOVLW  05
1070:  MOVWF  01
1072:  CLRF   00
1074:  DECFSZ 00,F
1076:  BRA    1074
1078:  DECFSZ 01,F
107A:  BRA    1072
107C:  MOVLW  2E
107E:  MOVWF  00
1080:  DECFSZ 00,F
1082:  BRA    1080
1084:  BRA    1086
1086:  DECFSZ FEF,F
1088:  BRA    106E
108A:  RETURN 0
.................... 
.................... /* hardware I2C port is slave and is connected to DCSWC bus */
.................... #use i2c(stream=STREAM_SLAVE,SLAVE, I2C1, FORCE_HW)
*
0E78:  MOVF   FC9,W
0E7A:  MOVFF  12D,FC9
0E7E:  BSF    FC6.4
0E80:  BCF    F9E.3
0E82:  BTFSC  FC7.0
0E84:  BRA    0E82
0E86:  CLRF   01
0E88:  BTFSS  FC5.6
0E8A:  INCF   01,F
0E8C:  RETURN 0
.................... /* slave address set based on dip switch in init() */
.................... 
.................... /* important FUSE notes! 
.................... MPLAB defaults to DEBUG mode and that will override fuses.
.................... make sure it is on "BUILD CONFIGURATION" of "RELEASE" under
.................... "PROJECT" menu.
.................... 
.................... CCS setup functions can override fuses. Check .LST file
.................... to see if anything has been overriden!
.................... */
.................... 
.................... #fuses NODEBUG 
.................... #fuses INTRC_IO
.................... #fuses NOPCLKEN
.................... #fuses NOPLLEN
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses BROWNOUT
.................... #fuses BORV30
.................... #fuses NOPUT
.................... #fuses WDT
.................... #fuses WDT128     /* this can be override by setup_wdt() */
.................... #fuses NOHFOFST
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses NOLVP
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... #fuses NOPROTECT
.................... #fuses NOWRT
.................... #fuses NOWRTC 
.................... #fuses NOWRTB
.................... #fuses NOWRTD
.................... #fuses NOEBTR
.................... #fuses NOEBTRB
.................... #fuses BBSIZ1K
.................... 
.................... 
.................... #use standard_io(ALL)
.................... 
.................... #use rs232(UART1,stream=STREAM_FTDI,baud=57600,errors)	
*
2B6E:  BTFSS  F9E.5
2B70:  BRA    2B6E
2B72:  MOVFF  FAB,1A
2B76:  MOVFF  FAE,01
2B7A:  BTFSS  1A.1
2B7C:  BRA    2B82
2B7E:  BCF    FAB.4
2B80:  BSF    FAB.4
2B82:  GOTO   2F6E (RETURN)
.................... 
.................... /* program config CRC of 0 and a serial_prefix of 'A' ... that will trigger a write default on first boot */
.................... #ROM 0xF00000 = { 0x00, 0x00, 0x40, 0x00 }
.................... 
.................... 
.................... 
.................... 
.................... #define SW_OVERRIDE_A        PIN_A5
.................... #define SW_OVERRIDE_B        PIN_A4
.................... #define BRIDGE_B_A           PIN_C5
.................... #define BRIDGE_A_B           PIN_C4
.................... #define BRIDGE_A_A           PIN_C3
.................... #define BRIDGE_B_B           PIN_C6
.................... #define AN_DIP               PIN_C7
.................... #define SER_TO_PC            PIN_B7
.................... #define AN_VTEMP             PIN_A2
.................... #define AN_IN_VOLTS          PIN_C0
.................... #define LED_A                PIN_C1
.................... #define LED_B                PIN_C2
.................... #define I2C_SDA              PIN_B4
.................... #define SER_FROM_PC          PIN_B5
.................... #define I2C_SCL              PIN_B6
.................... 
.................... 
.................... /* 
.................... Parameters are stored in EEPROM
.................... */
.................... #define PARAM_CRC_ADDRESS  0x00
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2
.................... 
.................... 
.................... 
.................... /* bit positions for a channel state byte */
.................... #define CH_STATE_BIT_FUTURE   7  /* reserved for future use */
.................... #define CH_STATE_BIT_HTD      6  /* high temperature disconnect */
.................... #define CH_STATE_BIT_LTD      5  /* low temperature disconnect */
.................... #define CH_STATE_BIT_HVD      4  /* high voltage disconnect */
.................... #define CH_STATE_BIT_LVD      3  /* low voltage disconnect */
.................... #define CH_STATE_BIT_CMD_OFF  2  /* commanded off */
.................... #define CH_STATE_BIT_CMD_ON   1  /* commanded on (takes presedence over commanded off) */
.................... #define CH_STATE_BIT_OVERRIDE 0  /* override switch */
.................... 
.................... /* _OVERRIDE or _CMD_ON set means output on */
.................... #define CH_STATE_MASK_ON     0b00000011 
.................... /* _CMD_OFF, _LVD, _HVD, _LTD, _HTD means output off, unless override by on mask */
.................... #define CH_STATE_MASK_OFF    0b01111100 
.................... 
.................... #define ADC_SAMPLE_TICKS              20
.................... #define CONTACTOR_POWER_SAVE_MS       200 /* milliseconds for contactor be on. Must be >0 and <= 255 */
.................... #define CONTACTOR_REFRESH_CYCLES      10  /* re-appply contactor coil voltage every N cycles. 65525 disables */
.................... 
.................... #define BLINK_ON_TIME                 254
.................... #define BLINK_OFF_TIME                200
.................... 
.................... 
.................... typedef struct {
.................... 	/* command on hold time */
.................... 	int16 command_on_hold_time;
.................... 
.................... 	/* command off hold time */
.................... 	int16 command_off_hold_time;
.................... 
.................... 	/* low voltage disconnect */
.................... 	int16 lvd_disconnect_adc;
.................... 	int16 lvd_disconnect_delay;
.................... 	int16 lvd_reconnect_adc;
.................... 	int16 lvd_reconnect_delay;
.................... 
.................... 	/* high voltage disconnect */
.................... 	int16 hvd_disconnect_adc;
.................... 	int16 hvd_disconnect_delay;
.................... 	int16 hvd_reconnect_adc;
.................... 	int16 hvd_reconnect_delay;
.................... 
.................... 	/* low temperature disconnect */
.................... 	int16 ltd_disconnect_adc;
.................... 	int16 ltd_disconnect_delay;
.................... 	int16 ltd_reconnect_adc;
.................... 	int16 ltd_reconnect_delay;
.................... 
.................... 	/* high temperature disconnect */
.................... 	int16 htd_disconnect_adc;
.................... 	int16 htd_disconnect_delay;
.................... 	int16 htd_reconnect_adc;
.................... 	int16 htd_reconnect_delay;
.................... } struct_config_channel;
.................... 
.................... typedef struct {
.................... 	/* not much going on here */
.................... 	struct_config_channel ch[2];
.................... } struct_config;
.................... 
.................... 
.................... typedef struct {
.................... 	int8 state;
.................... 
.................... 	int16 command_on_seconds;			/* counts down. Off at zero. */
.................... 	int16 command_on_hold_seconds;      /* counts down. Off at zero. */
.................... 
.................... 	int16 command_off_seconds;			/* counts down. Off at zero. */
.................... 	int16 command_off_hold_seconds;     /* counts down. Off at zero. */
.................... 
.................... 	int16 lvd_disconnect_delay_seconds;	/* counts down */
.................... 	int16  lvd_reconnect_delay_seconds;	/* counts down */
.................... 
.................... 	int16 hvd_disconnect_delay_seconds;	/* counts down */
.................... 	int16  hvd_reconnect_delay_seconds;	/* counts down */
.................... 
.................... 	int16 ltd_disconnect_delay_seconds; /* counts down */
.................... 	int16 ltd_reconnect_delay_seconds;  /* counts down */
.................... 
.................... 	int16 htd_disconnect_delay_seconds; /* counts down */
.................... 	int16 htd_reconnect_delay_seconds;  /* counts down */
.................... } struct_channel;
.................... 
.................... typedef struct {
.................... 	/* circular buffer for ADC readings */
.................... 	int16 adc_buffer[3][16];
.................... 	int8  adc_buffer_index;
.................... 
.................... 	int16 sequence_number;
.................... 	int16 uptime_minutes;
.................... 	int16 interval_milliseconds;
.................... 
.................... 	int8 factory_unlocked;
.................... 
.................... 
.................... 	int8 compile_year;
.................... 	int8 compile_month;
.................... 	int8 compile_day;
.................... 
.................... 
.................... 	int8 default_params_written;
.................... } struct_current;
.................... 
.................... typedef struct {
.................... 	/* action flags */
.................... 	int1 now_adc_sample;
.................... 	int1 now_adc_reset_count;
.................... 
.................... 	int1 now_millisecond;
.................... 
.................... 	int1 now_write_config;
.................... 	int1 now_reset_config;
.................... 
.................... 	int1 now_debug_dump;
.................... 
.................... 
.................... 	/* timers */
.................... 	int8 led_blink[2];
.................... 	int8 led_on[2];
.................... 	int8 led_off[2];
.................... 
.................... 	/* contactors */
.................... 	int8 contactor[2]; 	         /* current state */
.................... 	int8 contactor_powersave[2]; /* countdown to shut off power to coil at 0 */
.................... } struct_time_keep;
.................... 
.................... /* global structures */
.................... struct_config config={0};
.................... struct_current current={0};
.................... struct_time_keep timers={0};
.................... struct_channel channel[2]={0};
.................... 
.................... #include "adc_dcswc_module_latching_contactor.c"
.................... int16 adc_get(int8 ch) {
.................... 	int16 sum;
.................... 	int8 i;
.................... 
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */
.................... 	int16 *p;
.................... 	p = current.adc_buffer[ch];
*
0594:  MOVLB  1
0596:  MOVF   x2F,W
0598:  MULLW  20
059A:  MOVF   FF3,W
059C:  CLRF   03
059E:  ADDLW  63
05A0:  MOVWF  01
05A2:  MOVLW  00
05A4:  ADDWFC 03,F
05A6:  MOVFF  01,133
05AA:  MOVFF  03,134
.................... 
.................... 	// Calculate the mean.  This is done by summing up the
.................... 	// values and dividing by the number of elements.
.................... 	sum = 0;
05AE:  CLRF   x31
05B0:  CLRF   x30
.................... 	for( i = 0; i < 16 ; i++ ) {
05B2:  CLRF   x32
05B4:  MOVF   x32,W
05B6:  SUBLW  0F
05B8:  BNC   05E4
.................... //		sum += current.adc_buffer[ch][i];
.................... 		sum += p[i];
05BA:  CLRF   03
05BC:  MOVFF  132,02
05C0:  BCF    FD8.0
05C2:  RLCF   02,F
05C4:  RLCF   03,F
05C6:  MOVF   02,W
05C8:  ADDWF  x33,W
05CA:  MOVWF  FE9
05CC:  MOVF   x34,W
05CE:  ADDWFC 03,W
05D0:  MOVWF  FEA
05D2:  MOVFF  FEC,03
05D6:  MOVF   FED,F
05D8:  MOVF   FEF,W
05DA:  ADDWF  x30,F
05DC:  MOVF   03,W
05DE:  ADDWFC x31,F
05E0:  INCF   x32,F
05E2:  BRA    05B4
.................... 	}
.................... 
.................... 	/* divide sum by our 16 samples and round by adding 8 */
.................... 	return ( (sum+8) >> 4 );
05E4:  MOVLW  08
05E6:  ADDWF  x30,W
05E8:  MOVWF  x35
05EA:  MOVLW  00
05EC:  ADDWFC x31,W
05EE:  MOVWF  x36
05F0:  RRCF   x36,W
05F2:  MOVWF  03
05F4:  RRCF   x35,W
05F6:  MOVWF  02
05F8:  RRCF   03,F
05FA:  RRCF   02,F
05FC:  RRCF   03,F
05FE:  RRCF   02,F
0600:  RRCF   03,F
0602:  RRCF   02,F
0604:  MOVLW  0F
0606:  ANDWF  03,F
0608:  MOVFF  02,01
060C:  MOVFF  03,02
0610:  MOVLB  0
0612:  RETURN 0
.................... }
.................... 
.................... 
.................... void adc_update(void) {
.................... 
.................... 	/* wrap buffer around */
.................... 	current.adc_buffer_index++;
*
18D6:  INCF   xC3,F
.................... 	if ( current.adc_buffer_index >= 16 )
18D8:  MOVF   xC3,W
18DA:  SUBLW  0F
18DC:  BC    18E0
.................... 		current.adc_buffer_index=0;
18DE:  CLRF   xC3
.................... 
.................... 	set_adc_channel(4);
18E0:  MOVLW  10
18E2:  MOVWF  01
18E4:  MOVF   FC2,W
18E6:  ANDLW  C3
18E8:  IORWF  01,W
18EA:  MOVWF  FC2
.................... 	current.adc_buffer[0][current.adc_buffer_index] = read_adc();
18EC:  BCF    FD8.0
18EE:  RLCF   xC3,W
18F0:  CLRF   03
18F2:  ADDLW  63
18F4:  MOVWF  FE9
18F6:  MOVLW  00
18F8:  ADDWFC 03,W
18FA:  MOVWF  FEA
18FC:  BSF    FC2.1
18FE:  BTFSC  FC2.1
1900:  BRA    18FE
1902:  MOVFF  FC3,FEF
1906:  MOVFF  FC4,FEC
.................... 
.................... 
.................... 	set_adc_channel(2);
190A:  MOVLW  08
190C:  MOVWF  01
190E:  MOVF   FC2,W
1910:  ANDLW  C3
1912:  IORWF  01,W
1914:  MOVWF  FC2
.................... 	delay_ms(1);
1916:  MOVLW  01
1918:  MOVLB  1
191A:  MOVWF  x28
191C:  MOVLB  0
191E:  CALL   1062
.................... 	current.adc_buffer[1][current.adc_buffer_index] = read_adc();
1922:  BCF    FD8.0
1924:  RLCF   xC3,W
1926:  CLRF   03
1928:  ADDLW  83
192A:  MOVWF  FE9
192C:  MOVLW  00
192E:  ADDWFC 03,W
1930:  MOVWF  FEA
1932:  BSF    FC2.1
1934:  BTFSC  FC2.1
1936:  BRA    1934
1938:  MOVFF  FC3,FEF
193C:  MOVFF  FC4,FEC
.................... 
.................... 	set_adc_channel(9);
1940:  MOVLW  24
1942:  MOVWF  01
1944:  MOVF   FC2,W
1946:  ANDLW  C3
1948:  IORWF  01,W
194A:  MOVWF  FC2
.................... 	delay_ms(1);
194C:  MOVLW  01
194E:  MOVLB  1
1950:  MOVWF  x28
1952:  MOVLB  0
1954:  CALL   1062
.................... 	current.adc_buffer[2][current.adc_buffer_index] = read_adc();
1958:  BCF    FD8.0
195A:  RLCF   xC3,W
195C:  CLRF   03
195E:  ADDLW  A3
1960:  MOVWF  FE9
1962:  MOVLW  00
1964:  ADDWFC 03,W
1966:  MOVWF  FEA
1968:  BSF    FC2.1
196A:  BTFSC  FC2.1
196C:  BRA    196A
196E:  MOVFF  FC3,FEF
1972:  MOVFF  FC4,FEC
1976:  RETURN 0
.................... }
.................... 
.................... int8 read_dip_switch(void) {
.................... 	int16 adc;
.................... 
.................... 	set_adc_channel(9);
*
108C:  MOVLW  24
108E:  MOVWF  01
1090:  MOVF   FC2,W
1092:  ANDLW  C3
1094:  IORWF  01,W
1096:  MOVWF  FC2
.................... 	delay_ms(1);
1098:  MOVLW  01
109A:  MOVLB  1
109C:  MOVWF  x28
109E:  MOVLB  0
10A0:  RCALL  1062
.................... 	adc=read_adc();
10A2:  BSF    FC2.1
10A4:  BTFSC  FC2.1
10A6:  BRA    10A4
10A8:  MOVFF  FC4,127
10AC:  MOVFF  FC3,126
.................... 
.................... 	/* (note that table is sorted by vout reading 
.................... 	SW3.1 (LSB) SW3.2 (MSB) VALUE ADC
....................     OFF         OFF         0     1023
.................... 	OFF         ON          2     682
....................     ON          OFF         1     511
.................... 	ON          ON          3     409
.................... 	*/
.................... 
.................... 	if ( adc > (1023-64) )
10B0:  MOVLB  1
10B2:  MOVF   x27,W
10B4:  SUBLW  02
10B6:  BC    10C8
10B8:  XORLW  FF
10BA:  BNZ   10C2
10BC:  MOVF   x26,W
10BE:  SUBLW  BF
10C0:  BC    10C8
.................... 		return 0;
10C2:  MOVLW  00
10C4:  MOVWF  01
10C6:  BRA    10F8
.................... 	if ( adc > (682-64) )
10C8:  MOVF   x27,W
10CA:  SUBLW  01
10CC:  BC    10DE
10CE:  XORLW  FF
10D0:  BNZ   10D8
10D2:  MOVF   x26,W
10D4:  SUBLW  6A
10D6:  BC    10DE
.................... 		return 2;
10D8:  MOVLW  02
10DA:  MOVWF  01
10DC:  BRA    10F8
.................... 	if ( adc > (511-64) )
10DE:  MOVF   x27,W
10E0:  SUBLW  00
10E2:  BC    10F4
10E4:  XORLW  FF
10E6:  BNZ   10EE
10E8:  MOVF   x26,W
10EA:  SUBLW  BF
10EC:  BC    10F4
.................... 		return 1;
10EE:  MOVLW  01
10F0:  MOVWF  01
10F2:  BRA    10F8
.................... 
.................... 	return 3;
10F4:  MOVLW  03
10F6:  MOVWF  01
10F8:  MOVLB  0
10FA:  GOTO   13B0 (RETURN)
.................... }
.................... 
.................... #include "param_dcswc_module_latching_contactor.c"
.................... #inline
.................... char xor_crc(char oldcrc, char data) {
.................... 	return oldcrc ^ data;
*
147A:  MOVF   x28,W
147C:  XORWF  x29,W
147E:  MOVWF  01
*
14C8:  MOVF   x28,W
14CA:  XORWF  x29,W
14CC:  MOVWF  01
.................... }
.................... 
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) {
*
1412:  MOVLB  1
1414:  CLRF   x24
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
1416:  MOVFF  123,126
141A:  MOVF   x22,W
141C:  BTFSC  FD8.2
141E:  DECF   x23,F
1420:  DECF   x22,F
1422:  MOVWF  x25
1424:  MOVF   x25,F
1426:  BNZ   142C
1428:  MOVF   x26,F
142A:  BZ    148C
.................... 		*data = read_eeprom( address++ );
142C:  MOVFF  121,03
1430:  MOVF   x20,W
1432:  MOVWF  FE9
1434:  MOVFF  03,FEA
1438:  MOVF   x1F,W
143A:  MOVWF  03
143C:  MOVF   x1E,W
143E:  INCF   x1E,F
1440:  BTFSC  FD8.2
1442:  INCF   x1F,F
1444:  MOVWF  x27
1446:  MOVFF  03,128
144A:  MOVFF  FF2,129
144E:  BCF    FF2.7
1450:  MOVFF  127,FA9
1454:  BCF    FA6.6
1456:  BCF    FA6.7
1458:  BSF    FA6.0
145A:  MOVF   FA8,W
145C:  BTFSC  x29.7
145E:  BSF    FF2.7
1460:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data);
1462:  MOVFF  121,03
1466:  MOVF   x20,W
1468:  MOVWF  FE9
146A:  MOVFF  03,FEA
146E:  MOVFF  FEF,125
1472:  MOVFF  124,128
1476:  MOVFF  125,129
*
1480:  MOVFF  01,124
.................... 		data++;
1484:  INCF   x20,F
1486:  BTFSC  FD8.2
1488:  INCF   x21,F
148A:  BRA    1416
.................... 	}
.................... 	return crc;
148C:  MOVFF  124,01
1490:  MOVLB  0
1492:  GOTO   1860 (RETURN)
.................... }
.................... 
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) {
1496:  MOVLB  1
1498:  CLRF   x26
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
149A:  MOVFF  125,128
149E:  MOVF   x24,W
14A0:  BTFSC  FD8.2
14A2:  DECF   x25,F
14A4:  DECF   x24,F
14A6:  MOVWF  x27
14A8:  MOVF   x27,F
14AA:  BNZ   14B0
14AC:  MOVF   x28,F
14AE:  BZ    1528
.................... 		/* restart_wdt() */
.................... 		crc = xor_crc(crc,*data);
14B0:  MOVFF  123,03
14B4:  MOVF   x22,W
14B6:  MOVWF  FE9
14B8:  MOVFF  03,FEA
14BC:  MOVFF  FEF,127
14C0:  MOVFF  126,128
14C4:  MOVFF  127,129
*
14CE:  MOVFF  01,126
.................... 		write_eeprom( address++, *data++ );
14D2:  MOVF   x21,W
14D4:  MOVWF  03
14D6:  MOVF   x20,W
14D8:  INCF   x20,F
14DA:  BTFSC  FD8.2
14DC:  INCF   x21,F
14DE:  MOVWF  x27
14E0:  MOVFF  03,128
14E4:  MOVF   x23,W
14E6:  MOVWF  03
14E8:  MOVF   x22,W
14EA:  INCF   x22,F
14EC:  BTFSC  FD8.2
14EE:  INCF   x23,F
14F0:  MOVWF  FE9
14F2:  MOVFF  03,FEA
14F6:  MOVFF  FEF,129
14FA:  MOVF   FF2,W
14FC:  MOVWF  00
14FE:  BCF    FF2.7
1500:  MOVFF  127,FA9
1504:  MOVFF  129,FA8
1508:  BCF    FA6.6
150A:  BCF    FA6.7
150C:  BSF    FA6.2
150E:  MOVLB  F
1510:  MOVLW  55
1512:  MOVWF  FA7
1514:  MOVLW  AA
1516:  MOVWF  FA7
1518:  BSF    FA6.1
151A:  BTFSC  FA6.1
151C:  BRA    151A
151E:  BCF    FA6.2
1520:  MOVF   00,W
1522:  IORWF  FF2,F
1524:  MOVLB  1
1526:  BRA    149A
.................... 	}
.................... 
.................... 	return crc;
1528:  MOVFF  126,01
152C:  MOVLB  0
152E:  GOTO   154E (RETURN)
.................... }
.................... 
.................... void write_param_file() {
.................... 	int8 crc;
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config));
1532:  MOVLB  1
1534:  MOVLW  1B
1536:  MOVWF  x1E
1538:  CLRF   x21
153A:  MOVLW  02
153C:  MOVWF  x20
153E:  CLRF   x23
1540:  MOVFF  11E,122
1544:  CLRF   x25
1546:  MOVLW  48
1548:  MOVWF  x24
154A:  MOVLB  0
154C:  BRA    1496
154E:  MOVFF  01,11D
.................... 	/* write the CRC was calculated on the structure */
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc);
1552:  MOVF   FF2,W
1554:  MOVWF  00
1556:  BCF    FF2.7
1558:  CLRF   FA9
155A:  MOVFF  11D,FA8
155E:  BCF    FA6.6
1560:  BCF    FA6.7
1562:  BSF    FA6.2
1564:  MOVLB  F
1566:  MOVLW  55
1568:  MOVWF  FA7
156A:  MOVLW  AA
156C:  MOVWF  FA7
156E:  BSF    FA6.1
1570:  BTFSC  FA6.1
1572:  BRA    1570
1574:  BCF    FA6.2
1576:  MOVF   00,W
1578:  IORWF  FF2,F
157A:  MOVLB  0
157C:  RETURN 0
.................... }
.................... 
.................... void write_default_param_file() {
.................... 	int8 i;
.................... 
.................... 	current.default_params_written=1;
157E:  MOVLW  01
1580:  MOVWF  xCE
.................... 
.................... 	/* both LEDs on */
.................... 	timers.led_blink[0]=255;
1582:  SETF   xD0
.................... 	timers.led_blink[1]=255;
1584:  SETF   xD1
.................... 
.................... 
.................... 	for ( i=0 ; i<2 ; i++ ) {
1586:  MOVLB  1
1588:  CLRF   x1C
158A:  MOVF   x1C,W
158C:  SUBLW  01
158E:  BTFSS  FD8.0
1590:  BRA    183E
.................... 			/* low voltage disconnect */
.................... 			config.ch[i].lvd_disconnect_adc=593;  /* 23.16 volts */
1592:  MOVF   x1C,W
1594:  MULLW  24
1596:  MOVF   FF3,W
1598:  CLRF   x1E
159A:  MOVWF  x1D
159C:  MOVLW  04
159E:  ADDWF  x1D,W
15A0:  MOVWF  01
15A2:  MOVLW  00
15A4:  ADDWFC x1E,W
15A6:  MOVWF  03
15A8:  MOVF   01,W
15AA:  ADDLW  1B
15AC:  MOVWF  FE9
15AE:  MOVLW  00
15B0:  ADDWFC 03,W
15B2:  MOVWF  FEA
15B4:  MOVLW  02
15B6:  MOVWF  FEC
15B8:  MOVF   FED,F
15BA:  MOVLW  51
15BC:  MOVWF  FEF
.................... 			config.ch[i].lvd_disconnect_delay=20; /* 65535 disables LVD */
15BE:  MOVF   x1C,W
15C0:  MULLW  24
15C2:  MOVF   FF3,W
15C4:  CLRF   x1E
15C6:  MOVWF  x1D
15C8:  MOVLW  06
15CA:  ADDWF  x1D,W
15CC:  MOVWF  01
15CE:  MOVLW  00
15D0:  ADDWFC x1E,W
15D2:  MOVWF  03
15D4:  MOVF   01,W
15D6:  ADDLW  1B
15D8:  MOVWF  FE9
15DA:  MOVLW  00
15DC:  ADDWFC 03,W
15DE:  MOVWF  FEA
15E0:  CLRF   FEC
15E2:  MOVF   FED,F
15E4:  MOVLW  14
15E6:  MOVWF  FEF
.................... 			config.ch[i].lvd_reconnect_adc=602;   /* 23.51 volts */
15E8:  MOVF   x1C,W
15EA:  MULLW  24
15EC:  MOVF   FF3,W
15EE:  CLRF   x1E
15F0:  MOVWF  x1D
15F2:  MOVLW  08
15F4:  ADDWF  x1D,W
15F6:  MOVWF  01
15F8:  MOVLW  00
15FA:  ADDWFC x1E,W
15FC:  MOVWF  03
15FE:  MOVF   01,W
1600:  ADDLW  1B
1602:  MOVWF  FE9
1604:  MOVLW  00
1606:  ADDWFC 03,W
1608:  MOVWF  FEA
160A:  MOVLW  02
160C:  MOVWF  FEC
160E:  MOVF   FED,F
1610:  MOVLW  5A
1612:  MOVWF  FEF
.................... 			config.ch[i].lvd_reconnect_delay=10;
1614:  MOVF   x1C,W
1616:  MULLW  24
1618:  MOVF   FF3,W
161A:  CLRF   x1E
161C:  MOVWF  x1D
161E:  MOVLW  0A
1620:  ADDWF  x1D,W
1622:  MOVWF  01
1624:  MOVLW  00
1626:  ADDWFC x1E,W
1628:  MOVWF  03
162A:  MOVF   01,W
162C:  ADDLW  1B
162E:  MOVWF  FE9
1630:  MOVLW  00
1632:  ADDWFC 03,W
1634:  MOVWF  FEA
1636:  CLRF   FEC
1638:  MOVF   FED,F
163A:  MOVLW  0A
163C:  MOVWF  FEF
.................... 		
.................... 		/* high voltage disconnect */
.................... 		config.ch[i].hvd_disconnect_adc=700; 
163E:  MOVF   x1C,W
1640:  MULLW  24
1642:  MOVF   FF3,W
1644:  CLRF   x1E
1646:  MOVWF  x1D
1648:  MOVLW  0C
164A:  ADDWF  x1D,W
164C:  MOVWF  01
164E:  MOVLW  00
1650:  ADDWFC x1E,W
1652:  MOVWF  03
1654:  MOVF   01,W
1656:  ADDLW  1B
1658:  MOVWF  FE9
165A:  MOVLW  00
165C:  ADDWFC 03,W
165E:  MOVWF  FEA
1660:  MOVLW  02
1662:  MOVWF  FEC
1664:  MOVF   FED,F
1666:  MOVLW  BC
1668:  MOVWF  FEF
.................... 		config.ch[i].hvd_disconnect_delay=65535; /* 65535 disables HVD */
166A:  MOVF   x1C,W
166C:  MULLW  24
166E:  MOVF   FF3,W
1670:  CLRF   x1E
1672:  MOVWF  x1D
1674:  MOVLW  0E
1676:  ADDWF  x1D,W
1678:  MOVWF  01
167A:  MOVLW  00
167C:  ADDWFC x1E,W
167E:  MOVWF  03
1680:  MOVF   01,W
1682:  ADDLW  1B
1684:  MOVWF  FE9
1686:  MOVLW  00
1688:  ADDWFC 03,W
168A:  MOVWF  FEA
168C:  SETF   FEC
168E:  MOVF   FED,F
1690:  SETF   FEF
.................... 		config.ch[i].hvd_reconnect_adc=650;
1692:  MOVF   x1C,W
1694:  MULLW  24
1696:  MOVF   FF3,W
1698:  CLRF   x1E
169A:  MOVWF  x1D
169C:  MOVLW  10
169E:  ADDWF  x1D,W
16A0:  MOVWF  01
16A2:  MOVLW  00
16A4:  ADDWFC x1E,W
16A6:  MOVWF  03
16A8:  MOVF   01,W
16AA:  ADDLW  1B
16AC:  MOVWF  FE9
16AE:  MOVLW  00
16B0:  ADDWFC 03,W
16B2:  MOVWF  FEA
16B4:  MOVLW  02
16B6:  MOVWF  FEC
16B8:  MOVF   FED,F
16BA:  MOVLW  8A
16BC:  MOVWF  FEF
.................... 		config.ch[i].hvd_reconnect_delay=60;
16BE:  MOVF   x1C,W
16C0:  MULLW  24
16C2:  MOVF   FF3,W
16C4:  CLRF   x1E
16C6:  MOVWF  x1D
16C8:  MOVLW  12
16CA:  ADDWF  x1D,W
16CC:  MOVWF  01
16CE:  MOVLW  00
16D0:  ADDWFC x1E,W
16D2:  MOVWF  03
16D4:  MOVF   01,W
16D6:  ADDLW  1B
16D8:  MOVWF  FE9
16DA:  MOVLW  00
16DC:  ADDWFC 03,W
16DE:  MOVWF  FEA
16E0:  CLRF   FEC
16E2:  MOVF   FED,F
16E4:  MOVLW  3C
16E6:  MOVWF  FEF
.................... 
.................... 		/* low temperature disconnect */
.................... 		config.ch[i].ltd_disconnect_adc=786; // 0C / 32F
16E8:  MOVF   x1C,W
16EA:  MULLW  24
16EC:  MOVF   FF3,W
16EE:  CLRF   x1E
16F0:  MOVWF  x1D
16F2:  MOVLW  14
16F4:  ADDWF  x1D,W
16F6:  MOVWF  01
16F8:  MOVLW  00
16FA:  ADDWFC x1E,W
16FC:  MOVWF  03
16FE:  MOVF   01,W
1700:  ADDLW  1B
1702:  MOVWF  FE9
1704:  MOVLW  00
1706:  ADDWFC 03,W
1708:  MOVWF  FEA
170A:  MOVLW  03
170C:  MOVWF  FEC
170E:  MOVF   FED,F
1710:  MOVLW  12
1712:  MOVWF  FEF
.................... 		config.ch[i].ltd_disconnect_delay=65535; /* 65535 disables LTD */
1714:  MOVF   x1C,W
1716:  MULLW  24
1718:  MOVF   FF3,W
171A:  CLRF   x1E
171C:  MOVWF  x1D
171E:  MOVLW  16
1720:  ADDWF  x1D,W
1722:  MOVWF  01
1724:  MOVLW  00
1726:  ADDWFC x1E,W
1728:  MOVWF  03
172A:  MOVF   01,W
172C:  ADDLW  1B
172E:  MOVWF  FE9
1730:  MOVLW  00
1732:  ADDWFC 03,W
1734:  MOVWF  FEA
1736:  SETF   FEC
1738:  MOVF   FED,F
173A:  SETF   FEF
.................... 		config.ch[i].ltd_reconnect_adc=683;  // 10C / 50F
173C:  MOVF   x1C,W
173E:  MULLW  24
1740:  MOVF   FF3,W
1742:  CLRF   x1E
1744:  MOVWF  x1D
1746:  MOVLW  18
1748:  ADDWF  x1D,W
174A:  MOVWF  01
174C:  MOVLW  00
174E:  ADDWFC x1E,W
1750:  MOVWF  03
1752:  MOVF   01,W
1754:  ADDLW  1B
1756:  MOVWF  FE9
1758:  MOVLW  00
175A:  ADDWFC 03,W
175C:  MOVWF  FEA
175E:  MOVLW  02
1760:  MOVWF  FEC
1762:  MOVF   FED,F
1764:  MOVLW  AB
1766:  MOVWF  FEF
.................... 		config.ch[i].ltd_reconnect_delay=4;
1768:  MOVF   x1C,W
176A:  MULLW  24
176C:  MOVF   FF3,W
176E:  CLRF   x1E
1770:  MOVWF  x1D
1772:  MOVLW  1A
1774:  ADDWF  x1D,W
1776:  MOVWF  01
1778:  MOVLW  00
177A:  ADDWFC x1E,W
177C:  MOVWF  03
177E:  MOVF   01,W
1780:  ADDLW  1B
1782:  MOVWF  FE9
1784:  MOVLW  00
1786:  ADDWFC 03,W
1788:  MOVWF  FEA
178A:  CLRF   FEC
178C:  MOVF   FED,F
178E:  MOVLW  04
1790:  MOVWF  FEF
.................... 
.................... 		/* high temperature disconnect */
.................... 		config.ch[i].htd_disconnect_adc=405; // 35C / 95F
1792:  MOVF   x1C,W
1794:  MULLW  24
1796:  MOVF   FF3,W
1798:  CLRF   x1E
179A:  MOVWF  x1D
179C:  MOVLW  1C
179E:  ADDWF  x1D,W
17A0:  MOVWF  01
17A2:  MOVLW  00
17A4:  ADDWFC x1E,W
17A6:  MOVWF  03
17A8:  MOVF   01,W
17AA:  ADDLW  1B
17AC:  MOVWF  FE9
17AE:  MOVLW  00
17B0:  ADDWFC 03,W
17B2:  MOVWF  FEA
17B4:  MOVLW  01
17B6:  MOVWF  FEC
17B8:  MOVF   FED,F
17BA:  MOVLW  95
17BC:  MOVWF  FEF
.................... 		config.ch[i].htd_disconnect_delay=65535; /* 65535 disables LTD */
17BE:  MOVF   x1C,W
17C0:  MULLW  24
17C2:  MOVF   FF3,W
17C4:  CLRF   x1E
17C6:  MOVWF  x1D
17C8:  MOVLW  1E
17CA:  ADDWF  x1D,W
17CC:  MOVWF  01
17CE:  MOVLW  00
17D0:  ADDWFC x1E,W
17D2:  MOVWF  03
17D4:  MOVF   01,W
17D6:  ADDLW  1B
17D8:  MOVWF  FE9
17DA:  MOVLW  00
17DC:  ADDWFC 03,W
17DE:  MOVWF  FEA
17E0:  SETF   FEC
17E2:  MOVF   FED,F
17E4:  SETF   FEF
.................... 		config.ch[i].htd_reconnect_adc=512;  // 25C / 77F
17E6:  MOVF   x1C,W
17E8:  MULLW  24
17EA:  MOVF   FF3,W
17EC:  CLRF   x1E
17EE:  MOVWF  x1D
17F0:  MOVLW  20
17F2:  ADDWF  x1D,W
17F4:  MOVWF  01
17F6:  MOVLW  00
17F8:  ADDWFC x1E,W
17FA:  MOVWF  03
17FC:  MOVF   01,W
17FE:  ADDLW  1B
1800:  MOVWF  FE9
1802:  MOVLW  00
1804:  ADDWFC 03,W
1806:  MOVWF  FEA
1808:  MOVLW  02
180A:  MOVWF  FEC
180C:  MOVF   FED,F
180E:  CLRF   FEF
.................... 		config.ch[i].htd_reconnect_delay=4;
1810:  MOVF   x1C,W
1812:  MULLW  24
1814:  MOVF   FF3,W
1816:  CLRF   x1E
1818:  MOVWF  x1D
181A:  MOVLW  22
181C:  ADDWF  x1D,W
181E:  MOVWF  01
1820:  MOVLW  00
1822:  ADDWFC x1E,W
1824:  MOVWF  03
1826:  MOVF   01,W
1828:  ADDLW  1B
182A:  MOVWF  FE9
182C:  MOVLW  00
182E:  ADDWFC 03,W
1830:  MOVWF  FEA
1832:  CLRF   FEC
1834:  MOVF   FED,F
1836:  MOVLW  04
1838:  MOVWF  FEF
.................... 	}
.................... 	
.................... 
.................... #if 0
183A:  INCF   x1C,F
183C:  BRA    158A
.................... 	/* set the two channels differently */
.................... 	/* LVD 1 bus (modem, etc) @ Fairway */
.................... 	config.ch[0].lvd_disconnect_adc=602; /* 23.5 */
.................... 	config.ch[0].lvd_reconnect_adc=627;  /* 24.5 */
....................  	/* LVD 2 bus (CODAR) @ Fairway */
.................... 	config.ch[1].lvd_disconnect_adc=614; /* 24.0 */
.................... 	config.ch[1].lvd_reconnect_adc=640;  /* 25.0 */		
.................... #endif
.................... 
.................... 
.................... 	/* write them so next time we use from EEPROM */
.................... 	write_param_file();
183E:  MOVLB  0
1840:  RCALL  1532
1842:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void read_param_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config)); 
1844:  MOVLB  1
1846:  MOVLW  1B
1848:  MOVWF  x1C
184A:  CLRF   x1F
184C:  MOVLW  02
184E:  MOVWF  x1E
1850:  CLRF   x21
1852:  MOVFF  11C,120
1856:  CLRF   x23
1858:  MOVLW  48
185A:  MOVWF  x22
185C:  MOVLB  0
185E:  BRA    1412
1860:  MOVFF  01,11B
.................... 		
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) {
1864:  MOVFF  FF2,11C
1868:  BCF    FF2.7
186A:  CLRF   FA9
186C:  BCF    FA6.6
186E:  BCF    FA6.7
1870:  BSF    FA6.0
1872:  MOVF   FA8,W
1874:  MOVLB  1
1876:  BTFSC  x1C.7
1878:  BSF    FF2.7
187A:  SUBWF  x1B,W
187C:  BZ    1884
.................... 		write_default_param_file();
187E:  MOVLB  0
1880:  RCALL  157E
1882:  MOVLB  1
.................... 	}
1884:  MOVLB  0
1886:  GOTO   2E38 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... #include "i2c_handler_dcswc_module_latching_contactor.c"
.................... #include "registers_dcswc_module_latching_contactor.h"
.................... 
.................... /* first two or three registers will give enough information for telemetry */
.................... /* 10 bit input voltage ADC averaged value */
.................... #define I2C_REG_VOLTAGE_INPUT_AVG             0  
.................... /* two 8 bit channel states (A is MSB / B is LSB) */
.................... #define I2C_REG_STATE_CONTACTORS              1 
.................... /* 10 bit NTC thermistor ADC averaged value */
.................... #define I2C_REG_TEMPERATURE_BOARD_AVG         2
.................... 
....................   
.................... /* channel 0 / A */
.................... /* command can only come from I2C interface */
.................... #define I2C_REG_CH0_COMMAND_ON                3 /* R/W seconds */
.................... #define I2C_REG_CH0_COMMAND_ON_HOLD           4
.................... 
.................... #define I2C_REG_CH0_COMMAND_OFF               5 /* R/W seconds */
.................... #define I2C_REG_CH0_COMMAND_OFF_HOLD          6
.................... 
.................... /* low voltage disconnect */
.................... #define I2C_REG_CH0_LVD_DISCONNECT            7  /* R seconds */
.................... #define I2C_REG_CH0_LVD_RECONNECT             8 
.................... 
.................... /* high voltage disconnect */
.................... #define I2C_REG_CH0_HVD_DISCONNECT            9 /* R seconds */
.................... #define I2C_REG_CH0_HVD_RECONNECT             10
.................... 
.................... /* low temperature disconnect */
.................... #define I2C_REG_CH0_LTD_DISCONNECT            11  /* R seconds */
.................... #define I2C_REG_CH0_LTD_RECONNECT             12
.................... 
.................... /* high temperature disconnect */
.................... #define I2C_REG_CH0_HTD_DISCONNECT            13 /* R seconds */
.................... #define I2C_REG_CH0_HTD_RECONNECT             14
.................... 
.................... /* reserved for future, unimplemented */
.................... #define I2C_REG_CH0_FUT_DISCONNECT            15 /* R seconds */
.................... #define I2C_REG_CH0_FUT_RECONNECT             16
.................... 
.................... /* channel 1 / B */
.................... /* command can only come from I2C interface */
.................... #define I2C_REG_CH1_COMMAND_ON                17 /* R/W seconds */
.................... #define I2C_REG_CH1_COMMAND_ON_HOLD           18
.................... 
.................... #define I2C_REG_CH1_COMMAND_OFF               19 /* R/W seconds */
.................... #define I2C_REG_CH1_COMMAND_OFF_HOLD          20
.................... 
.................... /* low voltage disconnect */
.................... #define I2C_REG_CH1_LVD_DISCONNECT            21 /* R seconds */
.................... #define I2C_REG_CH1_LVD_RECONNECT             22 
.................... 
.................... /* high voltage disconnect */
.................... #define I2C_REG_CH1_HVD_DISCONNECT            23 /* R seconds */
.................... #define I2C_REG_CH1_HVD_RECONNECT             24
.................... 
.................... /* low temperature disconnect */
.................... #define I2C_REG_CH1_LTD_DISCONNECT            25  /* R seconds */
.................... #define I2C_REG_CH1_LTD_RECONNECT             26
.................... 
.................... /* high temperature disconnect */
.................... #define I2C_REG_CH1_HTD_DISCONNECT            27 /* R seconds */
.................... #define I2C_REG_CH1_HTD_RECONNECT             28
.................... 
.................... /* reserved for future, unimplemented */
.................... #define I2C_REG_CH1_FUT_DISCONNECT            29 /* R seconds */
.................... #define I2C_REG_CH1_FUT_RECONNECT             30
.................... 
.................... /* meta */
.................... #define I2C_REG_SEQUENCE_NUMBER               31 /* R */
.................... #define I2C_REG_TIME_INTERVAL_MILLISECONDS    32
.................... #define I2C_REG_TIME_UPTIME_MINUTES           33
.................... #define I2C_REG_DEFAULT_PARAMS_WRITTEN        34
.................... 
.................... /* channel configuration */
.................... /* channel 0 / A */
.................... #define I2C_REG_CH0_COMMAND_ON_HOLD_INITIAL   40
.................... 
.................... #define I2C_REG_CH0_COMMAND_OFF_HOLD_INITIAL  41
.................... 
.................... #define I2C_REG_CH0_LVD_DISCONNECT_ADC        42
.................... #define I2C_REG_CH0_LVD_DISCONNECT_DELAY      43
.................... #define I2C_REG_CH0_LVD_RECONNECT_ADC         44
.................... #define I2C_REG_CH0_LVD_RECONNECT_DELAY       45
.................... 
.................... #define I2C_REG_CH0_HVD_DISCONNECT_ADC        46
.................... #define I2C_REG_CH0_HVD_DISCONNECT_DELAY      47
.................... #define I2C_REG_CH0_HVD_RECONNECT_ADC         48
.................... #define I2C_REG_CH0_HVD_RECONNECT_DELAY       49
.................... 
.................... #define I2C_REG_CH0_LTD_DISCONNECT_ADC        50
.................... #define I2C_REG_CH0_LTD_DISCONNECT_DELAY      51
.................... #define I2C_REG_CH0_LTD_RECONNECT_ADC         52
.................... #define I2C_REG_CH0_LTD_RECONNECT_DELAY       53
.................... 
.................... #define I2C_REG_CH0_HTD_DISCONNECT_ADC        54
.................... #define I2C_REG_CH0_HTD_DISCONNECT_DELAY      55
.................... #define I2C_REG_CH0_HTD_RECONNECT_ADC         56
.................... #define I2C_REG_CH0_HTD_RECONNECT_DELAY       57
.................... 
.................... #define I2C_REG_CH0_FUT_DISCONNECT_VALUE      58
.................... #define I2C_REG_CH0_FUT_DISCONNECT_DELAY      59
.................... #define I2C_REG_CH0_FUT_RECONNECT_VALUE       60
.................... #define I2C_REG_CH0_FUT_RECONNECT_DELAY       61
.................... 
.................... /* channel 1 / B */
.................... #define I2C_REG_CH1_COMMAND_ON_HOLD_INITIAL   62
.................... 
.................... #define I2C_REG_CH1_COMMAND_OFF_HOLD_INITIAL  63
.................... 
.................... #define I2C_REG_CH1_LVD_DISCONNECT_ADC        64
.................... #define I2C_REG_CH1_LVD_DISCONNECT_DELAY      65
.................... #define I2C_REG_CH1_LVD_RECONNECT_ADC         66
.................... #define I2C_REG_CH1_LVD_RECONNECT_DELAY       67
.................... 
.................... #define I2C_REG_CH1_HVD_DISCONNECT_ADC        68
.................... #define I2C_REG_CH1_HVD_DISCONNECT_DELAY      69
.................... #define I2C_REG_CH1_HVD_RECONNECT_ADC         70
.................... #define I2C_REG_CH1_HVD_RECONNECT_DELAY       71
.................... 
.................... #define I2C_REG_CH1_LTD_DISCONNECT_ADC        72
.................... #define I2C_REG_CH1_LTD_DISCONNECT_DELAY      73
.................... #define I2C_REG_CH1_LTD_RECONNECT_ADC         74
.................... #define I2C_REG_CH1_LTD_RECONNECT_DELAY       75
.................... 
.................... #define I2C_REG_CH1_HTD_DISCONNECT_ADC        76
.................... #define I2C_REG_CH1_HTD_DISCONNECT_DELAY      77
.................... #define I2C_REG_CH1_HTD_RECONNECT_ADC         78
.................... #define I2C_REG_CH1_HTD_RECONNECT_DELAY       79
.................... 
.................... #define I2C_REG_CH1_FUT_DISCONNECT_VALUE      80
.................... #define I2C_REG_CH1_FUT_DISCONNECT_DELAY      81
.................... #define I2C_REG_CH1_FUT_RECONNECT_VALUE       82
.................... #define I2C_REG_CH1_FUT_RECONNECT_DELAY       83
.................... 
.................... 
.................... /* configuration */
.................... #define I2C_REG_CONFIG_HARDWARE_MODEL         84 /* R */
.................... #define I2C_REG_CONFIG_HARDWARE_VERSION       85
.................... #define I2C_REG_CONFIG_SOFTWARE_MODEL         86
.................... #define I2C_REG_CONFIG_SOFTWARE_VERSION       87
.................... #define I2C_REG_CONFIG_SOFTWARE_YEAR          88
.................... #define I2C_REG_CONFIG_SOFTWARE_MONTH         89
.................... #define I2C_REG_CONFIG_SOFTWARE_DAY           90
.................... 
.................... #define I2C_REG_CONFIG_PARAM_WRITE            100 /* R / W */
.................... 
.................... 
.................... 
.................... void write_i2c(int8 addr, int16 value) {
.................... 	int8 c;
.................... 
.................... 	/* c is the channel we are accessing based on register range */
.................... 	if ( addr >= I2C_REG_CH1_COMMAND_ON && addr <= I2C_REG_CH1_FUT_RECONNECT ) {
*
00DC:  MOVLB  1
00DE:  MOVF   x2E,W
00E0:  SUBLW  10
00E2:  BC    00F4
00E4:  MOVF   x2E,W
00E6:  SUBLW  1E
00E8:  BNC   00F4
.................... 		/* channel 1 status region */
.................... 		c=1;
00EA:  MOVLW  01
00EC:  MOVWF  x31
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON - I2C_REG_CH0_COMMAND_ON);
00EE:  MOVLW  0E
00F0:  SUBWF  x2E,F
.................... 	} else if ( addr >= I2C_REG_CH1_COMMAND_ON_HOLD && addr <= I2C_REG_CH1_FUT_RECONNECT_DELAY ) {
00F2:  BRA    010C
00F4:  MOVF   x2E,W
00F6:  SUBLW  11
00F8:  BC    010A
00FA:  MOVF   x2E,W
00FC:  SUBLW  53
00FE:  BNC   010A
.................... 		/* channel 1 configuration region */
.................... 		c=1;
0100:  MOVLW  01
0102:  MOVWF  x31
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON_HOLD - I2C_REG_CH0_COMMAND_ON_HOLD );
0104:  MOVLW  0E
0106:  SUBWF  x2E,F
.................... 	} else {
0108:  BRA    010C
.................... 		c=0;
010A:  CLRF   x31
.................... 	}
.................... 
.................... 	switch ( addr ) {
010C:  MOVF   x2E,W
010E:  XORLW  03
0110:  MOVLB  0
0112:  BZ    018A
0114:  XORLW  07
0116:  BZ    01BA
0118:  XORLW  01
011A:  BZ    01EA
011C:  XORLW  03
011E:  BTFSC  FD8.2
0120:  BRA    021A
0122:  XORLW  2C
0124:  BTFSC  FD8.2
0126:  BRA    024A
0128:  XORLW  01
012A:  BTFSC  FD8.2
012C:  BRA    027A
012E:  XORLW  07
0130:  BTFSC  FD8.2
0132:  BRA    02AA
0134:  XORLW  01
0136:  BTFSC  FD8.2
0138:  BRA    02DA
013A:  XORLW  03
013C:  BTFSC  FD8.2
013E:  BRA    030A
0140:  XORLW  01
0142:  BTFSC  FD8.2
0144:  BRA    033A
0146:  XORLW  1F
0148:  BTFSC  FD8.2
014A:  BRA    036A
014C:  XORLW  01
014E:  BTFSC  FD8.2
0150:  BRA    039A
0152:  XORLW  03
0154:  BTFSC  FD8.2
0156:  BRA    03CA
0158:  XORLW  01
015A:  BTFSC  FD8.2
015C:  BRA    03FA
015E:  XORLW  07
0160:  BTFSC  FD8.2
0162:  BRA    042A
0164:  XORLW  01
0166:  BTFSC  FD8.2
0168:  BRA    045A
016A:  XORLW  03
016C:  BTFSC  FD8.2
016E:  BRA    048A
0170:  XORLW  01
0172:  BTFSC  FD8.2
0174:  BRA    04BA
0176:  XORLW  0F
0178:  BTFSC  FD8.2
017A:  BRA    04EA
017C:  XORLW  01
017E:  BTFSC  FD8.2
0180:  BRA    051A
0182:  XORLW  5D
0184:  BTFSC  FD8.2
0186:  BRA    054A
0188:  BRA    0590
.................... 		case I2C_REG_CH0_COMMAND_ON:
.................... 			channel[c].command_on_seconds=value;
018A:  MOVLB  1
018C:  MOVF   x31,W
018E:  MULLW  19
0190:  MOVF   FF3,W
0192:  CLRF   x33
0194:  MOVWF  x32
0196:  MOVLW  01
0198:  ADDWF  x32,W
019A:  MOVWF  01
019C:  MOVLW  00
019E:  ADDWFC x33,W
01A0:  MOVWF  03
01A2:  MOVF   01,W
01A4:  ADDLW  DA
01A6:  MOVWF  FE9
01A8:  MOVLW  00
01AA:  ADDWFC 03,W
01AC:  MOVWF  FEA
01AE:  MOVFF  130,FEC
01B2:  MOVF   FED,F
01B4:  MOVFF  12F,FEF
01B8:  MOVLB  0
.................... 		case I2C_REG_CH0_COMMAND_ON_HOLD:
.................... 			channel[c].command_on_hold_seconds=value;
01BA:  MOVLB  1
01BC:  MOVF   x31,W
01BE:  MULLW  19
01C0:  MOVF   FF3,W
01C2:  CLRF   x33
01C4:  MOVWF  x32
01C6:  MOVLW  03
01C8:  ADDWF  x32,W
01CA:  MOVWF  01
01CC:  MOVLW  00
01CE:  ADDWFC x33,W
01D0:  MOVWF  03
01D2:  MOVF   01,W
01D4:  ADDLW  DA
01D6:  MOVWF  FE9
01D8:  MOVLW  00
01DA:  ADDWFC 03,W
01DC:  MOVWF  FEA
01DE:  MOVFF  130,FEC
01E2:  MOVF   FED,F
01E4:  MOVFF  12F,FEF
01E8:  MOVLB  0
.................... 	
.................... 		case I2C_REG_CH0_COMMAND_OFF:
.................... 			channel[c].command_off_seconds=value;
01EA:  MOVLB  1
01EC:  MOVF   x31,W
01EE:  MULLW  19
01F0:  MOVF   FF3,W
01F2:  CLRF   x33
01F4:  MOVWF  x32
01F6:  MOVLW  05
01F8:  ADDWF  x32,W
01FA:  MOVWF  01
01FC:  MOVLW  00
01FE:  ADDWFC x33,W
0200:  MOVWF  03
0202:  MOVF   01,W
0204:  ADDLW  DA
0206:  MOVWF  FE9
0208:  MOVLW  00
020A:  ADDWFC 03,W
020C:  MOVWF  FEA
020E:  MOVFF  130,FEC
0212:  MOVF   FED,F
0214:  MOVFF  12F,FEF
0218:  MOVLB  0
.................... 		case I2C_REG_CH0_COMMAND_OFF_HOLD:
.................... 			channel[c].command_off_hold_seconds=value;
021A:  MOVLB  1
021C:  MOVF   x31,W
021E:  MULLW  19
0220:  MOVF   FF3,W
0222:  CLRF   x33
0224:  MOVWF  x32
0226:  MOVLW  07
0228:  ADDWF  x32,W
022A:  MOVWF  01
022C:  MOVLW  00
022E:  ADDWFC x33,W
0230:  MOVWF  03
0232:  MOVF   01,W
0234:  ADDLW  DA
0236:  MOVWF  FE9
0238:  MOVLW  00
023A:  ADDWFC 03,W
023C:  MOVWF  FEA
023E:  MOVFF  130,FEC
0242:  MOVF   FED,F
0244:  MOVFF  12F,FEF
0248:  MOVLB  0
.................... 
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_ADC:
.................... 			config.ch[c].lvd_disconnect_adc=value;
024A:  MOVLB  1
024C:  MOVF   x31,W
024E:  MULLW  24
0250:  MOVF   FF3,W
0252:  CLRF   x33
0254:  MOVWF  x32
0256:  MOVLW  04
0258:  ADDWF  x32,W
025A:  MOVWF  01
025C:  MOVLW  00
025E:  ADDWFC x33,W
0260:  MOVWF  03
0262:  MOVF   01,W
0264:  ADDLW  1B
0266:  MOVWF  FE9
0268:  MOVLW  00
026A:  ADDWFC 03,W
026C:  MOVWF  FEA
026E:  MOVFF  130,FEC
0272:  MOVF   FED,F
0274:  MOVFF  12F,FEF
0278:  MOVLB  0
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_DELAY:
.................... 			config.ch[c].lvd_disconnect_delay=value;
027A:  MOVLB  1
027C:  MOVF   x31,W
027E:  MULLW  24
0280:  MOVF   FF3,W
0282:  CLRF   x33
0284:  MOVWF  x32
0286:  MOVLW  06
0288:  ADDWF  x32,W
028A:  MOVWF  01
028C:  MOVLW  00
028E:  ADDWFC x33,W
0290:  MOVWF  03
0292:  MOVF   01,W
0294:  ADDLW  1B
0296:  MOVWF  FE9
0298:  MOVLW  00
029A:  ADDWFC 03,W
029C:  MOVWF  FEA
029E:  MOVFF  130,FEC
02A2:  MOVF   FED,F
02A4:  MOVFF  12F,FEF
02A8:  MOVLB  0
.................... 		case I2C_REG_CH0_LVD_RECONNECT_ADC:
.................... 			config.ch[c].lvd_reconnect_adc=value;
02AA:  MOVLB  1
02AC:  MOVF   x31,W
02AE:  MULLW  24
02B0:  MOVF   FF3,W
02B2:  CLRF   x33
02B4:  MOVWF  x32
02B6:  MOVLW  08
02B8:  ADDWF  x32,W
02BA:  MOVWF  01
02BC:  MOVLW  00
02BE:  ADDWFC x33,W
02C0:  MOVWF  03
02C2:  MOVF   01,W
02C4:  ADDLW  1B
02C6:  MOVWF  FE9
02C8:  MOVLW  00
02CA:  ADDWFC 03,W
02CC:  MOVWF  FEA
02CE:  MOVFF  130,FEC
02D2:  MOVF   FED,F
02D4:  MOVFF  12F,FEF
02D8:  MOVLB  0
.................... 		case I2C_REG_CH0_LVD_RECONNECT_DELAY:
.................... 			config.ch[c].lvd_reconnect_delay=value;
02DA:  MOVLB  1
02DC:  MOVF   x31,W
02DE:  MULLW  24
02E0:  MOVF   FF3,W
02E2:  CLRF   x33
02E4:  MOVWF  x32
02E6:  MOVLW  0A
02E8:  ADDWF  x32,W
02EA:  MOVWF  01
02EC:  MOVLW  00
02EE:  ADDWFC x33,W
02F0:  MOVWF  03
02F2:  MOVF   01,W
02F4:  ADDLW  1B
02F6:  MOVWF  FE9
02F8:  MOVLW  00
02FA:  ADDWFC 03,W
02FC:  MOVWF  FEA
02FE:  MOVFF  130,FEC
0302:  MOVF   FED,F
0304:  MOVFF  12F,FEF
0308:  MOVLB  0
.................... 
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_ADC:
.................... 			config.ch[c].hvd_disconnect_adc=value;
030A:  MOVLB  1
030C:  MOVF   x31,W
030E:  MULLW  24
0310:  MOVF   FF3,W
0312:  CLRF   x33
0314:  MOVWF  x32
0316:  MOVLW  0C
0318:  ADDWF  x32,W
031A:  MOVWF  01
031C:  MOVLW  00
031E:  ADDWFC x33,W
0320:  MOVWF  03
0322:  MOVF   01,W
0324:  ADDLW  1B
0326:  MOVWF  FE9
0328:  MOVLW  00
032A:  ADDWFC 03,W
032C:  MOVWF  FEA
032E:  MOVFF  130,FEC
0332:  MOVF   FED,F
0334:  MOVFF  12F,FEF
0338:  MOVLB  0
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_DELAY:
.................... 			config.ch[c].hvd_disconnect_delay=value;
033A:  MOVLB  1
033C:  MOVF   x31,W
033E:  MULLW  24
0340:  MOVF   FF3,W
0342:  CLRF   x33
0344:  MOVWF  x32
0346:  MOVLW  0E
0348:  ADDWF  x32,W
034A:  MOVWF  01
034C:  MOVLW  00
034E:  ADDWFC x33,W
0350:  MOVWF  03
0352:  MOVF   01,W
0354:  ADDLW  1B
0356:  MOVWF  FE9
0358:  MOVLW  00
035A:  ADDWFC 03,W
035C:  MOVWF  FEA
035E:  MOVFF  130,FEC
0362:  MOVF   FED,F
0364:  MOVFF  12F,FEF
0368:  MOVLB  0
.................... 		case I2C_REG_CH0_HVD_RECONNECT_ADC:
.................... 			config.ch[c].hvd_reconnect_adc=value;
036A:  MOVLB  1
036C:  MOVF   x31,W
036E:  MULLW  24
0370:  MOVF   FF3,W
0372:  CLRF   x33
0374:  MOVWF  x32
0376:  MOVLW  10
0378:  ADDWF  x32,W
037A:  MOVWF  01
037C:  MOVLW  00
037E:  ADDWFC x33,W
0380:  MOVWF  03
0382:  MOVF   01,W
0384:  ADDLW  1B
0386:  MOVWF  FE9
0388:  MOVLW  00
038A:  ADDWFC 03,W
038C:  MOVWF  FEA
038E:  MOVFF  130,FEC
0392:  MOVF   FED,F
0394:  MOVFF  12F,FEF
0398:  MOVLB  0
.................... 		case I2C_REG_CH0_HVD_RECONNECT_DELAY:
.................... 			config.ch[c].hvd_reconnect_delay=value;
039A:  MOVLB  1
039C:  MOVF   x31,W
039E:  MULLW  24
03A0:  MOVF   FF3,W
03A2:  CLRF   x33
03A4:  MOVWF  x32
03A6:  MOVLW  12
03A8:  ADDWF  x32,W
03AA:  MOVWF  01
03AC:  MOVLW  00
03AE:  ADDWFC x33,W
03B0:  MOVWF  03
03B2:  MOVF   01,W
03B4:  ADDLW  1B
03B6:  MOVWF  FE9
03B8:  MOVLW  00
03BA:  ADDWFC 03,W
03BC:  MOVWF  FEA
03BE:  MOVFF  130,FEC
03C2:  MOVF   FED,F
03C4:  MOVFF  12F,FEF
03C8:  MOVLB  0
.................... 
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_ADC:
.................... 			config.ch[c].ltd_disconnect_adc=value;
03CA:  MOVLB  1
03CC:  MOVF   x31,W
03CE:  MULLW  24
03D0:  MOVF   FF3,W
03D2:  CLRF   x33
03D4:  MOVWF  x32
03D6:  MOVLW  14
03D8:  ADDWF  x32,W
03DA:  MOVWF  01
03DC:  MOVLW  00
03DE:  ADDWFC x33,W
03E0:  MOVWF  03
03E2:  MOVF   01,W
03E4:  ADDLW  1B
03E6:  MOVWF  FE9
03E8:  MOVLW  00
03EA:  ADDWFC 03,W
03EC:  MOVWF  FEA
03EE:  MOVFF  130,FEC
03F2:  MOVF   FED,F
03F4:  MOVFF  12F,FEF
03F8:  MOVLB  0
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_DELAY:
.................... 			config.ch[c].ltd_disconnect_delay=value;
03FA:  MOVLB  1
03FC:  MOVF   x31,W
03FE:  MULLW  24
0400:  MOVF   FF3,W
0402:  CLRF   x33
0404:  MOVWF  x32
0406:  MOVLW  16
0408:  ADDWF  x32,W
040A:  MOVWF  01
040C:  MOVLW  00
040E:  ADDWFC x33,W
0410:  MOVWF  03
0412:  MOVF   01,W
0414:  ADDLW  1B
0416:  MOVWF  FE9
0418:  MOVLW  00
041A:  ADDWFC 03,W
041C:  MOVWF  FEA
041E:  MOVFF  130,FEC
0422:  MOVF   FED,F
0424:  MOVFF  12F,FEF
0428:  MOVLB  0
.................... 		case I2C_REG_CH0_LTD_RECONNECT_ADC:
.................... 			config.ch[c].ltd_reconnect_adc=value;
042A:  MOVLB  1
042C:  MOVF   x31,W
042E:  MULLW  24
0430:  MOVF   FF3,W
0432:  CLRF   x33
0434:  MOVWF  x32
0436:  MOVLW  18
0438:  ADDWF  x32,W
043A:  MOVWF  01
043C:  MOVLW  00
043E:  ADDWFC x33,W
0440:  MOVWF  03
0442:  MOVF   01,W
0444:  ADDLW  1B
0446:  MOVWF  FE9
0448:  MOVLW  00
044A:  ADDWFC 03,W
044C:  MOVWF  FEA
044E:  MOVFF  130,FEC
0452:  MOVF   FED,F
0454:  MOVFF  12F,FEF
0458:  MOVLB  0
.................... 		case I2C_REG_CH0_LTD_RECONNECT_DELAY:
.................... 			config.ch[c].ltd_reconnect_delay=value;
045A:  MOVLB  1
045C:  MOVF   x31,W
045E:  MULLW  24
0460:  MOVF   FF3,W
0462:  CLRF   x33
0464:  MOVWF  x32
0466:  MOVLW  1A
0468:  ADDWF  x32,W
046A:  MOVWF  01
046C:  MOVLW  00
046E:  ADDWFC x33,W
0470:  MOVWF  03
0472:  MOVF   01,W
0474:  ADDLW  1B
0476:  MOVWF  FE9
0478:  MOVLW  00
047A:  ADDWFC 03,W
047C:  MOVWF  FEA
047E:  MOVFF  130,FEC
0482:  MOVF   FED,F
0484:  MOVFF  12F,FEF
0488:  MOVLB  0
.................... 
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_ADC:
.................... 			config.ch[c].htd_disconnect_adc=value;
048A:  MOVLB  1
048C:  MOVF   x31,W
048E:  MULLW  24
0490:  MOVF   FF3,W
0492:  CLRF   x33
0494:  MOVWF  x32
0496:  MOVLW  1C
0498:  ADDWF  x32,W
049A:  MOVWF  01
049C:  MOVLW  00
049E:  ADDWFC x33,W
04A0:  MOVWF  03
04A2:  MOVF   01,W
04A4:  ADDLW  1B
04A6:  MOVWF  FE9
04A8:  MOVLW  00
04AA:  ADDWFC 03,W
04AC:  MOVWF  FEA
04AE:  MOVFF  130,FEC
04B2:  MOVF   FED,F
04B4:  MOVFF  12F,FEF
04B8:  MOVLB  0
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_DELAY:
.................... 			config.ch[c].htd_disconnect_delay=value;
04BA:  MOVLB  1
04BC:  MOVF   x31,W
04BE:  MULLW  24
04C0:  MOVF   FF3,W
04C2:  CLRF   x33
04C4:  MOVWF  x32
04C6:  MOVLW  1E
04C8:  ADDWF  x32,W
04CA:  MOVWF  01
04CC:  MOVLW  00
04CE:  ADDWFC x33,W
04D0:  MOVWF  03
04D2:  MOVF   01,W
04D4:  ADDLW  1B
04D6:  MOVWF  FE9
04D8:  MOVLW  00
04DA:  ADDWFC 03,W
04DC:  MOVWF  FEA
04DE:  MOVFF  130,FEC
04E2:  MOVF   FED,F
04E4:  MOVFF  12F,FEF
04E8:  MOVLB  0
.................... 		case I2C_REG_CH0_HTD_RECONNECT_ADC:
.................... 			config.ch[c].htd_reconnect_adc=value;
04EA:  MOVLB  1
04EC:  MOVF   x31,W
04EE:  MULLW  24
04F0:  MOVF   FF3,W
04F2:  CLRF   x33
04F4:  MOVWF  x32
04F6:  MOVLW  20
04F8:  ADDWF  x32,W
04FA:  MOVWF  01
04FC:  MOVLW  00
04FE:  ADDWFC x33,W
0500:  MOVWF  03
0502:  MOVF   01,W
0504:  ADDLW  1B
0506:  MOVWF  FE9
0508:  MOVLW  00
050A:  ADDWFC 03,W
050C:  MOVWF  FEA
050E:  MOVFF  130,FEC
0512:  MOVF   FED,F
0514:  MOVFF  12F,FEF
0518:  MOVLB  0
.................... 		case I2C_REG_CH0_HTD_RECONNECT_DELAY:
.................... 			config.ch[c].htd_reconnect_delay=value;
051A:  MOVLB  1
051C:  MOVF   x31,W
051E:  MULLW  24
0520:  MOVF   FF3,W
0522:  CLRF   x33
0524:  MOVWF  x32
0526:  MOVLW  22
0528:  ADDWF  x32,W
052A:  MOVWF  01
052C:  MOVLW  00
052E:  ADDWFC x33,W
0530:  MOVWF  03
0532:  MOVF   01,W
0534:  ADDLW  1B
0536:  MOVWF  FE9
0538:  MOVLW  00
053A:  ADDWFC 03,W
053C:  MOVWF  FEA
053E:  MOVFF  130,FEC
0542:  MOVF   FED,F
0544:  MOVFF  12F,FEF
0548:  MOVLB  0
.................... 
.................... 		/* don't need to implement FUT ... there is nowhere for it to go anyhow */
.................... 
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			if ( 1 == value ) {
054A:  MOVLB  1
054C:  DECFSZ x2F,W
054E:  BRA    055C
0550:  MOVF   x30,F
0552:  BNZ   055C
.................... 				timers.now_write_config=1;
0554:  MOVLB  0
0556:  BSF    xCF.3
.................... 			} else if ( 2 == value ) {
0558:  BRA    0590
055A:  MOVLB  1
055C:  MOVF   x2F,W
055E:  SUBLW  02
0560:  BNZ   056E
0562:  MOVF   x30,F
0564:  BNZ   056E
.................... 				timers.now_reset_config=1;
0566:  MOVLB  0
0568:  BSF    xCF.4
.................... 			} else if ( 1802 == value ) {
056A:  BRA    0590
056C:  MOVLB  1
056E:  MOVF   x2F,W
0570:  SUBLW  0A
0572:  BNZ   0584
0574:  MOVF   x30,W
0576:  SUBLW  07
0578:  BNZ   0584
.................... 				current.factory_unlocked =1;
057A:  MOVLW  01
057C:  MOVLB  0
057E:  MOVWF  xCA
.................... 			} else if ( 65535 == value ) {
0580:  BRA    0590
0582:  MOVLB  1
0584:  INCFSZ x2F,W
0586:  BRA    058E
0588:  INCFSZ x30,W
058A:  BRA    058E
.................... 				reset_cpu();
058C:  RESET
058E:  MOVLB  0
.................... 			}
.................... 			break;
.................... 		default:
.................... 			/* do nothing */
.................... 	}
0590:  GOTO   0F12 (RETURN)
.................... 
.................... }
.................... 
.................... 
.................... int16 map_i2c(int8 addr) {
.................... 	int8 c;
.................... 
.................... 	/* c is the channel we are accessing based on register range */
.................... 	if ( addr >= I2C_REG_CH1_COMMAND_ON && addr <= I2C_REG_CH1_FUT_RECONNECT ) {
*
0614:  MOVLB  1
0616:  MOVF   x2D,W
0618:  SUBLW  10
061A:  BC    062C
061C:  MOVF   x2D,W
061E:  SUBLW  1E
0620:  BNC   062C
.................... 		/* channel 1 status region */
.................... 		c=1;
0622:  MOVLW  01
0624:  MOVWF  x2E
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON - I2C_REG_CH0_COMMAND_ON);
0626:  MOVLW  0E
0628:  SUBWF  x2D,F
.................... 	} else if ( addr >= I2C_REG_CH1_COMMAND_ON_HOLD && addr <= I2C_REG_CH1_FUT_RECONNECT_DELAY ) {
062A:  BRA    0644
062C:  MOVF   x2D,W
062E:  SUBLW  11
0630:  BC    0642
0632:  MOVF   x2D,W
0634:  SUBLW  53
0636:  BNC   0642
.................... 		/* channel 1 configuration region */
.................... 		c=1;
0638:  MOVLW  01
063A:  MOVWF  x2E
.................... 		/* remap down to channel 0 region */
.................... 		addr -= (I2C_REG_CH1_COMMAND_ON_HOLD - I2C_REG_CH0_COMMAND_ON_HOLD );
063C:  MOVLW  0E
063E:  SUBWF  x2D,F
.................... 	} else {
0640:  BRA    0644
.................... 		c=0;
0642:  CLRF   x2E
.................... 	}
.................... 
.................... 	switch ( addr ) {
0644:  MOVF   x2D,W
0646:  XORLW  00
0648:  MOVLB  0
064A:  BTFSC  FD8.2
064C:  BRA    077C
064E:  XORLW  01
0650:  BTFSC  FD8.2
0652:  BRA    0788
0654:  XORLW  03
0656:  BTFSC  FD8.2
0658:  BRA    0796
065A:  XORLW  01
065C:  BTFSC  FD8.2
065E:  BRA    07A4
0660:  XORLW  07
0662:  BTFSC  FD8.2
0664:  BRA    07DA
0666:  XORLW  01
0668:  BTFSC  FD8.2
066A:  BRA    0810
066C:  XORLW  03
066E:  BTFSC  FD8.2
0670:  BRA    0846
0672:  XORLW  01
0674:  BTFSC  FD8.2
0676:  BRA    087C
0678:  XORLW  0F
067A:  BTFSC  FD8.2
067C:  BRA    08B2
067E:  XORLW  01
0680:  BTFSC  FD8.2
0682:  BRA    08E8
0684:  XORLW  03
0686:  BTFSC  FD8.2
0688:  BRA    091E
068A:  XORLW  01
068C:  BTFSC  FD8.2
068E:  BRA    0954
0690:  XORLW  07
0692:  BTFSC  FD8.2
0694:  BRA    098A
0696:  XORLW  01
0698:  BTFSC  FD8.2
069A:  BRA    09C0
069C:  XORLW  03
069E:  BTFSC  FD8.2
06A0:  BRA    09F6
06A2:  XORLW  01
06A4:  BTFSC  FD8.2
06A6:  BRA    0A2C
06A8:  XORLW  1F
06AA:  BTFSC  FD8.2
06AC:  BRA    0A2C
06AE:  XORLW  0F
06B0:  BTFSC  FD8.2
06B2:  BRA    0A34
06B4:  XORLW  3F
06B6:  BTFSC  FD8.2
06B8:  BRA    0A3E
06BA:  XORLW  01
06BC:  BTFSC  FD8.2
06BE:  BRA    0A48
06C0:  XORLW  03
06C2:  BTFSC  FD8.2
06C4:  BRA    0A52
06C6:  XORLW  0A
06C8:  BTFSC  FD8.2
06CA:  BRA    0A5A
06CC:  XORLW  01
06CE:  BTFSC  FD8.2
06D0:  BRA    0A84
06D2:  XORLW  03
06D4:  BTFSC  FD8.2
06D6:  BRA    0ABA
06D8:  XORLW  01
06DA:  BTFSC  FD8.2
06DC:  BRA    0AF0
06DE:  XORLW  07
06E0:  BTFSC  FD8.2
06E2:  BRA    0B26
06E4:  XORLW  01
06E6:  BTFSC  FD8.2
06E8:  BRA    0B5C
06EA:  XORLW  03
06EC:  BTFSC  FD8.2
06EE:  BRA    0B92
06F0:  XORLW  01
06F2:  BTFSC  FD8.2
06F4:  BRA    0BC8
06F6:  XORLW  1F
06F8:  BTFSC  FD8.2
06FA:  BRA    0BFE
06FC:  XORLW  01
06FE:  BTFSC  FD8.2
0700:  BRA    0C34
0702:  XORLW  03
0704:  BTFSC  FD8.2
0706:  BRA    0C6A
0708:  XORLW  01
070A:  BTFSC  FD8.2
070C:  BRA    0CA0
070E:  XORLW  07
0710:  BTFSC  FD8.2
0712:  BRA    0CD6
0714:  XORLW  01
0716:  BTFSC  FD8.2
0718:  BRA    0D0C
071A:  XORLW  03
071C:  BTFSC  FD8.2
071E:  BRA    0D42
0720:  XORLW  01
0722:  BTFSC  FD8.2
0724:  BRA    0D78
0726:  XORLW  0F
0728:  BTFSC  FD8.2
072A:  BRA    0DAE
072C:  XORLW  01
072E:  BTFSC  FD8.2
0730:  BRA    0DE4
0732:  XORLW  03
0734:  BTFSC  FD8.2
0736:  BRA    0E1A
0738:  XORLW  01
073A:  BTFSC  FD8.2
073C:  BRA    0E1A
073E:  XORLW  07
0740:  BTFSC  FD8.2
0742:  BRA    0E1A
0744:  XORLW  01
0746:  BTFSC  FD8.2
0748:  BRA    0E1A
074A:  XORLW  69
074C:  BTFSC  FD8.2
074E:  BRA    0E22
0750:  XORLW  01
0752:  BTFSC  FD8.2
0754:  BRA    0E2C
0756:  XORLW  03
0758:  BTFSC  FD8.2
075A:  BRA    0E36
075C:  XORLW  01
075E:  BTFSC  FD8.2
0760:  BRA    0E40
0762:  XORLW  0F
0764:  BTFSC  FD8.2
0766:  BRA    0E4A
0768:  XORLW  01
076A:  BTFSC  FD8.2
076C:  BRA    0E52
076E:  XORLW  03
0770:  BTFSC  FD8.2
0772:  BRA    0E5A
0774:  XORLW  3E
0776:  BTFSC  FD8.2
0778:  BRA    0E62
077A:  BRA    0E6A
.................... 		/* not channel based */
.................... 		case I2C_REG_VOLTAGE_INPUT_AVG: 
.................... 			return (int16) adc_get(0);
077C:  MOVLB  1
077E:  CLRF   x2F
0780:  MOVLB  0
0782:  RCALL  0594
0784:  MOVF   02,W
0786:  BRA    0E74
.................... 		case I2C_REG_STATE_CONTACTORS:
.................... 			return (int16) make16(channel[0].state,channel[1].state);
0788:  MOVFF  DA,03
078C:  MOVFF  F3,01
0790:  MOVFF  DA,02
0794:  BRA    0E74
.................... 		case I2C_REG_TEMPERATURE_BOARD_AVG: 
.................... 			return (int16) adc_get(1);
0796:  MOVLW  01
0798:  MOVLB  1
079A:  MOVWF  x2F
079C:  MOVLB  0
079E:  RCALL  0594
07A0:  MOVF   02,W
07A2:  BRA    0E74
.................... 
.................... 		/* status based on channel value c */
.................... 		case I2C_REG_CH0_COMMAND_ON :
.................... 			return (int16) channel[c].command_on_seconds;
07A4:  MOVLB  1
07A6:  MOVF   x2E,W
07A8:  MULLW  19
07AA:  MOVF   FF3,W
07AC:  CLRF   x30
07AE:  MOVWF  x2F
07B0:  MOVLW  01
07B2:  ADDWF  x2F,W
07B4:  MOVWF  01
07B6:  MOVLW  00
07B8:  ADDWFC x30,W
07BA:  MOVWF  03
07BC:  MOVF   01,W
07BE:  ADDLW  DA
07C0:  MOVWF  FE9
07C2:  MOVLW  00
07C4:  ADDWFC 03,W
07C6:  MOVWF  FEA
07C8:  MOVFF  FEC,03
07CC:  MOVF   FED,F
07CE:  MOVFF  FEF,01
07D2:  MOVFF  03,02
07D6:  MOVLB  0
07D8:  BRA    0E74
.................... 		case I2C_REG_CH0_COMMAND_ON_HOLD:
.................... 			return (int16) channel[c].command_on_hold_seconds;
07DA:  MOVLB  1
07DC:  MOVF   x2E,W
07DE:  MULLW  19
07E0:  MOVF   FF3,W
07E2:  CLRF   x30
07E4:  MOVWF  x2F
07E6:  MOVLW  03
07E8:  ADDWF  x2F,W
07EA:  MOVWF  01
07EC:  MOVLW  00
07EE:  ADDWFC x30,W
07F0:  MOVWF  03
07F2:  MOVF   01,W
07F4:  ADDLW  DA
07F6:  MOVWF  FE9
07F8:  MOVLW  00
07FA:  ADDWFC 03,W
07FC:  MOVWF  FEA
07FE:  MOVFF  FEC,03
0802:  MOVF   FED,F
0804:  MOVFF  FEF,01
0808:  MOVFF  03,02
080C:  MOVLB  0
080E:  BRA    0E74
.................... 
.................... 		case I2C_REG_CH0_COMMAND_OFF:
.................... 			return (int16) channel[c].command_off_seconds;
0810:  MOVLB  1
0812:  MOVF   x2E,W
0814:  MULLW  19
0816:  MOVF   FF3,W
0818:  CLRF   x30
081A:  MOVWF  x2F
081C:  MOVLW  05
081E:  ADDWF  x2F,W
0820:  MOVWF  01
0822:  MOVLW  00
0824:  ADDWFC x30,W
0826:  MOVWF  03
0828:  MOVF   01,W
082A:  ADDLW  DA
082C:  MOVWF  FE9
082E:  MOVLW  00
0830:  ADDWFC 03,W
0832:  MOVWF  FEA
0834:  MOVFF  FEC,03
0838:  MOVF   FED,F
083A:  MOVFF  FEF,01
083E:  MOVFF  03,02
0842:  MOVLB  0
0844:  BRA    0E74
.................... 		case I2C_REG_CH0_COMMAND_OFF_HOLD:
.................... 			return (int16) channel[c].command_off_hold_seconds;
0846:  MOVLB  1
0848:  MOVF   x2E,W
084A:  MULLW  19
084C:  MOVF   FF3,W
084E:  CLRF   x30
0850:  MOVWF  x2F
0852:  MOVLW  07
0854:  ADDWF  x2F,W
0856:  MOVWF  01
0858:  MOVLW  00
085A:  ADDWFC x30,W
085C:  MOVWF  03
085E:  MOVF   01,W
0860:  ADDLW  DA
0862:  MOVWF  FE9
0864:  MOVLW  00
0866:  ADDWFC 03,W
0868:  MOVWF  FEA
086A:  MOVFF  FEC,03
086E:  MOVF   FED,F
0870:  MOVFF  FEF,01
0874:  MOVFF  03,02
0878:  MOVLB  0
087A:  BRA    0E74
.................... 
.................... 		case I2C_REG_CH0_LVD_DISCONNECT:
.................... 			return (int16) channel[c].lvd_disconnect_delay_seconds;
087C:  MOVLB  1
087E:  MOVF   x2E,W
0880:  MULLW  19
0882:  MOVF   FF3,W
0884:  CLRF   x30
0886:  MOVWF  x2F
0888:  MOVLW  09
088A:  ADDWF  x2F,W
088C:  MOVWF  01
088E:  MOVLW  00
0890:  ADDWFC x30,W
0892:  MOVWF  03
0894:  MOVF   01,W
0896:  ADDLW  DA
0898:  MOVWF  FE9
089A:  MOVLW  00
089C:  ADDWFC 03,W
089E:  MOVWF  FEA
08A0:  MOVFF  FEC,03
08A4:  MOVF   FED,F
08A6:  MOVFF  FEF,01
08AA:  MOVFF  03,02
08AE:  MOVLB  0
08B0:  BRA    0E74
.................... 		case I2C_REG_CH0_LVD_RECONNECT:
.................... 			return (int16) channel[c].lvd_reconnect_delay_seconds;
08B2:  MOVLB  1
08B4:  MOVF   x2E,W
08B6:  MULLW  19
08B8:  MOVF   FF3,W
08BA:  CLRF   x30
08BC:  MOVWF  x2F
08BE:  MOVLW  0B
08C0:  ADDWF  x2F,W
08C2:  MOVWF  01
08C4:  MOVLW  00
08C6:  ADDWFC x30,W
08C8:  MOVWF  03
08CA:  MOVF   01,W
08CC:  ADDLW  DA
08CE:  MOVWF  FE9
08D0:  MOVLW  00
08D2:  ADDWFC 03,W
08D4:  MOVWF  FEA
08D6:  MOVFF  FEC,03
08DA:  MOVF   FED,F
08DC:  MOVFF  FEF,01
08E0:  MOVFF  03,02
08E4:  MOVLB  0
08E6:  BRA    0E74
.................... 
.................... 		case I2C_REG_CH0_HVD_DISCONNECT:
.................... 			return (int16) channel[c].hvd_disconnect_delay_seconds;
08E8:  MOVLB  1
08EA:  MOVF   x2E,W
08EC:  MULLW  19
08EE:  MOVF   FF3,W
08F0:  CLRF   x30
08F2:  MOVWF  x2F
08F4:  MOVLW  0D
08F6:  ADDWF  x2F,W
08F8:  MOVWF  01
08FA:  MOVLW  00
08FC:  ADDWFC x30,W
08FE:  MOVWF  03
0900:  MOVF   01,W
0902:  ADDLW  DA
0904:  MOVWF  FE9
0906:  MOVLW  00
0908:  ADDWFC 03,W
090A:  MOVWF  FEA
090C:  MOVFF  FEC,03
0910:  MOVF   FED,F
0912:  MOVFF  FEF,01
0916:  MOVFF  03,02
091A:  MOVLB  0
091C:  BRA    0E74
.................... 		case I2C_REG_CH0_HVD_RECONNECT:
.................... 			return (int16) channel[c].hvd_reconnect_delay_seconds;
091E:  MOVLB  1
0920:  MOVF   x2E,W
0922:  MULLW  19
0924:  MOVF   FF3,W
0926:  CLRF   x30
0928:  MOVWF  x2F
092A:  MOVLW  0F
092C:  ADDWF  x2F,W
092E:  MOVWF  01
0930:  MOVLW  00
0932:  ADDWFC x30,W
0934:  MOVWF  03
0936:  MOVF   01,W
0938:  ADDLW  DA
093A:  MOVWF  FE9
093C:  MOVLW  00
093E:  ADDWFC 03,W
0940:  MOVWF  FEA
0942:  MOVFF  FEC,03
0946:  MOVF   FED,F
0948:  MOVFF  FEF,01
094C:  MOVFF  03,02
0950:  MOVLB  0
0952:  BRA    0E74
.................... 
.................... 		case I2C_REG_CH0_LTD_DISCONNECT:
.................... 			return (int16) channel[c].ltd_disconnect_delay_seconds;
0954:  MOVLB  1
0956:  MOVF   x2E,W
0958:  MULLW  19
095A:  MOVF   FF3,W
095C:  CLRF   x30
095E:  MOVWF  x2F
0960:  MOVLW  11
0962:  ADDWF  x2F,W
0964:  MOVWF  01
0966:  MOVLW  00
0968:  ADDWFC x30,W
096A:  MOVWF  03
096C:  MOVF   01,W
096E:  ADDLW  DA
0970:  MOVWF  FE9
0972:  MOVLW  00
0974:  ADDWFC 03,W
0976:  MOVWF  FEA
0978:  MOVFF  FEC,03
097C:  MOVF   FED,F
097E:  MOVFF  FEF,01
0982:  MOVFF  03,02
0986:  MOVLB  0
0988:  BRA    0E74
.................... 		case I2C_REG_CH0_LTD_RECONNECT:
.................... 			return (int16) channel[c].ltd_reconnect_delay_seconds;
098A:  MOVLB  1
098C:  MOVF   x2E,W
098E:  MULLW  19
0990:  MOVF   FF3,W
0992:  CLRF   x30
0994:  MOVWF  x2F
0996:  MOVLW  13
0998:  ADDWF  x2F,W
099A:  MOVWF  01
099C:  MOVLW  00
099E:  ADDWFC x30,W
09A0:  MOVWF  03
09A2:  MOVF   01,W
09A4:  ADDLW  DA
09A6:  MOVWF  FE9
09A8:  MOVLW  00
09AA:  ADDWFC 03,W
09AC:  MOVWF  FEA
09AE:  MOVFF  FEC,03
09B2:  MOVF   FED,F
09B4:  MOVFF  FEF,01
09B8:  MOVFF  03,02
09BC:  MOVLB  0
09BE:  BRA    0E74
.................... 
.................... 		case I2C_REG_CH0_HTD_DISCONNECT:
.................... 			return (int16) channel[c].htd_disconnect_delay_seconds;
09C0:  MOVLB  1
09C2:  MOVF   x2E,W
09C4:  MULLW  19
09C6:  MOVF   FF3,W
09C8:  CLRF   x30
09CA:  MOVWF  x2F
09CC:  MOVLW  15
09CE:  ADDWF  x2F,W
09D0:  MOVWF  01
09D2:  MOVLW  00
09D4:  ADDWFC x30,W
09D6:  MOVWF  03
09D8:  MOVF   01,W
09DA:  ADDLW  DA
09DC:  MOVWF  FE9
09DE:  MOVLW  00
09E0:  ADDWFC 03,W
09E2:  MOVWF  FEA
09E4:  MOVFF  FEC,03
09E8:  MOVF   FED,F
09EA:  MOVFF  FEF,01
09EE:  MOVFF  03,02
09F2:  MOVLB  0
09F4:  BRA    0E74
.................... 		case I2C_REG_CH0_HTD_RECONNECT:
.................... 			return (int16) channel[c].htd_reconnect_delay_seconds;
09F6:  MOVLB  1
09F8:  MOVF   x2E,W
09FA:  MULLW  19
09FC:  MOVF   FF3,W
09FE:  CLRF   x30
0A00:  MOVWF  x2F
0A02:  MOVLW  17
0A04:  ADDWF  x2F,W
0A06:  MOVWF  01
0A08:  MOVLW  00
0A0A:  ADDWFC x30,W
0A0C:  MOVWF  03
0A0E:  MOVF   01,W
0A10:  ADDLW  DA
0A12:  MOVWF  FE9
0A14:  MOVLW  00
0A16:  ADDWFC 03,W
0A18:  MOVWF  FEA
0A1A:  MOVFF  FEC,03
0A1E:  MOVF   FED,F
0A20:  MOVFF  FEF,01
0A24:  MOVFF  03,02
0A28:  MOVLB  0
0A2A:  BRA    0E74
.................... 
.................... 		case I2C_REG_CH0_FUT_DISCONNECT:
.................... 		case I2C_REG_CH0_FUT_RECONNECT:
.................... 			return (int16) 0xffff; /* not yet implemented */
0A2C:  MOVLW  FF
0A2E:  MOVWF  01
0A30:  MOVWF  02
0A32:  BRA    0E74
.................... 
.................... 
.................... 		/* non-channel based meta */
.................... 		case I2C_REG_SEQUENCE_NUMBER:
.................... 			return (int16) current.sequence_number;
0A34:  MOVFF  C4,01
0A38:  MOVFF  C5,02
0A3C:  BRA    0E74
.................... 		case I2C_REG_TIME_INTERVAL_MILLISECONDS:
.................... 			return (int16) current.interval_milliseconds;
0A3E:  MOVFF  C8,01
0A42:  MOVFF  C9,02
0A46:  BRA    0E74
.................... 		case I2C_REG_TIME_UPTIME_MINUTES:
.................... 			return (int16) current.uptime_minutes;
0A48:  MOVFF  C6,01
0A4C:  MOVFF  C7,02
0A50:  BRA    0E74
.................... 		case I2C_REG_DEFAULT_PARAMS_WRITTEN:
.................... 			return (int16) current.default_params_written;
0A52:  MOVFF  CE,01
0A56:  CLRF   02
0A58:  BRA    0E74
.................... 
.................... 		/* channel based configuration */
.................... 		case I2C_REG_CH0_COMMAND_ON_HOLD_INITIAL:
.................... 			return (int16) config.ch[c].command_on_hold_time;
0A5A:  MOVLB  1
0A5C:  MOVF   x2E,W
0A5E:  MULLW  24
0A60:  MOVF   FF3,W
0A62:  CLRF   x30
0A64:  MOVWF  x2F
0A66:  MOVLW  1B
0A68:  ADDWF  x2F,W
0A6A:  MOVWF  FE9
0A6C:  MOVLW  00
0A6E:  ADDWFC x30,W
0A70:  MOVWF  FEA
0A72:  MOVFF  FEC,03
0A76:  MOVF   FED,F
0A78:  MOVFF  FEF,01
0A7C:  MOVFF  03,02
0A80:  MOVLB  0
0A82:  BRA    0E74
.................... 
.................... 		case I2C_REG_CH0_COMMAND_OFF_HOLD_INITIAL:
.................... 			return (int16) config.ch[c].command_off_hold_time;
0A84:  MOVLB  1
0A86:  MOVF   x2E,W
0A88:  MULLW  24
0A8A:  MOVF   FF3,W
0A8C:  CLRF   x30
0A8E:  MOVWF  x2F
0A90:  MOVLW  02
0A92:  ADDWF  x2F,W
0A94:  MOVWF  01
0A96:  MOVLW  00
0A98:  ADDWFC x30,W
0A9A:  MOVWF  03
0A9C:  MOVF   01,W
0A9E:  ADDLW  1B
0AA0:  MOVWF  FE9
0AA2:  MOVLW  00
0AA4:  ADDWFC 03,W
0AA6:  MOVWF  FEA
0AA8:  MOVFF  FEC,03
0AAC:  MOVF   FED,F
0AAE:  MOVFF  FEF,01
0AB2:  MOVFF  03,02
0AB6:  MOVLB  0
0AB8:  BRA    0E74
.................... 
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].lvd_disconnect_adc;
0ABA:  MOVLB  1
0ABC:  MOVF   x2E,W
0ABE:  MULLW  24
0AC0:  MOVF   FF3,W
0AC2:  CLRF   x30
0AC4:  MOVWF  x2F
0AC6:  MOVLW  04
0AC8:  ADDWF  x2F,W
0ACA:  MOVWF  01
0ACC:  MOVLW  00
0ACE:  ADDWFC x30,W
0AD0:  MOVWF  03
0AD2:  MOVF   01,W
0AD4:  ADDLW  1B
0AD6:  MOVWF  FE9
0AD8:  MOVLW  00
0ADA:  ADDWFC 03,W
0ADC:  MOVWF  FEA
0ADE:  MOVFF  FEC,03
0AE2:  MOVF   FED,F
0AE4:  MOVFF  FEF,01
0AE8:  MOVFF  03,02
0AEC:  MOVLB  0
0AEE:  BRA    0E74
.................... 		case I2C_REG_CH0_LVD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].lvd_disconnect_delay;
0AF0:  MOVLB  1
0AF2:  MOVF   x2E,W
0AF4:  MULLW  24
0AF6:  MOVF   FF3,W
0AF8:  CLRF   x30
0AFA:  MOVWF  x2F
0AFC:  MOVLW  06
0AFE:  ADDWF  x2F,W
0B00:  MOVWF  01
0B02:  MOVLW  00
0B04:  ADDWFC x30,W
0B06:  MOVWF  03
0B08:  MOVF   01,W
0B0A:  ADDLW  1B
0B0C:  MOVWF  FE9
0B0E:  MOVLW  00
0B10:  ADDWFC 03,W
0B12:  MOVWF  FEA
0B14:  MOVFF  FEC,03
0B18:  MOVF   FED,F
0B1A:  MOVFF  FEF,01
0B1E:  MOVFF  03,02
0B22:  MOVLB  0
0B24:  BRA    0E74
.................... 		case I2C_REG_CH0_LVD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].lvd_reconnect_adc;
0B26:  MOVLB  1
0B28:  MOVF   x2E,W
0B2A:  MULLW  24
0B2C:  MOVF   FF3,W
0B2E:  CLRF   x30
0B30:  MOVWF  x2F
0B32:  MOVLW  08
0B34:  ADDWF  x2F,W
0B36:  MOVWF  01
0B38:  MOVLW  00
0B3A:  ADDWFC x30,W
0B3C:  MOVWF  03
0B3E:  MOVF   01,W
0B40:  ADDLW  1B
0B42:  MOVWF  FE9
0B44:  MOVLW  00
0B46:  ADDWFC 03,W
0B48:  MOVWF  FEA
0B4A:  MOVFF  FEC,03
0B4E:  MOVF   FED,F
0B50:  MOVFF  FEF,01
0B54:  MOVFF  03,02
0B58:  MOVLB  0
0B5A:  BRA    0E74
.................... 		case I2C_REG_CH0_LVD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].lvd_reconnect_delay;
0B5C:  MOVLB  1
0B5E:  MOVF   x2E,W
0B60:  MULLW  24
0B62:  MOVF   FF3,W
0B64:  CLRF   x30
0B66:  MOVWF  x2F
0B68:  MOVLW  0A
0B6A:  ADDWF  x2F,W
0B6C:  MOVWF  01
0B6E:  MOVLW  00
0B70:  ADDWFC x30,W
0B72:  MOVWF  03
0B74:  MOVF   01,W
0B76:  ADDLW  1B
0B78:  MOVWF  FE9
0B7A:  MOVLW  00
0B7C:  ADDWFC 03,W
0B7E:  MOVWF  FEA
0B80:  MOVFF  FEC,03
0B84:  MOVF   FED,F
0B86:  MOVFF  FEF,01
0B8A:  MOVFF  03,02
0B8E:  MOVLB  0
0B90:  BRA    0E74
.................... 
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].hvd_disconnect_adc;
0B92:  MOVLB  1
0B94:  MOVF   x2E,W
0B96:  MULLW  24
0B98:  MOVF   FF3,W
0B9A:  CLRF   x30
0B9C:  MOVWF  x2F
0B9E:  MOVLW  0C
0BA0:  ADDWF  x2F,W
0BA2:  MOVWF  01
0BA4:  MOVLW  00
0BA6:  ADDWFC x30,W
0BA8:  MOVWF  03
0BAA:  MOVF   01,W
0BAC:  ADDLW  1B
0BAE:  MOVWF  FE9
0BB0:  MOVLW  00
0BB2:  ADDWFC 03,W
0BB4:  MOVWF  FEA
0BB6:  MOVFF  FEC,03
0BBA:  MOVF   FED,F
0BBC:  MOVFF  FEF,01
0BC0:  MOVFF  03,02
0BC4:  MOVLB  0
0BC6:  BRA    0E74
.................... 		case I2C_REG_CH0_HVD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].hvd_disconnect_delay;
0BC8:  MOVLB  1
0BCA:  MOVF   x2E,W
0BCC:  MULLW  24
0BCE:  MOVF   FF3,W
0BD0:  CLRF   x30
0BD2:  MOVWF  x2F
0BD4:  MOVLW  0E
0BD6:  ADDWF  x2F,W
0BD8:  MOVWF  01
0BDA:  MOVLW  00
0BDC:  ADDWFC x30,W
0BDE:  MOVWF  03
0BE0:  MOVF   01,W
0BE2:  ADDLW  1B
0BE4:  MOVWF  FE9
0BE6:  MOVLW  00
0BE8:  ADDWFC 03,W
0BEA:  MOVWF  FEA
0BEC:  MOVFF  FEC,03
0BF0:  MOVF   FED,F
0BF2:  MOVFF  FEF,01
0BF6:  MOVFF  03,02
0BFA:  MOVLB  0
0BFC:  BRA    0E74
.................... 		case I2C_REG_CH0_HVD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].hvd_reconnect_adc;
0BFE:  MOVLB  1
0C00:  MOVF   x2E,W
0C02:  MULLW  24
0C04:  MOVF   FF3,W
0C06:  CLRF   x30
0C08:  MOVWF  x2F
0C0A:  MOVLW  10
0C0C:  ADDWF  x2F,W
0C0E:  MOVWF  01
0C10:  MOVLW  00
0C12:  ADDWFC x30,W
0C14:  MOVWF  03
0C16:  MOVF   01,W
0C18:  ADDLW  1B
0C1A:  MOVWF  FE9
0C1C:  MOVLW  00
0C1E:  ADDWFC 03,W
0C20:  MOVWF  FEA
0C22:  MOVFF  FEC,03
0C26:  MOVF   FED,F
0C28:  MOVFF  FEF,01
0C2C:  MOVFF  03,02
0C30:  MOVLB  0
0C32:  BRA    0E74
.................... 		case I2C_REG_CH0_HVD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].hvd_reconnect_delay;
0C34:  MOVLB  1
0C36:  MOVF   x2E,W
0C38:  MULLW  24
0C3A:  MOVF   FF3,W
0C3C:  CLRF   x30
0C3E:  MOVWF  x2F
0C40:  MOVLW  12
0C42:  ADDWF  x2F,W
0C44:  MOVWF  01
0C46:  MOVLW  00
0C48:  ADDWFC x30,W
0C4A:  MOVWF  03
0C4C:  MOVF   01,W
0C4E:  ADDLW  1B
0C50:  MOVWF  FE9
0C52:  MOVLW  00
0C54:  ADDWFC 03,W
0C56:  MOVWF  FEA
0C58:  MOVFF  FEC,03
0C5C:  MOVF   FED,F
0C5E:  MOVFF  FEF,01
0C62:  MOVFF  03,02
0C66:  MOVLB  0
0C68:  BRA    0E74
.................... 
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_disconnect_adc;
0C6A:  MOVLB  1
0C6C:  MOVF   x2E,W
0C6E:  MULLW  24
0C70:  MOVF   FF3,W
0C72:  CLRF   x30
0C74:  MOVWF  x2F
0C76:  MOVLW  14
0C78:  ADDWF  x2F,W
0C7A:  MOVWF  01
0C7C:  MOVLW  00
0C7E:  ADDWFC x30,W
0C80:  MOVWF  03
0C82:  MOVF   01,W
0C84:  ADDLW  1B
0C86:  MOVWF  FE9
0C88:  MOVLW  00
0C8A:  ADDWFC 03,W
0C8C:  MOVWF  FEA
0C8E:  MOVFF  FEC,03
0C92:  MOVF   FED,F
0C94:  MOVFF  FEF,01
0C98:  MOVFF  03,02
0C9C:  MOVLB  0
0C9E:  BRA    0E74
.................... 		case I2C_REG_CH0_LTD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_disconnect_delay;
0CA0:  MOVLB  1
0CA2:  MOVF   x2E,W
0CA4:  MULLW  24
0CA6:  MOVF   FF3,W
0CA8:  CLRF   x30
0CAA:  MOVWF  x2F
0CAC:  MOVLW  16
0CAE:  ADDWF  x2F,W
0CB0:  MOVWF  01
0CB2:  MOVLW  00
0CB4:  ADDWFC x30,W
0CB6:  MOVWF  03
0CB8:  MOVF   01,W
0CBA:  ADDLW  1B
0CBC:  MOVWF  FE9
0CBE:  MOVLW  00
0CC0:  ADDWFC 03,W
0CC2:  MOVWF  FEA
0CC4:  MOVFF  FEC,03
0CC8:  MOVF   FED,F
0CCA:  MOVFF  FEF,01
0CCE:  MOVFF  03,02
0CD2:  MOVLB  0
0CD4:  BRA    0E74
.................... 		case I2C_REG_CH0_LTD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_reconnect_adc;
0CD6:  MOVLB  1
0CD8:  MOVF   x2E,W
0CDA:  MULLW  24
0CDC:  MOVF   FF3,W
0CDE:  CLRF   x30
0CE0:  MOVWF  x2F
0CE2:  MOVLW  18
0CE4:  ADDWF  x2F,W
0CE6:  MOVWF  01
0CE8:  MOVLW  00
0CEA:  ADDWFC x30,W
0CEC:  MOVWF  03
0CEE:  MOVF   01,W
0CF0:  ADDLW  1B
0CF2:  MOVWF  FE9
0CF4:  MOVLW  00
0CF6:  ADDWFC 03,W
0CF8:  MOVWF  FEA
0CFA:  MOVFF  FEC,03
0CFE:  MOVF   FED,F
0D00:  MOVFF  FEF,01
0D04:  MOVFF  03,02
0D08:  MOVLB  0
0D0A:  BRA    0E74
.................... 		case I2C_REG_CH0_LTD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_reconnect_delay;
0D0C:  MOVLB  1
0D0E:  MOVF   x2E,W
0D10:  MULLW  24
0D12:  MOVF   FF3,W
0D14:  CLRF   x30
0D16:  MOVWF  x2F
0D18:  MOVLW  1A
0D1A:  ADDWF  x2F,W
0D1C:  MOVWF  01
0D1E:  MOVLW  00
0D20:  ADDWFC x30,W
0D22:  MOVWF  03
0D24:  MOVF   01,W
0D26:  ADDLW  1B
0D28:  MOVWF  FE9
0D2A:  MOVLW  00
0D2C:  ADDWFC 03,W
0D2E:  MOVWF  FEA
0D30:  MOVFF  FEC,03
0D34:  MOVF   FED,F
0D36:  MOVFF  FEF,01
0D3A:  MOVFF  03,02
0D3E:  MOVLB  0
0D40:  BRA    0E74
.................... 
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_disconnect_adc;
0D42:  MOVLB  1
0D44:  MOVF   x2E,W
0D46:  MULLW  24
0D48:  MOVF   FF3,W
0D4A:  CLRF   x30
0D4C:  MOVWF  x2F
0D4E:  MOVLW  14
0D50:  ADDWF  x2F,W
0D52:  MOVWF  01
0D54:  MOVLW  00
0D56:  ADDWFC x30,W
0D58:  MOVWF  03
0D5A:  MOVF   01,W
0D5C:  ADDLW  1B
0D5E:  MOVWF  FE9
0D60:  MOVLW  00
0D62:  ADDWFC 03,W
0D64:  MOVWF  FEA
0D66:  MOVFF  FEC,03
0D6A:  MOVF   FED,F
0D6C:  MOVFF  FEF,01
0D70:  MOVFF  03,02
0D74:  MOVLB  0
0D76:  BRA    0E74
.................... 		case I2C_REG_CH0_HTD_DISCONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_disconnect_delay;
0D78:  MOVLB  1
0D7A:  MOVF   x2E,W
0D7C:  MULLW  24
0D7E:  MOVF   FF3,W
0D80:  CLRF   x30
0D82:  MOVWF  x2F
0D84:  MOVLW  16
0D86:  ADDWF  x2F,W
0D88:  MOVWF  01
0D8A:  MOVLW  00
0D8C:  ADDWFC x30,W
0D8E:  MOVWF  03
0D90:  MOVF   01,W
0D92:  ADDLW  1B
0D94:  MOVWF  FE9
0D96:  MOVLW  00
0D98:  ADDWFC 03,W
0D9A:  MOVWF  FEA
0D9C:  MOVFF  FEC,03
0DA0:  MOVF   FED,F
0DA2:  MOVFF  FEF,01
0DA6:  MOVFF  03,02
0DAA:  MOVLB  0
0DAC:  BRA    0E74
.................... 		case I2C_REG_CH0_HTD_RECONNECT_ADC:
.................... 			return (int16) config.ch[c].ltd_reconnect_adc;
0DAE:  MOVLB  1
0DB0:  MOVF   x2E,W
0DB2:  MULLW  24
0DB4:  MOVF   FF3,W
0DB6:  CLRF   x30
0DB8:  MOVWF  x2F
0DBA:  MOVLW  18
0DBC:  ADDWF  x2F,W
0DBE:  MOVWF  01
0DC0:  MOVLW  00
0DC2:  ADDWFC x30,W
0DC4:  MOVWF  03
0DC6:  MOVF   01,W
0DC8:  ADDLW  1B
0DCA:  MOVWF  FE9
0DCC:  MOVLW  00
0DCE:  ADDWFC 03,W
0DD0:  MOVWF  FEA
0DD2:  MOVFF  FEC,03
0DD6:  MOVF   FED,F
0DD8:  MOVFF  FEF,01
0DDC:  MOVFF  03,02
0DE0:  MOVLB  0
0DE2:  BRA    0E74
.................... 		case I2C_REG_CH0_HTD_RECONNECT_DELAY:
.................... 			return (int16) config.ch[c].ltd_reconnect_delay;	
0DE4:  MOVLB  1
0DE6:  MOVF   x2E,W
0DE8:  MULLW  24
0DEA:  MOVF   FF3,W
0DEC:  CLRF   x30
0DEE:  MOVWF  x2F
0DF0:  MOVLW  1A
0DF2:  ADDWF  x2F,W
0DF4:  MOVWF  01
0DF6:  MOVLW  00
0DF8:  ADDWFC x30,W
0DFA:  MOVWF  03
0DFC:  MOVF   01,W
0DFE:  ADDLW  1B
0E00:  MOVWF  FE9
0E02:  MOVLW  00
0E04:  ADDWFC 03,W
0E06:  MOVWF  FEA
0E08:  MOVFF  FEC,03
0E0C:  MOVF   FED,F
0E0E:  MOVFF  FEF,01
0E12:  MOVFF  03,02
0E16:  MOVLB  0
0E18:  BRA    0E74
.................... 
.................... 		case I2C_REG_CH0_FUT_DISCONNECT_VALUE:
.................... 		case I2C_REG_CH0_FUT_DISCONNECT_DELAY:
.................... 		case I2C_REG_CH0_FUT_RECONNECT_VALUE:
.................... 		case I2C_REG_CH0_FUT_RECONNECT_DELAY:
.................... 			return (int16) 0xffff; /* not yet implemented */
0E1A:  MOVLW  FF
0E1C:  MOVWF  01
0E1E:  MOVWF  02
0E20:  BRA    0E74
.................... 		
.................... 		/* configuration */
.................... 		case I2C_REG_CONFIG_HARDWARE_MODEL: 
.................... 			return (int16) 'D';
0E22:  MOVLW  44
0E24:  MOVWF  01
0E26:  MOVLW  00
0E28:  MOVWF  02
0E2A:  BRA    0E74
.................... 		case I2C_REG_CONFIG_HARDWARE_VERSION: 
.................... 			return (int16) '2';
0E2C:  MOVLW  32
0E2E:  MOVWF  01
0E30:  MOVLW  00
0E32:  MOVWF  02
0E34:  BRA    0E74
.................... 		case I2C_REG_CONFIG_SOFTWARE_MODEL: 
.................... 			return (int16) 'L';
0E36:  MOVLW  4C
0E38:  MOVWF  01
0E3A:  MOVLW  00
0E3C:  MOVWF  02
0E3E:  BRA    0E74
.................... 		case I2C_REG_CONFIG_SOFTWARE_VERSION: 
.................... 			return (int16) '0';
0E40:  MOVLW  30
0E42:  MOVWF  01
0E44:  MOVLW  00
0E46:  MOVWF  02
0E48:  BRA    0E74
.................... 		case I2C_REG_CONFIG_SOFTWARE_YEAR:
.................... 			return (int16) current.compile_year;
0E4A:  MOVFF  CB,01
0E4E:  CLRF   02
0E50:  BRA    0E74
.................... 		case I2C_REG_CONFIG_SOFTWARE_MONTH:
.................... 			return (int16) current.compile_month;
0E52:  MOVFF  CC,01
0E56:  CLRF   02
0E58:  BRA    0E74
.................... 		case I2C_REG_CONFIG_SOFTWARE_DAY:
.................... 			return (int16) current.compile_day;
0E5A:  MOVFF  CD,01
0E5E:  CLRF   02
0E60:  BRA    0E74
.................... 
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			/* 1 if factory unlocked */ 
.................... 			return (int16) current.factory_unlocked; 	
0E62:  MOVFF  CA,01
0E66:  CLRF   02
0E68:  BRA    0E74
.................... 
.................... 		/* we should have range checked, and never gotten here ... or read unimplemented (future) register */
.................... 		default: return (int16) addr;
0E6A:  MOVLB  1
0E6C:  MOVFF  12D,01
0E70:  CLRF   02
0E72:  MOVLB  0
.................... 	}
0E74:  GOTO   0F2C (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... 
.................... 
.................... #include "interrupt_dcswc_module_latching_contactor.c"
.................... #int_timer2
.................... void isr_timer2() {
.................... 	timers.now_millisecond=1;
*
00D4:  BSF    xCF.2
.................... }
.................... 
.................... 
.................... 
.................... /* I2C slave interrupt */
00D6:  BCF    F9E.1
00D8:  GOTO   006C
.................... #byte SSPSTAT=GETENV("SFR:SSPSTAT")
.................... #INT_SSP
.................... void ssp_interrupt () {
.................... 	static int8 sstate;
.................... 	int8 state;
.................... 	int8 incoming;
.................... 	static int16 lastValue;
.................... 	static int8 lastMSB;
.................... 
.................... 	static int8 address; 
.................... 
.................... 	/* 
.................... 	our implementation of i2c_isr_state() that won't overflow and switch states
.................... 	but it will quit counting at 127 bytes. 
.................... 	If more bytes are needed, external counting variables can be used or the size of state can be made larger
.................... 	*/
.................... 
.................... 
.................... 	if ( ! bit_test(SSPSTAT,5) ) {
*
0E8E:  BTFSC  FC7.5
0E90:  BRA    0E9E
.................... 		/* address */
.................... 		sstate=0;
0E92:  MOVLB  1
0E94:  CLRF   x0C
.................... 
.................... 		if ( bit_test(SSPSTAT,2) ) {
0E96:  BTFSS  FC7.2
0E98:  BRA    0E9C
.................... 			/* set high bit if read */
.................... 			bit_set(sstate,7);
0E9A:  BSF    x0C.7
.................... 		}
.................... 	} else {
0E9C:  MOVLB  0
.................... 		/* data */
.................... 	}
.................... 
.................... 	/* state variable used below is not incremented */
.................... 	state=sstate;
0E9E:  MOVFF  10C,12A
.................... 
.................... 	/* increment the state counter for next pass through unless it will overflow us into another state */
.................... 	if ( sstate != 0x7f && sstate != 0xff) {
0EA2:  MOVLB  1
0EA4:  MOVF   x0C,W
0EA6:  SUBLW  7F
0EA8:  BZ    0EB2
0EAA:  INCFSZ x0C,W
0EAC:  BRA    0EB0
0EAE:  BRA    0EB2
.................... 		sstate++;
0EB0:  INCF   x0C,F
.................... 	}
.................... 
.................... 	
.................... 	/* i2c_isr_state() return an 8 bit int
.................... 		0 - Address match received with R/W bit clear, perform i2c_read( ) to read the I2C address.
.................... 		1-0x7F - Master has written data; i2c_read() will immediately return the data
.................... 		0x80 - Address match received with R/W bit set; perform i2c_read( ) to read the I2C address,
.................... 		and use i2c_write( ) to pre-load the transmit buffer for the next transaction (next I2C read
.................... 		performed by master will read this byte).
.................... 		0x81-0xFF - Transmission completed and acknowledged; respond with i2c_write() to pre-load
.................... 		the transmit buffer for the next transition (the next I2C read performed by master will read this
.................... 		byte).
.................... 		Function:
.................... 		Returns the state of I2C communications in I2C slave mode after an SSP interrupt. The return
.................... 		value increments with each byte received or sent.
.................... 		If 0x00 or 0x80 is returned, an i2C_read( ) needs to be performed to read the I2C address that
.................... 		was sent (it will match the address configured by #USE I2C so this value can be ignored)
.................... 	*/
.................... 
.................... 	if ( state <= 0x80 ) {                      
0EB2:  MOVF   x2A,W
0EB4:  SUBLW  80
0EB6:  BNC   0F14
.................... 		/* I2C master is sending us data */
.................... 		if ( 0x80 == state ) {
0EB8:  MOVF   x2A,W
0EBA:  SUBLW  80
0EBC:  BNZ   0EC4
.................... 			/* i2c_read(2) casues the function to read the SSPBUF without releasing the clock */
.................... 			incoming = i2c_read(STREAM_SLAVE,2);
0EBE:  MOVFF  FC9,12B
.................... 		} else {
0EC2:  BRA    0ED0
.................... 			incoming = i2c_read(STREAM_SLAVE);
0EC4:  BCF    FC6.6
0EC6:  BTFSS  FC7.0
0EC8:  BRA    0EC6
0ECA:  MOVF   FC9,W
0ECC:  BSF    FC6.4
0ECE:  MOVWF  x2B
.................... 		}
.................... 
.................... 		if ( 1 == state ) {             
0ED0:  DECFSZ x2A,W
0ED2:  BRA    0EDA
.................... 			/* first byte is address */                
.................... 			address = incoming;
0ED4:  MOVFF  12B,110
.................... 		} else if ( state >= 2 && 0x80 != state ) {
0ED8:  BRA    0F14
0EDA:  MOVF   x2A,W
0EDC:  SUBLW  01
0EDE:  BC    0F14
0EE0:  MOVF   x2A,W
0EE2:  SUBLW  80
0EE4:  BZ    0F14
.................... 			/* received byte is data */
.................... 		
.................... 			/* save MSB and we'll process it on next */
.................... 			if ( 2 == state ) {
0EE6:  MOVF   x2A,W
0EE8:  SUBLW  02
0EEA:  BNZ   0EF2
.................... 				lastMSB=incoming;
0EEC:  MOVFF  12B,10F
.................... 			} else if ( 3 == state ) {
0EF0:  BRA    0F14
0EF2:  MOVF   x2A,W
0EF4:  SUBLW  03
0EF6:  BNZ   0F14
.................... 				/* 16 bit value made of previous byte and this byte */
.................... 				write_i2c(address,make16(lastMSB,incoming));
0EF8:  MOVFF  10F,12D
0EFC:  MOVFF  12B,12C
0F00:  MOVFF  110,12E
0F04:  MOVFF  10F,130
0F08:  MOVFF  12B,12F
0F0C:  MOVLB  0
0F0E:  GOTO   00DC
0F12:  MOVLB  1
.................... 			}
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	if ( state >= 0x80 ) {
0F14:  MOVF   x2A,W
0F16:  SUBLW  7F
0F18:  BC    0F52
.................... 		/* I2C master is requesting data from us */
.................... 
.................... 		if ( ! bit_test(address,0) ) {
0F1A:  BTFSC  x10.0
0F1C:  BRA    0F42
.................... 			/* read 16 bit register (register address half of I2C address) on even address */
.................... 			lastValue=map_i2c(address>>1);
0F1E:  BCF    FD8.0
0F20:  RRCF   x10,W
0F22:  MOVWF  x2C
0F24:  MOVWF  x2D
0F26:  MOVLB  0
0F28:  GOTO   0614
0F2C:  MOVFF  02,10E
0F30:  MOVFF  01,10D
.................... 
.................... 			/* send the MSB */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,1));
0F34:  MOVFF  10E,12C
0F38:  MOVFF  10E,12D
0F3C:  RCALL  0E78
.................... 		} else {
0F3E:  BRA    0F4E
0F40:  MOVLB  1
.................... 			/* send LSB of 16 bit register on odd address */
.................... 			i2c_write(STREAM_SLAVE,make8(lastValue,0));
0F42:  MOVFF  10D,12C
0F46:  MOVFF  10D,12D
0F4A:  MOVLB  0
0F4C:  RCALL  0E78
.................... 		}
.................... 		address++;
0F4E:  MOVLB  1
0F50:  INCF   x10,F
.................... 	}
.................... }
.................... 
.................... 
.................... 
.................... 
0F52:  BCF    F9E.3
0F54:  MOVLB  0
0F56:  GOTO   006C
.................... #include "debug_dcswc_module_latching_contactor.c"
.................... void debug_dump(void) {
.................... 
.................... //	int8 i;
.................... 
.................... 	
.................... 	restart_wdt();
*
2C7E:  CLRWDT
2C80:  CLRF   19
2C82:  BTFSC  FF2.7
2C84:  BSF    19.7
2C86:  BCF    FF2.7
.................... #if 0
.................... 	fprintf(STREAM_FTDI,"# '%s'\r\n",__DATE__);
.................... 	fprintf(STREAM_FTDI,"#  compile_year=%u\r\n",current.compile_year);
.................... 	fprintf(STREAM_FTDI,"# compile_month=%u\r\n",current.compile_month);
.................... 	fprintf(STREAM_FTDI,"#   compile_day=%u\r\n",current.compile_day);
.................... #endif
.................... 	fprintf(STREAM_FTDI,"#       vin adc=%lu\r\n",adc_get(0));
2C88:  MOVLB  1
2C8A:  CLRF   x2F
2C8C:  MOVLB  0
2C8E:  CALL   0594
2C92:  BTFSC  19.7
2C94:  BSF    FF2.7
2C96:  MOVFF  02,11C
2C9A:  MOVFF  01,11B
2C9E:  MOVLW  5A
2CA0:  MOVWF  FF6
2CA2:  MOVLW  0F
2CA4:  MOVWF  FF7
2CA6:  MOVLW  10
2CA8:  MOVLB  1
2CAA:  MOVWF  x1D
2CAC:  MOVLB  0
2CAE:  CALL   188A
2CB2:  MOVLW  10
2CB4:  MOVWF  FE9
2CB6:  MOVFF  11C,11E
2CBA:  MOVFF  11B,11D
2CBE:  RCALL  2B86
2CC0:  MOVLW  0D
2CC2:  BTFSS  F9E.4
2CC4:  BRA    2CC2
2CC6:  MOVWF  FAD
2CC8:  MOVLW  0A
2CCA:  BTFSS  F9E.4
2CCC:  BRA    2CCA
2CCE:  MOVWF  FAD
2CD0:  CLRF   19
2CD2:  BTFSC  FF2.7
2CD4:  BSF    19.7
2CD6:  BCF    FF2.7
.................... 	fprintf(STREAM_FTDI,"#      temp adc=%lu\r\n",adc_get(1));
2CD8:  MOVLW  01
2CDA:  MOVLB  1
2CDC:  MOVWF  x2F
2CDE:  MOVLB  0
2CE0:  CALL   0594
2CE4:  BTFSC  19.7
2CE6:  BSF    FF2.7
2CE8:  MOVFF  02,11C
2CEC:  MOVFF  01,11B
2CF0:  MOVLW  70
2CF2:  MOVWF  FF6
2CF4:  MOVLW  0F
2CF6:  MOVWF  FF7
2CF8:  MOVLW  10
2CFA:  MOVLB  1
2CFC:  MOVWF  x1D
2CFE:  MOVLB  0
2D00:  CALL   188A
2D04:  MOVLW  10
2D06:  MOVWF  FE9
2D08:  MOVFF  11C,11E
2D0C:  MOVFF  11B,11D
2D10:  RCALL  2B86
2D12:  MOVLW  0D
2D14:  BTFSS  F9E.4
2D16:  BRA    2D14
2D18:  MOVWF  FAD
2D1A:  MOVLW  0A
2D1C:  BTFSS  F9E.4
2D1E:  BRA    2D1C
2D20:  MOVWF  FAD
.................... 	fprintf(STREAM_FTDI,"#   ch[0].state=0x%2X\r\n",channel[0].state);
2D22:  MOVLW  86
2D24:  MOVWF  FF6
2D26:  MOVLW  0F
2D28:  MOVWF  FF7
2D2A:  MOVLW  12
2D2C:  MOVLB  1
2D2E:  MOVWF  x1D
2D30:  MOVLB  0
2D32:  CALL   188A
2D36:  MOVFF  DA,11B
2D3A:  MOVLW  37
2D3C:  MOVLB  1
2D3E:  MOVWF  x1C
2D40:  MOVLB  0
2D42:  RCALL  2C38
2D44:  MOVLW  0D
2D46:  BTFSS  F9E.4
2D48:  BRA    2D46
2D4A:  MOVWF  FAD
2D4C:  MOVLW  0A
2D4E:  BTFSS  F9E.4
2D50:  BRA    2D4E
2D52:  MOVWF  FAD
.................... 	fprintf(STREAM_FTDI,"#   ch[1].state=0x%2X\r\n",channel[1].state);
2D54:  MOVLW  9E
2D56:  MOVWF  FF6
2D58:  MOVLW  0F
2D5A:  MOVWF  FF7
2D5C:  MOVLW  12
2D5E:  MOVLB  1
2D60:  MOVWF  x1D
2D62:  MOVLB  0
2D64:  CALL   188A
2D68:  MOVFF  F3,11B
2D6C:  MOVLW  37
2D6E:  MOVLB  1
2D70:  MOVWF  x1C
2D72:  MOVLB  0
2D74:  RCALL  2C38
2D76:  MOVLW  0D
2D78:  BTFSS  F9E.4
2D7A:  BRA    2D78
2D7C:  MOVWF  FAD
2D7E:  MOVLW  0A
2D80:  BTFSS  F9E.4
2D82:  BRA    2D80
2D84:  MOVWF  FAD
.................... //	fprintf(STREAM_FTDI,"# read_dip_sw()=%u\r\n",read_dip_switch());
.................... //	fprintf(STREAM_FTDI,"#    dip sw adc=%lu\r\n",adc_get(2));
.................... 
.................... #if 0
2D86:  GOTO   2F78 (RETURN)
.................... 	for ( i=0 ; i<2 ; i++ ) {
.................... 		restart_wdt();
.................... 		fprintf(STREAM_FTDI,"#-------\r\n");
.................... 		fprintf(STREAM_FTDI,"# config.ch[%u]\r\n",i);
.................... 		fprintf(STREAM_FTDI,"# command_off_hold_time=%lu\r\n",config.ch[i].command_off_hold_time);
.................... 
.................... 		fprintf(STREAM_FTDI,"#    lvd_disconnect_adc=%lu\r\n",config.ch[i].lvd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  lvd_disconnect_delay=%lu\r\n",config.ch[i].lvd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     lvd_reconnect_adc=%lu\r\n",config.ch[i].lvd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   lvd_reconnect_delay=%lu\r\n",config.ch[i].lvd_reconnect_delay);
.................... 
.................... 		fprintf(STREAM_FTDI,"#    hvd_disconnect_adc=%lu\r\n",config.ch[i].hvd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  hvd_disconnect_delay=%lu\r\n",config.ch[i].hvd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     hvd_reconnect_adc=%lu\r\n",config.ch[i].hvd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   hvd_reconnect_delay=%lu\r\n",config.ch[i].hvd_reconnect_delay);
.................... 
.................... 		restart_wdt();
.................... 		fprintf(STREAM_FTDI,"#    ltd_disconnect_adc=%lu\r\n",config.ch[i].ltd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  ltd_disconnect_delay=%lu\r\n",config.ch[i].ltd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     ltd_reconnect_adc=%lu\r\n",config.ch[i].ltd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   ltd_reconnect_delay=%lu\r\n",config.ch[i].ltd_reconnect_delay);
.................... 
.................... 		fprintf(STREAM_FTDI,"#    htd_disconnect_adc=%lu\r\n",config.ch[i].htd_disconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#  htd_disconnect_delay=%lu\r\n",config.ch[i].htd_disconnect_delay);
.................... 		fprintf(STREAM_FTDI,"#     htd_reconnect_adc=%lu\r\n",config.ch[i].htd_reconnect_adc);
.................... 		fprintf(STREAM_FTDI,"#   htd_reconnect_delay=%lu\r\n",config.ch[i].htd_reconnect_delay);
.................... 
.................... 
.................... 		restart_wdt();
.................... 		fprintf(STREAM_FTDI,"#\r\n");
.................... 		fprintf(STREAM_FTDI,"# channel[%u]\r\n",i);
.................... 		fprintf(STREAM_FTDI,"#                        state=0x%02x\r\n",channel[i].state);
.................... 		fprintf(STREAM_FTDI,"#           command_on_seconds=%lu\r\n",channel[i].command_on_seconds);
.................... 		fprintf(STREAM_FTDI,"#      command_on_hold_seconds=%lu\r\n",channel[i].command_on_hold_seconds);
.................... 
.................... 		fprintf(STREAM_FTDI,"#          command_off_seconds=%lu\r\n",channel[i].command_off_seconds);
.................... 		fprintf(STREAM_FTDI,"#     command_off_hold_seconds=%lu\r\n",channel[i].command_off_hold_seconds);
.................... 
.................... 		fprintf(STREAM_FTDI,"# lvd_disconnect_delay_seconds=%lu\r\n",channel[i].lvd_disconnect_delay_seconds);
.................... 		fprintf(STREAM_FTDI,"#  lvd_reconnect_delay_seconds=%lu\r\n",channel[i].lvd_reconnect_delay_seconds);
.................... 
.................... 		fprintf(STREAM_FTDI,"# hvd_disconnect_delay_seconds=%lu\r\n",channel[i].hvd_disconnect_delay_seconds);
.................... 		fprintf(STREAM_FTDI,"#  hvd_reconnect_delay_seconds=%lu\r\n",channel[i].hvd_reconnect_delay_seconds);
.................... 
.................... 		restart_wdt();
.................... 		fprintf(STREAM_FTDI,"# ltd_disconnect_delay_seconds=%lu\r\n",channel[i].ltd_disconnect_delay_seconds);
.................... 		fprintf(STREAM_FTDI,"#  ltd_reconnect_delay_seconds=%lu\r\n",channel[i].ltd_reconnect_delay_seconds);
.................... 
.................... 		fprintf(STREAM_FTDI,"# htd_disconnect_delay_seconds=%lu\r\n",channel[i].htd_disconnect_delay_seconds);
.................... 		fprintf(STREAM_FTDI,"#  htd_reconnect_delay_seconds=%lu\r\n",channel[i].htd_reconnect_delay_seconds);
.................... 	}
.................... 	#endif
.................... }
.................... 
.................... 
.................... 
.................... void contactor_on(int8 c) {
.................... 	/* only turn on contactor if it isn't on or needs a refresh */
.................... 	if ( 1 == timers.contactor[c] ) {
*
27E4:  CLRF   03
27E6:  MOVLB  1
27E8:  MOVF   x1E,W
27EA:  ADDLW  D6
27EC:  MOVWF  FE9
27EE:  MOVLW  00
27F0:  ADDWFC 03,W
27F2:  MOVWF  FEA
27F4:  MOVF   FEF,W
27F6:  SUBLW  01
27F8:  BNZ   27FC
.................... 		return;
27FA:  BRA    2836
.................... 	}
.................... 
.................... 	/* we start the powersave count down */
.................... 	timers.contactor_powersave[c]=CONTACTOR_POWER_SAVE_MS;
27FC:  CLRF   03
27FE:  MOVF   x1E,W
2800:  ADDLW  D8
2802:  MOVWF  FE9
2804:  MOVLW  00
2806:  ADDWFC 03,W
2808:  MOVWF  FEA
280A:  MOVLW  C8
280C:  MOVWF  FEF
.................... 
.................... 	/* control the actual coil depending on what channel we are on */
.................... 	if ( 0==c ) {
280E:  MOVF   x1E,F
2810:  BNZ   281C
.................... 		/* contactor A pins */
.................... 		output_low(BRIDGE_A_A);
2812:  BCF    F94.3
2814:  BCF    F8B.3
.................... 		output_high(BRIDGE_A_B);
2816:  BCF    F94.4
2818:  BSF    F8B.4
.................... 	} else {
281A:  BRA    2824
.................... 		/* contactor B pins */
.................... 		output_low(BRIDGE_B_A);
281C:  BCF    F94.5
281E:  BCF    F8B.5
.................... 		output_high(BRIDGE_B_B);
2820:  BCF    F94.6
2822:  BSF    F8B.6
.................... 	}
.................... 
.................... 	/* save state for next time */
.................... 	timers.contactor[c]=1;
2824:  CLRF   03
2826:  MOVF   x1E,W
2828:  ADDLW  D6
282A:  MOVWF  FE9
282C:  MOVLW  00
282E:  ADDWFC 03,W
2830:  MOVWF  FEA
2832:  MOVLW  01
2834:  MOVWF  FEF
2836:  MOVLB  0
2838:  GOTO   289E (RETURN)
.................... }
.................... 
.................... void contactor_off(int8 c) {
.................... 	/* only turn off contactor if it isn't on or needs a refresh */
.................... 	if ( 0 == timers.contactor[c] ) {
*
13C0:  CLRF   03
13C2:  MOVLB  1
13C4:  MOVF   x1E,W
13C6:  ADDLW  D6
13C8:  MOVWF  FE9
13CA:  MOVLW  00
13CC:  ADDWFC 03,W
13CE:  MOVWF  FEA
13D0:  MOVF   FEF,W
13D2:  BNZ   13D6
.................... 		return;
13D4:  BRA    140E
.................... 	}
.................... 
.................... 	/* we start the powersave count down */
.................... 	timers.contactor_powersave[c]=CONTACTOR_POWER_SAVE_MS;
13D6:  CLRF   03
13D8:  MOVF   x1E,W
13DA:  ADDLW  D8
13DC:  MOVWF  FE9
13DE:  MOVLW  00
13E0:  ADDWFC 03,W
13E2:  MOVWF  FEA
13E4:  MOVLW  C8
13E6:  MOVWF  FEF
.................... 
.................... 	/* control the actual coil depending on what channel we are on */
.................... 	if ( 0==c ) {
13E8:  MOVF   x1E,F
13EA:  BNZ   13F6
.................... 		output_high(BRIDGE_A_A);
13EC:  BCF    F94.3
13EE:  BSF    F8B.3
.................... 		output_low(BRIDGE_A_B);
13F0:  BCF    F94.4
13F2:  BCF    F8B.4
.................... 	} else {
13F4:  BRA    13FE
.................... 		output_high(BRIDGE_B_A);
13F6:  BCF    F94.5
13F8:  BSF    F8B.5
.................... 		output_low(BRIDGE_B_B);
13FA:  BCF    F94.6
13FC:  BCF    F8B.6
.................... 	}
.................... 
.................... 	/* save state for next time */
.................... 	timers.contactor[c]=0;
13FE:  CLRF   03
1400:  MOVF   x1E,W
1402:  ADDLW  D6
1404:  MOVWF  FE9
1406:  MOVLW  00
1408:  ADDWFC 03,W
140A:  MOVWF  FEA
140C:  CLRF   FEF
140E:  MOVLB  0
1410:  RETURN 0
.................... }
.................... 
.................... void contactor_set(int8 c) {
*
283C:  MOVLW  01
283E:  MOVLB  1
2840:  MOVWF  x1D
.................... 	int8 state=1;
.................... 
.................... 	/* if nothing is set in channel[c].state, contactor is on */
.................... 	state=1; 
2842:  MOVWF  x1D
.................... 
.................... 	if ( channel[c].state & CH_STATE_MASK_ON ) {
2844:  MOVF   x1C,W
2846:  MULLW  19
2848:  MOVF   FF3,W
284A:  CLRF   x1F
284C:  MOVWF  x1E
284E:  MOVLW  DA
2850:  ADDWF  x1E,W
2852:  MOVWF  FE9
2854:  MOVLW  00
2856:  ADDWFC x1F,W
2858:  MOVWF  FEA
285A:  MOVF   FEF,W
285C:  ANDLW  03
285E:  BZ    2866
.................... 		/* if override button (switch) is set or we are commanded on, then we will be on */
.................... 		state=1;
2860:  MOVLW  01
2862:  MOVWF  x1D
.................... 	} else if ( channel[c].state & CH_STATE_MASK_OFF ) {
2864:  BRA    2884
2866:  MOVF   x1C,W
2868:  MULLW  19
286A:  MOVF   FF3,W
286C:  CLRF   x1F
286E:  MOVWF  x1E
2870:  MOVLW  DA
2872:  ADDWF  x1E,W
2874:  MOVWF  FE9
2876:  MOVLW  00
2878:  ADDWFC x1F,W
287A:  MOVWF  FEA
287C:  MOVF   FEF,W
287E:  ANDLW  7C
2880:  BZ    2884
.................... 		/* if one of the disconnect bits is set, we will be off */
.................... 		state=0;
2882:  CLRF   x1D
.................... 	}
.................... 
.................... 	if ( 0==state ) {
2884:  MOVF   x1D,F
2886:  BNZ   2896
.................... 		contactor_off(c);
2888:  MOVFF  11C,11E
288C:  MOVLB  0
288E:  CALL   13C0
.................... 	} else {
2892:  BRA    289E
2894:  MOVLB  1
.................... 		contactor_on(c);
2896:  MOVFF  11C,11E
289A:  MOVLB  0
289C:  BRA    27E4
.................... 	}
289E:  RETURN 0
.................... 
.................... }
.................... 
.................... void contactor_logic(int8 c) {
.................... 	int16 adc;
.................... 
.................... 	/* override button / switch */
.................... 	if ( (0==c && 0==input(SW_OVERRIDE_A)) || (1==c && 0==input(SW_OVERRIDE_B)) ) {
*
19A0:  MOVLB  1
19A2:  MOVF   x1C,F
19A4:  BNZ   19AC
19A6:  BSF    F92.5
19A8:  BTFSS  F80.5
19AA:  BRA    19B6
19AC:  DECFSZ x1C,W
19AE:  BRA    19D4
19B0:  BSF    F92.4
19B2:  BTFSC  F80.4
19B4:  BRA    19D4
.................... 		bit_set(channel[c].state,CH_STATE_BIT_OVERRIDE);
19B6:  MOVF   x1C,W
19B8:  MULLW  19
19BA:  MOVF   FF3,W
19BC:  CLRF   x20
19BE:  MOVWF  x1F
19C0:  MOVLW  DA
19C2:  ADDWF  x1F,W
19C4:  MOVWF  01
19C6:  MOVLW  00
19C8:  ADDWFC x20,W
19CA:  MOVFF  01,FE9
19CE:  MOVWF  FEA
19D0:  BSF    FEF.0
.................... 	} else {
19D2:  BRA    19F0
.................... 		bit_clear(channel[c].state,CH_STATE_BIT_OVERRIDE);
19D4:  MOVF   x1C,W
19D6:  MULLW  19
19D8:  MOVF   FF3,W
19DA:  CLRF   x20
19DC:  MOVWF  x1F
19DE:  MOVLW  DA
19E0:  ADDWF  x1F,W
19E2:  MOVWF  01
19E4:  MOVLW  00
19E6:  ADDWFC x20,W
19E8:  MOVFF  01,FE9
19EC:  MOVWF  FEA
19EE:  BCF    FEF.0
.................... 	}
.................... 
.................... 	/* command on. 65535 disables */
.................... 	if ( 65535 != channel[c].command_on_seconds ) {
19F0:  MOVF   x1C,W
19F2:  MULLW  19
19F4:  MOVF   FF3,W
19F6:  CLRF   x20
19F8:  MOVWF  x1F
19FA:  MOVLW  01
19FC:  ADDWF  x1F,W
19FE:  MOVWF  01
1A00:  MOVLW  00
1A02:  ADDWFC x20,W
1A04:  MOVWF  03
1A06:  MOVF   01,W
1A08:  ADDLW  DA
1A0A:  MOVWF  FE9
1A0C:  MOVLW  00
1A0E:  ADDWFC 03,W
1A10:  MOVWF  FEA
1A12:  MOVFF  FEC,03
1A16:  MOVF   FED,F
1A18:  MOVF   FEF,W
1A1A:  SUBLW  FF
1A1C:  BNZ   1A24
1A1E:  INCFSZ 03,W
1A20:  BRA    1A24
1A22:  BRA    1BBA
.................... 		if ( channel[c].command_on_seconds > 0 ) {
1A24:  MOVF   x1C,W
1A26:  MULLW  19
1A28:  MOVF   FF3,W
1A2A:  CLRF   x20
1A2C:  MOVWF  x1F
1A2E:  MOVLW  01
1A30:  ADDWF  x1F,W
1A32:  MOVWF  01
1A34:  MOVLW  00
1A36:  ADDWFC x20,W
1A38:  MOVWF  03
1A3A:  MOVF   01,W
1A3C:  ADDLW  DA
1A3E:  MOVWF  FE9
1A40:  MOVLW  00
1A42:  ADDWFC 03,W
1A44:  MOVWF  FEA
1A46:  MOVFF  FEC,120
1A4A:  MOVF   FED,F
1A4C:  MOVFF  FEF,11F
1A50:  MOVF   x1F,F
1A52:  BNZ   1A58
1A54:  MOVF   x20,F
1A56:  BZ    1A86
.................... 			/* waiting to power on */
.................... 			channel[c].command_on_seconds--;
1A58:  MOVF   x1C,W
1A5A:  MULLW  19
1A5C:  MOVF   FF3,W
1A5E:  CLRF   x20
1A60:  MOVWF  x1F
1A62:  MOVLW  01
1A64:  ADDWF  x1F,W
1A66:  MOVWF  01
1A68:  MOVLW  00
1A6A:  ADDWFC x20,W
1A6C:  MOVWF  03
1A6E:  MOVF   01,W
1A70:  ADDLW  DA
1A72:  MOVWF  FE9
1A74:  MOVLW  00
1A76:  ADDWFC 03,W
1A78:  MOVWF  FEA
1A7A:  MOVLW  FF
1A7C:  ADDWF  FEF,F
1A7E:  BC    1A84
1A80:  MOVF   FEE,F
1A82:  DECF   FED,F
.................... 		} else {
1A84:  BRA    1BBA
.................... 			/* timer at zero, ready to power on or already powered on */
.................... 			if ( ! bit_test(channel[c].state,CH_STATE_BIT_CMD_ON) ) {
1A86:  MOVF   x1C,W
1A88:  MULLW  19
1A8A:  MOVF   FF3,W
1A8C:  CLRF   x20
1A8E:  MOVWF  x1F
1A90:  MOVLW  DA
1A92:  ADDWF  x1F,W
1A94:  MOVWF  FE9
1A96:  MOVLW  00
1A98:  ADDWFC x20,W
1A9A:  MOVWF  FEA
1A9C:  MOVFF  FEF,121
1AA0:  BTFSC  x21.1
1AA2:  BRA    1B18
.................... 				/* not currently set, so we set it and start the countdown */
.................... 				bit_set(channel[c].state,CH_STATE_BIT_CMD_ON);
1AA4:  MOVF   x1C,W
1AA6:  MULLW  19
1AA8:  MOVF   FF3,W
1AAA:  CLRF   x20
1AAC:  MOVWF  x1F
1AAE:  MOVLW  DA
1AB0:  ADDWF  x1F,W
1AB2:  MOVWF  01
1AB4:  MOVLW  00
1AB6:  ADDWFC x20,W
1AB8:  MOVFF  01,FE9
1ABC:  MOVWF  FEA
1ABE:  BSF    FEF.1
.................... 				channel[c].command_on_hold_seconds=config.ch[c].command_on_hold_time;
1AC0:  MOVF   x1C,W
1AC2:  MULLW  19
1AC4:  MOVF   FF3,W
1AC6:  CLRF   x20
1AC8:  MOVWF  x1F
1ACA:  MOVLW  03
1ACC:  ADDWF  x1F,W
1ACE:  MOVWF  01
1AD0:  MOVLW  00
1AD2:  ADDWFC x20,W
1AD4:  MOVWF  03
1AD6:  MOVF   01,W
1AD8:  ADDLW  DA
1ADA:  MOVWF  01
1ADC:  MOVLW  00
1ADE:  ADDWFC 03,F
1AE0:  MOVFF  03,120
1AE4:  MOVF   x1C,W
1AE6:  MULLW  24
1AE8:  MOVF   FF3,W
1AEA:  CLRF   x22
1AEC:  MOVWF  x21
1AEE:  MOVLW  1B
1AF0:  ADDWF  x21,W
1AF2:  MOVWF  FE9
1AF4:  MOVLW  00
1AF6:  ADDWFC x22,W
1AF8:  MOVWF  FEA
1AFA:  MOVFF  FEC,03
1AFE:  MOVF   FED,F
1B00:  MOVFF  FEF,123
1B04:  MOVFF  120,FEA
1B08:  MOVFF  01,FE9
1B0C:  MOVFF  03,FEC
1B10:  MOVF   FED,F
1B12:  MOVFF  123,FEF
.................... 			} else {
1B16:  BRA    1BBA
.................... 				/* set, so we clear it once countdown has elapsed */
.................... 				if ( 0==channel[c].command_on_hold_seconds ) {
1B18:  MOVF   x1C,W
1B1A:  MULLW  19
1B1C:  MOVF   FF3,W
1B1E:  CLRF   x20
1B20:  MOVWF  x1F
1B22:  MOVLW  03
1B24:  ADDWF  x1F,W
1B26:  MOVWF  01
1B28:  MOVLW  00
1B2A:  ADDWFC x20,W
1B2C:  MOVWF  03
1B2E:  MOVF   01,W
1B30:  ADDLW  DA
1B32:  MOVWF  FE9
1B34:  MOVLW  00
1B36:  ADDWFC 03,W
1B38:  MOVWF  FEA
1B3A:  MOVFF  FEC,03
1B3E:  MOVF   FED,F
1B40:  MOVF   FEF,W
1B42:  BNZ   1B8E
1B44:  MOVF   03,F
1B46:  BNZ   1B8E
.................... 					/* countdown elapsed, clear the flag and reset the timer */
.................... 					bit_clear(channel[c].state,CH_STATE_BIT_CMD_ON);
1B48:  MOVF   x1C,W
1B4A:  MULLW  19
1B4C:  MOVF   FF3,W
1B4E:  CLRF   x20
1B50:  MOVWF  x1F
1B52:  MOVLW  DA
1B54:  ADDWF  x1F,W
1B56:  MOVWF  01
1B58:  MOVLW  00
1B5A:  ADDWFC x20,W
1B5C:  MOVFF  01,FE9
1B60:  MOVWF  FEA
1B62:  BCF    FEF.1
.................... 					channel[c].command_on_seconds=65535;
1B64:  MOVF   x1C,W
1B66:  MULLW  19
1B68:  MOVF   FF3,W
1B6A:  CLRF   x20
1B6C:  MOVWF  x1F
1B6E:  MOVLW  01
1B70:  ADDWF  x1F,W
1B72:  MOVWF  01
1B74:  MOVLW  00
1B76:  ADDWFC x20,W
1B78:  MOVWF  03
1B7A:  MOVF   01,W
1B7C:  ADDLW  DA
1B7E:  MOVWF  FE9
1B80:  MOVLW  00
1B82:  ADDWFC 03,W
1B84:  MOVWF  FEA
1B86:  SETF   FEC
1B88:  MOVF   FED,F
1B8A:  SETF   FEF
.................... 				} else {
1B8C:  BRA    1BBA
.................... 					channel[c].command_on_hold_seconds--;
1B8E:  MOVF   x1C,W
1B90:  MULLW  19
1B92:  MOVF   FF3,W
1B94:  CLRF   x20
1B96:  MOVWF  x1F
1B98:  MOVLW  03
1B9A:  ADDWF  x1F,W
1B9C:  MOVWF  01
1B9E:  MOVLW  00
1BA0:  ADDWFC x20,W
1BA2:  MOVWF  03
1BA4:  MOVF   01,W
1BA6:  ADDLW  DA
1BA8:  MOVWF  FE9
1BAA:  MOVLW  00
1BAC:  ADDWFC 03,W
1BAE:  MOVWF  FEA
1BB0:  MOVLW  FF
1BB2:  ADDWF  FEF,F
1BB4:  BC    1BBA
1BB6:  MOVF   FEE,F
1BB8:  DECF   FED,F
.................... 				}
.................... 			}		
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	/* command off. 65535 disables */
.................... 	if ( 65535 != channel[c].command_off_seconds ) {
1BBA:  MOVF   x1C,W
1BBC:  MULLW  19
1BBE:  MOVF   FF3,W
1BC0:  CLRF   x20
1BC2:  MOVWF  x1F
1BC4:  MOVLW  05
1BC6:  ADDWF  x1F,W
1BC8:  MOVWF  01
1BCA:  MOVLW  00
1BCC:  ADDWFC x20,W
1BCE:  MOVWF  03
1BD0:  MOVF   01,W
1BD2:  ADDLW  DA
1BD4:  MOVWF  FE9
1BD6:  MOVLW  00
1BD8:  ADDWFC 03,W
1BDA:  MOVWF  FEA
1BDC:  MOVFF  FEC,03
1BE0:  MOVF   FED,F
1BE2:  MOVF   FEF,W
1BE4:  SUBLW  FF
1BE6:  BNZ   1BEE
1BE8:  INCFSZ 03,W
1BEA:  BRA    1BEE
1BEC:  BRA    1D94
.................... 		if ( channel[c].command_off_seconds > 0 ) {
1BEE:  MOVF   x1C,W
1BF0:  MULLW  19
1BF2:  MOVF   FF3,W
1BF4:  CLRF   x20
1BF6:  MOVWF  x1F
1BF8:  MOVLW  05
1BFA:  ADDWF  x1F,W
1BFC:  MOVWF  01
1BFE:  MOVLW  00
1C00:  ADDWFC x20,W
1C02:  MOVWF  03
1C04:  MOVF   01,W
1C06:  ADDLW  DA
1C08:  MOVWF  FE9
1C0A:  MOVLW  00
1C0C:  ADDWFC 03,W
1C0E:  MOVWF  FEA
1C10:  MOVFF  FEC,120
1C14:  MOVF   FED,F
1C16:  MOVFF  FEF,11F
1C1A:  MOVF   x1F,F
1C1C:  BNZ   1C22
1C1E:  MOVF   x20,F
1C20:  BZ    1C50
.................... 			/* waiting to power off */
.................... 			channel[c].command_off_seconds--;
1C22:  MOVF   x1C,W
1C24:  MULLW  19
1C26:  MOVF   FF3,W
1C28:  CLRF   x20
1C2A:  MOVWF  x1F
1C2C:  MOVLW  05
1C2E:  ADDWF  x1F,W
1C30:  MOVWF  01
1C32:  MOVLW  00
1C34:  ADDWFC x20,W
1C36:  MOVWF  03
1C38:  MOVF   01,W
1C3A:  ADDLW  DA
1C3C:  MOVWF  FE9
1C3E:  MOVLW  00
1C40:  ADDWFC 03,W
1C42:  MOVWF  FEA
1C44:  MOVLW  FF
1C46:  ADDWF  FEF,F
1C48:  BC    1C4E
1C4A:  MOVF   FEE,F
1C4C:  DECF   FED,F
.................... 		} else {
1C4E:  BRA    1D94
.................... 			/* timer at zero, ready to power off or already powered off */
.................... 			if ( ! bit_test(channel[c].state,CH_STATE_BIT_CMD_OFF) ) {
1C50:  MOVF   x1C,W
1C52:  MULLW  19
1C54:  MOVF   FF3,W
1C56:  CLRF   x20
1C58:  MOVWF  x1F
1C5A:  MOVLW  DA
1C5C:  ADDWF  x1F,W
1C5E:  MOVWF  FE9
1C60:  MOVLW  00
1C62:  ADDWFC x20,W
1C64:  MOVWF  FEA
1C66:  MOVFF  FEF,121
1C6A:  BTFSC  x21.2
1C6C:  BRA    1CF2
.................... 				/* not currently set, so we set it and start the countdown */
.................... 				bit_set(channel[c].state,CH_STATE_BIT_CMD_OFF);
1C6E:  MOVF   x1C,W
1C70:  MULLW  19
1C72:  MOVF   FF3,W
1C74:  CLRF   x20
1C76:  MOVWF  x1F
1C78:  MOVLW  DA
1C7A:  ADDWF  x1F,W
1C7C:  MOVWF  01
1C7E:  MOVLW  00
1C80:  ADDWFC x20,W
1C82:  MOVFF  01,FE9
1C86:  MOVWF  FEA
1C88:  BSF    FEF.2
.................... 				channel[c].command_off_hold_seconds=config.ch[c].command_off_hold_time;
1C8A:  MOVF   x1C,W
1C8C:  MULLW  19
1C8E:  MOVF   FF3,W
1C90:  CLRF   x20
1C92:  MOVWF  x1F
1C94:  MOVLW  07
1C96:  ADDWF  x1F,W
1C98:  MOVWF  01
1C9A:  MOVLW  00
1C9C:  ADDWFC x20,W
1C9E:  MOVWF  03
1CA0:  MOVF   01,W
1CA2:  ADDLW  DA
1CA4:  MOVWF  01
1CA6:  MOVLW  00
1CA8:  ADDWFC 03,F
1CAA:  MOVFF  01,11F
1CAE:  MOVFF  03,120
1CB2:  MOVF   x1C,W
1CB4:  MULLW  24
1CB6:  MOVF   FF3,W
1CB8:  CLRF   x22
1CBA:  MOVWF  x21
1CBC:  MOVLW  02
1CBE:  ADDWF  x21,W
1CC0:  MOVWF  01
1CC2:  MOVLW  00
1CC4:  ADDWFC x22,W
1CC6:  MOVWF  03
1CC8:  MOVF   01,W
1CCA:  ADDLW  1B
1CCC:  MOVWF  FE9
1CCE:  MOVLW  00
1CD0:  ADDWFC 03,W
1CD2:  MOVWF  FEA
1CD4:  MOVFF  FEC,03
1CD8:  MOVF   FED,F
1CDA:  MOVFF  FEF,121
1CDE:  MOVFF  120,FEA
1CE2:  MOVFF  11F,FE9
1CE6:  MOVFF  03,FEC
1CEA:  MOVF   FED,F
1CEC:  MOVFF  121,FEF
.................... 			} else {
1CF0:  BRA    1D94
.................... 				/* set, so we clear it once countdown has elapsed */
.................... 				if ( 0==channel[c].command_off_hold_seconds ) {
1CF2:  MOVF   x1C,W
1CF4:  MULLW  19
1CF6:  MOVF   FF3,W
1CF8:  CLRF   x20
1CFA:  MOVWF  x1F
1CFC:  MOVLW  07
1CFE:  ADDWF  x1F,W
1D00:  MOVWF  01
1D02:  MOVLW  00
1D04:  ADDWFC x20,W
1D06:  MOVWF  03
1D08:  MOVF   01,W
1D0A:  ADDLW  DA
1D0C:  MOVWF  FE9
1D0E:  MOVLW  00
1D10:  ADDWFC 03,W
1D12:  MOVWF  FEA
1D14:  MOVFF  FEC,03
1D18:  MOVF   FED,F
1D1A:  MOVF   FEF,W
1D1C:  BNZ   1D68
1D1E:  MOVF   03,F
1D20:  BNZ   1D68
.................... 					/* countdown elapsed, clear the flag and reset the timer */
.................... 					bit_clear(channel[c].state,CH_STATE_BIT_CMD_OFF);
1D22:  MOVF   x1C,W
1D24:  MULLW  19
1D26:  MOVF   FF3,W
1D28:  CLRF   x20
1D2A:  MOVWF  x1F
1D2C:  MOVLW  DA
1D2E:  ADDWF  x1F,W
1D30:  MOVWF  01
1D32:  MOVLW  00
1D34:  ADDWFC x20,W
1D36:  MOVFF  01,FE9
1D3A:  MOVWF  FEA
1D3C:  BCF    FEF.2
.................... 					channel[c].command_off_seconds=65535;
1D3E:  MOVF   x1C,W
1D40:  MULLW  19
1D42:  MOVF   FF3,W
1D44:  CLRF   x20
1D46:  MOVWF  x1F
1D48:  MOVLW  05
1D4A:  ADDWF  x1F,W
1D4C:  MOVWF  01
1D4E:  MOVLW  00
1D50:  ADDWFC x20,W
1D52:  MOVWF  03
1D54:  MOVF   01,W
1D56:  ADDLW  DA
1D58:  MOVWF  FE9
1D5A:  MOVLW  00
1D5C:  ADDWFC 03,W
1D5E:  MOVWF  FEA
1D60:  SETF   FEC
1D62:  MOVF   FED,F
1D64:  SETF   FEF
.................... 				} else {
1D66:  BRA    1D94
.................... 					channel[c].command_off_hold_seconds--;
1D68:  MOVF   x1C,W
1D6A:  MULLW  19
1D6C:  MOVF   FF3,W
1D6E:  CLRF   x20
1D70:  MOVWF  x1F
1D72:  MOVLW  07
1D74:  ADDWF  x1F,W
1D76:  MOVWF  01
1D78:  MOVLW  00
1D7A:  ADDWFC x20,W
1D7C:  MOVWF  03
1D7E:  MOVF   01,W
1D80:  ADDLW  DA
1D82:  MOVWF  FE9
1D84:  MOVLW  00
1D86:  ADDWFC 03,W
1D88:  MOVWF  FEA
1D8A:  MOVLW  FF
1D8C:  ADDWF  FEF,F
1D8E:  BC    1D94
1D90:  MOVF   FEE,F
1D92:  DECF   FED,F
.................... 				}
.................... 			}		
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	/* Low Voltage Disconnect. 65535 disables */
.................... 	if ( 65535 != config.ch[c].lvd_disconnect_delay ) {
1D94:  MOVF   x1C,W
1D96:  MULLW  24
1D98:  MOVF   FF3,W
1D9A:  CLRF   x20
1D9C:  MOVWF  x1F
1D9E:  MOVLW  06
1DA0:  ADDWF  x1F,W
1DA2:  MOVWF  01
1DA4:  MOVLW  00
1DA6:  ADDWFC x20,W
1DA8:  MOVWF  03
1DAA:  MOVF   01,W
1DAC:  ADDLW  1B
1DAE:  MOVWF  FE9
1DB0:  MOVLW  00
1DB2:  ADDWFC 03,W
1DB4:  MOVWF  FEA
1DB6:  MOVFF  FEC,03
1DBA:  MOVF   FED,F
1DBC:  MOVF   FEF,W
1DBE:  SUBLW  FF
1DC0:  BNZ   1DC8
1DC2:  INCFSZ 03,W
1DC4:  BRA    1DC8
1DC6:  BRA    2026
1DC8:  CLRF   19
1DCA:  BTFSC  FF2.7
1DCC:  BSF    19.7
1DCE:  BCF    FF2.7
.................... 		adc=adc_get(0);
1DD0:  CLRF   x2F
1DD2:  MOVLB  0
1DD4:  CALL   0594
1DD8:  BTFSC  19.7
1DDA:  BSF    FF2.7
1DDC:  MOVFF  02,11E
1DE0:  MOVFF  01,11D
.................... 
.................... 		if ( adc > config.ch[c].lvd_reconnect_adc ) {
1DE4:  MOVLB  1
1DE6:  MOVF   x1C,W
1DE8:  MULLW  24
1DEA:  MOVF   FF3,W
1DEC:  CLRF   x20
1DEE:  MOVWF  x1F
1DF0:  MOVLW  08
1DF2:  ADDWF  x1F,W
1DF4:  MOVWF  01
1DF6:  MOVLW  00
1DF8:  ADDWFC x20,W
1DFA:  MOVWF  03
1DFC:  MOVF   01,W
1DFE:  ADDLW  1B
1E00:  MOVWF  FE9
1E02:  MOVLW  00
1E04:  ADDWFC 03,W
1E06:  MOVWF  FEA
1E08:  MOVFF  FEC,03
1E0C:  MOVF   FED,F
1E0E:  MOVFF  FEF,01
1E12:  MOVF   03,W
1E14:  SUBWF  x1E,W
1E16:  BNC   1EA0
1E18:  BNZ   1E20
1E1A:  MOVF   x1D,W
1E1C:  SUBWF  01,W
1E1E:  BC    1EA0
.................... 			if ( channel[c].lvd_reconnect_delay_seconds > 0 ) {
1E20:  MOVF   x1C,W
1E22:  MULLW  19
1E24:  MOVF   FF3,W
1E26:  CLRF   x20
1E28:  MOVWF  x1F
1E2A:  MOVLW  0B
1E2C:  ADDWF  x1F,W
1E2E:  MOVWF  01
1E30:  MOVLW  00
1E32:  ADDWFC x20,W
1E34:  MOVWF  03
1E36:  MOVF   01,W
1E38:  ADDLW  DA
1E3A:  MOVWF  FE9
1E3C:  MOVLW  00
1E3E:  ADDWFC 03,W
1E40:  MOVWF  FEA
1E42:  MOVFF  FEC,120
1E46:  MOVF   FED,F
1E48:  MOVFF  FEF,11F
1E4C:  MOVF   x1F,F
1E4E:  BNZ   1E54
1E50:  MOVF   x20,F
1E52:  BZ    1E82
.................... 				channel[c].lvd_reconnect_delay_seconds--;
1E54:  MOVF   x1C,W
1E56:  MULLW  19
1E58:  MOVF   FF3,W
1E5A:  CLRF   x20
1E5C:  MOVWF  x1F
1E5E:  MOVLW  0B
1E60:  ADDWF  x1F,W
1E62:  MOVWF  01
1E64:  MOVLW  00
1E66:  ADDWFC x20,W
1E68:  MOVWF  03
1E6A:  MOVF   01,W
1E6C:  ADDLW  DA
1E6E:  MOVWF  FE9
1E70:  MOVLW  00
1E72:  ADDWFC 03,W
1E74:  MOVWF  FEA
1E76:  MOVLW  FF
1E78:  ADDWF  FEF,F
1E7A:  BC    1E80
1E7C:  MOVF   FEE,F
1E7E:  DECF   FED,F
.................... 			} else {
1E80:  BRA    1E9E
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_LVD);
1E82:  MOVF   x1C,W
1E84:  MULLW  19
1E86:  MOVF   FF3,W
1E88:  CLRF   x20
1E8A:  MOVWF  x1F
1E8C:  MOVLW  DA
1E8E:  ADDWF  x1F,W
1E90:  MOVWF  01
1E92:  MOVLW  00
1E94:  ADDWFC x20,W
1E96:  MOVFF  01,FE9
1E9A:  MOVWF  FEA
1E9C:  BCF    FEF.3
.................... 			}
.................... 		} else {
1E9E:  BRA    1F06
.................... 			channel[c].lvd_reconnect_delay_seconds=config.ch[c].lvd_reconnect_delay;
1EA0:  MOVF   x1C,W
1EA2:  MULLW  19
1EA4:  MOVF   FF3,W
1EA6:  CLRF   x20
1EA8:  MOVWF  x1F
1EAA:  MOVLW  0B
1EAC:  ADDWF  x1F,W
1EAE:  MOVWF  01
1EB0:  MOVLW  00
1EB2:  ADDWFC x20,W
1EB4:  MOVWF  03
1EB6:  MOVF   01,W
1EB8:  ADDLW  DA
1EBA:  MOVWF  01
1EBC:  MOVLW  00
1EBE:  ADDWFC 03,F
1EC0:  MOVFF  01,11F
1EC4:  MOVFF  03,120
1EC8:  MOVF   x1C,W
1ECA:  MULLW  24
1ECC:  MOVF   FF3,W
1ECE:  CLRF   x22
1ED0:  MOVWF  x21
1ED2:  MOVLW  0A
1ED4:  ADDWF  x21,W
1ED6:  MOVWF  01
1ED8:  MOVLW  00
1EDA:  ADDWFC x22,W
1EDC:  MOVWF  03
1EDE:  MOVF   01,W
1EE0:  ADDLW  1B
1EE2:  MOVWF  FE9
1EE4:  MOVLW  00
1EE6:  ADDWFC 03,W
1EE8:  MOVWF  FEA
1EEA:  MOVFF  FEC,03
1EEE:  MOVF   FED,F
1EF0:  MOVFF  FEF,121
1EF4:  MOVFF  120,FEA
1EF8:  MOVFF  11F,FE9
1EFC:  MOVFF  03,FEC
1F00:  MOVF   FED,F
1F02:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc < config.ch[c].lvd_disconnect_adc ) {
1F06:  MOVF   x1C,W
1F08:  MULLW  24
1F0A:  MOVF   FF3,W
1F0C:  CLRF   x20
1F0E:  MOVWF  x1F
1F10:  MOVLW  04
1F12:  ADDWF  x1F,W
1F14:  MOVWF  01
1F16:  MOVLW  00
1F18:  ADDWFC x20,W
1F1A:  MOVWF  03
1F1C:  MOVF   01,W
1F1E:  ADDLW  1B
1F20:  MOVWF  FE9
1F22:  MOVLW  00
1F24:  ADDWFC 03,W
1F26:  MOVWF  FEA
1F28:  MOVFF  FEC,03
1F2C:  MOVF   FED,F
1F2E:  MOVFF  FEF,01
1F32:  MOVF   x1E,W
1F34:  SUBWF  03,W
1F36:  BNC   1FC0
1F38:  BNZ   1F40
1F3A:  MOVF   01,W
1F3C:  SUBWF  x1D,W
1F3E:  BC    1FC0
.................... 			if ( channel[c].lvd_disconnect_delay_seconds > 0 ) {
1F40:  MOVF   x1C,W
1F42:  MULLW  19
1F44:  MOVF   FF3,W
1F46:  CLRF   x20
1F48:  MOVWF  x1F
1F4A:  MOVLW  09
1F4C:  ADDWF  x1F,W
1F4E:  MOVWF  01
1F50:  MOVLW  00
1F52:  ADDWFC x20,W
1F54:  MOVWF  03
1F56:  MOVF   01,W
1F58:  ADDLW  DA
1F5A:  MOVWF  FE9
1F5C:  MOVLW  00
1F5E:  ADDWFC 03,W
1F60:  MOVWF  FEA
1F62:  MOVFF  FEC,120
1F66:  MOVF   FED,F
1F68:  MOVFF  FEF,11F
1F6C:  MOVF   x1F,F
1F6E:  BNZ   1F74
1F70:  MOVF   x20,F
1F72:  BZ    1FA2
.................... 				channel[c].lvd_disconnect_delay_seconds--;
1F74:  MOVF   x1C,W
1F76:  MULLW  19
1F78:  MOVF   FF3,W
1F7A:  CLRF   x20
1F7C:  MOVWF  x1F
1F7E:  MOVLW  09
1F80:  ADDWF  x1F,W
1F82:  MOVWF  01
1F84:  MOVLW  00
1F86:  ADDWFC x20,W
1F88:  MOVWF  03
1F8A:  MOVF   01,W
1F8C:  ADDLW  DA
1F8E:  MOVWF  FE9
1F90:  MOVLW  00
1F92:  ADDWFC 03,W
1F94:  MOVWF  FEA
1F96:  MOVLW  FF
1F98:  ADDWF  FEF,F
1F9A:  BC    1FA0
1F9C:  MOVF   FEE,F
1F9E:  DECF   FED,F
.................... 			} else {
1FA0:  BRA    1FBE
.................... 				bit_set(channel[c].state,CH_STATE_BIT_LVD);
1FA2:  MOVF   x1C,W
1FA4:  MULLW  19
1FA6:  MOVF   FF3,W
1FA8:  CLRF   x20
1FAA:  MOVWF  x1F
1FAC:  MOVLW  DA
1FAE:  ADDWF  x1F,W
1FB0:  MOVWF  01
1FB2:  MOVLW  00
1FB4:  ADDWFC x20,W
1FB6:  MOVFF  01,FE9
1FBA:  MOVWF  FEA
1FBC:  BSF    FEF.3
.................... 			}
.................... 		} else {
1FBE:  BRA    2026
.................... 			channel[c].lvd_disconnect_delay_seconds=config.ch[c].lvd_disconnect_delay;
1FC0:  MOVF   x1C,W
1FC2:  MULLW  19
1FC4:  MOVF   FF3,W
1FC6:  CLRF   x20
1FC8:  MOVWF  x1F
1FCA:  MOVLW  09
1FCC:  ADDWF  x1F,W
1FCE:  MOVWF  01
1FD0:  MOVLW  00
1FD2:  ADDWFC x20,W
1FD4:  MOVWF  03
1FD6:  MOVF   01,W
1FD8:  ADDLW  DA
1FDA:  MOVWF  01
1FDC:  MOVLW  00
1FDE:  ADDWFC 03,F
1FE0:  MOVFF  01,11F
1FE4:  MOVFF  03,120
1FE8:  MOVF   x1C,W
1FEA:  MULLW  24
1FEC:  MOVF   FF3,W
1FEE:  CLRF   x22
1FF0:  MOVWF  x21
1FF2:  MOVLW  06
1FF4:  ADDWF  x21,W
1FF6:  MOVWF  01
1FF8:  MOVLW  00
1FFA:  ADDWFC x22,W
1FFC:  MOVWF  03
1FFE:  MOVF   01,W
2000:  ADDLW  1B
2002:  MOVWF  FE9
2004:  MOVLW  00
2006:  ADDWFC 03,W
2008:  MOVWF  FEA
200A:  MOVFF  FEC,03
200E:  MOVF   FED,F
2010:  MOVFF  FEF,121
2014:  MOVFF  120,FEA
2018:  MOVFF  11F,FE9
201C:  MOVFF  03,FEC
2020:  MOVF   FED,F
2022:  MOVFF  121,FEF
.................... 		}
.................... 	}
.................... 
.................... 	/* High Voltage Disconnect. 65535 disables */
.................... 	if ( 65535 != config.ch[c].hvd_disconnect_delay ) {
2026:  MOVF   x1C,W
2028:  MULLW  24
202A:  MOVF   FF3,W
202C:  CLRF   x20
202E:  MOVWF  x1F
2030:  MOVLW  0E
2032:  ADDWF  x1F,W
2034:  MOVWF  01
2036:  MOVLW  00
2038:  ADDWFC x20,W
203A:  MOVWF  03
203C:  MOVF   01,W
203E:  ADDLW  1B
2040:  MOVWF  FE9
2042:  MOVLW  00
2044:  ADDWFC 03,W
2046:  MOVWF  FEA
2048:  MOVFF  FEC,03
204C:  MOVF   FED,F
204E:  MOVF   FEF,W
2050:  SUBLW  FF
2052:  BNZ   205A
2054:  INCFSZ 03,W
2056:  BRA    205A
2058:  BRA    22B8
205A:  CLRF   19
205C:  BTFSC  FF2.7
205E:  BSF    19.7
2060:  BCF    FF2.7
.................... 		adc=adc_get(0);
2062:  CLRF   x2F
2064:  MOVLB  0
2066:  CALL   0594
206A:  BTFSC  19.7
206C:  BSF    FF2.7
206E:  MOVFF  02,11E
2072:  MOVFF  01,11D
.................... 
.................... 		if ( adc < config.ch[c].hvd_reconnect_adc ) {
2076:  MOVLB  1
2078:  MOVF   x1C,W
207A:  MULLW  24
207C:  MOVF   FF3,W
207E:  CLRF   x20
2080:  MOVWF  x1F
2082:  MOVLW  10
2084:  ADDWF  x1F,W
2086:  MOVWF  01
2088:  MOVLW  00
208A:  ADDWFC x20,W
208C:  MOVWF  03
208E:  MOVF   01,W
2090:  ADDLW  1B
2092:  MOVWF  FE9
2094:  MOVLW  00
2096:  ADDWFC 03,W
2098:  MOVWF  FEA
209A:  MOVFF  FEC,03
209E:  MOVF   FED,F
20A0:  MOVFF  FEF,01
20A4:  MOVF   x1E,W
20A6:  SUBWF  03,W
20A8:  BNC   2132
20AA:  BNZ   20B2
20AC:  MOVF   01,W
20AE:  SUBWF  x1D,W
20B0:  BC    2132
.................... 			if ( channel[c].hvd_reconnect_delay_seconds > 0 ) {
20B2:  MOVF   x1C,W
20B4:  MULLW  19
20B6:  MOVF   FF3,W
20B8:  CLRF   x20
20BA:  MOVWF  x1F
20BC:  MOVLW  0F
20BE:  ADDWF  x1F,W
20C0:  MOVWF  01
20C2:  MOVLW  00
20C4:  ADDWFC x20,W
20C6:  MOVWF  03
20C8:  MOVF   01,W
20CA:  ADDLW  DA
20CC:  MOVWF  FE9
20CE:  MOVLW  00
20D0:  ADDWFC 03,W
20D2:  MOVWF  FEA
20D4:  MOVFF  FEC,120
20D8:  MOVF   FED,F
20DA:  MOVFF  FEF,11F
20DE:  MOVF   x1F,F
20E0:  BNZ   20E6
20E2:  MOVF   x20,F
20E4:  BZ    2114
.................... 				channel[c].hvd_reconnect_delay_seconds--;
20E6:  MOVF   x1C,W
20E8:  MULLW  19
20EA:  MOVF   FF3,W
20EC:  CLRF   x20
20EE:  MOVWF  x1F
20F0:  MOVLW  0F
20F2:  ADDWF  x1F,W
20F4:  MOVWF  01
20F6:  MOVLW  00
20F8:  ADDWFC x20,W
20FA:  MOVWF  03
20FC:  MOVF   01,W
20FE:  ADDLW  DA
2100:  MOVWF  FE9
2102:  MOVLW  00
2104:  ADDWFC 03,W
2106:  MOVWF  FEA
2108:  MOVLW  FF
210A:  ADDWF  FEF,F
210C:  BC    2112
210E:  MOVF   FEE,F
2110:  DECF   FED,F
.................... 			} else {
2112:  BRA    2130
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_HVD);
2114:  MOVF   x1C,W
2116:  MULLW  19
2118:  MOVF   FF3,W
211A:  CLRF   x20
211C:  MOVWF  x1F
211E:  MOVLW  DA
2120:  ADDWF  x1F,W
2122:  MOVWF  01
2124:  MOVLW  00
2126:  ADDWFC x20,W
2128:  MOVFF  01,FE9
212C:  MOVWF  FEA
212E:  BCF    FEF.4
.................... 			}
.................... 		} else {
2130:  BRA    2198
.................... 			channel[c].hvd_reconnect_delay_seconds=config.ch[c].hvd_reconnect_delay;
2132:  MOVF   x1C,W
2134:  MULLW  19
2136:  MOVF   FF3,W
2138:  CLRF   x20
213A:  MOVWF  x1F
213C:  MOVLW  0F
213E:  ADDWF  x1F,W
2140:  MOVWF  01
2142:  MOVLW  00
2144:  ADDWFC x20,W
2146:  MOVWF  03
2148:  MOVF   01,W
214A:  ADDLW  DA
214C:  MOVWF  01
214E:  MOVLW  00
2150:  ADDWFC 03,F
2152:  MOVFF  01,11F
2156:  MOVFF  03,120
215A:  MOVF   x1C,W
215C:  MULLW  24
215E:  MOVF   FF3,W
2160:  CLRF   x22
2162:  MOVWF  x21
2164:  MOVLW  12
2166:  ADDWF  x21,W
2168:  MOVWF  01
216A:  MOVLW  00
216C:  ADDWFC x22,W
216E:  MOVWF  03
2170:  MOVF   01,W
2172:  ADDLW  1B
2174:  MOVWF  FE9
2176:  MOVLW  00
2178:  ADDWFC 03,W
217A:  MOVWF  FEA
217C:  MOVFF  FEC,03
2180:  MOVF   FED,F
2182:  MOVFF  FEF,121
2186:  MOVFF  120,FEA
218A:  MOVFF  11F,FE9
218E:  MOVFF  03,FEC
2192:  MOVF   FED,F
2194:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc > config.ch[c].hvd_disconnect_adc ) {
2198:  MOVF   x1C,W
219A:  MULLW  24
219C:  MOVF   FF3,W
219E:  CLRF   x20
21A0:  MOVWF  x1F
21A2:  MOVLW  0C
21A4:  ADDWF  x1F,W
21A6:  MOVWF  01
21A8:  MOVLW  00
21AA:  ADDWFC x20,W
21AC:  MOVWF  03
21AE:  MOVF   01,W
21B0:  ADDLW  1B
21B2:  MOVWF  FE9
21B4:  MOVLW  00
21B6:  ADDWFC 03,W
21B8:  MOVWF  FEA
21BA:  MOVFF  FEC,03
21BE:  MOVF   FED,F
21C0:  MOVFF  FEF,01
21C4:  MOVF   03,W
21C6:  SUBWF  x1E,W
21C8:  BNC   2252
21CA:  BNZ   21D2
21CC:  MOVF   x1D,W
21CE:  SUBWF  01,W
21D0:  BC    2252
.................... 			if ( channel[c].hvd_disconnect_delay_seconds > 0 ) {
21D2:  MOVF   x1C,W
21D4:  MULLW  19
21D6:  MOVF   FF3,W
21D8:  CLRF   x20
21DA:  MOVWF  x1F
21DC:  MOVLW  0D
21DE:  ADDWF  x1F,W
21E0:  MOVWF  01
21E2:  MOVLW  00
21E4:  ADDWFC x20,W
21E6:  MOVWF  03
21E8:  MOVF   01,W
21EA:  ADDLW  DA
21EC:  MOVWF  FE9
21EE:  MOVLW  00
21F0:  ADDWFC 03,W
21F2:  MOVWF  FEA
21F4:  MOVFF  FEC,120
21F8:  MOVF   FED,F
21FA:  MOVFF  FEF,11F
21FE:  MOVF   x1F,F
2200:  BNZ   2206
2202:  MOVF   x20,F
2204:  BZ    2234
.................... 				channel[c].hvd_disconnect_delay_seconds--;
2206:  MOVF   x1C,W
2208:  MULLW  19
220A:  MOVF   FF3,W
220C:  CLRF   x20
220E:  MOVWF  x1F
2210:  MOVLW  0D
2212:  ADDWF  x1F,W
2214:  MOVWF  01
2216:  MOVLW  00
2218:  ADDWFC x20,W
221A:  MOVWF  03
221C:  MOVF   01,W
221E:  ADDLW  DA
2220:  MOVWF  FE9
2222:  MOVLW  00
2224:  ADDWFC 03,W
2226:  MOVWF  FEA
2228:  MOVLW  FF
222A:  ADDWF  FEF,F
222C:  BC    2232
222E:  MOVF   FEE,F
2230:  DECF   FED,F
.................... 			} else {
2232:  BRA    2250
.................... 				bit_set(channel[c].state,CH_STATE_BIT_HVD);
2234:  MOVF   x1C,W
2236:  MULLW  19
2238:  MOVF   FF3,W
223A:  CLRF   x20
223C:  MOVWF  x1F
223E:  MOVLW  DA
2240:  ADDWF  x1F,W
2242:  MOVWF  01
2244:  MOVLW  00
2246:  ADDWFC x20,W
2248:  MOVFF  01,FE9
224C:  MOVWF  FEA
224E:  BSF    FEF.4
.................... 			}
.................... 		} else {
2250:  BRA    22B8
.................... 			channel[c].hvd_disconnect_delay_seconds=config.ch[c].hvd_disconnect_delay;
2252:  MOVF   x1C,W
2254:  MULLW  19
2256:  MOVF   FF3,W
2258:  CLRF   x20
225A:  MOVWF  x1F
225C:  MOVLW  0D
225E:  ADDWF  x1F,W
2260:  MOVWF  01
2262:  MOVLW  00
2264:  ADDWFC x20,W
2266:  MOVWF  03
2268:  MOVF   01,W
226A:  ADDLW  DA
226C:  MOVWF  01
226E:  MOVLW  00
2270:  ADDWFC 03,F
2272:  MOVFF  01,11F
2276:  MOVFF  03,120
227A:  MOVF   x1C,W
227C:  MULLW  24
227E:  MOVF   FF3,W
2280:  CLRF   x22
2282:  MOVWF  x21
2284:  MOVLW  0E
2286:  ADDWF  x21,W
2288:  MOVWF  01
228A:  MOVLW  00
228C:  ADDWFC x22,W
228E:  MOVWF  03
2290:  MOVF   01,W
2292:  ADDLW  1B
2294:  MOVWF  FE9
2296:  MOVLW  00
2298:  ADDWFC 03,W
229A:  MOVWF  FEA
229C:  MOVFF  FEC,03
22A0:  MOVF   FED,F
22A2:  MOVFF  FEF,121
22A6:  MOVFF  120,FEA
22AA:  MOVFF  11F,FE9
22AE:  MOVFF  03,FEC
22B2:  MOVF   FED,F
22B4:  MOVFF  121,FEF
.................... 		}
.................... 	}
.................... 
.................... 	/* Low Temperature Disconnect. 65535 disables */
.................... 	if ( 65535 != config.ch[c].ltd_disconnect_delay ) {
22B8:  MOVF   x1C,W
22BA:  MULLW  24
22BC:  MOVF   FF3,W
22BE:  CLRF   x20
22C0:  MOVWF  x1F
22C2:  MOVLW  16
22C4:  ADDWF  x1F,W
22C6:  MOVWF  01
22C8:  MOVLW  00
22CA:  ADDWFC x20,W
22CC:  MOVWF  03
22CE:  MOVF   01,W
22D0:  ADDLW  1B
22D2:  MOVWF  FE9
22D4:  MOVLW  00
22D6:  ADDWFC 03,W
22D8:  MOVWF  FEA
22DA:  MOVFF  FEC,03
22DE:  MOVF   FED,F
22E0:  MOVF   FEF,W
22E2:  SUBLW  FF
22E4:  BNZ   22EC
22E6:  INCFSZ 03,W
22E8:  BRA    22EC
22EA:  BRA    254C
22EC:  CLRF   19
22EE:  BTFSC  FF2.7
22F0:  BSF    19.7
22F2:  BCF    FF2.7
.................... 		adc=adc_get(1);
22F4:  MOVLW  01
22F6:  MOVWF  x2F
22F8:  MOVLB  0
22FA:  CALL   0594
22FE:  BTFSC  19.7
2300:  BSF    FF2.7
2302:  MOVFF  02,11E
2306:  MOVFF  01,11D
.................... 
.................... 		if ( adc < config.ch[c].ltd_reconnect_adc ) {
230A:  MOVLB  1
230C:  MOVF   x1C,W
230E:  MULLW  24
2310:  MOVF   FF3,W
2312:  CLRF   x20
2314:  MOVWF  x1F
2316:  MOVLW  18
2318:  ADDWF  x1F,W
231A:  MOVWF  01
231C:  MOVLW  00
231E:  ADDWFC x20,W
2320:  MOVWF  03
2322:  MOVF   01,W
2324:  ADDLW  1B
2326:  MOVWF  FE9
2328:  MOVLW  00
232A:  ADDWFC 03,W
232C:  MOVWF  FEA
232E:  MOVFF  FEC,03
2332:  MOVF   FED,F
2334:  MOVFF  FEF,01
2338:  MOVF   x1E,W
233A:  SUBWF  03,W
233C:  BNC   23C6
233E:  BNZ   2346
2340:  MOVF   01,W
2342:  SUBWF  x1D,W
2344:  BC    23C6
.................... 			/* above reconnect temperature */
.................... 			if ( channel[c].ltd_reconnect_delay_seconds > 0 ) {
2346:  MOVF   x1C,W
2348:  MULLW  19
234A:  MOVF   FF3,W
234C:  CLRF   x20
234E:  MOVWF  x1F
2350:  MOVLW  13
2352:  ADDWF  x1F,W
2354:  MOVWF  01
2356:  MOVLW  00
2358:  ADDWFC x20,W
235A:  MOVWF  03
235C:  MOVF   01,W
235E:  ADDLW  DA
2360:  MOVWF  FE9
2362:  MOVLW  00
2364:  ADDWFC 03,W
2366:  MOVWF  FEA
2368:  MOVFF  FEC,120
236C:  MOVF   FED,F
236E:  MOVFF  FEF,11F
2372:  MOVF   x1F,F
2374:  BNZ   237A
2376:  MOVF   x20,F
2378:  BZ    23A8
.................... 				channel[c].ltd_reconnect_delay_seconds--;
237A:  MOVF   x1C,W
237C:  MULLW  19
237E:  MOVF   FF3,W
2380:  CLRF   x20
2382:  MOVWF  x1F
2384:  MOVLW  13
2386:  ADDWF  x1F,W
2388:  MOVWF  01
238A:  MOVLW  00
238C:  ADDWFC x20,W
238E:  MOVWF  03
2390:  MOVF   01,W
2392:  ADDLW  DA
2394:  MOVWF  FE9
2396:  MOVLW  00
2398:  ADDWFC 03,W
239A:  MOVWF  FEA
239C:  MOVLW  FF
239E:  ADDWF  FEF,F
23A0:  BC    23A6
23A2:  MOVF   FEE,F
23A4:  DECF   FED,F
.................... 			} else {
23A6:  BRA    23C4
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_LTD);
23A8:  MOVF   x1C,W
23AA:  MULLW  19
23AC:  MOVF   FF3,W
23AE:  CLRF   x20
23B0:  MOVWF  x1F
23B2:  MOVLW  DA
23B4:  ADDWF  x1F,W
23B6:  MOVWF  01
23B8:  MOVLW  00
23BA:  ADDWFC x20,W
23BC:  MOVFF  01,FE9
23C0:  MOVWF  FEA
23C2:  BCF    FEF.5
.................... 			}
.................... 		} else {
23C4:  BRA    242C
.................... 			channel[c].ltd_reconnect_delay_seconds=config.ch[c].ltd_reconnect_delay;
23C6:  MOVF   x1C,W
23C8:  MULLW  19
23CA:  MOVF   FF3,W
23CC:  CLRF   x20
23CE:  MOVWF  x1F
23D0:  MOVLW  13
23D2:  ADDWF  x1F,W
23D4:  MOVWF  01
23D6:  MOVLW  00
23D8:  ADDWFC x20,W
23DA:  MOVWF  03
23DC:  MOVF   01,W
23DE:  ADDLW  DA
23E0:  MOVWF  01
23E2:  MOVLW  00
23E4:  ADDWFC 03,F
23E6:  MOVFF  01,11F
23EA:  MOVFF  03,120
23EE:  MOVF   x1C,W
23F0:  MULLW  24
23F2:  MOVF   FF3,W
23F4:  CLRF   x22
23F6:  MOVWF  x21
23F8:  MOVLW  1A
23FA:  ADDWF  x21,W
23FC:  MOVWF  01
23FE:  MOVLW  00
2400:  ADDWFC x22,W
2402:  MOVWF  03
2404:  MOVF   01,W
2406:  ADDLW  1B
2408:  MOVWF  FE9
240A:  MOVLW  00
240C:  ADDWFC 03,W
240E:  MOVWF  FEA
2410:  MOVFF  FEC,03
2414:  MOVF   FED,F
2416:  MOVFF  FEF,121
241A:  MOVFF  120,FEA
241E:  MOVFF  11F,FE9
2422:  MOVFF  03,FEC
2426:  MOVF   FED,F
2428:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc > config.ch[c].ltd_disconnect_adc ) {
242C:  MOVF   x1C,W
242E:  MULLW  24
2430:  MOVF   FF3,W
2432:  CLRF   x20
2434:  MOVWF  x1F
2436:  MOVLW  14
2438:  ADDWF  x1F,W
243A:  MOVWF  01
243C:  MOVLW  00
243E:  ADDWFC x20,W
2440:  MOVWF  03
2442:  MOVF   01,W
2444:  ADDLW  1B
2446:  MOVWF  FE9
2448:  MOVLW  00
244A:  ADDWFC 03,W
244C:  MOVWF  FEA
244E:  MOVFF  FEC,03
2452:  MOVF   FED,F
2454:  MOVFF  FEF,01
2458:  MOVF   03,W
245A:  SUBWF  x1E,W
245C:  BNC   24E6
245E:  BNZ   2466
2460:  MOVF   x1D,W
2462:  SUBWF  01,W
2464:  BC    24E6
.................... 			/* below disconnect temperature */
.................... 			if ( channel[c].ltd_disconnect_delay_seconds > 0 ) {
2466:  MOVF   x1C,W
2468:  MULLW  19
246A:  MOVF   FF3,W
246C:  CLRF   x20
246E:  MOVWF  x1F
2470:  MOVLW  11
2472:  ADDWF  x1F,W
2474:  MOVWF  01
2476:  MOVLW  00
2478:  ADDWFC x20,W
247A:  MOVWF  03
247C:  MOVF   01,W
247E:  ADDLW  DA
2480:  MOVWF  FE9
2482:  MOVLW  00
2484:  ADDWFC 03,W
2486:  MOVWF  FEA
2488:  MOVFF  FEC,120
248C:  MOVF   FED,F
248E:  MOVFF  FEF,11F
2492:  MOVF   x1F,F
2494:  BNZ   249A
2496:  MOVF   x20,F
2498:  BZ    24C8
.................... 				channel[c].ltd_disconnect_delay_seconds--;
249A:  MOVF   x1C,W
249C:  MULLW  19
249E:  MOVF   FF3,W
24A0:  CLRF   x20
24A2:  MOVWF  x1F
24A4:  MOVLW  11
24A6:  ADDWF  x1F,W
24A8:  MOVWF  01
24AA:  MOVLW  00
24AC:  ADDWFC x20,W
24AE:  MOVWF  03
24B0:  MOVF   01,W
24B2:  ADDLW  DA
24B4:  MOVWF  FE9
24B6:  MOVLW  00
24B8:  ADDWFC 03,W
24BA:  MOVWF  FEA
24BC:  MOVLW  FF
24BE:  ADDWF  FEF,F
24C0:  BC    24C6
24C2:  MOVF   FEE,F
24C4:  DECF   FED,F
.................... 			} else {
24C6:  BRA    24E4
.................... 				bit_set(channel[c].state,CH_STATE_BIT_LTD);
24C8:  MOVF   x1C,W
24CA:  MULLW  19
24CC:  MOVF   FF3,W
24CE:  CLRF   x20
24D0:  MOVWF  x1F
24D2:  MOVLW  DA
24D4:  ADDWF  x1F,W
24D6:  MOVWF  01
24D8:  MOVLW  00
24DA:  ADDWFC x20,W
24DC:  MOVFF  01,FE9
24E0:  MOVWF  FEA
24E2:  BSF    FEF.5
.................... 			}
.................... 		} else {
24E4:  BRA    254C
.................... 			channel[c].ltd_disconnect_delay_seconds=config.ch[c].ltd_disconnect_delay;
24E6:  MOVF   x1C,W
24E8:  MULLW  19
24EA:  MOVF   FF3,W
24EC:  CLRF   x20
24EE:  MOVWF  x1F
24F0:  MOVLW  11
24F2:  ADDWF  x1F,W
24F4:  MOVWF  01
24F6:  MOVLW  00
24F8:  ADDWFC x20,W
24FA:  MOVWF  03
24FC:  MOVF   01,W
24FE:  ADDLW  DA
2500:  MOVWF  01
2502:  MOVLW  00
2504:  ADDWFC 03,F
2506:  MOVFF  01,11F
250A:  MOVFF  03,120
250E:  MOVF   x1C,W
2510:  MULLW  24
2512:  MOVF   FF3,W
2514:  CLRF   x22
2516:  MOVWF  x21
2518:  MOVLW  16
251A:  ADDWF  x21,W
251C:  MOVWF  01
251E:  MOVLW  00
2520:  ADDWFC x22,W
2522:  MOVWF  03
2524:  MOVF   01,W
2526:  ADDLW  1B
2528:  MOVWF  FE9
252A:  MOVLW  00
252C:  ADDWFC 03,W
252E:  MOVWF  FEA
2530:  MOVFF  FEC,03
2534:  MOVF   FED,F
2536:  MOVFF  FEF,121
253A:  MOVFF  120,FEA
253E:  MOVFF  11F,FE9
2542:  MOVFF  03,FEC
2546:  MOVF   FED,F
2548:  MOVFF  121,FEF
.................... 		}
.................... 	}
.................... 
.................... 	/* High Temperature Disconnect. 65535 disables */
.................... 	if ( 65535 != config.ch[c].htd_disconnect_delay ) {
254C:  MOVF   x1C,W
254E:  MULLW  24
2550:  MOVF   FF3,W
2552:  CLRF   x20
2554:  MOVWF  x1F
2556:  MOVLW  1E
2558:  ADDWF  x1F,W
255A:  MOVWF  01
255C:  MOVLW  00
255E:  ADDWFC x20,W
2560:  MOVWF  03
2562:  MOVF   01,W
2564:  ADDLW  1B
2566:  MOVWF  FE9
2568:  MOVLW  00
256A:  ADDWFC 03,W
256C:  MOVWF  FEA
256E:  MOVFF  FEC,03
2572:  MOVF   FED,F
2574:  MOVF   FEF,W
2576:  SUBLW  FF
2578:  BNZ   2580
257A:  INCFSZ 03,W
257C:  BRA    2580
257E:  BRA    27E0
2580:  CLRF   19
2582:  BTFSC  FF2.7
2584:  BSF    19.7
2586:  BCF    FF2.7
.................... 		adc=adc_get(1);
2588:  MOVLW  01
258A:  MOVWF  x2F
258C:  MOVLB  0
258E:  CALL   0594
2592:  BTFSC  19.7
2594:  BSF    FF2.7
2596:  MOVFF  02,11E
259A:  MOVFF  01,11D
.................... 
.................... 		if ( adc > config.ch[c].htd_reconnect_adc ) {
259E:  MOVLB  1
25A0:  MOVF   x1C,W
25A2:  MULLW  24
25A4:  MOVF   FF3,W
25A6:  CLRF   x20
25A8:  MOVWF  x1F
25AA:  MOVLW  20
25AC:  ADDWF  x1F,W
25AE:  MOVWF  01
25B0:  MOVLW  00
25B2:  ADDWFC x20,W
25B4:  MOVWF  03
25B6:  MOVF   01,W
25B8:  ADDLW  1B
25BA:  MOVWF  FE9
25BC:  MOVLW  00
25BE:  ADDWFC 03,W
25C0:  MOVWF  FEA
25C2:  MOVFF  FEC,03
25C6:  MOVF   FED,F
25C8:  MOVFF  FEF,01
25CC:  MOVF   03,W
25CE:  SUBWF  x1E,W
25D0:  BNC   265A
25D2:  BNZ   25DA
25D4:  MOVF   x1D,W
25D6:  SUBWF  01,W
25D8:  BC    265A
.................... 			if ( channel[c].htd_reconnect_delay_seconds > 0 ) {
25DA:  MOVF   x1C,W
25DC:  MULLW  19
25DE:  MOVF   FF3,W
25E0:  CLRF   x20
25E2:  MOVWF  x1F
25E4:  MOVLW  17
25E6:  ADDWF  x1F,W
25E8:  MOVWF  01
25EA:  MOVLW  00
25EC:  ADDWFC x20,W
25EE:  MOVWF  03
25F0:  MOVF   01,W
25F2:  ADDLW  DA
25F4:  MOVWF  FE9
25F6:  MOVLW  00
25F8:  ADDWFC 03,W
25FA:  MOVWF  FEA
25FC:  MOVFF  FEC,120
2600:  MOVF   FED,F
2602:  MOVFF  FEF,11F
2606:  MOVF   x1F,F
2608:  BNZ   260E
260A:  MOVF   x20,F
260C:  BZ    263C
.................... 				channel[c].htd_reconnect_delay_seconds--;
260E:  MOVF   x1C,W
2610:  MULLW  19
2612:  MOVF   FF3,W
2614:  CLRF   x20
2616:  MOVWF  x1F
2618:  MOVLW  17
261A:  ADDWF  x1F,W
261C:  MOVWF  01
261E:  MOVLW  00
2620:  ADDWFC x20,W
2622:  MOVWF  03
2624:  MOVF   01,W
2626:  ADDLW  DA
2628:  MOVWF  FE9
262A:  MOVLW  00
262C:  ADDWFC 03,W
262E:  MOVWF  FEA
2630:  MOVLW  FF
2632:  ADDWF  FEF,F
2634:  BC    263A
2636:  MOVF   FEE,F
2638:  DECF   FED,F
.................... 			} else {
263A:  BRA    2658
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_HTD);
263C:  MOVF   x1C,W
263E:  MULLW  19
2640:  MOVF   FF3,W
2642:  CLRF   x20
2644:  MOVWF  x1F
2646:  MOVLW  DA
2648:  ADDWF  x1F,W
264A:  MOVWF  01
264C:  MOVLW  00
264E:  ADDWFC x20,W
2650:  MOVFF  01,FE9
2654:  MOVWF  FEA
2656:  BCF    FEF.6
.................... 			}
.................... 		} else {
2658:  BRA    26C0
.................... 			channel[c].htd_reconnect_delay_seconds=config.ch[c].htd_reconnect_delay;
265A:  MOVF   x1C,W
265C:  MULLW  19
265E:  MOVF   FF3,W
2660:  CLRF   x20
2662:  MOVWF  x1F
2664:  MOVLW  17
2666:  ADDWF  x1F,W
2668:  MOVWF  01
266A:  MOVLW  00
266C:  ADDWFC x20,W
266E:  MOVWF  03
2670:  MOVF   01,W
2672:  ADDLW  DA
2674:  MOVWF  01
2676:  MOVLW  00
2678:  ADDWFC 03,F
267A:  MOVFF  01,11F
267E:  MOVFF  03,120
2682:  MOVF   x1C,W
2684:  MULLW  24
2686:  MOVF   FF3,W
2688:  CLRF   x22
268A:  MOVWF  x21
268C:  MOVLW  22
268E:  ADDWF  x21,W
2690:  MOVWF  01
2692:  MOVLW  00
2694:  ADDWFC x22,W
2696:  MOVWF  03
2698:  MOVF   01,W
269A:  ADDLW  1B
269C:  MOVWF  FE9
269E:  MOVLW  00
26A0:  ADDWFC 03,W
26A2:  MOVWF  FEA
26A4:  MOVFF  FEC,03
26A8:  MOVF   FED,F
26AA:  MOVFF  FEF,121
26AE:  MOVFF  120,FEA
26B2:  MOVFF  11F,FE9
26B6:  MOVFF  03,FEC
26BA:  MOVF   FED,F
26BC:  MOVFF  121,FEF
.................... 		}
.................... 
.................... 		if ( adc < config.ch[c].htd_disconnect_adc ) {
26C0:  MOVF   x1C,W
26C2:  MULLW  24
26C4:  MOVF   FF3,W
26C6:  CLRF   x20
26C8:  MOVWF  x1F
26CA:  MOVLW  1C
26CC:  ADDWF  x1F,W
26CE:  MOVWF  01
26D0:  MOVLW  00
26D2:  ADDWFC x20,W
26D4:  MOVWF  03
26D6:  MOVF   01,W
26D8:  ADDLW  1B
26DA:  MOVWF  FE9
26DC:  MOVLW  00
26DE:  ADDWFC 03,W
26E0:  MOVWF  FEA
26E2:  MOVFF  FEC,03
26E6:  MOVF   FED,F
26E8:  MOVFF  FEF,01
26EC:  MOVF   x1E,W
26EE:  SUBWF  03,W
26F0:  BNC   277A
26F2:  BNZ   26FA
26F4:  MOVF   01,W
26F6:  SUBWF  x1D,W
26F8:  BC    277A
.................... 			if ( channel[c].htd_disconnect_delay_seconds > 0 ) {
26FA:  MOVF   x1C,W
26FC:  MULLW  19
26FE:  MOVF   FF3,W
2700:  CLRF   x20
2702:  MOVWF  x1F
2704:  MOVLW  15
2706:  ADDWF  x1F,W
2708:  MOVWF  01
270A:  MOVLW  00
270C:  ADDWFC x20,W
270E:  MOVWF  03
2710:  MOVF   01,W
2712:  ADDLW  DA
2714:  MOVWF  FE9
2716:  MOVLW  00
2718:  ADDWFC 03,W
271A:  MOVWF  FEA
271C:  MOVFF  FEC,120
2720:  MOVF   FED,F
2722:  MOVFF  FEF,11F
2726:  MOVF   x1F,F
2728:  BNZ   272E
272A:  MOVF   x20,F
272C:  BZ    275C
.................... 				channel[c].htd_disconnect_delay_seconds--;
272E:  MOVF   x1C,W
2730:  MULLW  19
2732:  MOVF   FF3,W
2734:  CLRF   x20
2736:  MOVWF  x1F
2738:  MOVLW  15
273A:  ADDWF  x1F,W
273C:  MOVWF  01
273E:  MOVLW  00
2740:  ADDWFC x20,W
2742:  MOVWF  03
2744:  MOVF   01,W
2746:  ADDLW  DA
2748:  MOVWF  FE9
274A:  MOVLW  00
274C:  ADDWFC 03,W
274E:  MOVWF  FEA
2750:  MOVLW  FF
2752:  ADDWF  FEF,F
2754:  BC    275A
2756:  MOVF   FEE,F
2758:  DECF   FED,F
.................... 			} else {
275A:  BRA    2778
.................... 				bit_set(channel[c].state,CH_STATE_BIT_HTD);
275C:  MOVF   x1C,W
275E:  MULLW  19
2760:  MOVF   FF3,W
2762:  CLRF   x20
2764:  MOVWF  x1F
2766:  MOVLW  DA
2768:  ADDWF  x1F,W
276A:  MOVWF  01
276C:  MOVLW  00
276E:  ADDWFC x20,W
2770:  MOVFF  01,FE9
2774:  MOVWF  FEA
2776:  BSF    FEF.6
.................... 			}
.................... 		} else {
2778:  BRA    27E0
.................... 			channel[c].htd_disconnect_delay_seconds=config.ch[c].htd_disconnect_delay;
277A:  MOVF   x1C,W
277C:  MULLW  19
277E:  MOVF   FF3,W
2780:  CLRF   x20
2782:  MOVWF  x1F
2784:  MOVLW  15
2786:  ADDWF  x1F,W
2788:  MOVWF  01
278A:  MOVLW  00
278C:  ADDWFC x20,W
278E:  MOVWF  03
2790:  MOVF   01,W
2792:  ADDLW  DA
2794:  MOVWF  01
2796:  MOVLW  00
2798:  ADDWFC 03,F
279A:  MOVFF  01,11F
279E:  MOVFF  03,120
27A2:  MOVF   x1C,W
27A4:  MULLW  24
27A6:  MOVF   FF3,W
27A8:  CLRF   x22
27AA:  MOVWF  x21
27AC:  MOVLW  1E
27AE:  ADDWF  x21,W
27B0:  MOVWF  01
27B2:  MOVLW  00
27B4:  ADDWFC x22,W
27B6:  MOVWF  03
27B8:  MOVF   01,W
27BA:  ADDLW  1B
27BC:  MOVWF  FE9
27BE:  MOVLW  00
27C0:  ADDWFC 03,W
27C2:  MOVWF  FEA
27C4:  MOVFF  FEC,03
27C8:  MOVF   FED,F
27CA:  MOVFF  FEF,121
27CE:  MOVFF  120,FEA
27D2:  MOVFF  11F,FE9
27D6:  MOVFF  03,FEC
27DA:  MOVF   FED,F
27DC:  MOVFF  121,FEF
.................... 		}
.................... 	}
27E0:  MOVLB  0
27E2:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void led_status_update(void) {
.................... 	static int8 cycle=0;
.................... 	int8 led;
.................... 
.................... 	for ( led=0 ; led<2 ; led++ ) {
*
28A0:  MOVLB  1
28A2:  CLRF   x1C
28A4:  MOVF   x1C,W
28A6:  SUBLW  01
28A8:  BNC   297E
.................... 		if ( cycle < 8 ) {
28AA:  MOVF   x11,W
28AC:  SUBLW  07
28AE:  BNC   2916
.................... 			/* first 8 cycles are 8 bits of state bit field */
.................... 
.................... 			/* if bit is set, then we blink the number of times+1 of the bit we are in. So bit 1 set means we blink 2 times */
.................... 			if ( bit_test(channel[led].state,cycle) ) {
28B0:  MOVF   x1C,W
28B2:  MULLW  19
28B4:  MOVF   FF3,W
28B6:  CLRF   x1E
28B8:  MOVWF  x1D
28BA:  MOVLW  DA
28BC:  ADDWF  x1D,W
28BE:  MOVWF  FE9
28C0:  MOVLW  00
28C2:  ADDWFC x1E,W
28C4:  MOVWF  FEA
28C6:  MOVFF  FEF,00
28CA:  MOVF   x11,W
28CC:  MOVWF  01
28CE:  BZ    28D8
28D0:  BCF    FD8.0
28D2:  RRCF   00,F
28D4:  DECFSZ 01,F
28D6:  BRA    28D0
28D8:  BTFSS  00.0
28DA:  BRA    2904
.................... 				timers.led_blink[led]=cycle+1;      /* number of blinks */
28DC:  CLRF   03
28DE:  MOVF   x1C,W
28E0:  ADDLW  D0
28E2:  MOVWF  FE9
28E4:  MOVLW  00
28E6:  ADDWFC 03,W
28E8:  MOVWF  FEA
28EA:  MOVLW  01
28EC:  ADDWF  x11,W
28EE:  MOVWF  FEF
.................... 				timers.led_on[led]=BLINK_ON_TIME;   /* how long to be on */
28F0:  CLRF   03
28F2:  MOVF   x1C,W
28F4:  ADDLW  D2
28F6:  MOVWF  FE9
28F8:  MOVLW  00
28FA:  ADDWFC 03,W
28FC:  MOVWF  FEA
28FE:  MOVLW  FE
2900:  MOVWF  FEF
.................... 			} else {
2902:  BRA    2914
.................... 				timers.led_blink[led]=0;
2904:  CLRF   03
2906:  MOVF   x1C,W
2908:  ADDLW  D0
290A:  MOVWF  FE9
290C:  MOVLW  00
290E:  ADDWFC 03,W
2910:  MOVWF  FEA
2912:  CLRF   FEF
.................... 			}
.................... 		} else if ( 8 == cycle ) {
2914:  BRA    297A
2916:  MOVF   x11,W
2918:  SUBLW  08
291A:  BNZ   292E
.................... 			/* solid light to mark start of next cycle */
.................... 			timers.led_blink[led]=255;
291C:  CLRF   03
291E:  MOVF   x1C,W
2920:  ADDLW  D0
2922:  MOVWF  FE9
2924:  MOVLW  00
2926:  ADDWFC 03,W
2928:  MOVWF  FEA
292A:  SETF   FEF
.................... 		} else if ( 9 == cycle ) {
292C:  BRA    297A
292E:  MOVF   x11,W
2930:  SUBLW  09
2932:  BNZ   296A
.................... 			/* solid on if contactor state is on, otherwise off */
.................... 			if ( timers.contactor[led] ) {
2934:  CLRF   03
2936:  MOVF   x1C,W
2938:  ADDLW  D6
293A:  MOVWF  FE9
293C:  MOVLW  00
293E:  ADDWFC 03,W
2940:  MOVWF  FEA
2942:  MOVF   FEF,F
2944:  BZ    2958
.................... 				timers.led_blink[led]=255;
2946:  CLRF   03
2948:  MOVF   x1C,W
294A:  ADDLW  D0
294C:  MOVWF  FE9
294E:  MOVLW  00
2950:  ADDWFC 03,W
2952:  MOVWF  FEA
2954:  SETF   FEF
.................... 			} else {
2956:  BRA    2968
.................... 				timers.led_blink[led]=0;
2958:  CLRF   03
295A:  MOVF   x1C,W
295C:  ADDLW  D0
295E:  MOVWF  FE9
2960:  MOVLW  00
2962:  ADDWFC 03,W
2964:  MOVWF  FEA
2966:  CLRF   FEF
.................... 			}
.................... 		} else {
2968:  BRA    297A
.................... 			/* blank period before starting the bit field */
.................... 			timers.led_blink[led]=0;
296A:  CLRF   03
296C:  MOVF   x1C,W
296E:  ADDLW  D0
2970:  MOVWF  FE9
2972:  MOVLW  00
2974:  ADDWFC 03,W
2976:  MOVWF  FEA
2978:  CLRF   FEF
.................... 		}
297A:  INCF   x1C,F
297C:  BRA    28A4
.................... 	}
.................... 
.................... //	fprintf(STREAM_FTDI,"# LED %u A=%03u (0x%02X) B=%03u (0x%02X)\r\n",cycle,timers.led_blink[0],channel[0].state,timers.led_blink[1],channel[1].state);
.................... 
.................... 	if ( 10 == cycle ) {
297E:  MOVF   x11,W
2980:  SUBLW  0A
2982:  BNZ   2988
.................... 		cycle=0; 
2984:  CLRF   x11
.................... 	} else {
2986:  BRA    298A
.................... 		cycle++;
2988:  INCF   x11,F
.................... 	}
298A:  MOVLB  0
298C:  GOTO   2B3A (RETURN)
.................... }
.................... 
.................... void led_on(int8 c) {
.................... 	if ( 0==c ) 
*
1978:  MOVLB  1
197A:  MOVF   x1C,F
197C:  BNZ   1984
.................... 		output_high(LED_A);
197E:  BCF    F94.1
1980:  BSF    F8B.1
1982:  BRA    1988
.................... 	else
.................... 		output_high(LED_B);
1984:  BCF    F94.2
1986:  BSF    F8B.2
1988:  MOVLB  0
198A:  RETURN 0
.................... }
.................... 
.................... void led_off(int8 c) {
.................... 	if ( 0==c ) 
198C:  MOVLB  1
198E:  MOVF   x1C,F
1990:  BNZ   1998
.................... 		output_low(LED_A);
1992:  BCF    F94.1
1994:  BCF    F8B.1
1996:  BRA    199C
.................... 	else
.................... 		output_low(LED_B);
1998:  BCF    F94.2
199A:  BCF    F8B.2
199C:  MOVLB  0
199E:  RETURN 0
.................... }
.................... 
.................... void periodic_millisecond(void) {
.................... 	static int8  uptimeTicks=0;
.................... 	static int8  statusTicks=0;
.................... 	static int16 adcTicks=0;
.................... 	static int16 ticks=0;
.................... 
.................... 	int8 i;
.................... 
.................... 
.................... 	timers.now_millisecond=0;
*
2990:  BCF    xCF.2
.................... 
.................... 	/* set LED output */
.................... 	for ( i=0 ; i<2 ; i++ ) {
2992:  MOVLB  1
2994:  CLRF   x1B
2996:  MOVF   x1B,W
2998:  SUBLW  01
299A:  BTFSS  FD8.0
299C:  BRA    2A9C
.................... 		if ( 255 == timers.led_blink[i] ) {
299E:  CLRF   03
29A0:  MOVF   x1B,W
29A2:  ADDLW  D0
29A4:  MOVWF  FE9
29A6:  MOVLW  00
29A8:  ADDWFC 03,W
29AA:  MOVWF  FEA
29AC:  MOVF   FEF,W
29AE:  SUBLW  FF
29B0:  BNZ   29C0
.................... 			led_on(i);
29B2:  MOVFF  11B,11C
29B6:  MOVLB  0
29B8:  CALL   1978
.................... 		} else if ( 0 == timers.led_blink[i] ) {
29BC:  BRA    2A96
29BE:  MOVLB  1
29C0:  CLRF   03
29C2:  MOVF   x1B,W
29C4:  ADDLW  D0
29C6:  MOVWF  FE9
29C8:  MOVLW  00
29CA:  ADDWFC 03,W
29CC:  MOVWF  FEA
29CE:  MOVF   FEF,W
29D0:  BNZ   29E0
.................... 			led_off(i);
29D2:  MOVFF  11B,11C
29D6:  MOVLB  0
29D8:  CALL   198C
.................... 		} else {
29DC:  BRA    2A96
29DE:  MOVLB  1
.................... 			/* led_blink[i] is somewhere between 1 and 254 */
.................... 			if ( timers.led_on[i] > 0 ) {
29E0:  CLRF   03
29E2:  MOVF   x1B,W
29E4:  ADDLW  D2
29E6:  MOVWF  FE9
29E8:  MOVLW  00
29EA:  ADDWFC 03,W
29EC:  MOVWF  FEA
29EE:  MOVF   FEF,F
29F0:  BZ    2A32
.................... 				led_on(i);
29F2:  MOVFF  11B,11C
29F6:  MOVLB  0
29F8:  CALL   1978
.................... 				timers.led_on[i]--;
29FC:  CLRF   03
29FE:  MOVLB  1
2A00:  MOVF   x1B,W
2A02:  ADDLW  D2
2A04:  MOVWF  FE9
2A06:  MOVLW  00
2A08:  ADDWFC 03,W
2A0A:  MOVWF  FEA
2A0C:  DECF   FEF,F
.................... 
.................... 				if ( 0==timers.led_on[i] ) {
2A0E:  CLRF   03
2A10:  MOVF   x1B,W
2A12:  ADDLW  D2
2A14:  MOVWF  FE9
2A16:  MOVLW  00
2A18:  ADDWFC 03,W
2A1A:  MOVWF  FEA
2A1C:  MOVF   FEF,W
2A1E:  BNZ   2A32
.................... 					/* hit zero, switch to our off timer */
.................... 					timers.led_off[i]=BLINK_OFF_TIME;
2A20:  CLRF   03
2A22:  MOVF   x1B,W
2A24:  ADDLW  D4
2A26:  MOVWF  FE9
2A28:  MOVLW  00
2A2A:  ADDWFC 03,W
2A2C:  MOVWF  FEA
2A2E:  MOVLW  C8
2A30:  MOVWF  FEF
.................... 				}
.................... 			}
.................... 
.................... 			if ( timers.led_off[i] > 0 ) {
2A32:  CLRF   03
2A34:  MOVF   x1B,W
2A36:  ADDLW  D4
2A38:  MOVWF  FE9
2A3A:  MOVLW  00
2A3C:  ADDWFC 03,W
2A3E:  MOVWF  FEA
2A40:  MOVF   FEF,F
2A42:  BZ    2A94
.................... 				led_off(i);
2A44:  MOVFF  11B,11C
2A48:  MOVLB  0
2A4A:  CALL   198C
.................... 				timers.led_off[i]--;
2A4E:  CLRF   03
2A50:  MOVLB  1
2A52:  MOVF   x1B,W
2A54:  ADDLW  D4
2A56:  MOVWF  FE9
2A58:  MOVLW  00
2A5A:  ADDWFC 03,W
2A5C:  MOVWF  FEA
2A5E:  DECF   FEF,F
.................... 
.................... 				if ( 0==timers.led_off[i] ) {
2A60:  CLRF   03
2A62:  MOVF   x1B,W
2A64:  ADDLW  D4
2A66:  MOVWF  FE9
2A68:  MOVLW  00
2A6A:  ADDWFC 03,W
2A6C:  MOVWF  FEA
2A6E:  MOVF   FEF,W
2A70:  BNZ   2A94
.................... 					/* hit zero, preload for next */
.................... 					timers.led_on[i]=BLINK_ON_TIME;
2A72:  CLRF   03
2A74:  MOVF   x1B,W
2A76:  ADDLW  D2
2A78:  MOVWF  FE9
2A7A:  MOVLW  00
2A7C:  ADDWFC 03,W
2A7E:  MOVWF  FEA
2A80:  MOVLW  FE
2A82:  MOVWF  FEF
.................... 					/* done with this blink cycle */	
.................... 					timers.led_blink[i]--;
2A84:  CLRF   03
2A86:  MOVF   x1B,W
2A88:  ADDLW  D0
2A8A:  MOVWF  FE9
2A8C:  MOVLW  00
2A8E:  ADDWFC 03,W
2A90:  MOVWF  FEA
2A92:  DECF   FEF,F
2A94:  MOVLB  0
.................... 				}
.................... 			}
.................... 		}
2A96:  MOVLB  1
2A98:  INCF   x1B,F
2A9A:  BRA    2996
.................... 	}
.................... 
.................... 
.................... 	/* some other random stuff that we don't need to do every cycle in main */
.................... 	if ( current.interval_milliseconds < 65535 ) {
2A9C:  MOVLB  0
2A9E:  INCFSZ xC8,W
2AA0:  BRA    2AA8
2AA2:  INCFSZ xC9,W
2AA4:  BRA    2AA8
2AA6:  BRA    2AAE
.................... 		current.interval_milliseconds++;
2AA8:  INCF   xC8,F
2AAA:  BTFSC  FD8.2
2AAC:  INCF   xC9,F
.................... 	}
.................... 
.................... 
.................... 	/* contactor timeout */
.................... 	if ( 0 == timers.contactor_powersave[0] ) {
2AAE:  MOVF   xD8,F
2AB0:  BNZ   2ABC
.................... 		output_low(BRIDGE_A_A);
2AB2:  BCF    F94.3
2AB4:  BCF    F8B.3
.................... 		output_low(BRIDGE_A_B);
2AB6:  BCF    F94.4
2AB8:  BCF    F8B.4
.................... 	} else {
2ABA:  BRA    2ABE
.................... 		timers.contactor_powersave[0]--;
2ABC:  DECF   xD8,F
.................... 	}
.................... 	if ( 0 == timers.contactor_powersave[1] ) {
2ABE:  MOVF   xD9,F
2AC0:  BNZ   2ACC
.................... 		output_low(BRIDGE_B_A);
2AC2:  BCF    F94.5
2AC4:  BCF    F8B.5
.................... 		output_low(BRIDGE_B_B);
2AC6:  BCF    F94.6
2AC8:  BCF    F8B.6
.................... 	} else {
2ACA:  BRA    2ACE
.................... 		timers.contactor_powersave[1]--;
2ACC:  DECF   xD9,F
.................... 	}
.................... 
.................... 
.................... 
.................... 
.................... 	/* seconds */
.................... 	ticks++;
2ACE:  MOVLB  1
2AD0:  INCF   x16,F
2AD2:  BTFSC  FD8.2
2AD4:  INCF   x17,F
.................... 	if ( 1000 == ticks ) {
2AD6:  MOVF   x16,W
2AD8:  SUBLW  E8
2ADA:  BNZ   2B3C
2ADC:  MOVF   x17,W
2ADE:  SUBLW  03
2AE0:  BNZ   2B3C
.................... 		ticks=0;
2AE2:  CLRF   x17
2AE4:  CLRF   x16
.................... 
.................... 		/* set channe[n].state based on logic */
.................... 		contactor_logic(0);
2AE6:  CLRF   x1C
2AE8:  MOVLB  0
2AEA:  CALL   19A0
.................... 		contactor_logic(1);
2AEE:  MOVLW  01
2AF0:  MOVLB  1
2AF2:  MOVWF  x1C
2AF4:  MOVLB  0
2AF6:  CALL   19A0
.................... 
.................... 		/* set contactor outputs based on their state bit field */
.................... 		contactor_set(0);
2AFA:  MOVLB  1
2AFC:  CLRF   x1C
2AFE:  MOVLB  0
2B00:  RCALL  283C
.................... 		contactor_set(1);		
2B02:  MOVLW  01
2B04:  MOVLB  1
2B06:  MOVWF  x1C
2B08:  MOVLB  0
2B0A:  RCALL  283C
.................... 
.................... 		/* uptime counter */
.................... 		uptimeTicks++;
2B0C:  MOVLB  1
2B0E:  INCF   x12,F
.................... 		if ( 60 == uptimeTicks ) {
2B10:  MOVF   x12,W
2B12:  SUBLW  3C
2B14:  BNZ   2B2C
.................... 			uptimeTicks=0;
2B16:  CLRF   x12
.................... 			if ( current.uptime_minutes < 65535 ) 
2B18:  MOVLB  0
2B1A:  INCFSZ xC6,W
2B1C:  BRA    2B24
2B1E:  INCFSZ xC7,W
2B20:  BRA    2B24
2B22:  BRA    2B2A
.................... 				current.uptime_minutes++;
2B24:  INCF   xC6,F
2B26:  BTFSC  FD8.2
2B28:  INCF   xC7,F
2B2A:  MOVLB  1
.................... 		}
.................... 
.................... 		/* LED status update every 4 seconds */
.................... 		statusTicks++;
2B2C:  INCF   x13,F
.................... 		if ( 4 == statusTicks ) {
2B2E:  MOVF   x13,W
2B30:  SUBLW  04
2B32:  BNZ   2B3C
.................... 			/* LED state display update */
.................... 			statusTicks=0;
2B34:  CLRF   x13
.................... 			led_status_update();
2B36:  MOVLB  0
2B38:  BRA    28A0
2B3A:  MOVLB  1
.................... 		}
.................... 
.................... 
.................... 	}
.................... 
.................... 	/* ADC sample counter */
.................... 	if ( timers.now_adc_reset_count ) {
2B3C:  MOVLB  0
2B3E:  BTFSS  xCF.1
2B40:  BRA    2B4C
.................... 		timers.now_adc_reset_count=0;
2B42:  BCF    xCF.1
.................... 		adcTicks=0;
2B44:  MOVLB  1
2B46:  CLRF   x15
2B48:  CLRF   x14
2B4A:  MOVLB  0
.................... 	}
.................... 
.................... 	/* ADC sampling trigger */
.................... 	adcTicks++;
2B4C:  MOVLB  1
2B4E:  INCF   x14,F
2B50:  BTFSC  FD8.2
2B52:  INCF   x15,F
.................... 	if ( ADC_SAMPLE_TICKS == adcTicks ) {
2B54:  MOVF   x14,W
2B56:  SUBLW  14
2B58:  BNZ   2B68
2B5A:  MOVF   x15,F
2B5C:  BNZ   2B68
.................... 		adcTicks=0;
2B5E:  CLRF   x15
2B60:  CLRF   x14
.................... 		timers.now_adc_sample=1;
2B62:  MOVLB  0
2B64:  BSF    xCF.0
2B66:  MOVLB  1
.................... 	}
2B68:  MOVLB  0
2B6A:  GOTO   2F68 (RETURN)
.................... 
.................... }
.................... 
.................... void init(void) {
.................... 	int8 i;
.................... 	int8 buff[10];
.................... 	setup_oscillator(OSC_16MHZ);
*
10FE:  MOVLW  70
1100:  MOVWF  FD3
1102:  BCF    F9B.6
1104:  BCF    F9B.7
.................... 
.................... 	setup_adc(ADC_CLOCK_DIV_16);
1106:  MOVF   FC0,W
1108:  ANDLW  C0
110A:  IORLW  05
110C:  MOVWF  FC0
110E:  BSF    FC0.7
1110:  BSF    FC2.0
.................... 	/* NTC thermistor on sAN2, input voltage divider on sAN4, DIP switch analog on sAN9
.................... 	voltage spans between 0 and Vdd */
.................... 	setup_adc_ports(sAN2 | sAN4 | sAN9,VSS_VDD);
1112:  MOVLW  14
1114:  MOVWF  F7E
1116:  BCF    FC1.0
1118:  BCF    FC1.1
111A:  BCF    FC1.2
111C:  BCF    FC1.3
111E:  MOVLW  02
1120:  MOVWF  F7F
.................... 
.................... 	setup_wdt(WDT_512MS); /* forces the fuse to WDT128 */
1122:  BSF    FD1.0
.................... 
.................... 	set_tris_a(0b00111111);
1124:  MOVLW  3F
1126:  MOVWF  F92
.................... 	set_tris_b(0b01110000);
1128:  MOVLW  70
112A:  MOVWF  F93
.................... 	set_tris_c(0b10000001);
112C:  MOVLW  81
112E:  MOVWF  F94
.................... //               76543210
.................... 
.................... 	port_a_pullups(0b00110000);
1130:  MOVLW  30
1132:  MOVWF  F77
1134:  BCF    FF1.7
.................... 	port_b_pullups(0b00000000);
1136:  CLRF   F78
.................... //                   76543210
.................... 
.................... 	/* data structure initialization */
.................... 	/* all initialized to 0 on declaration. Just do this if need non-zero */
.................... 	for ( i=0 ; i<=1 ; i++ ) {
1138:  MOVLB  1
113A:  CLRF   x1B
113C:  MOVF   x1B,W
113E:  SUBLW  01
1140:  BNC   1196
.................... 		channel[i].command_off_seconds=65535;
1142:  MOVF   x1B,W
1144:  MULLW  19
1146:  MOVF   FF3,W
1148:  CLRF   x27
114A:  MOVWF  x26
114C:  MOVLW  05
114E:  ADDWF  x26,W
1150:  MOVWF  01
1152:  MOVLW  00
1154:  ADDWFC x27,W
1156:  MOVWF  03
1158:  MOVF   01,W
115A:  ADDLW  DA
115C:  MOVWF  FE9
115E:  MOVLW  00
1160:  ADDWFC 03,W
1162:  MOVWF  FEA
1164:  SETF   FEC
1166:  MOVF   FED,F
1168:  SETF   FEF
.................... 		channel[i].command_on_seconds =65535;
116A:  MOVF   x1B,W
116C:  MULLW  19
116E:  MOVF   FF3,W
1170:  CLRF   x27
1172:  MOVWF  x26
1174:  MOVLW  01
1176:  ADDWF  x26,W
1178:  MOVWF  01
117A:  MOVLW  00
117C:  ADDWFC x27,W
117E:  MOVWF  03
1180:  MOVF   01,W
1182:  ADDLW  DA
1184:  MOVWF  FE9
1186:  MOVLW  00
1188:  ADDWFC 03,W
118A:  MOVWF  FEA
118C:  SETF   FEC
118E:  MOVF   FED,F
1190:  SETF   FEF
1192:  INCF   x1B,F
1194:  BRA    113C
.................... 	}
.................... 
.................... 	/* get our compiled date from constant  
.................... 	'5-Feb-22'
.................... 	 01234567
.................... 
.................... 	'25-Feb-22'
.................... 	 012345678
.................... 	*/
.................... 	strcpy(buff,__DATE__);
1196:  MOVLW  01
1198:  MOVWF  FEA
119A:  MOVLW  1C
119C:  MOVWF  FE9
119E:  MOVLW  00
11A0:  MOVLB  0
11A2:  CALL   00BA
11A6:  TBLRD*-
11A8:  TBLRD*+
11AA:  MOVF   FF5,W
11AC:  MOVWF  FEE
11AE:  IORLW  00
11B0:  BNZ   11A8
.................... 	i=0;
11B2:  MOVLB  1
11B4:  CLRF   x1B
.................... 	if ( '-' != buff[1] ) {
11B6:  MOVF   x1D,W
11B8:  SUBLW  2D
11BA:  BZ    11DA
.................... 		/* day can be one or two digits */
.................... 		current.compile_day =(buff[i]-'0')*10;
11BC:  CLRF   03
11BE:  MOVF   x1B,W
11C0:  ADDLW  1C
11C2:  MOVWF  FE9
11C4:  MOVLW  01
11C6:  ADDWFC 03,W
11C8:  MOVWF  FEA
11CA:  MOVLW  30
11CC:  SUBWF  FEF,W
11CE:  MULLW  0A
11D0:  MOVFF  FF3,CD
11D4:  MOVLB  0
.................... 		i++;
11D6:  MOVLB  1
11D8:  INCF   x1B,F
.................... 	}
.................... 	current.compile_day+=(buff[i]-'0');
11DA:  CLRF   03
11DC:  MOVF   x1B,W
11DE:  ADDLW  1C
11E0:  MOVWF  FE9
11E2:  MOVLW  01
11E4:  ADDWFC 03,W
11E6:  MOVWF  FEA
11E8:  MOVLW  30
11EA:  SUBWF  FEF,W
11EC:  MOVLB  0
11EE:  ADDWF  xCD,F
.................... 	i+=2; /* now points to month */
11F0:  MOVLW  02
11F2:  MOVLB  1
11F4:  ADDWF  x1B,F
.................... 
.................... 	/* determine month ... how annoying */
.................... 	if ( 'J'==buff[i+0] ) {
11F6:  CLRF   03
11F8:  MOVF   x1B,W
11FA:  ADDLW  1C
11FC:  MOVWF  FE9
11FE:  MOVLW  01
1200:  ADDWFC 03,W
1202:  MOVWF  FEA
1204:  MOVF   FEF,W
1206:  SUBLW  4A
1208:  BNZ   1254
.................... 		if ( 'A'==buff[i+1] )
120A:  MOVLW  01
120C:  ADDWF  x1B,W
120E:  CLRF   03
1210:  ADDLW  1C
1212:  MOVWF  FE9
1214:  MOVLW  01
1216:  ADDWFC 03,W
1218:  MOVWF  FEA
121A:  MOVF   FEF,W
121C:  SUBLW  41
121E:  BNZ   122A
.................... 			current.compile_month=1;
1220:  MOVLW  01
1222:  MOVLB  0
1224:  MOVWF  xCC
1226:  BRA    1250
1228:  MOVLB  1
.................... 		else if ( 'N'==buff[i+2] )
122A:  MOVLW  02
122C:  ADDWF  x1B,W
122E:  CLRF   03
1230:  ADDLW  1C
1232:  MOVWF  FE9
1234:  MOVLW  01
1236:  ADDWFC 03,W
1238:  MOVWF  FEA
123A:  MOVF   FEF,W
123C:  SUBLW  4E
123E:  BNZ   124A
.................... 			current.compile_month=6;
1240:  MOVLW  06
1242:  MOVLB  0
1244:  MOVWF  xCC
1246:  BRA    1250
1248:  MOVLB  1
.................... 		else
.................... 			current.compile_month=7;
124A:  MOVLW  07
124C:  MOVLB  0
124E:  MOVWF  xCC
.................... 	} else if ( 'A'==buff[i+0] ) {
1250:  BRA    136A
1252:  MOVLB  1
1254:  CLRF   03
1256:  MOVF   x1B,W
1258:  ADDLW  1C
125A:  MOVWF  FE9
125C:  MOVLW  01
125E:  ADDWFC 03,W
1260:  MOVWF  FEA
1262:  MOVF   FEF,W
1264:  SUBLW  41
1266:  BNZ   1292
.................... 		if ( 'P'==buff[i+1] )
1268:  MOVLW  01
126A:  ADDWF  x1B,W
126C:  CLRF   03
126E:  ADDLW  1C
1270:  MOVWF  FE9
1272:  MOVLW  01
1274:  ADDWFC 03,W
1276:  MOVWF  FEA
1278:  MOVF   FEF,W
127A:  SUBLW  50
127C:  BNZ   1288
.................... 			current.compile_month=4;
127E:  MOVLW  04
1280:  MOVLB  0
1282:  MOVWF  xCC
1284:  BRA    128E
1286:  MOVLB  1
.................... 		else
.................... 			current.compile_month=8;
1288:  MOVLW  08
128A:  MOVLB  0
128C:  MOVWF  xCC
.................... 	} else if ( 'M'==buff[i+0] ) {
128E:  BRA    136A
1290:  MOVLB  1
1292:  CLRF   03
1294:  MOVF   x1B,W
1296:  ADDLW  1C
1298:  MOVWF  FE9
129A:  MOVLW  01
129C:  ADDWFC 03,W
129E:  MOVWF  FEA
12A0:  MOVF   FEF,W
12A2:  SUBLW  4D
12A4:  BNZ   12D0
.................... 		if ( 'R'==buff[i+2] )
12A6:  MOVLW  02
12A8:  ADDWF  x1B,W
12AA:  CLRF   03
12AC:  ADDLW  1C
12AE:  MOVWF  FE9
12B0:  MOVLW  01
12B2:  ADDWFC 03,W
12B4:  MOVWF  FEA
12B6:  MOVF   FEF,W
12B8:  SUBLW  52
12BA:  BNZ   12C6
.................... 			current.compile_month=3;
12BC:  MOVLW  03
12BE:  MOVLB  0
12C0:  MOVWF  xCC
12C2:  BRA    12CC
12C4:  MOVLB  1
.................... 		else
.................... 			current.compile_month=5;
12C6:  MOVLW  05
12C8:  MOVLB  0
12CA:  MOVWF  xCC
.................... 	} else if ( 'F'==buff[i+0] ) {
12CC:  BRA    136A
12CE:  MOVLB  1
12D0:  CLRF   03
12D2:  MOVF   x1B,W
12D4:  ADDLW  1C
12D6:  MOVWF  FE9
12D8:  MOVLW  01
12DA:  ADDWFC 03,W
12DC:  MOVWF  FEA
12DE:  MOVF   FEF,W
12E0:  SUBLW  46
12E2:  BNZ   12EE
.................... 		current.compile_month=2;
12E4:  MOVLW  02
12E6:  MOVLB  0
12E8:  MOVWF  xCC
.................... 	} else if ( 'S'==buff[i+0] ) {
12EA:  BRA    136A
12EC:  MOVLB  1
12EE:  CLRF   03
12F0:  MOVF   x1B,W
12F2:  ADDLW  1C
12F4:  MOVWF  FE9
12F6:  MOVLW  01
12F8:  ADDWFC 03,W
12FA:  MOVWF  FEA
12FC:  MOVF   FEF,W
12FE:  SUBLW  53
1300:  BNZ   130C
.................... 		current.compile_month=9;
1302:  MOVLW  09
1304:  MOVLB  0
1306:  MOVWF  xCC
.................... 	} else if ( 'O'==buff[i+0] ) {
1308:  BRA    136A
130A:  MOVLB  1
130C:  CLRF   03
130E:  MOVF   x1B,W
1310:  ADDLW  1C
1312:  MOVWF  FE9
1314:  MOVLW  01
1316:  ADDWFC 03,W
1318:  MOVWF  FEA
131A:  MOVF   FEF,W
131C:  SUBLW  4F
131E:  BNZ   132A
.................... 		current.compile_month=10;
1320:  MOVLW  0A
1322:  MOVLB  0
1324:  MOVWF  xCC
.................... 	} else if ( 'N'==buff[i+0] ) {
1326:  BRA    136A
1328:  MOVLB  1
132A:  CLRF   03
132C:  MOVF   x1B,W
132E:  ADDLW  1C
1330:  MOVWF  FE9
1332:  MOVLW  01
1334:  ADDWFC 03,W
1336:  MOVWF  FEA
1338:  MOVF   FEF,W
133A:  SUBLW  4E
133C:  BNZ   1348
.................... 		current.compile_month=11;
133E:  MOVLW  0B
1340:  MOVLB  0
1342:  MOVWF  xCC
.................... 	} else if ( 'D'==buff[i+0] ) {
1344:  BRA    136A
1346:  MOVLB  1
1348:  CLRF   03
134A:  MOVF   x1B,W
134C:  ADDLW  1C
134E:  MOVWF  FE9
1350:  MOVLW  01
1352:  ADDWFC 03,W
1354:  MOVWF  FEA
1356:  MOVF   FEF,W
1358:  SUBLW  44
135A:  BNZ   1366
.................... 		current.compile_month=12;
135C:  MOVLW  0C
135E:  MOVLB  0
1360:  MOVWF  xCC
.................... 	} else {
1362:  BRA    136A
1364:  MOVLB  1
.................... 		/* error parsing, shouldn't happen */
.................... 		current.compile_month=255;
1366:  MOVLB  0
1368:  SETF   xCC
.................... 	}
.................... 	current.compile_year =(buff[i+4]-'0')*10;
136A:  MOVLW  04
136C:  MOVLB  1
136E:  ADDWF  x1B,W
1370:  CLRF   03
1372:  ADDLW  1C
1374:  MOVWF  FE9
1376:  MOVLW  01
1378:  ADDWFC 03,W
137A:  MOVWF  FEA
137C:  MOVLW  30
137E:  SUBWF  FEF,W
1380:  MULLW  0A
1382:  MOVFF  FF3,CB
1386:  MOVLB  0
.................... 	current.compile_year+=(buff[i+5]-'0');
1388:  MOVLW  05
138A:  MOVLB  1
138C:  ADDWF  x1B,W
138E:  CLRF   03
1390:  ADDLW  1C
1392:  MOVWF  FE9
1394:  MOVLW  01
1396:  ADDWFC 03,W
1398:  MOVWF  FEA
139A:  MOVLW  30
139C:  SUBWF  FEF,W
139E:  MOVLB  0
13A0:  ADDWF  xCB,F
.................... 
.................... 
.................... 	/* one periodic interrupt @ 1mS. Generated from system 16 MHz clock */
.................... 	/* prescale=16, match=249, postscale=1. Match is 249 because when match occurs, one cycle is lost */
.................... 	setup_timer_2(T2_DIV_BY_16,249,1);
13A2:  MOVLW  00
13A4:  IORLW  06
13A6:  MOVWF  FCA
13A8:  MOVLW  F9
13AA:  MOVWF  FCB
.................... 
.................... 	enable_interrupts(INT_TIMER2);
13AC:  BSF    F9D.1
.................... 
.................... 	/* set I2C slave address, which is always an even number */
.................... 	i2c_slaveaddr(STREAM_SLAVE,0x3e + (read_dip_switch()<<1) );
13AE:  BRA    108C
13B0:  BCF    FD8.0
13B2:  RLCF   01,W
13B4:  ADDLW  3E
13B6:  MOVLB  1
13B8:  MOVWF  FC8
13BA:  MOVLB  0
13BC:  GOTO   2E18 (RETURN)
.................... }
.................... 
.................... 
.................... void main(void) {
*
2D8A:  CLRF   FF8
2D8C:  BCF    FD0.7
2D8E:  BSF    07.7
2D90:  BSF    F93.6
2D92:  BSF    F93.4
2D94:  CLRF   FC8
2D96:  MOVLW  36
2D98:  MOVWF  FC6
2D9A:  BSF    FC5.0
2D9C:  BSF    FC5.7
2D9E:  CLRF   1A
2DA0:  BSF    FB8.3
2DA2:  MOVLW  44
2DA4:  MOVWF  FAF
2DA6:  MOVLW  00
2DA8:  MOVWF  FB0
2DAA:  MOVLW  A6
2DAC:  MOVWF  FAC
2DAE:  MOVLW  90
2DB0:  MOVWF  FAB
2DB2:  MOVLB  1
2DB4:  CLRF   x19
2DB6:  CLRF   x18
2DB8:  MOVLW  00
2DBA:  MOVWF  F7E
2DBC:  BCF    FC1.0
2DBE:  BCF    FC1.1
2DC0:  BCF    FC1.2
2DC2:  BCF    FC1.3
2DC4:  MOVWF  F7F
2DC6:  CLRF   F6C
2DC8:  CLRF   F6B
2DCA:  CLRF   F6D
2DCC:  BRA    2DD4
2DCE:  DATA FD,40
2DD0:  DATA 1B,00
2DD2:  DATA 00,00
2DD4:  MOVLW  00
2DD6:  MOVWF  FF8
2DD8:  MOVLW  2D
2DDA:  MOVWF  FF7
2DDC:  MOVLW  CE
2DDE:  MOVWF  FF6
2DE0:  TBLRD*+
2DE2:  MOVF   FF5,W
2DE4:  MOVWF  00
2DE6:  XORLW  00
2DE8:  BZ    2E10
2DEA:  TBLRD*+
2DEC:  MOVF   FF5,W
2DEE:  MOVWF  01
2DF0:  BTFSC  FE8.7
2DF2:  BRA    2DFE
2DF4:  ANDLW  3F
2DF6:  MOVWF  FEA
2DF8:  TBLRD*+
2DFA:  MOVFF  FF5,FE9
2DFE:  BTFSC  01.6
2E00:  TBLRD*+
2E02:  BTFSS  01.6
2E04:  TBLRD*+
2E06:  MOVFF  FF5,FEE
2E0A:  DCFSNZ 00,F
2E0C:  BRA    2DE0
2E0E:  BRA    2E02
2E10:  CLRF   FF8
.................... 	int8 i;
.................... 
.................... 	init();
2E12:  MOVLB  0
2E14:  GOTO   10FE
.................... 
.................... 	/* force off both contactors */
.................... 	timers.contactor[0]=1;
2E18:  MOVLW  01
2E1A:  MOVWF  xD6
.................... 	timers.contactor[1]=1;
2E1C:  MOVWF  xD7
.................... 	contactor_off(0);
2E1E:  MOVLB  1
2E20:  CLRF   x1E
2E22:  MOVLB  0
2E24:  CALL   13C0
.................... 	contactor_off(1);
2E28:  MOVLW  01
2E2A:  MOVLB  1
2E2C:  MOVWF  x1E
2E2E:  MOVLB  0
2E30:  CALL   13C0
.................... 
.................... 
.................... 	/* read parameters from EEPROM and write defaults if CRC doesn't match */
.................... 	read_param_file();
2E34:  GOTO   1844
.................... 
.................... 
.................... 	/* flash on startup */
.................... 	for ( i=0 ; i<5 ; i++ ) {
2E38:  MOVLB  1
2E3A:  CLRF   x1A
2E3C:  MOVF   x1A,W
2E3E:  SUBLW  04
2E40:  BNC   2E68
.................... 		restart_wdt();
2E42:  CLRWDT
.................... 		output_high(LED_A);
2E44:  BCF    F94.1
2E46:  BSF    F8B.1
.................... 		delay_ms(200);
2E48:  MOVLW  C8
2E4A:  MOVWF  x28
2E4C:  MOVLB  0
2E4E:  CALL   1062
.................... 		output_low(LED_A);
2E52:  BCF    F94.1
2E54:  BCF    F8B.1
.................... 		delay_ms(200);
2E56:  MOVLW  C8
2E58:  MOVLB  1
2E5A:  MOVWF  x28
2E5C:  MOVLB  0
2E5E:  CALL   1062
2E62:  MOVLB  1
2E64:  INCF   x1A,F
2E66:  BRA    2E3C
.................... 	}
.................... 
.................... 	fprintf(STREAM_FTDI,"# dcswc_module_latching_contactor %s\r\n# ",__DATE__);
2E68:  MOVLW  B6
2E6A:  MOVWF  FF6
2E6C:  MOVLW  0F
2E6E:  MOVWF  FF7
2E70:  MOVLW  22
2E72:  MOVWF  x1D
2E74:  MOVLB  0
2E76:  CALL   188A
2E7A:  MOVLW  E0
2E7C:  MOVWF  FF6
2E7E:  MOVLW  0F
2E80:  MOVWF  FF7
2E82:  CALL   18B4
2E86:  MOVLW  DA
2E88:  MOVWF  FF6
2E8A:  MOVLW  0F
2E8C:  MOVWF  FF7
2E8E:  MOVLW  04
2E90:  MOVLB  1
2E92:  MOVWF  x1D
2E94:  MOVLB  0
2E96:  CALL   188A
.................... 	switch ( restart_cause ) {
2E9A:  MOVLW  07
2E9C:  SUBWF  00,W
2E9E:  BZ    2EC4
2EA0:  MOVLW  0B
2EA2:  SUBWF  00,W
2EA4:  BZ    2ED2
2EA6:  MOVLW  0F
2EA8:  SUBWF  00,W
2EAA:  BZ    2EE0
2EAC:  MOVLW  0C
2EAE:  SUBWF  00,W
2EB0:  BZ    2EEE
2EB2:  MOVLW  0E
2EB4:  SUBWF  00,W
2EB6:  BZ    2EFC
2EB8:  MOVLW  03
2EBA:  SUBWF  00,W
2EBC:  BZ    2F0A
2EBE:  MOVF   00,F
2EC0:  BZ    2F18
2EC2:  BRA    2F26
.................... 		case WDT_TIMEOUT:       fprintf(STREAM_FTDI,"WDT TIMEOUT"); break;
2EC4:  MOVLW  EA
2EC6:  MOVWF  FF6
2EC8:  MOVLW  0F
2ECA:  MOVWF  FF7
2ECC:  CALL   18B4
2ED0:  BRA    2F32
.................... 		case MCLR_FROM_SLEEP:   fprintf(STREAM_FTDI,"MCLR FROM SLEEP"); break;
2ED2:  MOVLW  F6
2ED4:  MOVWF  FF6
2ED6:  MOVLW  0F
2ED8:  MOVWF  FF7
2EDA:  CALL   18B4
2EDE:  BRA    2F32
.................... 		case MCLR_FROM_RUN:     fprintf(STREAM_FTDI,"MCLR FROM RUN"); break;
2EE0:  MOVLW  06
2EE2:  MOVWF  FF6
2EE4:  MOVLW  10
2EE6:  MOVWF  FF7
2EE8:  CALL   18B4
2EEC:  BRA    2F32
.................... 		case NORMAL_POWER_UP:   fprintf(STREAM_FTDI,"NORMAL POWER UP"); break;
2EEE:  MOVLW  14
2EF0:  MOVWF  FF6
2EF2:  MOVLW  10
2EF4:  MOVWF  FF7
2EF6:  CALL   18B4
2EFA:  BRA    2F32
.................... 		case BROWNOUT_RESTART:  fprintf(STREAM_FTDI,"BROWNOUT RESTART"); break;
2EFC:  MOVLW  24
2EFE:  MOVWF  FF6
2F00:  MOVLW  10
2F02:  MOVWF  FF7
2F04:  CALL   18B4
2F08:  BRA    2F32
.................... 		case WDT_FROM_SLEEP:    fprintf(STREAM_FTDI,"WDT FROM SLEEP"); break;
2F0A:  MOVLW  36
2F0C:  MOVWF  FF6
2F0E:  MOVLW  10
2F10:  MOVWF  FF7
2F12:  CALL   18B4
2F16:  BRA    2F32
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_FTDI,"RESET INSTRUCTION"); break;
2F18:  MOVLW  46
2F1A:  MOVWF  FF6
2F1C:  MOVLW  10
2F1E:  MOVWF  FF7
2F20:  CALL   18B4
2F24:  BRA    2F32
.................... 		default:                fprintf(STREAM_FTDI,"UNKNOWN!");
2F26:  MOVLW  58
2F28:  MOVWF  FF6
2F2A:  MOVLW  10
2F2C:  MOVWF  FF7
2F2E:  CALL   18B4
.................... 	}
.................... 	fprintf(STREAM_FTDI,"\r\n");
2F32:  MOVLW  0D
2F34:  BTFSS  F9E.4
2F36:  BRA    2F34
2F38:  MOVWF  FAD
2F3A:  MOVLW  0A
2F3C:  BTFSS  F9E.4
2F3E:  BRA    2F3C
2F40:  MOVWF  FAD
.................... 
.................... 	enable_interrupts(GLOBAL);
2F42:  MOVLW  C0
2F44:  IORWF  FF2,F
.................... 
.................... 	/* Prime ADC filter */
.................... 	for ( i=0 ; i<30 ; i++ ) {
2F46:  MOVLB  1
2F48:  CLRF   x1A
2F4A:  MOVF   x1A,W
2F4C:  SUBLW  1D
2F4E:  BNC   2F5C
.................... 		adc_update();
2F50:  MOVLB  0
2F52:  CALL   18D6
2F56:  MOVLB  1
2F58:  INCF   x1A,F
2F5A:  BRA    2F4A
.................... 	}
.................... 
.................... 
.................... 	/* enable I2C slave interrupt */
.................... 	enable_interrupts(INT_SSP);
2F5C:  BSF    F9D.3
.................... 
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
2F5E:  CLRWDT
.................... 
.................... 		if ( timers.now_millisecond ) {
2F60:  MOVLB  0
2F62:  BTFSS  xCF.2
2F64:  BRA    2F68
.................... 			periodic_millisecond();
2F66:  BRA    2990
.................... 		}
.................... 
.................... 		if ( kbhit() ) {
2F68:  BTFSS  F9E.5
2F6A:  BRA    2F70
.................... 			getc();
2F6C:  BRA    2B6E
.................... 			timers.now_debug_dump=1;
2F6E:  BSF    xCF.5
.................... 		}
.................... 
.................... 		if ( timers.now_debug_dump ) {
2F70:  BTFSS  xCF.5
2F72:  BRA    2F78
.................... 			timers.now_debug_dump=0;
2F74:  BCF    xCF.5
.................... 
.................... 			debug_dump();
2F76:  BRA    2C7E
.................... 		}
.................... 
.................... 		if ( timers.now_adc_sample ) {
2F78:  BTFSS  xCF.0
2F7A:  BRA    2F82
.................... 			timers.now_adc_sample=0;
2F7C:  BCF    xCF.0
.................... 			adc_update();
2F7E:  CALL   18D6
.................... 		}
.................... 
.................... 		if ( timers.now_write_config ) {
2F82:  BTFSS  xCF.3
2F84:  BRA    2F8C
.................... 			timers.now_write_config=0;
2F86:  BCF    xCF.3
.................... 			write_param_file();
2F88:  CALL   1532
.................... 		}
.................... 		if ( timers.now_reset_config ) {
2F8C:  BTFSS  xCF.4
2F8E:  BRA    2F96
.................... 			timers.now_reset_config=0;
2F90:  BCF    xCF.4
.................... 			write_default_param_file();
2F92:  CALL   157E
.................... 		}
2F96:  MOVLB  1
2F98:  BRA    2F5E
.................... 
.................... 
.................... 	}
.................... 
.................... 
.................... }
2F9A:  SLEEP 

Configuration Fuses:
   Word  1: 0800   INTRC_IO NOPLLEN NOPCLKEN NOFCMEN NOIESO
   Word  2: 0F07   NOPUT BROWNOUT BORV30 WDT WDT128
   Word  3: 0000   NOHFOFST NOMCLR
   Word  4: 0081   STVREN NOLVP BBSIZ1K NOXINST NODEBUG
   Word  5: C003   NOPROTECT NOCPB NOCPD
   Word  6: E003   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 4003   NOEBTR NOEBTRB

ROM data:
F00000: 00 00 40 00                                        ..@.
