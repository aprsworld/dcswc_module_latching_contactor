CCS PCH C Compiler, Version 5.090, 49113               14-Jan-22 16:42

               Filename:   C:\Users\James Jarvis\Desktop\planetPrecision\dcswc_module_latching_contactor\dcswc_module_latching_contactor.lst

               ROM used:   6508 bytes (42%)
                           Largest free fragment is 9044
               RAM used:   244 (48%) at main() level
                           283 (55%) worst case
               Stack used: 4 locations (2 in main + 2 for interrupts)
               Stack size: 30

0000:  GOTO   12F4
*
0008:  MOVWF  04
000A:  MOVFF  FD8,05
000E:  MOVFF  FE0,06
0012:  MOVLB  0
0014:  MOVFF  FE9,0C
0018:  MOVFF  FEA,07
001C:  MOVFF  FE1,08
0020:  MOVFF  FE2,09
0024:  MOVFF  FD9,0A
0028:  MOVFF  FDA,0B
002C:  MOVFF  FF3,12
0030:  MOVFF  FF4,13
0034:  MOVFF  FFA,14
0038:  MOVFF  FF5,15
003C:  MOVFF  FF6,16
0040:  MOVFF  FF7,17
0044:  MOVFF  00,0E
0048:  MOVFF  01,0F
004C:  MOVFF  02,10
0050:  MOVFF  03,11
0054:  BTFSS  F9D.1
0056:  GOTO   0060
005A:  BTFSC  F9E.1
005C:  GOTO   00D4
0060:  BTFSS  F9D.3
0062:  GOTO   006C
0066:  BTFSC  F9E.3
0068:  GOTO   0106
006C:  MOVFF  0E,00
0070:  MOVFF  0F,01
0074:  MOVFF  10,02
0078:  MOVFF  11,03
007C:  MOVFF  0C,FE9
0080:  MOVFF  07,FEA
0084:  BSF    07.7
0086:  MOVFF  08,FE1
008A:  MOVFF  09,FE2
008E:  MOVFF  0A,FD9
0092:  MOVFF  0B,FDA
0096:  MOVFF  12,FF3
009A:  MOVFF  13,FF4
009E:  MOVFF  14,FFA
00A2:  MOVFF  15,FF5
00A6:  MOVFF  16,FF6
00AA:  MOVFF  17,FF7
00AE:  MOVF   04,W
00B0:  MOVFF  06,FE0
00B4:  MOVFF  05,FD8
00B8:  RETFIE 0
.................... #include "dcswc_module_latching_contactor.h"
.................... #include <18F14K22.h>
.................... //////////// Standard Header file for the PIC18F14K22 device ////////////////
.................... ///////////////////////////////////////////////////////////////////////////
.................... ////        (C) Copyright 1996, 2014 Custom Computer Services          ////
.................... //// This source code may only be used by licensed users of the CCS C  ////
.................... //// compiler.  This source code may only be distributed to other      ////
.................... //// licensed users of the CCS C compiler.  No other use, reproduction ////
.................... //// or distribution is permitted without written permission.          ////
.................... //// Derivative programs created using this software in object code    ////
.................... //// form are not restricted in any way.                               ////
.................... ///////////////////////////////////////////////////////////////////////////
.................... #device PIC18F14K22
00BA:  CLRF   FF7
00BC:  ADDLW  CA
00BE:  MOVWF  FF6
00C0:  MOVLW  00
00C2:  ADDWFC FF7,F
00C4:  TBLRD*+
00C6:  MOVF   FF5,W
00C8:  RETURN 0
00CA:  DATA 31,34
00CC:  DATA 2D,4A
00CE:  DATA 61,6E
00D0:  DATA 2D,32
00D2:  DATA 32,00
*
01B0:  DATA 23,20
01B2:  DATA 64,63
01B4:  DATA 73,77
01B6:  DATA 63,5F
01B8:  DATA 6D,6F
01BA:  DATA 64,75
01BC:  DATA 6C,65
01BE:  DATA 5F,6C
01C0:  DATA 61,74
01C2:  DATA 63,68
01C4:  DATA 69,6E
01C6:  DATA 67,5F
01C8:  DATA 63,6F
01CA:  DATA 6E,74
01CC:  DATA 61,63
01CE:  DATA 74,6F
01D0:  DATA 72,20
01D2:  DATA 25,73
01D4:  DATA 0D,0A
01D6:  DATA 23,20
01D8:  DATA 00,00
01DA:  DATA 31,34
01DC:  DATA 2D,4A
01DE:  DATA 61,6E
01E0:  DATA 2D,32
01E2:  DATA 32,00
01E4:  DATA 57,44
01E6:  DATA 54,20
01E8:  DATA 54,49
01EA:  DATA 4D,45
01EC:  DATA 4F,55
01EE:  DATA 54,00
01F0:  DATA 4D,43
01F2:  DATA 4C,52
01F4:  DATA 20,46
01F6:  DATA 52,4F
01F8:  DATA 4D,20
01FA:  DATA 53,4C
01FC:  DATA 45,45
01FE:  DATA 50,00
0200:  DATA 4D,43
0202:  DATA 4C,52
0204:  DATA 20,46
0206:  DATA 52,4F
0208:  DATA 4D,20
020A:  DATA 52,55
020C:  DATA 4E,00
020E:  DATA 4E,4F
0210:  DATA 52,4D
0212:  DATA 41,4C
0214:  DATA 20,50
0216:  DATA 4F,57
0218:  DATA 45,52
021A:  DATA 20,55
021C:  DATA 50,00
021E:  DATA 42,52
0220:  DATA 4F,57
0222:  DATA 4E,4F
0224:  DATA 55,54
0226:  DATA 20,52
0228:  DATA 45,53
022A:  DATA 54,41
022C:  DATA 52,54
022E:  DATA 00,00
0230:  DATA 57,44
0232:  DATA 54,20
0234:  DATA 46,52
0236:  DATA 4F,4D
0238:  DATA 20,53
023A:  DATA 4C,45
023C:  DATA 45,50
023E:  DATA 00,00
0240:  DATA 52,45
0242:  DATA 53,45
0244:  DATA 54,20
0246:  DATA 49,4E
0248:  DATA 53,54
024A:  DATA 52,55
024C:  DATA 43,54
024E:  DATA 49,4F
0250:  DATA 4E,00
0252:  DATA 55,4E
0254:  DATA 4B,4E
0256:  DATA 4F,57
0258:  DATA 4E,21
025A:  DATA 00,00
025C:  DATA 23,20
025E:  DATA 72,65
0260:  DATA 61,64
0262:  DATA 5F,64
0264:  DATA 69,70
0266:  DATA 5F,73
0268:  DATA 77,69
026A:  DATA 74,63
026C:  DATA 68,28
026E:  DATA 29,3D
0270:  DATA 25,75
0272:  DATA 0D,0A
0274:  DATA 00,00
0276:  DATA 23,20
0278:  DATA 20,20
027A:  DATA 20,76
027C:  DATA 69,6E
027E:  DATA 20,61
0280:  DATA 64,63
0282:  DATA 3D,25
0284:  DATA 6C,75
0286:  DATA 0D,0A
0288:  DATA 00,00
028A:  DATA 23,20
028C:  DATA 20,20
028E:  DATA 74,65
0290:  DATA 6D,70
0292:  DATA 20,61
0294:  DATA 64,63
0296:  DATA 3D,25
0298:  DATA 6C,75
029A:  DATA 0D,0A
029C:  DATA 00,00
029E:  DATA 23,20
02A0:  DATA 64,69
02A2:  DATA 70,20
02A4:  DATA 73,77
02A6:  DATA 20,61
02A8:  DATA 64,63
02AA:  DATA 3D,25
02AC:  DATA 6C,75
02AE:  DATA 0D,0A
02B0:  DATA 00,00
02B2:  DATA 23,20
02B4:  DATA 63,68
02B6:  DATA 61,6E
02B8:  DATA 6E,65
02BA:  DATA 6C,5B
02BC:  DATA 25,75
02BE:  DATA 5D,0D
02C0:  DATA 0A,00
02C2:  DATA 23,20
02C4:  DATA 20,20
02C6:  DATA 20,20
02C8:  DATA 20,20
02CA:  DATA 20,20
02CC:  DATA 20,20
02CE:  DATA 20,20
02D0:  DATA 20,20
02D2:  DATA 20,20
02D4:  DATA 20,20
02D6:  DATA 20,20
02D8:  DATA 20,20
02DA:  DATA 20,73
02DC:  DATA 74,61
02DE:  DATA 74,65
02E0:  DATA 3D,30
02E2:  DATA 78,25
02E4:  DATA 30,32
02E6:  DATA 78,0D
02E8:  DATA 0A,00
02EA:  DATA 23,20
02EC:  DATA 20,20
02EE:  DATA 20,20
02F0:  DATA 20,20
02F2:  DATA 20,20
02F4:  DATA 20,20
02F6:  DATA 63,6F
02F8:  DATA 6D,6D
02FA:  DATA 61,6E
02FC:  DATA 64,5F
02FE:  DATA 6F,6E
0300:  DATA 5F,73
0302:  DATA 65,63
0304:  DATA 6F,6E
0306:  DATA 64,73
0308:  DATA 3D,25
030A:  DATA 6C,75
030C:  DATA 0D,0A
030E:  DATA 00,00
0310:  DATA 23,20
0312:  DATA 20,20
0314:  DATA 20,20
0316:  DATA 20,63
0318:  DATA 6F,6D
031A:  DATA 6D,61
031C:  DATA 6E,64
031E:  DATA 5F,6F
0320:  DATA 6E,5F
0322:  DATA 68,6F
0324:  DATA 6C,64
0326:  DATA 5F,73
0328:  DATA 65,63
032A:  DATA 6F,6E
032C:  DATA 64,73
032E:  DATA 3D,25
0330:  DATA 6C,75
0332:  DATA 0D,0A
0334:  DATA 00,00
0336:  DATA 23,20
0338:  DATA 20,20
033A:  DATA 20,20
033C:  DATA 20,20
033E:  DATA 20,20
0340:  DATA 20,63
0342:  DATA 6F,6D
0344:  DATA 6D,61
0346:  DATA 6E,64
0348:  DATA 5F,6F
034A:  DATA 66,66
034C:  DATA 5F,73
034E:  DATA 65,63
0350:  DATA 6F,6E
0352:  DATA 64,73
0354:  DATA 3D,25
0356:  DATA 6C,75
0358:  DATA 0D,0A
035A:  DATA 00,00
035C:  DATA 23,20
035E:  DATA 20,20
0360:  DATA 20,20
0362:  DATA 63,6F
0364:  DATA 6D,6D
0366:  DATA 61,6E
0368:  DATA 64,5F
036A:  DATA 6F,66
036C:  DATA 66,5F
036E:  DATA 68,6F
0370:  DATA 6C,64
0372:  DATA 5F,73
0374:  DATA 65,63
0376:  DATA 6F,6E
0378:  DATA 64,73
037A:  DATA 3D,25
037C:  DATA 6C,75
037E:  DATA 0D,0A
0380:  DATA 00,00
0382:  DATA 23,20
0384:  DATA 6C,76
0386:  DATA 64,5F
0388:  DATA 64,69
038A:  DATA 73,63
038C:  DATA 6F,6E
038E:  DATA 6E,65
0390:  DATA 63,74
0392:  DATA 5F,64
0394:  DATA 65,6C
0396:  DATA 61,79
0398:  DATA 5F,73
039A:  DATA 65,63
039C:  DATA 6F,6E
039E:  DATA 64,73
03A0:  DATA 3D,25
03A2:  DATA 6C,75
03A4:  DATA 0D,0A
03A6:  DATA 00,00
03A8:  DATA 23,20
03AA:  DATA 20,6C
03AC:  DATA 76,64
03AE:  DATA 5F,72
03B0:  DATA 65,63
03B2:  DATA 6F,6E
03B4:  DATA 6E,65
03B6:  DATA 63,74
03B8:  DATA 5F,64
03BA:  DATA 65,6C
03BC:  DATA 61,79
03BE:  DATA 5F,73
03C0:  DATA 65,63
03C2:  DATA 6F,6E
03C4:  DATA 64,73
03C6:  DATA 3D,25
03C8:  DATA 75,0D
03CA:  DATA 0A,00
03CC:  DATA 23,20
03CE:  DATA 68,76
03D0:  DATA 64,5F
03D2:  DATA 64,69
03D4:  DATA 73,63
03D6:  DATA 6F,6E
03D8:  DATA 6E,65
03DA:  DATA 63,74
03DC:  DATA 5F,64
03DE:  DATA 65,6C
03E0:  DATA 61,79
03E2:  DATA 5F,73
03E4:  DATA 65,63
03E6:  DATA 6F,6E
03E8:  DATA 64,73
03EA:  DATA 3D,25
03EC:  DATA 6C,75
03EE:  DATA 0D,0A
03F0:  DATA 00,00
03F2:  DATA 23,20
03F4:  DATA 20,68
03F6:  DATA 76,64
03F8:  DATA 5F,72
03FA:  DATA 65,63
03FC:  DATA 6F,6E
03FE:  DATA 6E,65
0400:  DATA 63,74
0402:  DATA 5F,64
0404:  DATA 65,6C
0406:  DATA 61,79
0408:  DATA 5F,73
040A:  DATA 65,63
040C:  DATA 6F,6E
040E:  DATA 64,73
0410:  DATA 3D,25
0412:  DATA 75,0D
0414:  DATA 0A,00
*
08C6:  TBLRD*+
08C8:  MOVFF  FF6,F5
08CC:  MOVFF  FF7,F6
08D0:  MOVF   FF5,W
08D2:  BTFSS  F9E.4
08D4:  BRA    08D2
08D6:  MOVWF  FAD
08D8:  MOVFF  F5,FF6
08DC:  MOVFF  F6,FF7
08E0:  DECFSZ xF4,F
08E2:  BRA    08C6
08E4:  RETURN 0
08E6:  TBLRD*+
08E8:  MOVF   FF5,F
08EA:  BZ    0906
08EC:  MOVFF  FF6,F1
08F0:  MOVFF  FF7,F2
08F4:  MOVF   FF5,W
08F6:  BTFSS  F9E.4
08F8:  BRA    08F6
08FA:  MOVWF  FAD
08FC:  MOVFF  F1,FF6
0900:  MOVFF  F2,FF7
0904:  BRA    08E6
0906:  RETURN 0
*
1110:  MOVF   xF5,W
1112:  CLRF   01
1114:  SUBWF  xF4,W
1116:  BC    111E
1118:  MOVFF  F4,00
111C:  BRA    1136
111E:  CLRF   00
1120:  MOVLW  08
1122:  MOVWF  xF6
1124:  RLCF   xF4,F
1126:  RLCF   00,F
1128:  MOVF   xF5,W
112A:  SUBWF  00,W
112C:  BTFSC  FD8.0
112E:  MOVWF  00
1130:  RLCF   01,F
1132:  DECFSZ xF6,F
1134:  BRA    1124
1136:  RETURN 0
1138:  MOVF   01,W
113A:  MOVFF  F2,F4
113E:  MOVLW  64
1140:  MOVWF  xF5
1142:  RCALL  1110
1144:  MOVFF  00,F2
1148:  MOVF   01,W
114A:  MOVLW  30
114C:  BNZ   115C
114E:  BTFSS  xF3.1
1150:  BRA    116C
1152:  BTFSC  xF3.3
1154:  BRA    116C
1156:  BTFSC  xF3.4
1158:  MOVLW  20
115A:  BRA    1162
115C:  BCF    xF3.3
115E:  BCF    xF3.4
1160:  BSF    xF3.0
1162:  ADDWF  01,F
1164:  MOVF   01,W
1166:  BTFSS  F9E.4
1168:  BRA    1166
116A:  MOVWF  FAD
116C:  MOVFF  F2,F4
1170:  MOVLW  0A
1172:  MOVWF  xF5
1174:  RCALL  1110
1176:  MOVFF  00,F2
117A:  MOVF   01,W
117C:  MOVLW  30
117E:  BNZ   118C
1180:  BTFSC  xF3.3
1182:  BRA    1196
1184:  BTFSS  xF3.0
1186:  BRA    1196
1188:  BTFSC  xF3.4
118A:  MOVLW  20
118C:  ADDWF  01,F
118E:  MOVF   01,W
1190:  BTFSS  F9E.4
1192:  BRA    1190
1194:  MOVWF  FAD
1196:  MOVLW  30
1198:  ADDWF  xF2,F
119A:  MOVF   xF2,W
119C:  BTFSS  F9E.4
119E:  BRA    119C
11A0:  MOVWF  FAD
11A2:  RETURN 0
11A4:  MOVFF  FEA,FB
11A8:  MOVFF  FE9,FA
11AC:  SWAPF  xF4,W
11AE:  IORLW  F0
11B0:  MOVWF  xF6
11B2:  ADDWF  xF6,F
11B4:  ADDLW  E2
11B6:  MOVWF  xF7
11B8:  ADDLW  32
11BA:  MOVWF  xF9
11BC:  MOVF   xF4,W
11BE:  ANDLW  0F
11C0:  ADDWF  xF7,F
11C2:  ADDWF  xF7,F
11C4:  ADDWF  xF9,F
11C6:  ADDLW  E9
11C8:  MOVWF  xF8
11CA:  ADDWF  xF8,F
11CC:  ADDWF  xF8,F
11CE:  SWAPF  xF3,W
11D0:  ANDLW  0F
11D2:  ADDWF  xF8,F
11D4:  ADDWF  xF9,F
11D6:  RLCF   xF8,F
11D8:  RLCF   xF9,F
11DA:  COMF   xF9,F
11DC:  RLCF   xF9,F
11DE:  MOVF   xF3,W
11E0:  ANDLW  0F
11E2:  ADDWF  xF9,F
11E4:  RLCF   xF6,F
11E6:  MOVLW  07
11E8:  MOVWF  xF5
11EA:  MOVLW  0A
11EC:  DECF   xF8,F
11EE:  ADDWF  xF9,F
11F0:  BNC   11EC
11F2:  DECF   xF7,F
11F4:  ADDWF  xF8,F
11F6:  BNC   11F2
11F8:  DECF   xF6,F
11FA:  ADDWF  xF7,F
11FC:  BNC   11F8
11FE:  DECF   xF5,F
1200:  ADDWF  xF6,F
1202:  BNC   11FE
1204:  CLRF   FEA
1206:  MOVLW  F5
1208:  MOVWF  FE9
120A:  MOVLW  07
120C:  ANDWF  xFA,W
120E:  BCF    xFA.6
1210:  ADDWF  FE9,F
1212:  MOVLW  00
1214:  ADDWFC FEA,F
1216:  MOVF   FE9,W
1218:  SUBLW  F9
121A:  BNZ   1222
121C:  MOVF   FEA,F
121E:  BNZ   1222
1220:  BSF    xFA.6
1222:  MOVF   FEF,W
1224:  MOVWF  00
1226:  BNZ   1238
1228:  BTFSC  xFA.6
122A:  BRA    1238
122C:  BTFSC  xFA.4
122E:  BRA    1248
1230:  BTFSC  xFA.3
1232:  BRA    1238
1234:  MOVLW  20
1236:  BRA    123E
1238:  BSF    xFA.3
123A:  BCF    xFA.4
123C:  MOVLW  30
123E:  ADDWF  00,F
1240:  MOVF   00,W
1242:  BTFSS  F9E.4
1244:  BRA    1242
1246:  MOVWF  FAD
1248:  MOVF   FEE,W
124A:  BTFSS  xFA.6
124C:  BRA    1216
124E:  RETURN 0
1250:  BTFSC  xF5.7
1252:  BRA    1274
1254:  MOVLW  0F
1256:  MOVWF  00
1258:  SWAPF  xF4,W
125A:  ANDWF  00,F
125C:  MOVLW  0A
125E:  SUBWF  00,W
1260:  BC    1268
1262:  MOVLW  30
1264:  ADDWF  00,F
1266:  BRA    126C
1268:  MOVF   xF5,W
126A:  ADDWF  00,F
126C:  MOVF   00,W
126E:  BTFSS  F9E.4
1270:  BRA    126E
1272:  MOVWF  FAD
1274:  MOVLW  0F
1276:  ANDWF  xF4,F
1278:  MOVLW  0A
127A:  SUBWF  xF4,W
127C:  BC    1282
127E:  MOVLW  30
1280:  BRA    1286
1282:  BCF    xF5.7
1284:  MOVF   xF5,W
1286:  ADDWF  xF4,F
1288:  MOVF   xF4,W
128A:  BTFSS  F9E.4
128C:  BRA    128A
128E:  MOVWF  FAD
1290:  GOTO   1632 (RETURN)
.................... 
.................... #list
.................... 
.................... #device ADC=10
.................... #device *=16
.................... #use delay(clock=16MHz)
*
0416:  MOVLW  01
0418:  MOVWF  FEA
041A:  MOVLW  13
041C:  MOVWF  FE9
041E:  MOVF   FEF,W
0420:  BZ    043E
0422:  MOVLW  05
0424:  MOVWF  01
0426:  CLRF   00
0428:  DECFSZ 00,F
042A:  BRA    0428
042C:  DECFSZ 01,F
042E:  BRA    0426
0430:  MOVLW  2E
0432:  MOVWF  00
0434:  DECFSZ 00,F
0436:  BRA    0434
0438:  BRA    043A
043A:  DECFSZ FEF,F
043C:  BRA    0422
043E:  RETURN 0
.................... 
.................... /* hardware I2C port is slave and is connected to DCSWC bus */
.................... #use i2c(stream=STREAM_SLAVE,SLAVE, I2C1, FORCE_HW)
*
00F0:  MOVF   FC9,W
00F2:  MOVFF  117,FC9
00F6:  BSF    FC6.4
00F8:  BCF    F9E.3
00FA:  BTFSC  FC7.0
00FC:  BRA    00FA
00FE:  CLRF   01
0100:  BTFSS  FC5.6
0102:  INCF   01,F
0104:  RETURN 0
.................... /* slave address set based on dip switch in init() */
.................... 
.................... 
.................... #fuses INTRC_IO
.................... #fuses NOPLLEN
.................... #fuses NOFCMEN
.................... #fuses NOIESO
.................... #fuses PUT
.................... #fuses BROWNOUT
.................... #fuses WDT512
.................... #fuses NOHFOFST
.................... #fuses NOMCLR
.................... #fuses STVREN
.................... #fuses NOLVP
.................... #fuses NOXINST
.................... #fuses NODEBUG
.................... #fuses NOPROTECT
.................... #fuses NOWRT
.................... #fuses NOWRTC 
.................... #fuses NOWRTB
.................... #fuses NOWRTD
.................... #fuses NOEBTR
.................... #fuses NOEBTRB
.................... 
.................... #use standard_io(ALL)
.................... 
.................... #use rs232(UART1,stream=STREAM_FTDI,baud=9600,errors)	
*
10F8:  BTFSS  F9E.5
10FA:  BRA    10F8
10FC:  MOVFF  FAB,19
1100:  MOVFF  FAE,01
1104:  BTFSS  19.1
1106:  BRA    110C
1108:  BCF    FAB.4
110A:  BSF    FAB.4
110C:  GOTO   14DE (RETURN)
.................... 
.................... /* program config CRC of 0 and a serial_prefix of 'A' ... that will trigger a write default on first boot */
.................... #ROM 0xF00000 = { 0x00, 0x00, 0x40, 0x00 }
.................... 
.................... 
.................... 
.................... 
.................... #define SW_OVERRIDE_A        PIN_A5
.................... #define SW_OVERRIDE_B        PIN_A4
.................... #define BRIDGE_B_A           PIN_C5
.................... #define BRIDGE_A_B           PIN_C4
.................... #define BRIDGE_A_A           PIN_C3
.................... #define BRIDGE_B_B           PIN_C6
.................... #define AN_DIP               PIN_C7
.................... #define SER_TO_PC            PIN_B7
.................... #define AN_VTEMP             PIN_A2
.................... #define AN_IN_VOLTS          PIN_C0
.................... #define LED_A                PIN_C1
.................... #define LED_B                PIN_C2
.................... #define I2C_SDA              PIN_B4
.................... #define SER_FROM_PC          PIN_B5
.................... #define I2C_SCL              PIN_B6
.................... 
.................... 
.................... /* 
.................... Parameters are stored in EEPROM
.................... */
.................... #define PARAM_CRC_ADDRESS  0x00
.................... #define PARAM_ADDRESS      PARAM_CRC_ADDRESS+2
.................... 
.................... 
.................... 
.................... /* bit positions for a channel state byte */
.................... #define CH_STATE_BIT_FUTURE   7  /* reserved for future use */
.................... #define CH_STATE_BIT_HTD      6  /* high temperature disconnect */
.................... #define CH_STATE_BIT_LTD      5  /* low temperature disconnect */
.................... #define CH_STATE_BIT_HVD      4  /* high voltage disconnect */
.................... #define CH_STATE_BIT_LVD      3  /* low voltage disconnect */
.................... #define CH_STATE_BIT_CMD_OFF  2  /* commanded off */
.................... #define CH_STATE_BIT_CMD_ON   1  /* commanded on (takes presedence over commanded off) */
.................... #define CH_STATE_BIT_OVERRIDE 0  /* override switch */
....................       
.................... 
.................... 
.................... #define CONTACTOR_POWER_SAVE_MS       200 /* milliseconds for contactor be on. Must be >0 and <= 255 */
.................... 
.................... 
.................... typedef struct {
.................... 	/* low voltage disconnect */
.................... 	int16 lvd_disconnect_adc;
.................... 	int16 lvd_disconnect_delay;
.................... 	int16 lvd_reconnect_adc;
.................... 
.................... 	/* high voltage disconnect */
.................... 	int16 hvd_disconnect_adc;
.................... 	int16 hvd_disconnect_delay;
.................... 	int16 hvd_reconnect_adc;
.................... 
.................... 	/* low temperature disconnect */
.................... 	int16 ltd_disconnect_adc;
.................... 	int16 ltd_disconnect_delay;
.................... 	int16 ltd_reconnect_adc;
.................... 
.................... 	/* high voltage disconnect */
.................... 	int16 htd_disconnect_adc;
.................... 	int16 htd_disconnect_delay;
.................... 	int16 htd_reconnect_adc;
.................... } struct_config_channel;
.................... 
.................... typedef struct {
.................... 	int16 adc_sample_ticks;
.................... 
.................... 	int16 startup_power_on_delay;
.................... 	int8 reconnect_delay;
.................... 
.................... 	int16 command_off_hold_time;
.................... 	int16 command_on_hold_time;
.................... 
.................... 	struct_config_channel ch[2];
.................... } struct_config;
.................... 
.................... 
.................... typedef struct {
.................... 	int8 state;
.................... 
.................... 	int16 command_on_seconds;			/* counts down. Off at zero. */
.................... 	int16 command_on_hold_seconds;      /* counts down. Off at zero. */
.................... 
.................... 	int16 command_off_seconds;			/* counts down. Off at zero. */
.................... 	int16 command_off_hold_seconds;     /* counts down. Off at zero. */
.................... 
.................... 	int16 lvd_disconnect_delay_seconds;	/* counts down */
.................... 	int8  lvd_reconnect_delay_seconds;	/* counts down */
.................... 
.................... 	int16 hvd_disconnect_delay_seconds;	/* counts down */
.................... 	int8  hvd_reconnect_delay_seconds;	/* counts down */
.................... } struct_channel;
.................... 
.................... typedef struct {
.................... 	/* circular buffer for ADC readings */
.................... 	int16 adc_buffer[3][16];
.................... 	int8  adc_buffer_index;
.................... 
.................... 	int16 sequence_number;
.................... 	int16 uptime_minutes;
.................... 	int16 interval_milliseconds;
.................... 
.................... 	int8 factory_unlocked;
.................... 
.................... 
.................... 	int8 compile_year;
.................... 	int8 compile_month;
.................... 	int8 compile_day;
.................... 
.................... 
.................... 	int8 default_params_written;
.................... } struct_current;
.................... 
.................... typedef struct {
.................... 	/* action flags */
.................... 	int1 now_adc_sample;
.................... 	int1 now_adc_reset_count;
.................... 
.................... 	int1 now_millisecond;
.................... 
.................... 	int1 now_write_config;
.................... 	int1 now_reset_config;
.................... 
.................... 	/* contactor states */
.................... 	int1 contactor_a;
.................... 	int1 contactor_b;
.................... 
.................... 	/* timers */
.................... 	int8 led_on_a;
.................... 	int8 led_on_b;
.................... 
.................... 	int8  contactor_a_powersave;        /* counts down. Off at zero. */
.................... 	int8  contactor_b_powersave;        /* counts down. Off at zero. */
.................... 
.................... 
.................... 
.................... } struct_time_keep;
.................... 
.................... /* global structures */
.................... struct_config config={0};
.................... struct_current current={0};
.................... struct_time_keep timers={0};
.................... struct_channel channel[2]={0};
.................... 
.................... #include "adc_dcswc_module_latching_contactor.c"
.................... // const int8 adcChannelMap[8]={AN_IN_VOLTS, AN_TEMPERATURE, AN_WIND_DIR_0, AN_WIND_DIR_1, AN_USER_USER_0, AN_USER_USER_1, AN_USER_USER_2, AN_USER_USER_3};
.................... 
.................... int16 adc_get(int8 ch) {
.................... 	int16 sum;
.................... 	int8 i;
.................... 
.................... 	/* pre-compute address of channel adc buffer. Saves computing it 16 times in the loop below */
.................... 	int16 *p;
.................... 	p = current.adc_buffer[ch];
*
09A6:  MOVF   xF4,W
09A8:  MULLW  20
09AA:  MOVF   FF3,W
09AC:  CLRF   03
09AE:  ADDLW  53
09B0:  MOVWF  01
09B2:  MOVLW  00
09B4:  ADDWFC 03,F
09B6:  MOVFF  01,F8
09BA:  MOVFF  03,F9
.................... 
.................... 	// Calculate the mean.  This is done by summing up the
.................... 	// values and dividing by the number of elements.
.................... 	sum = 0;
09BE:  CLRF   xF6
09C0:  CLRF   xF5
.................... 	for( i = 0; i < 16 ; i++ ) {
09C2:  CLRF   xF7
09C4:  MOVF   xF7,W
09C6:  SUBLW  0F
09C8:  BNC   09F4
.................... //		sum += current.adc_buffer[ch][i];
.................... 		sum += p[i];
09CA:  CLRF   03
09CC:  MOVFF  F7,02
09D0:  BCF    FD8.0
09D2:  RLCF   02,F
09D4:  RLCF   03,F
09D6:  MOVF   02,W
09D8:  ADDWF  xF8,W
09DA:  MOVWF  FE9
09DC:  MOVF   xF9,W
09DE:  ADDWFC 03,W
09E0:  MOVWF  FEA
09E2:  MOVFF  FEC,03
09E6:  MOVF   FED,F
09E8:  MOVF   FEF,W
09EA:  ADDWF  xF5,F
09EC:  MOVF   03,W
09EE:  ADDWFC xF6,F
09F0:  INCF   xF7,F
09F2:  BRA    09C4
.................... 	}
.................... 
.................... 	/* divide sum by our 16 samples and round by adding 8 */
.................... 	return ( (sum+8) >> 4 );
09F4:  MOVLW  08
09F6:  ADDWF  xF5,W
09F8:  MOVWF  xFA
09FA:  MOVLW  00
09FC:  ADDWFC xF6,W
09FE:  MOVWF  xFB
0A00:  RRCF   xFB,W
0A02:  MOVWF  03
0A04:  RRCF   xFA,W
0A06:  MOVWF  02
0A08:  RRCF   03,F
0A0A:  RRCF   02,F
0A0C:  RRCF   03,F
0A0E:  RRCF   02,F
0A10:  RRCF   03,F
0A12:  RRCF   02,F
0A14:  MOVLW  0F
0A16:  ANDWF  03,F
0A18:  MOVFF  02,01
0A1C:  MOVFF  03,02
0A20:  RETURN 0
.................... }
.................... 
.................... 
.................... void adc_update(void) {
.................... 
.................... 	/* wrap buffer around */
.................... 	current.adc_buffer_index++;
*
0908:  INCF   xB3,F
.................... 	if ( current.adc_buffer_index >= 16 )
090A:  MOVF   xB3,W
090C:  SUBLW  0F
090E:  BC    0912
.................... 		current.adc_buffer_index=0;
0910:  CLRF   xB3
.................... 
.................... 	set_adc_channel(4);
0912:  MOVLW  10
0914:  MOVWF  01
0916:  MOVF   FC2,W
0918:  ANDLW  C3
091A:  IORWF  01,W
091C:  MOVWF  FC2
.................... 	current.adc_buffer[0][current.adc_buffer_index] = read_adc();
091E:  BCF    FD8.0
0920:  RLCF   xB3,W
0922:  CLRF   03
0924:  ADDLW  53
0926:  MOVWF  FE9
0928:  MOVLW  00
092A:  ADDWFC 03,W
092C:  MOVWF  FEA
092E:  BSF    FC2.1
0930:  BTFSC  FC2.1
0932:  BRA    0930
0934:  MOVFF  FC3,FEF
0938:  MOVFF  FC4,FEC
.................... 
.................... 
.................... 	set_adc_channel(2);
093C:  MOVLW  08
093E:  MOVWF  01
0940:  MOVF   FC2,W
0942:  ANDLW  C3
0944:  IORWF  01,W
0946:  MOVWF  FC2
.................... 	delay_ms(1);
0948:  MOVLW  01
094A:  MOVLB  1
094C:  MOVWF  x13
094E:  MOVLB  0
0950:  RCALL  0416
.................... 	current.adc_buffer[1][current.adc_buffer_index] = read_adc();
0952:  BCF    FD8.0
0954:  RLCF   xB3,W
0956:  CLRF   03
0958:  ADDLW  73
095A:  MOVWF  FE9
095C:  MOVLW  00
095E:  ADDWFC 03,W
0960:  MOVWF  FEA
0962:  BSF    FC2.1
0964:  BTFSC  FC2.1
0966:  BRA    0964
0968:  MOVFF  FC3,FEF
096C:  MOVFF  FC4,FEC
.................... 
.................... 	set_adc_channel(9);
0970:  MOVLW  24
0972:  MOVWF  01
0974:  MOVF   FC2,W
0976:  ANDLW  C3
0978:  IORWF  01,W
097A:  MOVWF  FC2
.................... 	delay_ms(1);
097C:  MOVLW  01
097E:  MOVLB  1
0980:  MOVWF  x13
0982:  MOVLB  0
0984:  RCALL  0416
.................... 	current.adc_buffer[2][current.adc_buffer_index] = read_adc();
0986:  BCF    FD8.0
0988:  RLCF   xB3,W
098A:  CLRF   03
098C:  ADDLW  93
098E:  MOVWF  FE9
0990:  MOVLW  00
0992:  ADDWFC 03,W
0994:  MOVWF  FEA
0996:  BSF    FC2.1
0998:  BTFSC  FC2.1
099A:  BRA    0998
099C:  MOVFF  FC3,FEF
09A0:  MOVFF  FC4,FEC
09A4:  RETURN 0
.................... }
.................... 
.................... #include "param_dcswc_module_latching_contactor.c"
.................... #inline
.................... char xor_crc(char oldcrc, char data) {
.................... 	return oldcrc ^ data;
*
0646:  MOVF   xFE,W
0648:  XORWF  xFF,W
064A:  MOVWF  01
*
0690:  MOVF   xFE,W
0692:  XORWF  xFF,W
0694:  MOVWF  01
.................... }
.................... 
.................... char EEPROMDataRead( int16 address, int8 *data, int16 count ) {
*
05E0:  CLRF   xFA
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
05E2:  MOVFF  F9,FC
05E6:  MOVF   xF8,W
05E8:  BTFSC  FD8.2
05EA:  DECF   xF9,F
05EC:  DECF   xF8,F
05EE:  MOVWF  xFB
05F0:  MOVF   xFB,F
05F2:  BNZ   05F8
05F4:  MOVF   xFC,F
05F6:  BZ    0658
.................... 		*data = read_eeprom( address++ );
05F8:  MOVFF  F7,03
05FC:  MOVF   xF6,W
05FE:  MOVWF  FE9
0600:  MOVFF  03,FEA
0604:  MOVF   xF5,W
0606:  MOVWF  03
0608:  MOVF   xF4,W
060A:  INCF   xF4,F
060C:  BTFSC  FD8.2
060E:  INCF   xF5,F
0610:  MOVWF  xFD
0612:  MOVFF  03,FE
0616:  MOVFF  FF2,FF
061A:  BCF    FF2.7
061C:  MOVFF  FD,FA9
0620:  BCF    FA6.6
0622:  BCF    FA6.7
0624:  BSF    FA6.0
0626:  MOVF   FA8,W
0628:  BTFSC  xFF.7
062A:  BSF    FF2.7
062C:  MOVWF  FEF
.................... 		crc = xor_crc(crc,*data);
062E:  MOVFF  F7,03
0632:  MOVF   xF6,W
0634:  MOVWF  FE9
0636:  MOVFF  03,FEA
063A:  MOVFF  FEF,FB
063E:  MOVFF  FA,FE
0642:  MOVFF  FB,FF
*
064C:  MOVFF  01,FA
.................... 		data++;
0650:  INCF   xF6,F
0652:  BTFSC  FD8.2
0654:  INCF   xF7,F
0656:  BRA    05E2
.................... 	}
.................... 	return crc;
0658:  MOVFF  FA,01
065C:  GOTO   08A4 (RETURN)
.................... }
.................... 
.................... char EEPROMDataWrite( int16 address, int8 *data, int16 count ) {
0660:  CLRF   xFC
.................... 	char crc=0;
.................... 
.................... 	while ( count-- != 0 ) {
0662:  MOVFF  FB,FE
0666:  MOVF   xFA,W
0668:  BTFSC  FD8.2
066A:  DECF   xFB,F
066C:  DECF   xFA,F
066E:  MOVWF  xFD
0670:  MOVF   xFD,F
0672:  BNZ   0678
0674:  MOVF   xFE,F
0676:  BZ    06F0
.................... 		/* restart_wdt() */
.................... 		crc = xor_crc(crc,*data);
0678:  MOVFF  F9,03
067C:  MOVF   xF8,W
067E:  MOVWF  FE9
0680:  MOVFF  03,FEA
0684:  MOVFF  FEF,FD
0688:  MOVFF  FC,FE
068C:  MOVFF  FD,FF
*
0696:  MOVFF  01,FC
.................... 		write_eeprom( address++, *data++ );
069A:  MOVF   xF7,W
069C:  MOVWF  03
069E:  MOVF   xF6,W
06A0:  INCF   xF6,F
06A2:  BTFSC  FD8.2
06A4:  INCF   xF7,F
06A6:  MOVWF  xFD
06A8:  MOVFF  03,FE
06AC:  MOVF   xF9,W
06AE:  MOVWF  03
06B0:  MOVF   xF8,W
06B2:  INCF   xF8,F
06B4:  BTFSC  FD8.2
06B6:  INCF   xF9,F
06B8:  MOVWF  FE9
06BA:  MOVFF  03,FEA
06BE:  MOVFF  FEF,FF
06C2:  MOVF   FF2,W
06C4:  MOVWF  00
06C6:  BCF    FF2.7
06C8:  MOVFF  FD,FA9
06CC:  MOVFF  FF,FA8
06D0:  BCF    FA6.6
06D2:  BCF    FA6.7
06D4:  BSF    FA6.2
06D6:  MOVLB  F
06D8:  MOVLW  55
06DA:  MOVWF  FA7
06DC:  MOVLW  AA
06DE:  MOVWF  FA7
06E0:  BSF    FA6.1
06E2:  BTFSC  FA6.1
06E4:  BRA    06E2
06E6:  BCF    FA6.2
06E8:  MOVF   00,W
06EA:  IORWF  FF2,F
06EC:  MOVLB  0
06EE:  BRA    0662
.................... 	}
.................... 
.................... 	return crc;
06F0:  MOVFF  FC,01
06F4:  GOTO   0710 (RETURN)
.................... }
.................... 
.................... void write_param_file() {
.................... 	int8 crc;
.................... 
.................... 	/* write the config structure */
.................... 	crc = EEPROMDataWrite(PARAM_ADDRESS,(void *)&config,sizeof(config));
06F8:  MOVLW  1A
06FA:  MOVWF  xF4
06FC:  CLRF   xF7
06FE:  MOVLW  02
0700:  MOVWF  xF6
0702:  CLRF   xF9
0704:  MOVFF  F4,F8
0708:  CLRF   xFB
070A:  MOVLW  39
070C:  MOVWF  xFA
070E:  BRA    0660
0710:  MOVFF  01,F3
.................... 	/* write the CRC was calculated on the structure */
.................... 	write_eeprom(PARAM_CRC_ADDRESS,crc);
0714:  MOVF   FF2,W
0716:  MOVWF  00
0718:  BCF    FF2.7
071A:  CLRF   FA9
071C:  MOVFF  F3,FA8
0720:  BCF    FA6.6
0722:  BCF    FA6.7
0724:  BSF    FA6.2
0726:  MOVLB  F
0728:  MOVLW  55
072A:  MOVWF  FA7
072C:  MOVLW  AA
072E:  MOVWF  FA7
0730:  BSF    FA6.1
0732:  BTFSC  FA6.1
0734:  BRA    0732
0736:  BCF    FA6.2
0738:  MOVF   00,W
073A:  IORWF  FF2,F
073C:  MOVLB  0
073E:  RETURN 0
.................... }
.................... 
.................... void write_default_param_file() {
.................... 	int8 i;
.................... 
.................... 	current.default_params_written=1;
0740:  MOVLW  01
0742:  MOVWF  xBE
.................... 
.................... 	/* both LEDs on */
.................... 	timers.led_on_a=150;
0744:  MOVLW  96
0746:  MOVWF  xC0
.................... 	timers.led_on_b=150;
0748:  MOVWF  xC1
.................... 
.................... 	config.adc_sample_ticks=20;
074A:  CLRF   1B
074C:  MOVLW  14
074E:  MOVWF  1A
.................... 
.................... 	config.startup_power_on_delay=5;
0750:  CLRF   1D
0752:  MOVLW  05
0754:  MOVWF  1C
.................... 	config.reconnect_delay=5;
0756:  MOVWF  1E
.................... 
.................... 	config.command_off_hold_time=2;
0758:  CLRF   20
075A:  MOVLW  02
075C:  MOVWF  1F
.................... 
.................... 	for ( i=0 ; i<2 ; i++ ) {
075E:  CLRF   xF2
0760:  MOVF   xF2,W
0762:  SUBLW  01
0764:  BTFSS  FD8.0
0766:  BRA    0888
.................... 		config.ch[i].lvd_disconnect_adc=303;
0768:  MOVF   xF2,W
076A:  MULLW  18
076C:  MOVF   FF3,W
076E:  CLRF   03
0770:  ADDLW  23
0772:  MOVWF  FE9
0774:  MOVLW  00
0776:  ADDWFC 03,W
0778:  MOVWF  FEA
077A:  MOVLW  01
077C:  MOVWF  FEC
077E:  MOVF   FED,F
0780:  MOVLW  2F
0782:  MOVWF  FEF
.................... 		config.ch[i].lvd_disconnect_delay=40;
0784:  MOVF   xF2,W
0786:  MULLW  18
0788:  MOVF   FF3,W
078A:  CLRF   03
078C:  ADDLW  09
078E:  MOVWF  xF3
0790:  MOVLW  00
0792:  ADDWFC 03,W
0794:  MOVWF  xF4
0796:  MOVLW  02
0798:  ADDWF  xF3,W
079A:  MOVWF  01
079C:  MOVLW  00
079E:  ADDWFC xF4,W
07A0:  MOVWF  03
07A2:  MOVF   01,W
07A4:  ADDLW  1A
07A6:  MOVWF  FE9
07A8:  MOVLW  00
07AA:  ADDWFC 03,W
07AC:  MOVWF  FEA
07AE:  CLRF   FEC
07B0:  MOVF   FED,F
07B2:  MOVLW  28
07B4:  MOVWF  FEF
.................... 		config.ch[i].lvd_reconnect_adc=308;
07B6:  MOVF   xF2,W
07B8:  MULLW  18
07BA:  MOVF   FF3,W
07BC:  CLRF   03
07BE:  ADDLW  09
07C0:  MOVWF  xF3
07C2:  MOVLW  00
07C4:  ADDWFC 03,W
07C6:  MOVWF  xF4
07C8:  MOVLW  04
07CA:  ADDWF  xF3,W
07CC:  MOVWF  01
07CE:  MOVLW  00
07D0:  ADDWFC xF4,W
07D2:  MOVWF  03
07D4:  MOVF   01,W
07D6:  ADDLW  1A
07D8:  MOVWF  FE9
07DA:  MOVLW  00
07DC:  ADDWFC 03,W
07DE:  MOVWF  FEA
07E0:  MOVLW  01
07E2:  MOVWF  FEC
07E4:  MOVF   FED,F
07E6:  MOVLW  34
07E8:  MOVWF  FEF
.................... 
.................... 		config.ch[i].hvd_disconnect_adc=410;
07EA:  MOVF   xF2,W
07EC:  MULLW  18
07EE:  MOVF   FF3,W
07F0:  CLRF   03
07F2:  ADDLW  09
07F4:  MOVWF  xF3
07F6:  MOVLW  00
07F8:  ADDWFC 03,W
07FA:  MOVWF  xF4
07FC:  MOVLW  06
07FE:  ADDWF  xF3,W
0800:  MOVWF  01
0802:  MOVLW  00
0804:  ADDWFC xF4,W
0806:  MOVWF  03
0808:  MOVF   01,W
080A:  ADDLW  1A
080C:  MOVWF  FE9
080E:  MOVLW  00
0810:  ADDWFC 03,W
0812:  MOVWF  FEA
0814:  MOVLW  01
0816:  MOVWF  FEC
0818:  MOVF   FED,F
081A:  MOVLW  9A
081C:  MOVWF  FEF
.................... 		config.ch[i].hvd_disconnect_delay=15;
081E:  MOVF   xF2,W
0820:  MULLW  18
0822:  MOVF   FF3,W
0824:  CLRF   03
0826:  ADDLW  09
0828:  MOVWF  xF3
082A:  MOVLW  00
082C:  ADDWFC 03,W
082E:  MOVWF  xF4
0830:  MOVLW  08
0832:  ADDWF  xF3,W
0834:  MOVWF  01
0836:  MOVLW  00
0838:  ADDWFC xF4,W
083A:  MOVWF  03
083C:  MOVF   01,W
083E:  ADDLW  1A
0840:  MOVWF  FE9
0842:  MOVLW  00
0844:  ADDWFC 03,W
0846:  MOVWF  FEA
0848:  CLRF   FEC
084A:  MOVF   FED,F
084C:  MOVLW  0F
084E:  MOVWF  FEF
.................... 		config.ch[i].hvd_reconnect_adc=385;
0850:  MOVF   xF2,W
0852:  MULLW  18
0854:  MOVF   FF3,W
0856:  CLRF   03
0858:  ADDLW  09
085A:  MOVWF  xF3
085C:  MOVLW  00
085E:  ADDWFC 03,W
0860:  MOVWF  xF4
0862:  MOVLW  0A
0864:  ADDWF  xF3,W
0866:  MOVWF  01
0868:  MOVLW  00
086A:  ADDWFC xF4,W
086C:  MOVWF  03
086E:  MOVF   01,W
0870:  ADDLW  1A
0872:  MOVWF  FE9
0874:  MOVLW  00
0876:  ADDWFC 03,W
0878:  MOVWF  FEA
087A:  MOVLW  01
087C:  MOVWF  FEC
087E:  MOVF   FED,F
0880:  MOVLW  81
0882:  MOVWF  FEF
0884:  INCF   xF2,F
0886:  BRA    0760
.................... 	}
.................... 	
.................... 	/* write them so next time we use from EEPROM */
.................... 	write_param_file();
0888:  RCALL  06F8
088A:  RETURN 0
.................... 
.................... }
.................... 
.................... 
.................... void read_param_file() {
.................... 	int8 crc;
.................... 
.................... 	crc = EEPROMDataRead(PARAM_ADDRESS, (void *)&config, sizeof(config)); 
088C:  MOVLW  1A
088E:  MOVWF  xF2
0890:  CLRF   xF5
0892:  MOVLW  02
0894:  MOVWF  xF4
0896:  CLRF   xF7
0898:  MOVFF  F2,F6
089C:  CLRF   xF9
089E:  MOVLW  39
08A0:  MOVWF  xF8
08A2:  BRA    05E0
08A4:  MOVFF  01,F1
.................... 		
.................... 	if ( crc != read_eeprom(PARAM_CRC_ADDRESS) ) {
08A8:  MOVFF  FF2,F2
08AC:  BCF    FF2.7
08AE:  CLRF   FA9
08B0:  BCF    FA6.6
08B2:  BCF    FA6.7
08B4:  BSF    FA6.0
08B6:  MOVF   FA8,W
08B8:  BTFSC  xF2.7
08BA:  BSF    FF2.7
08BC:  SUBWF  xF1,W
08BE:  BZ    08C2
.................... 		write_default_param_file();
08C0:  RCALL  0740
.................... 	}
08C2:  GOTO   1390 (RETURN)
.................... }
.................... 
.................... 
.................... 
.................... #include "i2c_handler_dcswc_module_latching_contactor.c"
.................... #include "registers_dcswc_module_latching_contactor.h"
.................... 
.................... /* first three registers will give enough information for telemetry */
.................... #define I2C_REG_VOLTAGE_INPUT_AVG             0  /* 10 bit input voltage ADC averaged value */
.................... #define I2C_REG_STATE_CONTACTORS              1  /* two 8 bit channel states (A is MSB / B is LSB) */
.................... #define I2C_REG_TEMPERATURE_BOARD_AVG         2  /* 10 bit NTC thermistor ADC averaged value */
.................... 
.................... #define I2C_REG_VOLTAGE_INPUT_NOW             3  /* 10 bit input voltage ADC latest value */
.................... #define I2C_REG_TEMPERATURE_BOARD_NOW         4  /* 10 bit NTC thermistor ADC latest value */
.................... 
.................... /* command can only come from I2C interface */
.................... #define I2C_REG_COMMAND_ON_A                  5  /* R/W seconds */
.................... #define I2C_REG_COMMAND_ON_B                  6
.................... 
.................... #define I2C_REG_COMMAND_OFF_A                 7  /* R/W seconds */
.................... #define I2C_REG_COMMAND_OFF_B                 8
.................... 
.................... /* low voltage disconnect */
.................... #define I2C_REG_LVD_DISCONNECT_A              9  /* R seconds */
.................... #define I2C_REG_LVD_DISCONNECT_B              10
.................... 
.................... /* high voltage disconnect */
.................... #define I2C_REG_HVD_DISCONNECT_A              11 /* R seconds */
.................... #define I2C_REG_HVD_DISCONNECT_B              12
.................... 
.................... /* low temperature disconnect */
.................... #define I2C_REG_LTD_DISCONNECT_A              9  /* R seconds */
.................... #define I2C_REG_LTD_DISCONNECT_B              10
.................... 
.................... /* high temperature disconnect */
.................... #define I2C_REG_HTD_DISCONNECT_A              11 /* R seconds */
.................... #define I2C_REG_HTD_DISCONNECT_B              12
.................... 
.................... /* reserved for future, unimplemented */
.................... #define I2C_REG_FUT_DISCONNECT_A              13 /* R seconds */
.................... #define I2C_REG_FUT_DISCONNECT_B              14
.................... 
.................... 
.................... #define I2C_REG_SEQUENCE_NUMBER               8  /* R */
.................... #define I2C_REG_TIME_INTERVAL_MILLISECONDS    9
.................... #define I2C_REG_TIME_UPTIME_MINUTES           10
.................... #define I2C_REG_DEFAULT_PARAMS_WRITTEN        13
.................... 
.................... 
.................... /* configuration */
.................... #define I2C_REG_CONFIG_HARDWARE_MODEL              128 /* R */
.................... #define I2C_REG_CONFIG_HARDWARE_VERSION            129
.................... #define I2C_REG_CONFIG_SOFTWARE_MODEL              130
.................... #define I2C_REG_CONFIG_SOFTWARE_VERSION            131
.................... #define I2C_REG_CONFIG_SOFTWARE_YEAR               132
.................... #define I2C_REG_CONFIG_SOFTWARE_MONTH              133
.................... #define I2C_REG_CONFIG_SOFTWARE_DAY                134
.................... 
.................... #define I2C_REG_CONFIG_PARAM_WRITE                 135 /* R / W */
.................... 
.................... #define I2C_REG_CONFIG_STARTUP_POWER_ON_DELAY      136
.................... #define I2C_REG_CONFIG_RECONNECT_DELAY             137
.................... 
.................... #define I2C_REG_CONFIG_COMMAND_OFF_HOLD_TIME        44
.................... #define I2C_REG_CONFIG_COMMAND_ON_HOLD_TIME         44
.................... 
.................... 
.................... #define I2C_REG_CONFIG_LVD_DISCONNECT_VOLTAGE       49
.................... #define I2C_REG_CONFIG_LVD_DISCONNECT_DELAY         50
.................... #define I2C_REG_CONFIG_LVD_RECONNECT_VOLTAGE        51
.................... #define I2C_REG_CONFIG_HVD_DISCONNECT_VOLTAGE       52
.................... #define I2C_REG_CONFIG_HVD_DISCONNECT_DELAY         53
.................... #define I2C_REG_CONFIG_HVD_RECONNECT_VOLTAGE        54
.................... 
.................... 
.................... void write_i2c(int8 address, int16 value) {
.................... 
.................... #if 0
*
0004:  GOTO   0172 (RETURN)
.................... 		case I2C_REG_COMMAND_OFF:
.................... 			timers.command_off_seconds=value;
.................... 			break;
.................... 
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			if ( 1 == value ) {
.................... 				timers.now_write_config=1;
.................... 			} else if ( 2 == value ) {
.................... 				timers.now_reset_config=1;
.................... 			} else if ( 1802 == value ) {
.................... 				current.factory_unlocked =1;
.................... 			} else if ( 65535 == value ) {
.................... 				reset_cpu();
.................... 			}
.................... 			break;
.................... 		case I2C_REG_CONFIG_TICKS_ADC:
.................... 			config.adc_sample_ticks=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_STARTUP_POWER_ON_DELAY:
.................... 			config.startup_power_on_delay=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_COMMAND_OFF_HOLD_TIME:
.................... 			config.command_off_hold_time=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_LVD_DISCONNECT_VOLTAGE:
.................... 			config.lvd_disconnect_adc=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_LVD_DISCONNECT_DELAY:
.................... 			config.lvd_disconnect_delay=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_LVD_RECONNECT_VOLTAGE:
.................... 			config.lvd_reconnect_adc=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_HVD_DISCONNECT_VOLTAGE:
.................... 			config.hvd_disconnect_adc=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_HVD_DISCONNECT_DELAY:
.................... 			config.hvd_disconnect_delay=value;
.................... 			break;
.................... 		case I2C_REG_CONFIG_HVD_RECONNECT_VOLTAGE:
.................... 			config.hvd_reconnect_adc=value;
.................... 			break;
.................... 		default:
.................... 			/* do nothing */
.................... 	}
.................... #endif
.................... 
.................... }
.................... 
.................... 
.................... int16 map_i2c(int8 addr) {
.................... 
.................... 	timers.led_on_a=100;
*
00DC:  MOVLW  64
00DE:  MOVWF  xC0
.................... 
.................... 	switch ( addr ) {
00E0:  MOVLB  1
00E2:  MOVF   x17,W
.................... #if 0
.................... 
.................... 
.................... 		/* analog channels */
.................... 		/* input voltage */
.................... 		case I2C_REG_VOLTAGE_INPUT_NOW: 
.................... 			return (int16) current.adc_buffer[0][current.adc_buffer_index];
.................... 		case I2C_REG_VOLTAGE_INPUT_AVG: 
.................... 			return (int16) adc_get(0);
.................... 
.................... 		/* temperature sensor */
.................... 		case I2C_REG_TEMPERATURE_BOARD_NOW: 
.................... 			return (int16) current.adc_buffer[1][current.adc_buffer_index];
.................... 		case I2C_REG_TEMPERATURE_BOARD_AVG: 
.................... 			return (int16) adc_get(1);
.................... 		
.................... 		/* status */
.................... 		case I2C_REG_SEQUENCE_NUMBER: 
.................... 			return (int16) current.sequence_number++;
.................... 		case I2C_REG_TIME_INTERVAL_MILLISECONDS: 
.................... 			return (int16) current.interval_milliseconds; /* milliseconds since last query */
.................... 		case I2C_REG_TIME_UPTIME_MINUTES: 
.................... 			return (int16) current.uptime_minutes; 
.................... 		case I2C_REG_DEFAULT_PARAMS_WRITTEN:
.................... 			return (int16) current.default_params_written;
.................... 		case I2C_REG_COMMAND_OFF:
.................... 			return (int16) timers.command_off_seconds;
.................... 		case I2C_REG_POWER_OFF_FLAGS:
.................... 			return (int16) current.power_off_flags;
.................... 
.................... 
.................... 		/* configuration */
.................... 		case I2C_REG_CONFIG_HARDWARE_MODEL: 
.................... 			return (int16) 'P';
.................... 		case I2C_REG_CONFIG_HARDWARE_VERSION: 
.................... 			return (int16) 'Z';
.................... 		case I2C_REG_CONFIG_SOFTWARE_MODEL: 
.................... 			return (int16) 'P';
.................... 		case I2C_REG_CONFIG_SOFTWARE_VERSION: 
.................... 			return (int16) 3;
.................... 		case I2C_REG_CONFIG_SOFTWARE_YEAR:
.................... 			return (int16) current.compile_year;
.................... 		case I2C_REG_CONFIG_SOFTWARE_MONTH:
.................... 			return (int16) current.compile_month;
.................... 		case I2C_REG_CONFIG_SOFTWARE_DAY:
.................... 			return (int16) current.compile_day;
.................... 
.................... 		case I2C_REG_CONFIG_PARAM_WRITE:
.................... 			/* 1 if factory unlocked */ 
.................... 			return (int16) current.factory_unlocked; 	
.................... 		case I2C_REG_CONFIG_TICKS_ADC: 
.................... 			return (int16) config.adc_sample_ticks;
.................... 		case I2C_REG_CONFIG_STARTUP_POWER_ON_DELAY: 
.................... 			return (int16) config.startup_power_on_delay;
.................... 		case I2C_REG_CONFIG_COMMAND_OFF_HOLD_TIME:
.................... 			return (int16) config.command_off_hold_time;
.................... 		case I2C_REG_CONFIG_LVD_DISCONNECT_VOLTAGE:
.................... 			return (int16) config.lvd_disconnect_adc;
.................... 		case I2C_REG_CONFIG_LVD_DISCONNECT_DELAY:
.................... 			return (int16) config.lvd_disconnect_delay;
.................... 		case I2C_REG_CONFIG_LVD_RECONNECT_VOLTAGE:
.................... 			return (int16) config.lvd_reconnect_adc;
.................... 		case I2C_REG_CONFIG_HVD_DISCONNECT_VOLTAGE:
.................... 			return (int16) config.hvd_disconnect_adc;
.................... 		case I2C_REG_CONFIG_HVD_DISCONNECT_DELAY:
.................... 			return (int16) config.hvd_disconnect_delay;
.................... 		case I2C_REG_CONFIG_HVD_RECONNECT_VOLTAGE:
.................... 			return (int16) config.hvd_reconnect_adc;
.................... 
.................... #endif
.................... 
.................... 		/* we should have range checked, and never gotten here ... or read unimplemented (future) register */
.................... 		default: return (int16) addr;
00E4:  MOVFF  117,01
00E8:  CLRF   02
.................... 	}
00EA:  MOVLB  0
00EC:  GOTO   018E (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... 
.................... 
.................... #include "interrupt_dcswc_module_latching_contactor.c"
.................... #int_timer2
.................... void isr_timer2() {
.................... 	timers.now_millisecond=1;
*
00D4:  BSF    xBF.2
00D6:  BCF    F9E.1
00D8:  GOTO   006C
.................... }
.................... 
.................... 
.................... 
.................... unsigned int8 address;
.................... 
.................... #INT_SSP
.................... void ssp_interrupt () {
.................... 	unsigned int8 incoming, state;
.................... 	static int16 lastValue;
.................... 	static int8 lastMSB;
.................... 
.................... 
.................... 	state = i2c_isr_state();
*
0106:  BTFSC  FC7.5
0108:  BRA    0110
010A:  CLRF   xE6
010C:  BTFSC  FC7.2
010E:  BSF    xE6.7
0110:  MOVF   xE6,W
0112:  INCF   xE6,F
0114:  MOVLB  1
0116:  MOVWF  x15
.................... 
.................... 	if(state <= 0x80) {                      
0118:  MOVF   x15,W
011A:  SUBLW  80
011C:  BNC   0174
.................... 		// Master is sending data
.................... 		if ( state == 0x80 ) {
011E:  MOVF   x15,W
0120:  SUBLW  80
0122:  BNZ   012A
.................... 			incoming = i2c_read(2); //Passing 2 as parameter, causes the function to read the SSPBUF without releasing the clock
0124:  MOVFF  FC9,114
.................... 		} else {
0128:  BRA    0136
.................... 			incoming = i2c_read();
012A:  BCF    FC6.6
012C:  BTFSS  FC7.0
012E:  BRA    012C
0130:  MOVF   FC9,W
0132:  BSF    FC6.4
0134:  MOVWF  x14
.................... 		}
.................... 
.................... 		if ( state == 1 ) {                      
0136:  DECFSZ x15,W
0138:  BRA    0140
.................... 			// First received byte is address
.................... 			address = incoming;
013A:  MOVFF  114,E2
.................... 		} else if ( state >= 2 && state != 0x80 ) {
013E:  BRA    0174
0140:  MOVF   x15,W
0142:  SUBLW  01
0144:  BC    0174
0146:  MOVF   x15,W
0148:  SUBLW  80
014A:  BZ    0174
.................... 			// Received byte is data
.................... 			// buffer[address++] = incoming;
.................... 		
.................... 			/* save MSB and we'll process it on next */
.................... 			if ( 2 == state ) {
014C:  MOVF   x15,W
014E:  SUBLW  02
0150:  BNZ   0158
.................... 				lastMSB=incoming;
0152:  MOVFF  114,E5
.................... 			} else if ( 3 == state ) {
0156:  BRA    0174
0158:  MOVF   x15,W
015A:  SUBLW  03
015C:  BNZ   0174
.................... 				/* 16 bit value made of previous byte and this byte */
.................... 				write_i2c(address,make16(lastMSB,incoming));
015E:  MOVFF  E5,11A
0162:  MOVFF  114,116
0166:  MOVFF  E2,118
016A:  MOVFF  114,119
016E:  MOVLB  0
0170:  BRA    0004
0172:  MOVLB  1
.................... 			}
.................... 			
.................... 
.................... //			address++;
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	if ( state >= 0x80 ) {
0174:  MOVF   x15,W
0176:  SUBLW  7F
0178:  BC    01A8
.................... 		//Master is requesting data
.................... 		
.................... 		if ( ! bit_test(address,0) ) {
017A:  MOVLB  0
017C:  BTFSC  xE2.0
017E:  BRA    019E
.................... 			/* read 16 bit register on even address */
.................... 			lastValue=map_i2c(address>>1);
0180:  BCF    FD8.0
0182:  RRCF   xE2,W
0184:  MOVLB  1
0186:  MOVWF  x16
0188:  MOVWF  x17
018A:  MOVLB  0
018C:  BRA    00DC
018E:  MOVFF  02,E4
0192:  MOVFF  01,E3
.................... 
.................... 			 i2c_write(make8(lastValue,1));
0196:  MOVFF  E4,117
019A:  RCALL  00F0
.................... 		} else {
019C:  BRA    01A4
.................... 			/* send other byte of 16 bit register on odd address */
.................... 			i2c_write(make8(lastValue,0));
019E:  MOVFF  E3,117
01A2:  RCALL  00F0
.................... 		}
.................... 
.................... 		address++;
01A4:  INCF   xE2,F
01A6:  MOVLB  1
.................... 	}
01A8:  BCF    F9E.3
01AA:  MOVLB  0
01AC:  GOTO   006C
.................... }
.................... 
.................... 
.................... 
.................... 
.................... 
.................... int8 read_dip_switch(void) {
.................... 	int16 adc;
.................... 
.................... 	set_adc_channel(9);
*
0440:  MOVLW  24
0442:  MOVWF  01
0444:  MOVF   FC2,W
0446:  ANDLW  C3
0448:  IORWF  01,W
044A:  MOVWF  FC2
.................... 	delay_ms(1);
044C:  MOVLW  01
044E:  MOVLB  1
0450:  MOVWF  x13
0452:  MOVLB  0
0454:  RCALL  0416
.................... 	adc=read_adc();
0456:  BSF    FC2.1
0458:  BTFSC  FC2.1
045A:  BRA    0458
045C:  MOVFF  FC4,112
0460:  MOVFF  FC3,111
.................... 
.................... 	/* (note that table is sorted by vout reading 
.................... 	SW3.1 (LSB) SW3.2 (MSB) VALUE ADC
....................     OFF         OFF         0     1023
.................... 	OFF         ON          2     682
....................     ON          OFF         1     511
.................... 	ON          ON          3     409
.................... 	*/
.................... 
.................... 	if ( adc > (1023-64) )
0464:  MOVLB  1
0466:  MOVF   x12,W
0468:  SUBLW  02
046A:  BC    047C
046C:  XORLW  FF
046E:  BNZ   0476
0470:  MOVF   x11,W
0472:  SUBLW  BF
0474:  BC    047C
.................... 		return 0;
0476:  MOVLW  00
0478:  MOVWF  01
047A:  BRA    04AC
.................... 	if ( adc > (682-64) )
047C:  MOVF   x12,W
047E:  SUBLW  01
0480:  BC    0492
0482:  XORLW  FF
0484:  BNZ   048C
0486:  MOVF   x11,W
0488:  SUBLW  6A
048A:  BC    0492
.................... 		return 2;
048C:  MOVLW  02
048E:  MOVWF  01
0490:  BRA    04AC
.................... 	if ( adc > (511-64) )
0492:  MOVF   x12,W
0494:  SUBLW  00
0496:  BC    04A8
0498:  XORLW  FF
049A:  BNZ   04A2
049C:  MOVF   x11,W
049E:  SUBLW  BF
04A0:  BC    04A8
.................... 		return 1;
04A2:  MOVLW  01
04A4:  MOVWF  01
04A6:  BRA    04AC
.................... 
.................... 	return 3;
04A8:  MOVLW  03
04AA:  MOVWF  01
04AC:  MOVLB  0
04AE:  RETURN 0
.................... }
.................... 
.................... void contactor_on_a(void) {
.................... 	/* only turn on contactor if it isn't on or needs a refresh */
.................... 	if ( 1 == timers.contactor_a )
*
1294:  BTFSS  xBF.5
1296:  BRA    129A
.................... 		return;
1298:  BRA    12A8
.................... 
.................... 	timers.contactor_a_powersave=CONTACTOR_POWER_SAVE_MS;
129A:  MOVLW  C8
129C:  MOVWF  xC2
.................... 
.................... 	output_high(BRIDGE_A_A);
129E:  BCF    F94.3
12A0:  BSF    F8B.3
.................... 	output_low(BRIDGE_A_B);
12A2:  BCF    F94.4
12A4:  BCF    F8B.4
.................... 
.................... 	timers.contactor_a=1;
12A6:  BSF    xBF.5
12A8:  GOTO   1920 (RETURN)
.................... }
.................... 
.................... void contactor_off_a(void) {
.................... 	/* only turn off contactor if it isn't on or needs a refresh */
.................... 	if ( 0 == timers.contactor_a )
12AC:  BTFSC  xBF.5
12AE:  BRA    12B2
.................... 		return;
12B0:  BRA    12C0
.................... 
.................... 	timers.contactor_a_powersave=CONTACTOR_POWER_SAVE_MS;
12B2:  MOVLW  C8
12B4:  MOVWF  xC2
.................... 
.................... 	output_low(BRIDGE_A_A);
12B6:  BCF    F94.3
12B8:  BCF    F8B.3
.................... 	output_high(BRIDGE_A_B);
12BA:  BCF    F94.4
12BC:  BSF    F8B.4
.................... 
.................... 	timers.contactor_a=0;
12BE:  BCF    xBF.5
12C0:  GOTO   1926 (RETURN)
.................... }
.................... 
.................... void contactor_on_b(void) {
.................... 	/* only turn on contactor if it isn't on or needs a refresh */
.................... 	if ( 1 == timers.contactor_b )
12C4:  BTFSS  xBF.6
12C6:  BRA    12CA
.................... 		return;
12C8:  BRA    12D8
.................... 
.................... 	timers.contactor_b_powersave=CONTACTOR_POWER_SAVE_MS;
12CA:  MOVLW  C8
12CC:  MOVWF  xC3
.................... 
.................... 	output_high(BRIDGE_B_A);
12CE:  BCF    F94.5
12D0:  BSF    F8B.5
.................... 	output_low(BRIDGE_B_B);
12D2:  BCF    F94.6
12D4:  BCF    F8B.6
.................... 
.................... 	timers.contactor_b=1;
12D6:  BSF    xBF.6
12D8:  GOTO   1944 (RETURN)
.................... }
.................... 
.................... void contactor_off_b(void) {
.................... 	/* only turn off contactor if it isn't on or needs a refresh */
.................... 	if ( 0 == timers.contactor_b )
12DC:  BTFSC  xBF.6
12DE:  BRA    12E2
.................... 		return;
12E0:  BRA    12F0
.................... 
.................... 	timers.contactor_b_powersave=CONTACTOR_POWER_SAVE_MS;
12E2:  MOVLW  C8
12E4:  MOVWF  xC3
.................... 
.................... 	output_low(BRIDGE_B_A);
12E6:  BCF    F94.5
12E8:  BCF    F8B.5
.................... 	output_high(BRIDGE_B_B);
12EA:  BCF    F94.6
12EC:  BSF    F8B.6
.................... 
.................... 	timers.contactor_b=0;
12EE:  BCF    xBF.6
12F0:  GOTO   194A (RETURN)
.................... }
.................... 
.................... void contactor_logic(int8 c) {
.................... 	int16 adc;
.................... 
.................... 	/* TODO: implement Command On.  */
.................... 
.................... 	/* command off. 65535 disables */
.................... 	if ( 65535 != channel[c].command_off_seconds ) {
*
0A22:  MOVF   xF1,W
0A24:  MULLW  0F
0A26:  MOVF   FF3,W
0A28:  CLRF   xF5
0A2A:  MOVWF  xF4
0A2C:  MOVLW  05
0A2E:  ADDWF  xF4,W
0A30:  MOVWF  01
0A32:  MOVLW  00
0A34:  ADDWFC xF5,W
0A36:  MOVWF  03
0A38:  MOVF   01,W
0A3A:  ADDLW  C4
0A3C:  MOVWF  FE9
0A3E:  MOVLW  00
0A40:  ADDWFC 03,W
0A42:  MOVWF  FEA
0A44:  MOVFF  FEC,03
0A48:  MOVF   FED,F
0A4A:  MOVF   FEF,W
0A4C:  SUBLW  FF
0A4E:  BNZ   0A56
0A50:  INCFSZ 03,W
0A52:  BRA    0A56
0A54:  BRA    0BC2
.................... 		if ( channel[c].command_off_seconds > 0 ) {
0A56:  MOVF   xF1,W
0A58:  MULLW  0F
0A5A:  MOVF   FF3,W
0A5C:  CLRF   xF5
0A5E:  MOVWF  xF4
0A60:  MOVLW  05
0A62:  ADDWF  xF4,W
0A64:  MOVWF  01
0A66:  MOVLW  00
0A68:  ADDWFC xF5,W
0A6A:  MOVWF  03
0A6C:  MOVF   01,W
0A6E:  ADDLW  C4
0A70:  MOVWF  FE9
0A72:  MOVLW  00
0A74:  ADDWFC 03,W
0A76:  MOVWF  FEA
0A78:  MOVFF  FEC,F5
0A7C:  MOVF   FED,F
0A7E:  MOVFF  FEF,F4
0A82:  MOVF   xF4,F
0A84:  BNZ   0A8A
0A86:  MOVF   xF5,F
0A88:  BZ    0AB8
.................... 			/* waiting to power off */
.................... 			channel[c].command_off_seconds--;
0A8A:  MOVF   xF1,W
0A8C:  MULLW  0F
0A8E:  MOVF   FF3,W
0A90:  CLRF   xF5
0A92:  MOVWF  xF4
0A94:  MOVLW  05
0A96:  ADDWF  xF4,W
0A98:  MOVWF  01
0A9A:  MOVLW  00
0A9C:  ADDWFC xF5,W
0A9E:  MOVWF  03
0AA0:  MOVF   01,W
0AA2:  ADDLW  C4
0AA4:  MOVWF  FE9
0AA6:  MOVLW  00
0AA8:  ADDWFC 03,W
0AAA:  MOVWF  FEA
0AAC:  MOVLW  FF
0AAE:  ADDWF  FEF,F
0AB0:  BC    0AB6
0AB2:  MOVF   FEE,F
0AB4:  DECF   FED,F
.................... 		} else {
0AB6:  BRA    0BC2
.................... 			/* timer at zero, ready to power off or already powered off */
.................... 			if ( ! bit_test(channel[c].state,CH_STATE_BIT_CMD_OFF) ) {
0AB8:  MOVF   xF1,W
0ABA:  MULLW  0F
0ABC:  MOVF   FF3,W
0ABE:  CLRF   xF5
0AC0:  MOVWF  xF4
0AC2:  MOVLW  C4
0AC4:  ADDWF  xF4,W
0AC6:  MOVWF  FE9
0AC8:  MOVLW  00
0ACA:  ADDWFC xF5,W
0ACC:  MOVWF  FEA
0ACE:  MOVFF  FEF,F6
0AD2:  BTFSC  xF6.2
0AD4:  BRA    0B20
.................... 				/* not currently set, so we set it and start the countdown */
.................... 				bit_set(channel[c].state,CH_STATE_BIT_CMD_OFF);
0AD6:  MOVF   xF1,W
0AD8:  MULLW  0F
0ADA:  MOVF   FF3,W
0ADC:  CLRF   xF5
0ADE:  MOVWF  xF4
0AE0:  MOVLW  C4
0AE2:  ADDWF  xF4,W
0AE4:  MOVWF  01
0AE6:  MOVLW  00
0AE8:  ADDWFC xF5,W
0AEA:  MOVFF  01,FE9
0AEE:  MOVWF  FEA
0AF0:  BSF    FEF.2
.................... 				channel[c].command_off_hold_seconds=config.command_off_hold_time;
0AF2:  MOVF   xF1,W
0AF4:  MULLW  0F
0AF6:  MOVF   FF3,W
0AF8:  CLRF   xF5
0AFA:  MOVWF  xF4
0AFC:  MOVLW  07
0AFE:  ADDWF  xF4,W
0B00:  MOVWF  01
0B02:  MOVLW  00
0B04:  ADDWFC xF5,W
0B06:  MOVWF  03
0B08:  MOVF   01,W
0B0A:  ADDLW  C4
0B0C:  MOVWF  FE9
0B0E:  MOVLW  00
0B10:  ADDWFC 03,W
0B12:  MOVWF  FEA
0B14:  MOVFF  20,FEC
0B18:  MOVF   FED,F
0B1A:  MOVFF  1F,FEF
.................... 			} else {
0B1E:  BRA    0BC2
.................... 				/* set, so we clear it once countdown has elapsed */
.................... 				if ( 0==channel[c].command_off_hold_seconds ) {
0B20:  MOVF   xF1,W
0B22:  MULLW  0F
0B24:  MOVF   FF3,W
0B26:  CLRF   xF5
0B28:  MOVWF  xF4
0B2A:  MOVLW  07
0B2C:  ADDWF  xF4,W
0B2E:  MOVWF  01
0B30:  MOVLW  00
0B32:  ADDWFC xF5,W
0B34:  MOVWF  03
0B36:  MOVF   01,W
0B38:  ADDLW  C4
0B3A:  MOVWF  FE9
0B3C:  MOVLW  00
0B3E:  ADDWFC 03,W
0B40:  MOVWF  FEA
0B42:  MOVFF  FEC,03
0B46:  MOVF   FED,F
0B48:  MOVF   FEF,W
0B4A:  BNZ   0B96
0B4C:  MOVF   03,F
0B4E:  BNZ   0B96
.................... 					/* countdown elapsed, clear the flag and reset the timer */
.................... 					bit_clear(channel[c].state,CH_STATE_BIT_CMD_OFF);
0B50:  MOVF   xF1,W
0B52:  MULLW  0F
0B54:  MOVF   FF3,W
0B56:  CLRF   xF5
0B58:  MOVWF  xF4
0B5A:  MOVLW  C4
0B5C:  ADDWF  xF4,W
0B5E:  MOVWF  01
0B60:  MOVLW  00
0B62:  ADDWFC xF5,W
0B64:  MOVFF  01,FE9
0B68:  MOVWF  FEA
0B6A:  BCF    FEF.2
.................... 					channel[c].command_off_seconds=65535;
0B6C:  MOVF   xF1,W
0B6E:  MULLW  0F
0B70:  MOVF   FF3,W
0B72:  CLRF   xF5
0B74:  MOVWF  xF4
0B76:  MOVLW  05
0B78:  ADDWF  xF4,W
0B7A:  MOVWF  01
0B7C:  MOVLW  00
0B7E:  ADDWFC xF5,W
0B80:  MOVWF  03
0B82:  MOVF   01,W
0B84:  ADDLW  C4
0B86:  MOVWF  FE9
0B88:  MOVLW  00
0B8A:  ADDWFC 03,W
0B8C:  MOVWF  FEA
0B8E:  SETF   FEC
0B90:  MOVF   FED,F
0B92:  SETF   FEF
.................... 				} else {
0B94:  BRA    0BC2
.................... 					channel[c].command_off_hold_seconds--;
0B96:  MOVF   xF1,W
0B98:  MULLW  0F
0B9A:  MOVF   FF3,W
0B9C:  CLRF   xF5
0B9E:  MOVWF  xF4
0BA0:  MOVLW  07
0BA2:  ADDWF  xF4,W
0BA4:  MOVWF  01
0BA6:  MOVLW  00
0BA8:  ADDWFC xF5,W
0BAA:  MOVWF  03
0BAC:  MOVF   01,W
0BAE:  ADDLW  C4
0BB0:  MOVWF  FE9
0BB2:  MOVLW  00
0BB4:  ADDWFC 03,W
0BB6:  MOVWF  FEA
0BB8:  MOVLW  FF
0BBA:  ADDWF  FEF,F
0BBC:  BC    0BC2
0BBE:  MOVF   FEE,F
0BC0:  DECF   FED,F
.................... 				}
.................... 			}		
.................... 		}
.................... 	}
.................... 
.................... 
.................... 	/* LVD. 65535 disables */
.................... 	if ( 65535 != config.ch[c].lvd_disconnect_delay ) {
0BC2:  MOVF   xF1,W
0BC4:  MULLW  18
0BC6:  MOVF   FF3,W
0BC8:  CLRF   03
0BCA:  ADDLW  09
0BCC:  MOVWF  xF4
0BCE:  MOVLW  00
0BD0:  ADDWFC 03,W
0BD2:  MOVWF  xF5
0BD4:  MOVLW  02
0BD6:  ADDWF  xF4,W
0BD8:  MOVWF  01
0BDA:  MOVLW  00
0BDC:  ADDWFC xF5,W
0BDE:  MOVWF  03
0BE0:  MOVF   01,W
0BE2:  ADDLW  1A
0BE4:  MOVWF  FE9
0BE6:  MOVLW  00
0BE8:  ADDWFC 03,W
0BEA:  MOVWF  FEA
0BEC:  MOVFF  FEC,03
0BF0:  MOVF   FED,F
0BF2:  MOVF   FEF,W
0BF4:  SUBLW  FF
0BF6:  BNZ   0BFE
0BF8:  INCFSZ 03,W
0BFA:  BRA    0BFE
0BFC:  BRA    0DF4
.................... 		adc=adc_get(0);
0BFE:  CLRF   xF4
0C00:  RCALL  09A6
0C02:  MOVFF  02,F3
0C06:  MOVFF  01,F2
.................... 
.................... 		if ( adc > config.ch[c].lvd_reconnect_adc ) {
0C0A:  MOVF   xF1,W
0C0C:  MULLW  18
0C0E:  MOVF   FF3,W
0C10:  CLRF   03
0C12:  ADDLW  09
0C14:  MOVWF  xF4
0C16:  MOVLW  00
0C18:  ADDWFC 03,W
0C1A:  MOVWF  xF5
0C1C:  MOVLW  04
0C1E:  ADDWF  xF4,W
0C20:  MOVWF  01
0C22:  MOVLW  00
0C24:  ADDWFC xF5,W
0C26:  MOVWF  03
0C28:  MOVF   01,W
0C2A:  ADDLW  1A
0C2C:  MOVWF  FE9
0C2E:  MOVLW  00
0C30:  ADDWFC 03,W
0C32:  MOVWF  FEA
0C34:  MOVFF  FEC,03
0C38:  MOVF   FED,F
0C3A:  MOVFF  FEF,01
0C3E:  MOVF   03,W
0C40:  SUBWF  xF3,W
0C42:  BNC   0CB6
0C44:  BNZ   0C4C
0C46:  MOVF   xF2,W
0C48:  SUBWF  01,W
0C4A:  BC    0CB6
.................... 			if ( channel[c].lvd_reconnect_delay_seconds > 0 ) {
0C4C:  MOVF   xF1,W
0C4E:  MULLW  0F
0C50:  MOVF   FF3,W
0C52:  CLRF   xF5
0C54:  MOVWF  xF4
0C56:  MOVLW  0B
0C58:  ADDWF  xF4,W
0C5A:  MOVWF  01
0C5C:  MOVLW  00
0C5E:  ADDWFC xF5,W
0C60:  MOVWF  03
0C62:  MOVF   01,W
0C64:  ADDLW  C4
0C66:  MOVWF  FE9
0C68:  MOVLW  00
0C6A:  ADDWFC 03,W
0C6C:  MOVWF  FEA
0C6E:  MOVF   FEF,F
0C70:  BZ    0C98
.................... 				channel[c].lvd_reconnect_delay_seconds--;
0C72:  MOVF   xF1,W
0C74:  MULLW  0F
0C76:  MOVF   FF3,W
0C78:  CLRF   xF5
0C7A:  MOVWF  xF4
0C7C:  MOVLW  0B
0C7E:  ADDWF  xF4,W
0C80:  MOVWF  01
0C82:  MOVLW  00
0C84:  ADDWFC xF5,W
0C86:  MOVWF  03
0C88:  MOVF   01,W
0C8A:  ADDLW  C4
0C8C:  MOVWF  FE9
0C8E:  MOVLW  00
0C90:  ADDWFC 03,W
0C92:  MOVWF  FEA
0C94:  DECF   FEF,F
.................... 			} else {
0C96:  BRA    0CB4
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_LVD);
0C98:  MOVF   xF1,W
0C9A:  MULLW  0F
0C9C:  MOVF   FF3,W
0C9E:  CLRF   xF5
0CA0:  MOVWF  xF4
0CA2:  MOVLW  C4
0CA4:  ADDWF  xF4,W
0CA6:  MOVWF  01
0CA8:  MOVLW  00
0CAA:  ADDWFC xF5,W
0CAC:  MOVFF  01,FE9
0CB0:  MOVWF  FEA
0CB2:  BCF    FEF.3
.................... 			}
.................... 		} else {
0CB4:  BRA    0CDC
.................... 			channel[c].lvd_reconnect_delay_seconds=config.reconnect_delay; /* 5 seconds countdown before reconnecting */
0CB6:  MOVF   xF1,W
0CB8:  MULLW  0F
0CBA:  MOVF   FF3,W
0CBC:  CLRF   xF5
0CBE:  MOVWF  xF4
0CC0:  MOVLW  0B
0CC2:  ADDWF  xF4,W
0CC4:  MOVWF  01
0CC6:  MOVLW  00
0CC8:  ADDWFC xF5,W
0CCA:  MOVWF  03
0CCC:  MOVF   01,W
0CCE:  ADDLW  C4
0CD0:  MOVWF  FE9
0CD2:  MOVLW  00
0CD4:  ADDWFC 03,W
0CD6:  MOVWF  FEA
0CD8:  MOVFF  1E,FEF
.................... 		}
.................... 
.................... 		if ( adc < config.ch[c].lvd_disconnect_adc ) {
0CDC:  MOVF   xF1,W
0CDE:  MULLW  18
0CE0:  MOVF   FF3,W
0CE2:  CLRF   03
0CE4:  ADDLW  23
0CE6:  MOVWF  FE9
0CE8:  MOVLW  00
0CEA:  ADDWFC 03,W
0CEC:  MOVWF  FEA
0CEE:  MOVFF  FEC,03
0CF2:  MOVF   FED,F
0CF4:  MOVFF  FEF,01
0CF8:  MOVF   xF3,W
0CFA:  SUBWF  03,W
0CFC:  BNC   0D86
0CFE:  BNZ   0D06
0D00:  MOVF   01,W
0D02:  SUBWF  xF2,W
0D04:  BC    0D86
.................... 			if ( channel[c].lvd_disconnect_delay_seconds > 0 ) {
0D06:  MOVF   xF1,W
0D08:  MULLW  0F
0D0A:  MOVF   FF3,W
0D0C:  CLRF   xF5
0D0E:  MOVWF  xF4
0D10:  MOVLW  09
0D12:  ADDWF  xF4,W
0D14:  MOVWF  01
0D16:  MOVLW  00
0D18:  ADDWFC xF5,W
0D1A:  MOVWF  03
0D1C:  MOVF   01,W
0D1E:  ADDLW  C4
0D20:  MOVWF  FE9
0D22:  MOVLW  00
0D24:  ADDWFC 03,W
0D26:  MOVWF  FEA
0D28:  MOVFF  FEC,F5
0D2C:  MOVF   FED,F
0D2E:  MOVFF  FEF,F4
0D32:  MOVF   xF4,F
0D34:  BNZ   0D3A
0D36:  MOVF   xF5,F
0D38:  BZ    0D68
.................... 				channel[c].lvd_disconnect_delay_seconds--;
0D3A:  MOVF   xF1,W
0D3C:  MULLW  0F
0D3E:  MOVF   FF3,W
0D40:  CLRF   xF5
0D42:  MOVWF  xF4
0D44:  MOVLW  09
0D46:  ADDWF  xF4,W
0D48:  MOVWF  01
0D4A:  MOVLW  00
0D4C:  ADDWFC xF5,W
0D4E:  MOVWF  03
0D50:  MOVF   01,W
0D52:  ADDLW  C4
0D54:  MOVWF  FE9
0D56:  MOVLW  00
0D58:  ADDWFC 03,W
0D5A:  MOVWF  FEA
0D5C:  MOVLW  FF
0D5E:  ADDWF  FEF,F
0D60:  BC    0D66
0D62:  MOVF   FEE,F
0D64:  DECF   FED,F
.................... 			} else {
0D66:  BRA    0D84
.................... 				bit_set(channel[c].state,CH_STATE_BIT_LVD);
0D68:  MOVF   xF1,W
0D6A:  MULLW  0F
0D6C:  MOVF   FF3,W
0D6E:  CLRF   xF5
0D70:  MOVWF  xF4
0D72:  MOVLW  C4
0D74:  ADDWF  xF4,W
0D76:  MOVWF  01
0D78:  MOVLW  00
0D7A:  ADDWFC xF5,W
0D7C:  MOVFF  01,FE9
0D80:  MOVWF  FEA
0D82:  BSF    FEF.3
.................... 			}
.................... 		} else {
0D84:  BRA    0DF4
.................... 			channel[c].lvd_disconnect_delay_seconds=config.ch[c].lvd_disconnect_delay;
0D86:  MOVF   xF1,W
0D88:  MULLW  0F
0D8A:  MOVF   FF3,W
0D8C:  CLRF   xF5
0D8E:  MOVWF  xF4
0D90:  MOVLW  09
0D92:  ADDWF  xF4,W
0D94:  MOVWF  01
0D96:  MOVLW  00
0D98:  ADDWFC xF5,W
0D9A:  MOVWF  03
0D9C:  MOVF   01,W
0D9E:  ADDLW  C4
0DA0:  MOVWF  01
0DA2:  MOVLW  00
0DA4:  ADDWFC 03,F
0DA6:  MOVFF  01,F4
0DAA:  MOVFF  03,F5
0DAE:  MOVF   xF1,W
0DB0:  MULLW  18
0DB2:  MOVF   FF3,W
0DB4:  CLRF   03
0DB6:  ADDLW  09
0DB8:  MOVWF  xF6
0DBA:  MOVLW  00
0DBC:  ADDWFC 03,W
0DBE:  MOVWF  xF7
0DC0:  MOVLW  02
0DC2:  ADDWF  xF6,W
0DC4:  MOVWF  01
0DC6:  MOVLW  00
0DC8:  ADDWFC xF7,W
0DCA:  MOVWF  03
0DCC:  MOVF   01,W
0DCE:  ADDLW  1A
0DD0:  MOVWF  FE9
0DD2:  MOVLW  00
0DD4:  ADDWFC 03,W
0DD6:  MOVWF  FEA
0DD8:  MOVFF  FEC,03
0DDC:  MOVF   FED,F
0DDE:  MOVFF  FEF,F6
0DE2:  MOVFF  F5,FEA
0DE6:  MOVFF  F4,FE9
0DEA:  MOVFF  03,FEC
0DEE:  MOVF   FED,F
0DF0:  MOVFF  F6,FEF
.................... 		}
.................... 	}
.................... 
.................... 	/* HVD. 65535 disables */
.................... 	if ( 65535 != config.ch[c].hvd_disconnect_delay ) {
0DF4:  MOVF   xF1,W
0DF6:  MULLW  18
0DF8:  MOVF   FF3,W
0DFA:  CLRF   03
0DFC:  ADDLW  09
0DFE:  MOVWF  xF4
0E00:  MOVLW  00
0E02:  ADDWFC 03,W
0E04:  MOVWF  xF5
0E06:  MOVLW  08
0E08:  ADDWF  xF4,W
0E0A:  MOVWF  01
0E0C:  MOVLW  00
0E0E:  ADDWFC xF5,W
0E10:  MOVWF  03
0E12:  MOVF   01,W
0E14:  ADDLW  1A
0E16:  MOVWF  FE9
0E18:  MOVLW  00
0E1A:  ADDWFC 03,W
0E1C:  MOVWF  FEA
0E1E:  MOVFF  FEC,03
0E22:  MOVF   FED,F
0E24:  MOVF   FEF,W
0E26:  SUBLW  FF
0E28:  BNZ   0E30
0E2A:  INCFSZ 03,W
0E2C:  BRA    0E30
0E2E:  BRA    103E
.................... 		adc=adc_get(0);
0E30:  CLRF   xF4
0E32:  RCALL  09A6
0E34:  MOVFF  02,F3
0E38:  MOVFF  01,F2
.................... 
.................... 		if ( adc < config.ch[c].hvd_reconnect_adc ) {
0E3C:  MOVF   xF1,W
0E3E:  MULLW  18
0E40:  MOVF   FF3,W
0E42:  CLRF   03
0E44:  ADDLW  09
0E46:  MOVWF  xF4
0E48:  MOVLW  00
0E4A:  ADDWFC 03,W
0E4C:  MOVWF  xF5
0E4E:  MOVLW  0A
0E50:  ADDWF  xF4,W
0E52:  MOVWF  01
0E54:  MOVLW  00
0E56:  ADDWFC xF5,W
0E58:  MOVWF  03
0E5A:  MOVF   01,W
0E5C:  ADDLW  1A
0E5E:  MOVWF  FE9
0E60:  MOVLW  00
0E62:  ADDWFC 03,W
0E64:  MOVWF  FEA
0E66:  MOVFF  FEC,03
0E6A:  MOVF   FED,F
0E6C:  MOVFF  FEF,01
0E70:  MOVF   xF3,W
0E72:  SUBWF  03,W
0E74:  BNC   0EE8
0E76:  BNZ   0E7E
0E78:  MOVF   01,W
0E7A:  SUBWF  xF2,W
0E7C:  BC    0EE8
.................... 			if ( channel[c].hvd_reconnect_delay_seconds > 0 ) {
0E7E:  MOVF   xF1,W
0E80:  MULLW  0F
0E82:  MOVF   FF3,W
0E84:  CLRF   xF5
0E86:  MOVWF  xF4
0E88:  MOVLW  0E
0E8A:  ADDWF  xF4,W
0E8C:  MOVWF  01
0E8E:  MOVLW  00
0E90:  ADDWFC xF5,W
0E92:  MOVWF  03
0E94:  MOVF   01,W
0E96:  ADDLW  C4
0E98:  MOVWF  FE9
0E9A:  MOVLW  00
0E9C:  ADDWFC 03,W
0E9E:  MOVWF  FEA
0EA0:  MOVF   FEF,F
0EA2:  BZ    0ECA
.................... 				channel[c].hvd_reconnect_delay_seconds--;
0EA4:  MOVF   xF1,W
0EA6:  MULLW  0F
0EA8:  MOVF   FF3,W
0EAA:  CLRF   xF5
0EAC:  MOVWF  xF4
0EAE:  MOVLW  0E
0EB0:  ADDWF  xF4,W
0EB2:  MOVWF  01
0EB4:  MOVLW  00
0EB6:  ADDWFC xF5,W
0EB8:  MOVWF  03
0EBA:  MOVF   01,W
0EBC:  ADDLW  C4
0EBE:  MOVWF  FE9
0EC0:  MOVLW  00
0EC2:  ADDWFC 03,W
0EC4:  MOVWF  FEA
0EC6:  DECF   FEF,F
.................... 			} else {
0EC8:  BRA    0EE6
.................... 				bit_clear(channel[c].state,CH_STATE_BIT_HVD);
0ECA:  MOVF   xF1,W
0ECC:  MULLW  0F
0ECE:  MOVF   FF3,W
0ED0:  CLRF   xF5
0ED2:  MOVWF  xF4
0ED4:  MOVLW  C4
0ED6:  ADDWF  xF4,W
0ED8:  MOVWF  01
0EDA:  MOVLW  00
0EDC:  ADDWFC xF5,W
0EDE:  MOVFF  01,FE9
0EE2:  MOVWF  FEA
0EE4:  BCF    FEF.4
.................... 			}
.................... 		} else {
0EE6:  BRA    0F0E
.................... 			channel[c].hvd_reconnect_delay_seconds=config.reconnect_delay; /* 5 seconds countdown before reconnecting */
0EE8:  MOVF   xF1,W
0EEA:  MULLW  0F
0EEC:  MOVF   FF3,W
0EEE:  CLRF   xF5
0EF0:  MOVWF  xF4
0EF2:  MOVLW  0E
0EF4:  ADDWF  xF4,W
0EF6:  MOVWF  01
0EF8:  MOVLW  00
0EFA:  ADDWFC xF5,W
0EFC:  MOVWF  03
0EFE:  MOVF   01,W
0F00:  ADDLW  C4
0F02:  MOVWF  FE9
0F04:  MOVLW  00
0F06:  ADDWFC 03,W
0F08:  MOVWF  FEA
0F0A:  MOVFF  1E,FEF
.................... 		}
.................... 
.................... 		if ( adc > config.ch[c].hvd_disconnect_adc ) {
0F0E:  MOVF   xF1,W
0F10:  MULLW  18
0F12:  MOVF   FF3,W
0F14:  CLRF   03
0F16:  ADDLW  09
0F18:  MOVWF  xF4
0F1A:  MOVLW  00
0F1C:  ADDWFC 03,W
0F1E:  MOVWF  xF5
0F20:  MOVLW  06
0F22:  ADDWF  xF4,W
0F24:  MOVWF  01
0F26:  MOVLW  00
0F28:  ADDWFC xF5,W
0F2A:  MOVWF  03
0F2C:  MOVF   01,W
0F2E:  ADDLW  1A
0F30:  MOVWF  FE9
0F32:  MOVLW  00
0F34:  ADDWFC 03,W
0F36:  MOVWF  FEA
0F38:  MOVFF  FEC,03
0F3C:  MOVF   FED,F
0F3E:  MOVFF  FEF,01
0F42:  MOVF   03,W
0F44:  SUBWF  xF3,W
0F46:  BNC   0FD0
0F48:  BNZ   0F50
0F4A:  MOVF   xF2,W
0F4C:  SUBWF  01,W
0F4E:  BC    0FD0
.................... 			if ( channel[c].hvd_disconnect_delay_seconds > 0 ) {
0F50:  MOVF   xF1,W
0F52:  MULLW  0F
0F54:  MOVF   FF3,W
0F56:  CLRF   xF5
0F58:  MOVWF  xF4
0F5A:  MOVLW  0C
0F5C:  ADDWF  xF4,W
0F5E:  MOVWF  01
0F60:  MOVLW  00
0F62:  ADDWFC xF5,W
0F64:  MOVWF  03
0F66:  MOVF   01,W
0F68:  ADDLW  C4
0F6A:  MOVWF  FE9
0F6C:  MOVLW  00
0F6E:  ADDWFC 03,W
0F70:  MOVWF  FEA
0F72:  MOVFF  FEC,F5
0F76:  MOVF   FED,F
0F78:  MOVFF  FEF,F4
0F7C:  MOVF   xF4,F
0F7E:  BNZ   0F84
0F80:  MOVF   xF5,F
0F82:  BZ    0FB2
.................... 				channel[c].hvd_disconnect_delay_seconds--;
0F84:  MOVF   xF1,W
0F86:  MULLW  0F
0F88:  MOVF   FF3,W
0F8A:  CLRF   xF5
0F8C:  MOVWF  xF4
0F8E:  MOVLW  0C
0F90:  ADDWF  xF4,W
0F92:  MOVWF  01
0F94:  MOVLW  00
0F96:  ADDWFC xF5,W
0F98:  MOVWF  03
0F9A:  MOVF   01,W
0F9C:  ADDLW  C4
0F9E:  MOVWF  FE9
0FA0:  MOVLW  00
0FA2:  ADDWFC 03,W
0FA4:  MOVWF  FEA
0FA6:  MOVLW  FF
0FA8:  ADDWF  FEF,F
0FAA:  BC    0FB0
0FAC:  MOVF   FEE,F
0FAE:  DECF   FED,F
.................... 			} else {
0FB0:  BRA    0FCE
.................... 				bit_set(channel[c].state,CH_STATE_BIT_HVD);
0FB2:  MOVF   xF1,W
0FB4:  MULLW  0F
0FB6:  MOVF   FF3,W
0FB8:  CLRF   xF5
0FBA:  MOVWF  xF4
0FBC:  MOVLW  C4
0FBE:  ADDWF  xF4,W
0FC0:  MOVWF  01
0FC2:  MOVLW  00
0FC4:  ADDWFC xF5,W
0FC6:  MOVFF  01,FE9
0FCA:  MOVWF  FEA
0FCC:  BSF    FEF.4
.................... 			}
.................... 		} else {
0FCE:  BRA    103E
.................... 			channel[c].hvd_disconnect_delay_seconds=config.ch[c].hvd_disconnect_delay;
0FD0:  MOVF   xF1,W
0FD2:  MULLW  0F
0FD4:  MOVF   FF3,W
0FD6:  CLRF   xF5
0FD8:  MOVWF  xF4
0FDA:  MOVLW  0C
0FDC:  ADDWF  xF4,W
0FDE:  MOVWF  01
0FE0:  MOVLW  00
0FE2:  ADDWFC xF5,W
0FE4:  MOVWF  03
0FE6:  MOVF   01,W
0FE8:  ADDLW  C4
0FEA:  MOVWF  01
0FEC:  MOVLW  00
0FEE:  ADDWFC 03,F
0FF0:  MOVFF  01,F4
0FF4:  MOVFF  03,F5
0FF8:  MOVF   xF1,W
0FFA:  MULLW  18
0FFC:  MOVF   FF3,W
0FFE:  CLRF   03
1000:  ADDLW  09
1002:  MOVWF  xF6
1004:  MOVLW  00
1006:  ADDWFC 03,W
1008:  MOVWF  xF7
100A:  MOVLW  08
100C:  ADDWF  xF6,W
100E:  MOVWF  01
1010:  MOVLW  00
1012:  ADDWFC xF7,W
1014:  MOVWF  03
1016:  MOVF   01,W
1018:  ADDLW  1A
101A:  MOVWF  FE9
101C:  MOVLW  00
101E:  ADDWFC 03,W
1020:  MOVWF  FEA
1022:  MOVFF  FEC,03
1026:  MOVF   FED,F
1028:  MOVFF  FEF,F6
102C:  MOVFF  F5,FEA
1030:  MOVFF  F4,FE9
1034:  MOVFF  03,FEC
1038:  MOVF   FED,F
103A:  MOVFF  F6,FEF
.................... 		}
.................... 	}
103E:  RETURN 0
.................... 
.................... 
.................... 	/* TODO: implement Low Temperature Disconnect (LTD) and High Temperature Disconnect (HTD) */
.................... }
.................... 
.................... void contactor_set() {
1040:  GOTO   10B8 (RETURN)
.................... 
.................... 
.................... }
.................... 
.................... 
.................... void periodic_millisecond(void) {
.................... 	static int8 uptimeticks=0;
.................... 	static int16 adcTicks=0;
.................... 	static int16 ticks=0;
.................... 
.................... 
.................... 	timers.now_millisecond=0;
1044:  BCF    xBF.2
.................... 
.................... 	/* LED control */
.................... 	if ( 0==timers.led_on_a ) {
1046:  MOVF   xC0,F
1048:  BNZ   1050
.................... 		output_low(LED_A);
104A:  BCF    F94.1
104C:  BCF    F8B.1
.................... 	} else {
104E:  BRA    1056
.................... 		output_high(LED_A);
1050:  BCF    F94.1
1052:  BSF    F8B.1
.................... 		timers.led_on_a--;
1054:  DECF   xC0,F
.................... 	}
.................... 	if ( 0==timers.led_on_b ) {
1056:  MOVF   xC1,F
1058:  BNZ   1060
.................... 		output_low(LED_B);
105A:  BCF    F94.2
105C:  BCF    F8B.2
.................... 	} else {
105E:  BRA    1066
.................... 		output_high(LED_B);
1060:  BCF    F94.2
1062:  BSF    F8B.2
.................... 		timers.led_on_b--;
1064:  DECF   xC1,F
.................... 	}
.................... 
.................... 	/* some other random stuff that we don't need to do every cycle in main */
.................... 	if ( current.interval_milliseconds < 65535 ) {
1066:  INCFSZ xB8,W
1068:  BRA    1070
106A:  INCFSZ xB9,W
106C:  BRA    1070
106E:  BRA    1076
.................... 		current.interval_milliseconds++;
1070:  INCF   xB8,F
1072:  BTFSC  FD8.2
1074:  INCF   xB9,F
.................... 	}
.................... 
.................... 	/* contactor timeout */
.................... 	if ( 0 == timers.contactor_a_powersave ) {
1076:  MOVF   xC2,F
1078:  BNZ   1084
.................... 		output_low(BRIDGE_A_A);
107A:  BCF    F94.3
107C:  BCF    F8B.3
.................... 		output_low(BRIDGE_A_B);
107E:  BCF    F94.4
1080:  BCF    F8B.4
.................... 	} else {
1082:  BRA    1086
.................... 		timers.contactor_a_powersave--;
1084:  DECF   xC2,F
.................... 	}
.................... 	if ( 0 == timers.contactor_b_powersave ) {
1086:  MOVF   xC3,F
1088:  BNZ   1094
.................... 		output_low(BRIDGE_B_A);
108A:  BCF    F94.5
108C:  BCF    F8B.5
.................... 		output_low(BRIDGE_B_B);
108E:  BCF    F94.6
1090:  BCF    F8B.6
.................... 	} else {
1092:  BRA    1096
.................... 		timers.contactor_b_powersave--;
1094:  DECF   xC3,F
.................... 	}
.................... 
.................... 
.................... 	/* seconds */
.................... 	ticks++;
1096:  INCF   xEA,F
1098:  BTFSC  FD8.2
109A:  INCF   xEB,F
.................... 	if ( 1000 == ticks ) {
109C:  MOVF   xEA,W
109E:  SUBLW  E8
10A0:  BNZ   10D2
10A2:  MOVF   xEB,W
10A4:  SUBLW  03
10A6:  BNZ   10D2
.................... 		ticks=0;
10A8:  CLRF   xEB
10AA:  CLRF   xEA
.................... 
.................... 		/* set channe[n].state based on logic */
.................... 		contactor_logic(0);
10AC:  CLRF   xF1
10AE:  RCALL  0A22
.................... 		contactor_logic(1);
10B0:  MOVLW  01
10B2:  MOVWF  xF1
10B4:  RCALL  0A22
.................... 
.................... 		/* set contactor outputs */
.................... 		contactor_set();
10B6:  BRA    1040
.................... 		
.................... 		/* uptime counter */
.................... 		uptimeTicks++;
10B8:  INCF   xE7,F
.................... 		if ( 60 == uptimeTicks ) {
10BA:  MOVF   xE7,W
10BC:  SUBLW  3C
10BE:  BNZ   10D2
.................... 			uptimeTicks=0;
10C0:  CLRF   xE7
.................... 			if ( current.uptime_minutes < 65535 ) 
10C2:  INCFSZ xB6,W
10C4:  BRA    10CC
10C6:  INCFSZ xB7,W
10C8:  BRA    10CC
10CA:  BRA    10D2
.................... 				current.uptime_minutes++;
10CC:  INCF   xB6,F
10CE:  BTFSC  FD8.2
10D0:  INCF   xB7,F
.................... 		}
.................... 	}
.................... 
.................... 	/* ADC sample counter */
.................... 	if ( timers.now_adc_reset_count ) {
10D2:  BTFSS  xBF.1
10D4:  BRA    10DC
.................... 		timers.now_adc_reset_count=0;
10D6:  BCF    xBF.1
.................... 		adcTicks=0;
10D8:  CLRF   xE9
10DA:  CLRF   xE8
.................... 	}
.................... 
.................... 	/* ADC sampling trigger */
.................... 	adcTicks++;
10DC:  INCF   xE8,F
10DE:  BTFSC  FD8.2
10E0:  INCF   xE9,F
.................... 	if ( adcTicks == config.adc_sample_ticks ) {
10E2:  MOVF   1A,W
10E4:  SUBWF  xE8,W
10E6:  BNZ   10F4
10E8:  MOVF   1B,W
10EA:  SUBWF  xE9,W
10EC:  BNZ   10F4
.................... 		adcTicks=0;
10EE:  CLRF   xE9
10F0:  CLRF   xE8
.................... 		timers.now_adc_sample=1;
10F2:  BSF    xBF.0
.................... 	}
10F4:  GOTO   14D8 (RETURN)
.................... 
.................... }
.................... 
.................... void init(void) {
.................... 	int8 buff[32];
.................... 	setup_oscillator(OSC_16MHZ);
*
04B0:  MOVLW  70
04B2:  MOVWF  FD3
04B4:  BCF    F9B.6
04B6:  BCF    F9B.7
.................... 
.................... 	setup_adc(ADC_CLOCK_DIV_16);
04B8:  MOVF   FC0,W
04BA:  ANDLW  C0
04BC:  IORLW  05
04BE:  MOVWF  FC0
04C0:  BSF    FC0.7
04C2:  BSF    FC2.0
.................... 	/* NTC thermistor on sAN2, input voltage divider on sAN4, DIP switch analog on sAN9
.................... 	voltage spans between 0 and Vdd */
.................... 	setup_adc_ports(sAN2 | sAN4 | sAN9,VSS_VDD);
04C4:  MOVLW  14
04C6:  MOVWF  F7E
04C8:  BCF    FC1.0
04CA:  BCF    FC1.1
04CC:  BCF    FC1.2
04CE:  BCF    FC1.3
04D0:  MOVLW  02
04D2:  MOVWF  F7F
.................... 
.................... 	setup_wdt(WDT_512MS);
04D4:  BSF    FD1.0
.................... 
.................... 	set_tris_a(0b00111111);
04D6:  MOVLW  3F
04D8:  MOVWF  F92
.................... 	set_tris_b(0b01110000);
04DA:  MOVLW  70
04DC:  MOVWF  F93
.................... 	set_tris_c(0b10000001);
04DE:  MOVLW  81
04E0:  MOVWF  F94
.................... //               76543210
.................... 
.................... 	port_a_pullups(0b00110000);
04E2:  MOVLW  30
04E4:  MOVWF  F77
04E6:  BCF    FF1.7
.................... 	port_b_pullups(0b00000000);
04E8:  CLRF   F78
.................... //                   76543210
.................... 
.................... 	/* data structure initialization */
.................... 	/* all initialized to 0 on declaration. Just do this if need non-zero */
.................... 	channel[0].command_off_seconds=65535;
04EA:  SETF   xCA
04EC:  SETF   xC9
.................... 	channel[1].command_off_seconds=65535;
04EE:  SETF   xD9
04F0:  SETF   xD8
.................... 	channel[0].command_on_seconds =65535;
04F2:  SETF   xC6
04F4:  SETF   xC5
.................... 	channel[1].command_on_seconds =65535;
04F6:  SETF   xD5
04F8:  SETF   xD4
.................... 
.................... 
.................... 	/* get our compiled date from constant */
.................... 	strcpy(buff,__DATE__);
04FA:  CLRF   FEA
04FC:  MOVLW  F1
04FE:  MOVWF  FE9
0500:  MOVLW  00
0502:  RCALL  00BA
0504:  TBLRD*-
0506:  TBLRD*+
0508:  MOVF   FF5,W
050A:  MOVWF  FEE
050C:  IORLW  00
050E:  BNZ   0506
.................... 	current.compile_day =(buff[0]-'0')*10;
0510:  MOVLW  30
0512:  SUBWF  xF1,W
0514:  MULLW  0A
0516:  MOVFF  FF3,BD
.................... 	current.compile_day+=(buff[1]-'0');
051A:  MOVLW  30
051C:  SUBWF  xF2,W
051E:  ADDWF  xBD,F
.................... 	/* determine month ... how annoying */
.................... 	if ( 'J'==buff[3] ) {
0520:  MOVF   xF4,W
0522:  SUBLW  4A
0524:  BNZ   0544
.................... 		if ( 'A'==buff[4] )
0526:  MOVF   xF5,W
0528:  SUBLW  41
052A:  BNZ   0532
.................... 			current.compile_month=1;
052C:  MOVLW  01
052E:  MOVWF  xBC
0530:  BRA    0542
.................... 		else if ( 'N'==buff[5] )
0532:  MOVF   xF6,W
0534:  SUBLW  4E
0536:  BNZ   053E
.................... 			current.compile_month=6;
0538:  MOVLW  06
053A:  MOVWF  xBC
053C:  BRA    0542
.................... 		else
.................... 			current.compile_month=7;
053E:  MOVLW  07
0540:  MOVWF  xBC
.................... 	} else if ( 'A'==buff[3] ) {
0542:  BRA    05B2
0544:  MOVF   xF4,W
0546:  SUBLW  41
0548:  BNZ   055C
.................... 		if ( 'P'==buff[4] )
054A:  MOVF   xF5,W
054C:  SUBLW  50
054E:  BNZ   0556
.................... 			current.compile_month=4;
0550:  MOVLW  04
0552:  MOVWF  xBC
0554:  BRA    055A
.................... 		else
.................... 			current.compile_month=8;
0556:  MOVLW  08
0558:  MOVWF  xBC
.................... 	} else if ( 'M'==buff[3] ) {
055A:  BRA    05B2
055C:  MOVF   xF4,W
055E:  SUBLW  4D
0560:  BNZ   0574
.................... 		if ( 'R'==buff[5] )
0562:  MOVF   xF6,W
0564:  SUBLW  52
0566:  BNZ   056E
.................... 			current.compile_month=3;
0568:  MOVLW  03
056A:  MOVWF  xBC
056C:  BRA    0572
.................... 		else
.................... 			current.compile_month=5;
056E:  MOVLW  05
0570:  MOVWF  xBC
.................... 	} else if ( 'F'==buff[3] ) {
0572:  BRA    05B2
0574:  MOVF   xF4,W
0576:  SUBLW  46
0578:  BNZ   0580
.................... 		current.compile_month=2;
057A:  MOVLW  02
057C:  MOVWF  xBC
.................... 	} else if ( 'S'==buff[3] ) {
057E:  BRA    05B2
0580:  MOVF   xF4,W
0582:  SUBLW  53
0584:  BNZ   058C
.................... 		current.compile_month=9;
0586:  MOVLW  09
0588:  MOVWF  xBC
.................... 	} else if ( 'O'==buff[3] ) {
058A:  BRA    05B2
058C:  MOVF   xF4,W
058E:  SUBLW  4F
0590:  BNZ   0598
.................... 		current.compile_month=10;
0592:  MOVLW  0A
0594:  MOVWF  xBC
.................... 	} else if ( 'N'==buff[3] ) {
0596:  BRA    05B2
0598:  MOVF   xF4,W
059A:  SUBLW  4E
059C:  BNZ   05A4
.................... 		current.compile_month=11;
059E:  MOVLW  0B
05A0:  MOVWF  xBC
.................... 	} else if ( 'D'==buff[3] ) {
05A2:  BRA    05B2
05A4:  MOVF   xF4,W
05A6:  SUBLW  44
05A8:  BNZ   05B0
.................... 		current.compile_month=12;
05AA:  MOVLW  0C
05AC:  MOVWF  xBC
.................... 	} else {
05AE:  BRA    05B2
.................... 		/* error parsing, shouldn't happen */
.................... 		current.compile_month=255;
05B0:  SETF   xBC
.................... 	}
.................... 	current.compile_year =(buff[7]-'0')*10;
05B2:  MOVLW  30
05B4:  SUBWF  xF8,W
05B6:  MULLW  0A
05B8:  MOVFF  FF3,BB
.................... 	current.compile_year+=(buff[8]-'0');
05BC:  MOVLW  30
05BE:  SUBWF  xF9,W
05C0:  ADDWF  xBB,F
.................... 
.................... 
.................... 	/* one periodic interrupt @ 1mS. Generated from system 16 MHz clock */
.................... 	/* prescale=16, match=249, postscale=1. Match is 249 because when match occurs, one cycle is lost */
.................... 	setup_timer_2(T2_DIV_BY_16,249,1);
05C2:  MOVLW  00
05C4:  IORLW  06
05C6:  MOVWF  FCA
05C8:  MOVLW  F9
05CA:  MOVWF  FCB
.................... 
.................... 	enable_interrupts(INT_TIMER2);
05CC:  BSF    F9D.1
.................... 
.................... 	/* set I2C slave address, which is always an even number */
.................... 	i2c_slaveaddr(0x3e + (read_dip_switch()<<1) );
05CE:  RCALL  0440
05D0:  BCF    FD8.0
05D2:  RLCF   01,W
05D4:  ADDLW  3E
05D6:  MOVLB  1
05D8:  MOVWF  FC8
05DA:  MOVLB  0
05DC:  GOTO   138C (RETURN)
.................... }
.................... 
.................... 
.................... void main(void) {
*
12F4:  CLRF   FF8
12F6:  BCF    FD0.7
12F8:  BSF    07.7
12FA:  BSF    F93.6
12FC:  BSF    F93.4
12FE:  CLRF   FC8
1300:  MOVLW  36
1302:  MOVWF  FC6
1304:  BSF    FC5.0
1306:  BSF    FC5.7
1308:  CLRF   19
130A:  BSF    FB8.3
130C:  MOVLW  A0
130E:  MOVWF  FAF
1310:  MOVLW  01
1312:  MOVWF  FB0
1314:  MOVLW  A6
1316:  MOVWF  FAC
1318:  MOVLW  90
131A:  MOVWF  FAB
131C:  MOVLW  03
131E:  MOVWF  xE6
1320:  CLRF   xED
1322:  CLRF   xEC
1324:  MOVLW  00
1326:  MOVWF  F7E
1328:  BCF    FC1.0
132A:  BCF    FC1.1
132C:  BCF    FC1.2
132E:  BCF    FC1.3
1330:  MOVWF  F7F
1332:  CLRF   F6C
1334:  CLRF   F6B
1336:  CLRF   F6D
1338:  BRA    134A
133A:  DATA C8,40
133C:  DATA 1A,00
133E:  DATA 03,00
1340:  DATA E3,00
1342:  DATA 00,00
1344:  DATA 05,40
1346:  DATA E7,00
1348:  DATA 00,00
134A:  MOVLW  00
134C:  MOVWF  FF8
134E:  MOVLW  13
1350:  MOVWF  FF7
1352:  MOVLW  3A
1354:  MOVWF  FF6
1356:  TBLRD*+
1358:  MOVF   FF5,W
135A:  MOVWF  00
135C:  XORLW  00
135E:  BZ    1386
1360:  TBLRD*+
1362:  MOVF   FF5,W
1364:  MOVWF  01
1366:  BTFSC  FE8.7
1368:  BRA    1374
136A:  ANDLW  3F
136C:  MOVWF  FEA
136E:  TBLRD*+
1370:  MOVFF  FF5,FE9
1374:  BTFSC  01.6
1376:  TBLRD*+
1378:  BTFSS  01.6
137A:  TBLRD*+
137C:  MOVFF  FF5,FEE
1380:  DCFSNZ 00,F
1382:  BRA    1356
1384:  BRA    1378
1386:  CLRF   FF8
.................... 	int8 i;
.................... 	int8 last_a, last_b;
.................... 
.................... 	init();
1388:  GOTO   04B0
.................... 
.................... 
.................... 	/* read parameters from EEPROM and write defaults if CRC doesn't match */
.................... 	read_param_file();
138C:  GOTO   088C
.................... 
.................... 	if ( config.startup_power_on_delay > 100 )
1390:  MOVF   1D,F
1392:  BNZ   139A
1394:  MOVF   1C,W
1396:  SUBLW  64
1398:  BC    13A0
.................... 		config.startup_power_on_delay=100;
139A:  CLRF   1D
139C:  MOVLW  64
139E:  MOVWF  1C
.................... 
.................... 	/* flash on startup */
.................... 	for ( i=0 ; i<config.startup_power_on_delay ; i++ ) {
13A0:  CLRF   xEE
13A2:  MOVF   1D,F
13A4:  BNZ   13AC
13A6:  MOVF   1C,W
13A8:  SUBWF  xEE,W
13AA:  BC    13D2
.................... 		restart_wdt();
13AC:  CLRWDT
.................... 		output_high(LED_A);
13AE:  BCF    F94.1
13B0:  BSF    F8B.1
.................... 		delay_ms(200);
13B2:  MOVLW  C8
13B4:  MOVLB  1
13B6:  MOVWF  x13
13B8:  MOVLB  0
13BA:  CALL   0416
.................... 		output_low(LED_A);
13BE:  BCF    F94.1
13C0:  BCF    F8B.1
.................... 		delay_ms(200);
13C2:  MOVLW  C8
13C4:  MOVLB  1
13C6:  MOVWF  x13
13C8:  MOVLB  0
13CA:  CALL   0416
13CE:  INCF   xEE,F
13D0:  BRA    13A2
.................... 	}
.................... 
.................... 	fprintf(STREAM_FTDI,"# dcswc_module_latching_contactor %s\r\n# ",__DATE__);
13D2:  MOVLW  B0
13D4:  MOVWF  FF6
13D6:  MOVLW  01
13D8:  MOVWF  FF7
13DA:  MOVLW  22
13DC:  MOVWF  xF4
13DE:  CALL   08C6
13E2:  MOVLW  DA
13E4:  MOVWF  FF6
13E6:  MOVLW  01
13E8:  MOVWF  FF7
13EA:  CALL   08E6
13EE:  MOVLW  D4
13F0:  MOVWF  FF6
13F2:  MOVLW  01
13F4:  MOVWF  FF7
13F6:  MOVLW  04
13F8:  MOVWF  xF4
13FA:  CALL   08C6
.................... 	switch ( restart_cause ) {
13FE:  MOVLW  07
1400:  SUBWF  00,W
1402:  BZ    1428
1404:  MOVLW  0B
1406:  SUBWF  00,W
1408:  BZ    1436
140A:  MOVLW  0F
140C:  SUBWF  00,W
140E:  BZ    1444
1410:  MOVLW  0C
1412:  SUBWF  00,W
1414:  BZ    1452
1416:  MOVLW  0E
1418:  SUBWF  00,W
141A:  BZ    1460
141C:  MOVLW  03
141E:  SUBWF  00,W
1420:  BZ    146E
1422:  MOVF   00,F
1424:  BZ    147C
1426:  BRA    148A
.................... 		case WDT_TIMEOUT:       fprintf(STREAM_FTDI,"WDT TIMEOUT"); break;
1428:  MOVLW  E4
142A:  MOVWF  FF6
142C:  MOVLW  01
142E:  MOVWF  FF7
1430:  CALL   08E6
1434:  BRA    1496
.................... 		case MCLR_FROM_SLEEP:   fprintf(STREAM_FTDI,"MCLR FROM SLEEP"); break;
1436:  MOVLW  F0
1438:  MOVWF  FF6
143A:  MOVLW  01
143C:  MOVWF  FF7
143E:  CALL   08E6
1442:  BRA    1496
.................... 		case MCLR_FROM_RUN:     fprintf(STREAM_FTDI,"MCLR FROM RUN"); break;
1444:  MOVLW  00
1446:  MOVWF  FF6
1448:  MOVLW  02
144A:  MOVWF  FF7
144C:  CALL   08E6
1450:  BRA    1496
.................... 		case NORMAL_POWER_UP:   fprintf(STREAM_FTDI,"NORMAL POWER UP"); break;
1452:  MOVLW  0E
1454:  MOVWF  FF6
1456:  MOVLW  02
1458:  MOVWF  FF7
145A:  CALL   08E6
145E:  BRA    1496
.................... 		case BROWNOUT_RESTART:  fprintf(STREAM_FTDI,"BROWNOUT RESTART"); break;
1460:  MOVLW  1E
1462:  MOVWF  FF6
1464:  MOVLW  02
1466:  MOVWF  FF7
1468:  CALL   08E6
146C:  BRA    1496
.................... 		case WDT_FROM_SLEEP:    fprintf(STREAM_FTDI,"WDT FROM SLEEP"); break;
146E:  MOVLW  30
1470:  MOVWF  FF6
1472:  MOVLW  02
1474:  MOVWF  FF7
1476:  CALL   08E6
147A:  BRA    1496
.................... 		case RESET_INSTRUCTION: fprintf(STREAM_FTDI,"RESET INSTRUCTION"); break;
147C:  MOVLW  40
147E:  MOVWF  FF6
1480:  MOVLW  02
1482:  MOVWF  FF7
1484:  CALL   08E6
1488:  BRA    1496
.................... 		default:                fprintf(STREAM_FTDI,"UNKNOWN!");
148A:  MOVLW  52
148C:  MOVWF  FF6
148E:  MOVLW  02
1490:  MOVWF  FF7
1492:  CALL   08E6
.................... 	}
.................... 	fprintf(STREAM_FTDI,"\r\n");
1496:  MOVLW  0D
1498:  BTFSS  F9E.4
149A:  BRA    1498
149C:  MOVWF  FAD
149E:  MOVLW  0A
14A0:  BTFSS  F9E.4
14A2:  BRA    14A0
14A4:  MOVWF  FAD
.................... 
.................... 	timers.led_on_a=500;
14A6:  MOVLW  F4
14A8:  MOVWF  xC0
.................... 
.................... 	enable_interrupts(GLOBAL);
14AA:  MOVLW  C0
14AC:  IORWF  FF2,F
.................... 
.................... 	/* Prime ADC filter */
.................... 	for ( i=0 ; i<30 ; i++ ) {
14AE:  CLRF   xEE
14B0:  MOVF   xEE,W
14B2:  SUBLW  1D
14B4:  BNC   14BE
.................... 		adc_update();
14B6:  CALL   0908
14BA:  INCF   xEE,F
14BC:  BRA    14B0
.................... 	}
.................... 
.................... 	last_a = ! input(SW_OVERRIDE_A);
14BE:  BSF    F92.5
14C0:  CLRF   xEF
14C2:  BTFSS  F80.5
14C4:  INCF   xEF,F
.................... 	last_b = ! input(SW_OVERRIDE_B);
14C6:  BSF    F92.4
14C8:  CLRF   xF0
14CA:  BTFSS  F80.4
14CC:  INCF   xF0,F
.................... 
.................... 
.................... 	/* enable I2C slave interrupt */
.................... 	enable_interrupts(INT_SSP);
14CE:  BSF    F9D.3
.................... 
.................... 	for ( ; ; ) {
.................... 		restart_wdt();
14D0:  CLRWDT
.................... 
.................... 		if ( timers.now_millisecond ) {
14D2:  BTFSS  xBF.2
14D4:  BRA    14D8
.................... 			periodic_millisecond();
14D6:  BRA    1044
.................... 		}
.................... 
.................... 		if ( kbhit() ) {
14D8:  BTFSS  F9E.5
14DA:  BRA    1902
.................... 			getc();
14DC:  BRA    10F8
.................... 			fprintf(STREAM_FTDI,"# read_dip_switch()=%u\r\n",read_dip_switch());
14DE:  CALL   0440
14E2:  MOVFF  01,F1
14E6:  MOVLW  5C
14E8:  MOVWF  FF6
14EA:  MOVLW  02
14EC:  MOVWF  FF7
14EE:  MOVLW  14
14F0:  MOVWF  xF4
14F2:  CALL   08C6
14F6:  MOVFF  F1,F2
14FA:  MOVLW  1B
14FC:  MOVWF  xF3
14FE:  RCALL  1138
1500:  MOVLW  0D
1502:  BTFSS  F9E.4
1504:  BRA    1502
1506:  MOVWF  FAD
1508:  MOVLW  0A
150A:  BTFSS  F9E.4
150C:  BRA    150A
150E:  MOVWF  FAD
.................... 			fprintf(STREAM_FTDI,"#    vin adc=%lu\r\n",adc_get(0));
1510:  CLRF   xF4
1512:  CALL   09A6
1516:  MOVFF  02,F2
151A:  MOVFF  01,F1
151E:  MOVLW  76
1520:  MOVWF  FF6
1522:  MOVLW  02
1524:  MOVWF  FF7
1526:  MOVLW  0D
1528:  MOVWF  xF4
152A:  CALL   08C6
152E:  MOVLW  10
1530:  MOVWF  FE9
1532:  MOVFF  F2,F4
1536:  MOVFF  F1,F3
153A:  RCALL  11A4
153C:  MOVLW  0D
153E:  BTFSS  F9E.4
1540:  BRA    153E
1542:  MOVWF  FAD
1544:  MOVLW  0A
1546:  BTFSS  F9E.4
1548:  BRA    1546
154A:  MOVWF  FAD
.................... 			fprintf(STREAM_FTDI,"#   temp adc=%lu\r\n",adc_get(1));
154C:  MOVLW  01
154E:  MOVWF  xF4
1550:  CALL   09A6
1554:  MOVFF  02,F2
1558:  MOVFF  01,F1
155C:  MOVLW  8A
155E:  MOVWF  FF6
1560:  MOVLW  02
1562:  MOVWF  FF7
1564:  MOVLW  0D
1566:  MOVWF  xF4
1568:  CALL   08C6
156C:  MOVLW  10
156E:  MOVWF  FE9
1570:  MOVFF  F2,F4
1574:  MOVFF  F1,F3
1578:  RCALL  11A4
157A:  MOVLW  0D
157C:  BTFSS  F9E.4
157E:  BRA    157C
1580:  MOVWF  FAD
1582:  MOVLW  0A
1584:  BTFSS  F9E.4
1586:  BRA    1584
1588:  MOVWF  FAD
.................... 			fprintf(STREAM_FTDI,"# dip sw adc=%lu\r\n",adc_get(2));
158A:  MOVLW  02
158C:  MOVWF  xF4
158E:  CALL   09A6
1592:  MOVFF  02,F2
1596:  MOVFF  01,F1
159A:  MOVLW  9E
159C:  MOVWF  FF6
159E:  MOVLW  02
15A0:  MOVWF  FF7
15A2:  MOVLW  0D
15A4:  MOVWF  xF4
15A6:  CALL   08C6
15AA:  MOVLW  10
15AC:  MOVWF  FE9
15AE:  MOVFF  F2,F4
15B2:  MOVFF  F1,F3
15B6:  RCALL  11A4
15B8:  MOVLW  0D
15BA:  BTFSS  F9E.4
15BC:  BRA    15BA
15BE:  MOVWF  FAD
15C0:  MOVLW  0A
15C2:  BTFSS  F9E.4
15C4:  BRA    15C2
15C6:  MOVWF  FAD
.................... 
.................... 			for ( i=0 ; i<2 ; i++ ) {
15C8:  CLRF   xEE
15CA:  MOVF   xEE,W
15CC:  SUBLW  01
15CE:  BTFSS  FD8.0
15D0:  BRA    1902
.................... 				restart_wdt();
15D2:  CLRWDT
.................... 				fprintf(STREAM_FTDI,"# channel[%u]\r\n",i);
15D4:  MOVLW  B2
15D6:  MOVWF  FF6
15D8:  MOVLW  02
15DA:  MOVWF  FF7
15DC:  MOVLW  0A
15DE:  MOVWF  xF4
15E0:  CALL   08C6
15E4:  MOVFF  EE,F2
15E8:  MOVLW  1B
15EA:  MOVWF  xF3
15EC:  RCALL  1138
15EE:  MOVLW  BE
15F0:  MOVWF  FF6
15F2:  MOVLW  02
15F4:  MOVWF  FF7
15F6:  MOVLW  03
15F8:  MOVWF  xF4
15FA:  CALL   08C6
.................... 				fprintf(STREAM_FTDI,"#                        state=0x%02x\r\n",channel[i].state);
15FE:  MOVF   xEE,W
1600:  MULLW  0F
1602:  MOVF   FF3,W
1604:  CLRF   xF2
1606:  MOVWF  xF1
1608:  MOVLW  C4
160A:  ADDWF  xF1,W
160C:  MOVWF  FE9
160E:  MOVLW  00
1610:  ADDWFC xF2,W
1612:  MOVWF  FEA
1614:  MOVFF  FEF,F3
1618:  MOVLW  C2
161A:  MOVWF  FF6
161C:  MOVLW  02
161E:  MOVWF  FF7
1620:  MOVLW  21
1622:  MOVWF  xF4
1624:  CALL   08C6
1628:  MOVFF  F3,F4
162C:  MOVLW  57
162E:  MOVWF  xF5
1630:  BRA    1250
1632:  MOVLW  0D
1634:  BTFSS  F9E.4
1636:  BRA    1634
1638:  MOVWF  FAD
163A:  MOVLW  0A
163C:  BTFSS  F9E.4
163E:  BRA    163C
1640:  MOVWF  FAD
.................... 				fprintf(STREAM_FTDI,"#           command_on_seconds=%lu\r\n",channel[i].command_on_seconds);
1642:  MOVF   xEE,W
1644:  MULLW  0F
1646:  MOVF   FF3,W
1648:  CLRF   xF2
164A:  MOVWF  xF1
164C:  MOVLW  01
164E:  ADDWF  xF1,W
1650:  MOVWF  01
1652:  MOVLW  00
1654:  ADDWFC xF2,W
1656:  MOVWF  03
1658:  MOVF   01,W
165A:  ADDLW  C4
165C:  MOVWF  FE9
165E:  MOVLW  00
1660:  ADDWFC 03,W
1662:  MOVWF  FEA
1664:  MOVFF  FEC,F2
1668:  MOVF   FED,F
166A:  MOVFF  FEF,F1
166E:  MOVLW  EA
1670:  MOVWF  FF6
1672:  MOVLW  02
1674:  MOVWF  FF7
1676:  MOVLW  1F
1678:  MOVWF  xF4
167A:  CALL   08C6
167E:  MOVLW  10
1680:  MOVWF  FE9
1682:  MOVFF  F2,F4
1686:  MOVFF  F1,F3
168A:  RCALL  11A4
168C:  MOVLW  0D
168E:  BTFSS  F9E.4
1690:  BRA    168E
1692:  MOVWF  FAD
1694:  MOVLW  0A
1696:  BTFSS  F9E.4
1698:  BRA    1696
169A:  MOVWF  FAD
.................... 				fprintf(STREAM_FTDI,"#      command_on_hold_seconds=%lu\r\n",channel[i].command_on_hold_seconds);
169C:  MOVF   xEE,W
169E:  MULLW  0F
16A0:  MOVF   FF3,W
16A2:  CLRF   xF2
16A4:  MOVWF  xF1
16A6:  MOVLW  03
16A8:  ADDWF  xF1,W
16AA:  MOVWF  01
16AC:  MOVLW  00
16AE:  ADDWFC xF2,W
16B0:  MOVWF  03
16B2:  MOVF   01,W
16B4:  ADDLW  C4
16B6:  MOVWF  FE9
16B8:  MOVLW  00
16BA:  ADDWFC 03,W
16BC:  MOVWF  FEA
16BE:  MOVFF  FEC,F2
16C2:  MOVF   FED,F
16C4:  MOVFF  FEF,F1
16C8:  MOVLW  10
16CA:  MOVWF  FF6
16CC:  MOVLW  03
16CE:  MOVWF  FF7
16D0:  MOVLW  1F
16D2:  MOVWF  xF4
16D4:  CALL   08C6
16D8:  MOVLW  10
16DA:  MOVWF  FE9
16DC:  MOVFF  F2,F4
16E0:  MOVFF  F1,F3
16E4:  RCALL  11A4
16E6:  MOVLW  0D
16E8:  BTFSS  F9E.4
16EA:  BRA    16E8
16EC:  MOVWF  FAD
16EE:  MOVLW  0A
16F0:  BTFSS  F9E.4
16F2:  BRA    16F0
16F4:  MOVWF  FAD
.................... 
.................... 				fprintf(STREAM_FTDI,"#          command_off_seconds=%lu\r\n",channel[i].command_off_seconds);
16F6:  MOVF   xEE,W
16F8:  MULLW  0F
16FA:  MOVF   FF3,W
16FC:  CLRF   xF2
16FE:  MOVWF  xF1
1700:  MOVLW  05
1702:  ADDWF  xF1,W
1704:  MOVWF  01
1706:  MOVLW  00
1708:  ADDWFC xF2,W
170A:  MOVWF  03
170C:  MOVF   01,W
170E:  ADDLW  C4
1710:  MOVWF  FE9
1712:  MOVLW  00
1714:  ADDWFC 03,W
1716:  MOVWF  FEA
1718:  MOVFF  FEC,F2
171C:  MOVF   FED,F
171E:  MOVFF  FEF,F1
1722:  MOVLW  36
1724:  MOVWF  FF6
1726:  MOVLW  03
1728:  MOVWF  FF7
172A:  MOVLW  1F
172C:  MOVWF  xF4
172E:  CALL   08C6
1732:  MOVLW  10
1734:  MOVWF  FE9
1736:  MOVFF  F2,F4
173A:  MOVFF  F1,F3
173E:  RCALL  11A4
1740:  MOVLW  0D
1742:  BTFSS  F9E.4
1744:  BRA    1742
1746:  MOVWF  FAD
1748:  MOVLW  0A
174A:  BTFSS  F9E.4
174C:  BRA    174A
174E:  MOVWF  FAD
.................... 				fprintf(STREAM_FTDI,"#     command_off_hold_seconds=%lu\r\n",channel[i].command_off_hold_seconds);
1750:  MOVF   xEE,W
1752:  MULLW  0F
1754:  MOVF   FF3,W
1756:  CLRF   xF2
1758:  MOVWF  xF1
175A:  MOVLW  07
175C:  ADDWF  xF1,W
175E:  MOVWF  01
1760:  MOVLW  00
1762:  ADDWFC xF2,W
1764:  MOVWF  03
1766:  MOVF   01,W
1768:  ADDLW  C4
176A:  MOVWF  FE9
176C:  MOVLW  00
176E:  ADDWFC 03,W
1770:  MOVWF  FEA
1772:  MOVFF  FEC,F2
1776:  MOVF   FED,F
1778:  MOVFF  FEF,F1
177C:  MOVLW  5C
177E:  MOVWF  FF6
1780:  MOVLW  03
1782:  MOVWF  FF7
1784:  MOVLW  1F
1786:  MOVWF  xF4
1788:  CALL   08C6
178C:  MOVLW  10
178E:  MOVWF  FE9
1790:  MOVFF  F2,F4
1794:  MOVFF  F1,F3
1798:  RCALL  11A4
179A:  MOVLW  0D
179C:  BTFSS  F9E.4
179E:  BRA    179C
17A0:  MOVWF  FAD
17A2:  MOVLW  0A
17A4:  BTFSS  F9E.4
17A6:  BRA    17A4
17A8:  MOVWF  FAD
.................... 
.................... 				fprintf(STREAM_FTDI,"# lvd_disconnect_delay_seconds=%lu\r\n",channel[i].lvd_disconnect_delay_seconds);
17AA:  MOVF   xEE,W
17AC:  MULLW  0F
17AE:  MOVF   FF3,W
17B0:  CLRF   xF2
17B2:  MOVWF  xF1
17B4:  MOVLW  09
17B6:  ADDWF  xF1,W
17B8:  MOVWF  01
17BA:  MOVLW  00
17BC:  ADDWFC xF2,W
17BE:  MOVWF  03
17C0:  MOVF   01,W
17C2:  ADDLW  C4
17C4:  MOVWF  FE9
17C6:  MOVLW  00
17C8:  ADDWFC 03,W
17CA:  MOVWF  FEA
17CC:  MOVFF  FEC,F2
17D0:  MOVF   FED,F
17D2:  MOVFF  FEF,F1
17D6:  MOVLW  82
17D8:  MOVWF  FF6
17DA:  MOVLW  03
17DC:  MOVWF  FF7
17DE:  MOVLW  1F
17E0:  MOVWF  xF4
17E2:  CALL   08C6
17E6:  MOVLW  10
17E8:  MOVWF  FE9
17EA:  MOVFF  F2,F4
17EE:  MOVFF  F1,F3
17F2:  RCALL  11A4
17F4:  MOVLW  0D
17F6:  BTFSS  F9E.4
17F8:  BRA    17F6
17FA:  MOVWF  FAD
17FC:  MOVLW  0A
17FE:  BTFSS  F9E.4
1800:  BRA    17FE
1802:  MOVWF  FAD
.................... 				fprintf(STREAM_FTDI,"#  lvd_reconnect_delay_seconds=%u\r\n",channel[i].lvd_reconnect_delay_seconds);
1804:  MOVF   xEE,W
1806:  MULLW  0F
1808:  MOVF   FF3,W
180A:  CLRF   xF2
180C:  MOVWF  xF1
180E:  MOVLW  0B
1810:  ADDWF  xF1,W
1812:  MOVWF  01
1814:  MOVLW  00
1816:  ADDWFC xF2,W
1818:  MOVWF  03
181A:  MOVF   01,W
181C:  ADDLW  C4
181E:  MOVWF  FE9
1820:  MOVLW  00
1822:  ADDWFC 03,W
1824:  MOVWF  FEA
1826:  MOVFF  FEF,F1
182A:  MOVLW  A8
182C:  MOVWF  FF6
182E:  MOVLW  03
1830:  MOVWF  FF7
1832:  MOVLW  1F
1834:  MOVWF  xF4
1836:  CALL   08C6
183A:  MOVFF  F1,F2
183E:  MOVLW  1B
1840:  MOVWF  xF3
1842:  RCALL  1138
1844:  MOVLW  0D
1846:  BTFSS  F9E.4
1848:  BRA    1846
184A:  MOVWF  FAD
184C:  MOVLW  0A
184E:  BTFSS  F9E.4
1850:  BRA    184E
1852:  MOVWF  FAD
.................... 
.................... 				fprintf(STREAM_FTDI,"# hvd_disconnect_delay_seconds=%lu\r\n",channel[i].hvd_disconnect_delay_seconds);
1854:  MOVF   xEE,W
1856:  MULLW  0F
1858:  MOVF   FF3,W
185A:  CLRF   xF2
185C:  MOVWF  xF1
185E:  MOVLW  0C
1860:  ADDWF  xF1,W
1862:  MOVWF  01
1864:  MOVLW  00
1866:  ADDWFC xF2,W
1868:  MOVWF  03
186A:  MOVF   01,W
186C:  ADDLW  C4
186E:  MOVWF  FE9
1870:  MOVLW  00
1872:  ADDWFC 03,W
1874:  MOVWF  FEA
1876:  MOVFF  FEC,F2
187A:  MOVF   FED,F
187C:  MOVFF  FEF,F1
1880:  MOVLW  CC
1882:  MOVWF  FF6
1884:  MOVLW  03
1886:  MOVWF  FF7
1888:  MOVLW  1F
188A:  MOVWF  xF4
188C:  CALL   08C6
1890:  MOVLW  10
1892:  MOVWF  FE9
1894:  MOVFF  F2,F4
1898:  MOVFF  F1,F3
189C:  RCALL  11A4
189E:  MOVLW  0D
18A0:  BTFSS  F9E.4
18A2:  BRA    18A0
18A4:  MOVWF  FAD
18A6:  MOVLW  0A
18A8:  BTFSS  F9E.4
18AA:  BRA    18A8
18AC:  MOVWF  FAD
.................... 				fprintf(STREAM_FTDI,"#  hvd_reconnect_delay_seconds=%u\r\n",channel[i].hvd_reconnect_delay_seconds);
18AE:  MOVF   xEE,W
18B0:  MULLW  0F
18B2:  MOVF   FF3,W
18B4:  CLRF   xF2
18B6:  MOVWF  xF1
18B8:  MOVLW  0E
18BA:  ADDWF  xF1,W
18BC:  MOVWF  01
18BE:  MOVLW  00
18C0:  ADDWFC xF2,W
18C2:  MOVWF  03
18C4:  MOVF   01,W
18C6:  ADDLW  C4
18C8:  MOVWF  FE9
18CA:  MOVLW  00
18CC:  ADDWFC 03,W
18CE:  MOVWF  FEA
18D0:  MOVFF  FEF,F1
18D4:  MOVLW  F2
18D6:  MOVWF  FF6
18D8:  MOVLW  03
18DA:  MOVWF  FF7
18DC:  MOVLW  1F
18DE:  MOVWF  xF4
18E0:  CALL   08C6
18E4:  MOVFF  F1,F2
18E8:  MOVLW  1B
18EA:  MOVWF  xF3
18EC:  RCALL  1138
18EE:  MOVLW  0D
18F0:  BTFSS  F9E.4
18F2:  BRA    18F0
18F4:  MOVWF  FAD
18F6:  MOVLW  0A
18F8:  BTFSS  F9E.4
18FA:  BRA    18F8
18FC:  MOVWF  FAD
18FE:  INCF   xEE,F
1900:  BRA    15CA
.................... 			}
.................... 
.................... 		}
.................... 
.................... 		if ( input(SW_OVERRIDE_A) != last_a ) {
1902:  BSF    F92.5
1904:  MOVLW  00
1906:  BTFSC  F80.5
1908:  MOVLW  01
190A:  SUBWF  xEF,W
190C:  BZ    1926
.................... 			last_a=input(SW_OVERRIDE_A);
190E:  BSF    F92.5
1910:  CLRF   xEF
1912:  BTFSC  F80.5
1914:  INCF   xEF,F
.................... 
.................... 			if ( last_a ) {
1916:  MOVF   xEF,F
1918:  BZ    1922
.................... 				timers.led_on_a=500;
191A:  MOVLW  F4
191C:  MOVWF  xC0
.................... 				contactor_on_a();
191E:  BRA    1294
.................... 			} else {
1920:  BRA    1926
.................... 				timers.led_on_a=0;
1922:  CLRF   xC0
.................... 				contactor_off_a();
1924:  BRA    12AC
.................... 			}
.................... 		}
.................... 
.................... 
.................... 		if ( input(SW_OVERRIDE_B) != last_b ) {
1926:  BSF    F92.4
1928:  MOVLW  00
192A:  BTFSC  F80.4
192C:  MOVLW  01
192E:  SUBWF  xF0,W
1930:  BZ    194A
.................... 			last_B=input(SW_OVERRIDE_B);
1932:  BSF    F92.4
1934:  CLRF   xF0
1936:  BTFSC  F80.4
1938:  INCF   xF0,F
.................... 
.................... 			if ( last_b ) {
193A:  MOVF   xF0,F
193C:  BZ    1946
.................... 				timers.led_on_b=500;
193E:  MOVLW  F4
1940:  MOVWF  xC1
.................... 				contactor_on_b();
1942:  BRA    12C4
.................... 			} else {
1944:  BRA    194A
.................... 				timers.led_on_b=0;
1946:  CLRF   xC1
.................... 				contactor_off_b();
1948:  BRA    12DC
.................... 			}
.................... 		}
.................... 
.................... 
.................... 
.................... 		if ( timers.now_adc_sample ) {
194A:  BTFSS  xBF.0
194C:  BRA    1954
.................... 			timers.now_adc_sample=0;
194E:  BCF    xBF.0
.................... 			adc_update();
1950:  CALL   0908
.................... 		}
.................... 
.................... 		if ( timers.now_write_config ) {
1954:  BTFSS  xBF.3
1956:  BRA    195E
.................... 			timers.now_write_config=0;
1958:  BCF    xBF.3
.................... 			write_param_file();
195A:  CALL   06F8
.................... 		}
.................... 		if ( timers.now_reset_config ) {
195E:  BTFSS  xBF.4
1960:  BRA    1968
.................... 			timers.now_reset_config=0;
1962:  BCF    xBF.4
.................... 			write_default_param_file();
1964:  CALL   0740
.................... 		}
1968:  BRA    14D0
.................... 
.................... 
.................... 	}
.................... 
.................... 
.................... }
196A:  BRA    196A

Configuration Fuses:
   Word  1: 2800   INTRC_IO NOPLLEN PCLKEN NOFCMEN NOIESO
   Word  2: 0E19   NOPUT NOBROWNOUT BORV19 NOWDT WDT128
   Word  3: 0000   NOHFOFST NOMCLR
   Word  4: 0009   STVREN NOLVP BBSIZ2K NOXINST DEBUG
   Word  5: C003   NOPROTECT NOCPB NOCPD
   Word  6: E003   NOWRT NOWRTC NOWRTB NOWRTD
   Word  7: 4003   NOEBTR NOEBTRB

   Some fuses have been forced to be compatible with the ICD debugger.

ROM data:
F00000: 00 00 40 00                                        ..@.
